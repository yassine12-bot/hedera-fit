{"version":3,"file":"PrivateKey.js","sources":["../src/PrivateKey.js"],"sourcesContent":["// SPDX-License-Identifier: Apache-2.0\nimport { hexlify } from \"@ethersproject/bytes\";\nimport { PrivateKey as PrivateKeyCrypto } from \"@hashgraph/cryptography\";\nimport { proto } from \"@hashgraph/proto\";\nimport Mnemonic from \"./Mnemonic.js\";\nimport PublicKey from \"./PublicKey.js\";\nimport Key from \"./Key.js\";\nimport CACHE from \"./Cache.js\";\nimport SignatureMap from \"./transaction/SignatureMap.js\";\nimport AccountId from \"./account/AccountId.js\";\nimport TransactionId from \"./transaction/TransactionId.js\";\nimport { decode } from \"./encoding/hex.js\";\nimport { ASN1Decoder } from \"./util/ASN1-Decoder.js\";\n\n/**\n * @typedef {import(\"./transaction/Transaction.js\").default} Transaction\n */\n\n/**\n * @namespace proto\n * @typedef {import(\"@hashgraph/proto\").proto.IKey} HieroProto.proto.IKey\n * @typedef {import(\"@hashgraph/proto\").proto.ITransaction} HieroProto.proto.ITransaction\n * @typedef {import(\"@hashgraph/proto\").proto.ISignaturePair} HieroProto.proto.ISignaturePair\n * @typedef {import(\"@hashgraph/proto\").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction\n * @typedef {import(\"@hashgraph/proto\").proto.TransactionBody} HieroProto.proto.TransactionBody\n */\n\nexport default class PrivateKey extends Key {\n    /**\n     * @internal\n     * @hideconstructor\n     * @param {PrivateKeyCrypto} key\n     */\n    constructor(key) {\n        super();\n\n        this._key = key;\n    }\n\n    /**\n     * Generate a random Ed25519 private key.\n     *\n     * @returns {PrivateKey}\n     */\n    static generateED25519() {\n        return new PrivateKey(PrivateKeyCrypto.generateED25519());\n    }\n\n    /**\n     * Generate a random EDSA private key.\n     *\n     * @returns {PrivateKey}\n     */\n    static generateECDSA() {\n        return new PrivateKey(PrivateKeyCrypto.generateECDSA());\n    }\n\n    /**\n     * Depredated - Use `generateED25519()` instead\n     * Generate a random Ed25519 private key.\n     *\n     * @returns {PrivateKey}\n     */\n    static generate() {\n        return PrivateKey.generateED25519();\n    }\n\n    /**\n     * Depredated - Use `generateED25519Async()` instead\n     * Generate a random Ed25519 private key.\n     *\n     * @returns {Promise<PrivateKey>}\n     */\n    static async generateAsync() {\n        return new PrivateKey(await PrivateKeyCrypto.generateAsync());\n    }\n\n    /**\n     * Generate a random Ed25519 private key.\n     *\n     * @returns {Promise<PrivateKey>}\n     */\n    static async generateED25519Async() {\n        return new PrivateKey(await PrivateKeyCrypto.generateED25519Async());\n    }\n\n    /**\n     * Generate a random ECDSA private key.\n     *\n     * @returns {Promise<PrivateKey>}\n     */\n    static async generateECDSAAsync() {\n        return new PrivateKey(await PrivateKeyCrypto.generateECDSAAsync());\n    }\n\n    /**\n     * Construct a private key from bytes. Requires DER header.\n     *\n     * @param {Uint8Array} data\n     * @returns {PrivateKey}\n     */\n    static fromBytes(data) {\n        const keyString = hexlify(data);\n        if (PrivateKey.isDerKey(keyString)) {\n            if (PrivateKey.getAlgorithm(keyString) === \"ecdsa\") {\n                return new PrivateKey(PrivateKeyCrypto.fromBytesECDSA(data));\n            } else {\n                return new PrivateKey(PrivateKeyCrypto.fromBytesED25519(data));\n            }\n        }\n\n        // If the key is not DER, we assume it's a raw private key\n        // this will default to ED25519 as we dont have a way\n        // to determine the type of the key based on the raw bytes\n        return new PrivateKey(PrivateKeyCrypto.fromBytes(data));\n    }\n\n    /**\n     * Construct a ECDSA private key from bytes.\n     *\n     * @param {Uint8Array} data\n     * @returns {PrivateKey}\n     */\n    static fromBytesECDSA(data) {\n        return new PrivateKey(PrivateKeyCrypto.fromBytesECDSA(data));\n    }\n\n    /**\n     * Construct a ED25519 private key from bytes.\n     *\n     * @param {Uint8Array} data\n     * @returns {PrivateKey}\n     */\n    static fromBytesED25519(data) {\n        return new PrivateKey(PrivateKeyCrypto.fromBytesED25519(data));\n    }\n\n    /**\n     * @deprecated - Use fromStringECDSA() or fromStringED2551() on a HEX-encoded string\n     * and fromStringDer() on a HEX-encoded string with DER prefix instead.\n     * Construct a private key from a hex-encoded string. Requires DER header.\n     * @param {string} text\n     * @returns {PrivateKey}\n     */\n    static fromString(text) {\n        if (PrivateKey.isDerKey(text)) {\n            return this.fromStringDer(text);\n        }\n        // If the key is not DER, we assume it's a raw private key\n        // this will default to ED25519 as we dont have a way\n        // to determine the type of the key based on the raw bytes\n        return new PrivateKey(PrivateKeyCrypto.fromString(text));\n    }\n\n    /**\n     * Construct a private key from a HEX-encoded string with a der prefix\n     *\n     * @param {string} text\n     * @returns {PrivateKey}\n     */\n    static fromStringDer(text) {\n        // previous versions of the library used to accept non-der encoded private keys here\n        // and it fallbacked to PrivateKey.fromString() so we need to keep this behavior\n        if (!PrivateKey.isDerKey(text)) {\n            // eslint-disable-next-line deprecation/deprecation\n            return PrivateKey.fromString(text);\n        }\n\n        if (PrivateKey.getAlgorithm(text) === \"ecdsa\") {\n            return this.fromStringECDSA(text);\n        } else {\n            return this.fromStringED25519(text);\n        }\n    }\n\n    /**\n     * Construct a ECDSA private key from a hex-encoded string.\n     *\n     * @param {string} text\n     * @returns {PrivateKey}\n     */\n    static fromStringECDSA(text) {\n        return new PrivateKey(PrivateKeyCrypto.fromStringECDSA(text));\n    }\n\n    /**\n     * Construct a Ed25519 private key from a hex-encoded string.\n     *\n     * @param {string} text\n     * @returns {PrivateKey}\n     */\n    static fromStringED25519(text) {\n        return new PrivateKey(PrivateKeyCrypto.fromStringED25519(text));\n    }\n\n    /**\n     * Construct a Ed25519 private key from a Uint8Array seed.\n     *\n     * @param {Uint8Array} seed\n     * @returns {Promise<PrivateKey>}\n     */\n    static async fromSeedED25519(seed) {\n        return new PrivateKey(await PrivateKeyCrypto.fromSeedED25519(seed));\n    }\n\n    /**\n     * Construct a Ed25519 private key from a Uint8Array seed.\n     *\n     * @param {Uint8Array} seed\n     * @returns {Promise<PrivateKey>}\n     */\n    static async fromSeedECDSAsecp256k1(seed) {\n        return new PrivateKey(\n            await PrivateKeyCrypto.fromSeedECDSAsecp256k1(seed),\n        );\n    }\n\n    /**\n     * @deprecated - Use `Mnemonic.from[Words|String]().to[Ed25519|Ecdsa]PrivateKey()` instead\n     *\n     * Recover a private key from a mnemonic phrase (and optionally a password).\n     * @param {Mnemonic  | string} mnemonic\n     * @param {string} [passphrase]\n     * @returns {Promise<PrivateKey>}\n     */\n    static async fromMnemonic(mnemonic, passphrase = \"\") {\n        if (mnemonic instanceof Mnemonic) {\n            return new PrivateKey(\n                // eslint-disable-next-line deprecation/deprecation\n                await PrivateKeyCrypto.fromMnemonic(\n                    mnemonic._mnemonic,\n                    passphrase,\n                ),\n            );\n        }\n\n        return new PrivateKey(\n            // eslint-disable-next-line deprecation/deprecation\n            await PrivateKeyCrypto.fromMnemonic(mnemonic, passphrase),\n        );\n    }\n\n    /**\n     * Recover a private key from a keystore, previously created by `.toKeystore()`.\n     *\n     * This key will _not_ support child key derivation.\n     *\n     * @param {Uint8Array} data\n     * @param {string} [passphrase]\n     * @returns {Promise<PrivateKey>}\n     * @throws {cryptography.BadKeyError} If the passphrase is incorrect or the hash fails to validate.\n     */\n    static async fromKeystore(data, passphrase = \"\") {\n        return new PrivateKey(\n            await PrivateKeyCrypto.fromKeystore(data, passphrase),\n        );\n    }\n\n    /**\n     * Recover a private key from a pem string; the private key may be encrypted.\n     *\n     * This method assumes the .pem file has been converted to a string already.\n     *\n     * If `passphrase` is not null or empty, this looks for the first `ENCRYPTED PRIVATE KEY`\n     * section and uses `passphrase` to decrypt it; otherwise, it looks for the first `PRIVATE KEY`\n     * section and decodes that as a DER-encoded  private key.\n     *\n     * @param {string} data\n     * @param {string} [passphrase]\n     * @returns {Promise<PrivateKey>}\n     */\n    static async fromPem(data, passphrase = \"\") {\n        return new PrivateKey(await PrivateKeyCrypto.fromPem(data, passphrase));\n    }\n\n    /**\n     * Derive a new private key at the given wallet index.\n     *\n     * Only currently supported for keys created with `fromMnemonic()`; other keys will throw\n     * an error.\n     *\n     * You can check if a key supports derivation with `.supportsDerivation()`\n     *\n     * @param {number} index\n     * @returns {Promise<PrivateKey>}\n     * @throws If this key does not support derivation.\n     */\n    async derive(index) {\n        return new PrivateKey(await this._key.derive(index));\n    }\n\n    /**\n     * @param {number} index\n     * @returns {Promise<PrivateKey>}\n     * @throws If this key does not support derivation.\n     */\n    async legacyDerive(index) {\n        return new PrivateKey(await this._key.legacyDerive(index));\n    }\n\n    /**\n     * Get the public key associated with this private key.\n     *\n     * The public key can be freely given and used by other parties to verify\n     * the signatures generated by this private key.\n     *\n     * @returns {PublicKey}\n     */\n    get publicKey() {\n        return new PublicKey(this._key.publicKey);\n    }\n\n    /**\n     * Get the public key associated with this private key.\n     *\n     * The public key can be freely given and used by other parties to verify\n     * the signatures generated by this private key.\n     *\n     * @returns {?Uint8Array}\n     */\n    get chainCode() {\n        return this._key._chainCode;\n    }\n\n    /**\n     * Sign a message with this private key.\n     *\n     * @param {Uint8Array} bytes\n     * @returns {Uint8Array} - The signature bytes without the message\n     */\n    sign(bytes) {\n        return this._key.sign(bytes);\n    }\n\n    /**\n     * @deprecated - Use legacy=false flag to use the modern approach\n     * or don't pass it at all.\n     * @overload\n     * @param {Transaction} transaction\n     * @param {true} legacy\n     * @returns {Uint8Array | Uint8Array[] }\n     */\n\n    /**\n     * @overload\n     * @param {Transaction} transaction\n     * @param {false} [legacy]\n     * @returns {SignatureMap}\n     */\n\n    /**\n     * @param {Transaction} transaction\n     * @param {boolean} [legacy]\n     * @returns {Uint8Array | Uint8Array[] | SignatureMap}\n     */\n    signTransaction(transaction, legacy = false) {\n        if (legacy) {\n            return this._signTransactionLegacy(transaction);\n        }\n\n        const sigMap = new SignatureMap();\n\n        for (const signedTx of transaction._signedTransactions.list) {\n            const bodyBytes = signedTx.bodyBytes;\n            if (!bodyBytes) throw new Error(\"Body bytes are missing\");\n\n            const body = proto.TransactionBody.decode(bodyBytes);\n            if (!body.transactionID || !body.nodeAccountID) {\n                throw new Error(\n                    \"Transaction ID or Node Account ID not found in the signed transaction\",\n                );\n            }\n\n            const nodeId = AccountId._fromProtobuf(body.nodeAccountID);\n            const transactionId = TransactionId._fromProtobuf(\n                body.transactionID,\n            );\n            const sig = this._key.sign(bodyBytes);\n            sigMap.addSignature(nodeId, transactionId, this.publicKey, sig);\n        }\n\n        transaction.addSignature(this.publicKey, sigMap);\n        return sigMap;\n    }\n\n    /**\n     * deprecated - This method is deprecated and will be removed in future versions.\n     * Use the `signTransaction` method with the `legacy=false` flag or don't\n     * pass it all for the modern approach.\n     * @param {Transaction} transaction\n     * @returns {Uint8Array | Uint8Array[]}\n     */\n    _signTransactionLegacy(transaction) {\n        const signatures = transaction._signedTransactions.list.map(\n            (signedTransaction) => {\n                const bodyBytes = signedTransaction.bodyBytes;\n                if (!bodyBytes) {\n                    return new Uint8Array();\n                }\n\n                return this._key.sign(bodyBytes);\n            },\n        );\n        transaction.addSignature(this.publicKey, signatures);\n        // Return directly Uint8Array if there is only one signature\n        return signatures.length === 1 ? signatures[0] : signatures;\n    }\n\n    /**\n     * Check if `derive` can be called on this private key.\n     *\n     * This is only the case if the key was created from a mnemonic.\n     *\n     * @returns {boolean}\n     */\n    isDerivable() {\n        return this._key.isDerivable();\n    }\n\n    /**\n     * @returns {Uint8Array}\n     */\n    toBytes() {\n        return this._key.toBytes();\n    }\n\n    /**\n     * @returns {Uint8Array}\n     */\n    toBytesDer() {\n        return this._key.toBytesDer();\n    }\n\n    /**\n     * @returns {Uint8Array}\n     */\n    toBytesRaw() {\n        return this._key.toBytesRaw();\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return this._key.toStringDer();\n    }\n\n    /**\n     * @returns {string}\n     */\n    toStringDer() {\n        return this._key.toStringDer();\n    }\n\n    /**\n     * @returns {string}\n     */\n    toStringRaw() {\n        return this._key.toStringRaw();\n    }\n\n    /**\n     * Create a keystore with a given passphrase.\n     *\n     * The key can be recovered later with `fromKeystore()`.\n     *\n     * Note that this will not retain the ancillary data used for\n     * deriving child keys, thus `.derive()` on the restored key will\n     * throw even if this instance supports derivation.\n     *\n     * @param {string} [passphrase]\n     * @returns {Promise<Uint8Array>}\n     */\n    toKeystore(passphrase = \"\") {\n        return this._key.toKeystore(passphrase);\n    }\n\n    /**\n     * @returns {HieroProto.proto.IKey}\n     */\n    _toProtobufKey() {\n        return this.publicKey._toProtobufKey();\n    }\n\n    /**\n     * @param {Long | number} shard\n     * @param {Long | number} realm\n     * @returns {AccountId}\n     */\n    toAccountId(shard, realm) {\n        return this.publicKey.toAccountId(shard, realm);\n    }\n\n    /**\n     * @returns {string}\n     */\n    get type() {\n        return this._key._type;\n    }\n\n    /**\n     * Recover the recovery ID used in the signature for the given message.\n     *\n     * **Note:** This method only works for ECDSA secp256k1 keys.\n     * @param {Uint8Array} r - 32-byte `r` component of the signature\n     * @param {Uint8Array} s - 32-byte `s` component of the signature\n     * @param {Uint8Array} message - The original (unhashed) message\n     * @returns {number} Recovery ID (0â€“3), or -1 if not found or not applicable\n     */\n    getRecoveryId(r, s, message) {\n        return this._key.getRecoveryId(r, s, message);\n    }\n\n    /**\n     * @param {string} privateKey\n     * @returns { \"ecdsa\" | \"ed25519\"}\n     */\n    static getAlgorithm(privateKey) {\n        if (!PrivateKey.isDerKey(privateKey)) {\n            throw new Error(\"Only der keys are supported\");\n        }\n\n        const decoder = new ASN1Decoder(Uint8Array.from(decode(privateKey)));\n        decoder.read();\n        const decodedKeyType = decoder.getOidKeyTypes()[0];\n        // @ts-ignored\n        return decodedKeyType;\n    }\n\n    /**\n     * @internal\n     * @param {string} key\n     * @returns {boolean}\n     */\n    static isDerKey(key) {\n        try {\n            const data = Uint8Array.from(decode(key));\n            const decoder = new ASN1Decoder(data);\n            decoder.read(); // Attempt to read the ASN.1 structure\n            return true;\n        } catch (error) {\n            return false;\n        }\n    }\n}\n\nCACHE.setPrivateKeyConstructor((key) => new PrivateKey(key));\n"],"names":["PrivateKey","Key","constructor","key","super","this","_key","generateED25519","PrivateKeyCrypto","generateECDSA","generate","generateAsync","generateED25519Async","generateECDSAAsync","fromBytes","data","keyString","hexlify","isDerKey","getAlgorithm","fromBytesECDSA","fromBytesED25519","fromString","text","fromStringDer","fromStringECDSA","fromStringED25519","fromSeedED25519","seed","fromSeedECDSAsecp256k1","fromMnemonic","mnemonic","passphrase","Mnemonic","_mnemonic","fromKeystore","fromPem","derive","index","legacyDerive","publicKey","PublicKey","chainCode","_chainCode","sign","bytes","signTransaction","transaction","legacy","_signTransactionLegacy","sigMap","SignatureMap","signedTx","_signedTransactions","list","bodyBytes","Error","body","proto","TransactionBody","decode","transactionID","nodeAccountID","nodeId","AccountId","_fromProtobuf","transactionId","TransactionId","sig","addSignature","signatures","map","signedTransaction","Uint8Array","length","isDerivable","toBytes","toBytesDer","toBytesRaw","toString","toStringDer","toStringRaw","toKeystore","_toProtobufKey","toAccountId","shard","realm","type","_type","getRecoveryId","r","s","message","privateKey","decoder","ASN1Decoder","from","read","getOidKeyTypes","error","CACHE","setPrivateKeyConstructor"],"mappings":"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"}