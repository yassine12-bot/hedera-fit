import t from"./grpc/GrpcServiceError.js";import e from"./grpc/GrpcStatus.js";import n from"./transaction/List.js";import{encode as o}from"./encoding/hex.js";import r from"./http/HttpError.js";import s from"./Status.js";import i from"./MaxAttemptsOrTimeoutError.js";const c={Finished:"Finished",Retry:"Retry",Error:"Error"},a=/\brst[^0-9a-zA-Z]stream\b/i,h=10;class d{constructor(){this._maxAttempts=10,this._nodeAccountIds=new n,this.transactionNodeIds=[],this._signOnDemand=!1,this._minBackoff=null,this._maxBackoff=8e3,this._operator=null,this._requestTimeout=null,this._grpcDeadline=null,this._logger=null}get nodeAccountIds(){return this._nodeAccountIds.isEmpty?null:(this._nodeAccountIds.setLocked(),this._nodeAccountIds.list)}setNodeAccountIds(t){return this._nodeAccountIds.setList(t).setLocked(),this}get maxRetries(){return console.warn("Deprecated: use maxAttempts instead"),this.maxAttempts}setMaxRetries(t){return console.warn("Deprecated: use setMaxAttempts() instead"),this.setMaxAttempts(t)}get maxAttempts(){return this._maxAttempts}setMaxAttempts(t){return this._maxAttempts=t,this}get grpcDeadline(){return this._grpcDeadline}setGrpcDeadline(t){return this._grpcDeadline=t,this}setMinBackoff(t){if(null==t)throw new Error("minBackoff cannot be null.");if(null!=this._maxBackoff&&t>this._maxBackoff)throw new Error("minBackoff cannot be larger than maxBackoff.");return this._minBackoff=t,this}get minBackoff(){return this._minBackoff}setMaxBackoff(t){if(null==t)throw new Error("maxBackoff cannot be null.");if(null!=this._minBackoff&&t<this._minBackoff)throw new Error("maxBackoff cannot be smaller than minBackoff.");return this._maxBackoff=t,this}get maxBackoff(){return this._maxBackoff}_beforeExecute(t){throw new Error("not implemented")}_makeRequestAsync(){throw new Error("not implemented")}_mapStatusError(t,e,n){throw new Error("not implemented")}_mapResponse(t,e,n){throw new Error("not implemented")}_execute(t,e){throw new Error("not implemented")}_getTransactionId(){throw new Error("not implemented")}_getLogId(){throw new Error("not implemented")}_requestToBytes(t){throw new Error("not implemented")}_responseToBytes(t){throw new Error("not implemented")}_shouldRetry(t,e){throw new Error("not implemented")}_shouldRetryExceptionally(n){return!(n instanceof t)||(n.status._code===e.Timeout._code||n.status._code===e.DeadlineExceeded._code||n.status._code===e.Unavailable._code||n.status._code===e.ResourceExhausted._code||n.status._code===e.GrpcWeb._code||n.status._code===e.Internal._code&&a.test(n.message))}_setOperatorWith(t,e,n){return this._operator={transactionSigner:n,accountId:t,publicKey:e},this}async executeWithSigner(t){return t.call(this)}isBatchedAndNotBatchTransaction(){return!1}async execute(n,a){const h=null!=n.network["127.0.0.1:50211"];if(this.isBatchedAndNotBatchTransaction())throw new Error("Cannot execute batchified transaction outside of BatchTransaction");this._logger=null==this._logger?null!=n._logger?n._logger:null:this._logger,null==this._requestTimeout&&(this._requestTimeout=null!=a?a:n.requestTimeout),null==this._grpcDeadline&&(this._grpcDeadline=n.grpcDeadline),await this._beforeExecute(n),null==this._maxBackoff&&(this._maxBackoff=n.maxBackoff),null==this._minBackoff&&(this._minBackoff=n.minBackoff);const d=Date.now();let g=null;const m=h?1e3:n._maxAttempts??this._maxAttempts;if(this.transactionNodeIds.length){const t=this._nodeAccountIds.list.map(t=>t.toString());if(!this.transactionNodeIds.some(e=>t.includes(e))){const e=t.length>2?`${t.slice(0,2).join(", ")} ...`:t.join(", "),n=1===t.length;throw new Error(`Attempting to execute a transaction against node${n?"":"s"} ${e}, which ${n?"is":"are"} not included in the Client's node list. Please review your Client configuration.`)}}for(let a=1;a<=m;a+=1){if(null!=this._requestTimeout&&d+this._requestTimeout<=Date.now())throw new i("timeout exceeded",this._nodeAccountIds.isEmpty?"No node account ID set":this._nodeAccountIds.current.toString());let _,f;if(this._nodeAccountIds.isEmpty?(f=n._network.getNode(),_=f.accountId,this._nodeAccountIds.setList([_])):(_=this._nodeAccountIds.current,f=n._network.getNode(_)),null==f)throw new Error(`NodeAccountId not recognized: ${_.toString()}`);if(this.transactionNodeIds.length){if(!this.transactionNodeIds.includes(_.toString())){console.error(`Attempting to execute a transaction against node ${_.toString()}, which is not included in the Client's node list. Please review your Client configuration.`),this._nodeAccountIds.advance();continue}}const p=this._getLogId();this._logger&&this._logger.debug(`[${p}] Node AccountID: ${f.accountId.toString()}, IP: ${f.address.toString()}`);const w=f.getChannel();null!=this._grpcDeadline&&w.setGrpcDeadline(this._grpcDeadline);const x=await this._makeRequestAsync();let k;if(!f.isHealthy()){const t=this._nodeAccountIds.index===this._nodeAccountIds.list.length-1;if(u(x)||h){await l(h,a,this._minBackoff,this._maxBackoff);continue}if(t||this._nodeAccountIds.length<=1)throw new Error(`Network connectivity issue: All nodes are unhealthy. Original node list: ${this._nodeAccountIds.list.join(", ")}`);this._logger&&this._logger.debug(`[${p}] Node is not healthy, trying the next node.`),this._nodeAccountIds.advance();continue}this._nodeAccountIds.advance();try{const n=[];null!=this._grpcDeadline&&n.push(new Promise((n,o)=>setTimeout(()=>o(new t(e.DeadlineExceeded)),this._grpcDeadline))),this._logger&&this._logger.trace(`[${this._getLogId()}] sending protobuf ${o(this._requestToBytes(x))}`),n.push(this._execute(w,x)),k=await Promise.race(n)}catch(e){const o=t._fromResponse(e);if(g=o,this._logger&&this._logger.debug(`[${p}] received error ${JSON.stringify(o)}`),(o instanceof t||o instanceof r)&&this._shouldRetryExceptionally(o)&&a<=m){this._logger&&this._logger.debug(`[${this._getLogId()}] node with accountId: ${f.accountId.toString()} and proxy IP: ${f.address.toString()} is unhealthy`),n._network.increaseBackoff(f);continue}throw e}this._logger&&this._logger.trace(`[${this._getLogId()}] sending protobuf ${o(this._responseToBytes(k))}`),n._network.decreaseBackoff(f);const[A,B]=this._shouldRetry(x,k);switch(A.toString()!==s.Ok.toString()&&A.toString()!==s.Success.toString()&&(g=A),B){case c.Retry:await l(h,a,this._minBackoff,this._maxBackoff);continue;case c.Finished:return this._mapResponse(k,_,x);case c.Error:throw this._mapStatusError(x,k,_);default:throw new Error("(BUG) non-exhaustive switch statement for `ExecutionState`")}}throw new i(`max attempts of ${m.toString()} was reached for request with last error being: ${null!=g?g.toString():""}`,this._nodeAccountIds.current.toString())}toBytes(){throw new Error("not implemented")}setLogger(t){return this._logger=t,this}get logger(){return this._logger}}function u(t){return"object"==typeof t&&null!==t&&("transactionGetReceipt"in t||"transactionGetRecord"in t)}function l(t,e,n,o){if(t)return new Promise(t=>setTimeout(t,n));const r=Math.min(Math.floor(n*Math.pow(2,e)),o);return new Promise(t=>setTimeout(t,r))}export{h as DEFAULT_MAX_ATTEMPTS,c as ExecutionState,a as RST_STREAM,d as default};
//# sourceMappingURL=Executable.js.map
