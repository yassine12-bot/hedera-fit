{"version":3,"file":"WebChannel.js","sources":["../../src/channel/WebChannel.js"],"sourcesContent":["// SPDX-License-Identifier: Apache-2.0\nimport { ALL_WEB_NETWORK_NODES } from \"../constants/ClientConstants.js\";\nimport GrpcServiceError from \"../grpc/GrpcServiceError.js\";\nimport GrpcStatus from \"../grpc/GrpcStatus.js\";\nimport HttpError from \"../http/HttpError.js\";\nimport HttpStatus from \"../http/HttpStatus.js\";\nimport { SDK_NAME, SDK_VERSION } from \"../version.js\";\nimport Channel, { encodeRequest, decodeUnaryResponse } from \"./Channel.js\";\n\nexport default class WebChannel extends Channel {\n    /**\n     * @param {string} address\n     * @param {number=} grpcDeadline\n     */\n    constructor(address, grpcDeadline) {\n        super(grpcDeadline);\n\n        /**\n         * @type {string}\n         * @private\n         */\n        this._address = address;\n\n        // Set the gRPC deadline using the base class method\n\n        /**\n         * Flag indicating if the connection is ready (health check has passed)\n         * Set to true after the first successful health check\n         *\n         * @type {boolean}\n         * @private\n         */\n        this._isReady = false;\n\n        /**\n         * Promise that resolves when the health check is complete\n         * Used to prevent multiple concurrent health checks\n         *\n         * @type {Promise<void>|null}\n         * @private\n         */\n        this._healthCheckPromise = null;\n    }\n\n    /**\n     * Determines whether to use HTTPS based on the address\n     * @param {string} address - The address to check\n     * @returns {boolean} - True if HTTPS should be used, false for HTTP\n     * @private\n     */\n    _shouldUseHttps(address) {\n        return !(\n            address.includes(\"localhost\") || address.includes(\"127.0.0.1\")\n        );\n    }\n\n    /**\n     * Builds the full URL with appropriate scheme (http/https)\n     * @param {string} address - The base address\n     * @returns {string} - The full URL with scheme\n     * @private\n     */\n    _buildUrl(address) {\n        // Check if address already contains a scheme\n        const hasScheme =\n            address.startsWith(\"http://\") || address.startsWith(\"https://\");\n\n        if (hasScheme) {\n            // Use the address as-is if it already has a scheme\n            return address;\n        } else {\n            // Only prepend scheme if none exists\n            const shouldUseHttps = this._shouldUseHttps(address);\n            return shouldUseHttps ? `https://${address}` : `http://${address}`;\n        }\n    }\n\n    /**\n     * Check if the gRPC-Web proxy is reachable and healthy\n     * Performs a POST request and verifies the response has gRPC-Web headers,\n     * which indicates the proxy is running and processing gRPC requests.\n     * Results are cached per address for the entire lifecycle.\n     * Uses promise-based synchronization to prevent multiple concurrent health checks.\n     *\n     * @param {Date} deadline - Deadline for the health check\n     * @returns {Promise<void>}\n     * @private\n     */\n    async _waitForReady(deadline) {\n        // Check if we've already validated this address\n        if (this._isReady) {\n            return; // Health check already passed for this address\n        }\n\n        // If a health check is already in progress, wait for it to complete\n        if (this._healthCheckPromise) {\n            return this._healthCheckPromise;\n        }\n\n        // Start a new health check and store the promise\n        this._healthCheckPromise = this._performHealthCheck(deadline);\n\n        try {\n            await this._healthCheckPromise;\n        } finally {\n            // Clear the promise when done (success or failure)\n            this._healthCheckPromise = null;\n        }\n    }\n\n    /**\n     * Performs the actual health check request\n     * @param {Date} deadline - Deadline for the health check\n     * @returns {Promise<void>}\n     * @private\n     */\n    async _performHealthCheck(deadline) {\n        const address = this._buildUrl(this._address);\n\n        // Calculate remaining time until deadline\n        const timeoutMs = deadline.getTime() - Date.now();\n        if (timeoutMs <= 0) {\n            throw new GrpcServiceError(\n                GrpcStatus.Timeout,\n                ALL_WEB_NETWORK_NODES?.[this._address]?.toString(),\n            );\n        }\n\n        const abortController = new AbortController();\n        const timeoutId = setTimeout(() => abortController.abort(), timeoutMs);\n\n        try {\n            // Make a POST request to verify the gRPC-Web proxy is running\n            // We use a minimal gRPC-Web compatible request\n            //eslint-disable-next-line n/no-unsupported-features/node-builtins\n            const response = await fetch(address, {\n                method: \"POST\",\n                headers: {\n                    \"content-type\": \"application/grpc-web+proto\",\n                    \"x-user-agent\": `${SDK_NAME}/${SDK_VERSION}`,\n                    \"x-grpc-web\": \"1\",\n                },\n                body: new Uint8Array(0), // Empty body for health check\n                signal: abortController.signal,\n            });\n\n            clearTimeout(timeoutId);\n\n            // Check if response is successful (200) or indicates a redirect (3xx)\n            // 3xx status codes indicate the resource has moved, which is valid for proxies\n            if (\n                response.ok ||\n                (response.status >= 300 && response.status < 400)\n            ) {\n                const grpcStatus = response.headers.get(\"grpc-status\");\n                const grpcMessage = response.headers.get(\"grpc-message\");\n\n                // If gRPC headers exist, the proxy is running and processing requests\n                if (grpcStatus != null || grpcMessage != null) {\n                    // Mark this connection as ready\n                    this._isReady = true;\n                    return; //  Healthy - gRPC-Web proxy is responding\n                }\n            }\n\n            // If we get here, either status isn't 200/3xx or no gRPC headers present\n            // This means the proxy might not be configured correctly or not running\n            throw new GrpcServiceError(\n                GrpcStatus.Unavailable,\n                ALL_WEB_NETWORK_NODES?.[this._address]?.toString(),\n            );\n        } catch (error) {\n            clearTimeout(timeoutId);\n\n            if (error instanceof Error && error.name === \"AbortError\") {\n                throw new GrpcServiceError(\n                    GrpcStatus.Timeout,\n                    ALL_WEB_NETWORK_NODES?.[this._address]?.toString(),\n                );\n            }\n\n            if (error instanceof GrpcServiceError) {\n                throw error;\n            }\n\n            // Network error - server is not reachable\n            throw new GrpcServiceError(\n                GrpcStatus.Unavailable,\n                ALL_WEB_NETWORK_NODES?.[this._address]?.toString(),\n            );\n        }\n    }\n\n    /**\n     * @override\n     * @returns {void}\n     */\n    close() {\n        // do nothing\n    }\n\n    /**\n     * @override\n     * @protected\n     * @param {string} serviceName\n     * @returns {import(\"protobufjs\").RPCImpl}\n     */\n    _createUnaryClient(serviceName) {\n        // eslint-disable-next-line @typescript-eslint/no-misused-promises\n        return async (method, requestData, callback) => {\n            // Calculate deadline for connection check\n            const deadline = new Date();\n            const milliseconds = this._grpcDeadline;\n\n            deadline.setMilliseconds(deadline.getMilliseconds() + milliseconds);\n\n            try {\n                // Wait for connection to be ready (similar to gRPC waitForReady)\n                await this._waitForReady(deadline);\n\n                // Build the full URL with appropriate scheme\n                const address = this._buildUrl(this._address);\n                // this will be executed in a browser environment so eslint is\n                // disabled for the fetch call\n                //eslint-disable-next-line n/no-unsupported-features/node-builtins\n                const response = await fetch(\n                    `${address}/proto.${serviceName}/${method.name}`,\n                    {\n                        method: \"POST\",\n                        headers: {\n                            \"content-type\": \"application/grpc-web+proto\",\n                            \"x-user-agent\": `${SDK_NAME}/${SDK_VERSION}`,\n                            \"x-grpc-web\": \"1\",\n                        },\n                        body: encodeRequest(requestData),\n                    },\n                );\n\n                if (!response.ok) {\n                    const error = new HttpError(\n                        HttpStatus._fromValue(response.status),\n                    );\n                    callback(error, null);\n                    return;\n                }\n\n                // Check headers for gRPC errors\n                const grpcStatus = response.headers.get(\"grpc-status\");\n                const grpcMessage = response.headers.get(\"grpc-message\");\n\n                if (grpcStatus != null && grpcMessage != null) {\n                    const error = new GrpcServiceError(\n                        GrpcStatus._fromValue(parseInt(grpcStatus)),\n                        ALL_WEB_NETWORK_NODES?.[this._address]?.toString(),\n                    );\n                    error.message = grpcMessage;\n                    callback(error, null);\n                    return;\n                }\n\n                const responseBuffer = await response.arrayBuffer();\n                const unaryResponse = decodeUnaryResponse(responseBuffer);\n\n                callback(null, unaryResponse);\n            } catch (error) {\n                if (error instanceof GrpcServiceError) {\n                    callback(error, null);\n                    return;\n                }\n\n                const err = new GrpcServiceError(\n                    // retry on grpc web errors\n                    GrpcStatus._fromValue(18),\n                    ALL_WEB_NETWORK_NODES?.[this._address]?.toString(),\n                );\n                callback(err, null);\n            }\n        };\n    }\n}\n"],"names":["WebChannel","Channel","constructor","address","grpcDeadline","super","this","_address","_isReady","_healthCheckPromise","_shouldUseHttps","includes","_buildUrl","startsWith","_waitForReady","deadline","_performHealthCheck","timeoutMs","getTime","Date","now","GrpcServiceError","GrpcStatus","Timeout","ALL_WEB_NETWORK_NODES","toString","abortController","AbortController","timeoutId","setTimeout","abort","response","fetch","method","headers","SDK_NAME","SDK_VERSION","body","Uint8Array","signal","clearTimeout","ok","status","grpcStatus","get","grpcMessage","Unavailable","error","Error","name","close","_createUnaryClient","serviceName","async","requestData","callback","milliseconds","_grpcDeadline","setMilliseconds","getMilliseconds","encodeRequest","HttpError","HttpStatus","_fromValue","parseInt","message","responseBuffer","arrayBuffer","decodeUnaryResponse"],"mappings":"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"}