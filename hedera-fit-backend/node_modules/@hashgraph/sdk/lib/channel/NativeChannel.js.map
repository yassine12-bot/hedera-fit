{"version":3,"file":"NativeChannel.js","sources":["../../src/channel/NativeChannel.js"],"sourcesContent":["// SPDX-License-Identifier: Apache-2.0\nimport Channel, { encodeRequest, decodeUnaryResponse } from \"./Channel.js\";\nimport * as base64 from \"../encoding/base64.native.js\";\nimport HttpError from \"../http/HttpError.js\";\nimport HttpStatus from \"../http/HttpStatus.js\";\nimport { SDK_NAME, SDK_VERSION } from \"../version.js\";\nimport GrpcServiceError from \"../grpc/GrpcServiceError.js\";\nimport GrpcStatus from \"../grpc/GrpcStatus.js\";\n\nexport default class NativeChannel extends Channel {\n    /**\n     * @param {string} address\n     * @param {number=} grpcDeadline\n     */\n    constructor(address, grpcDeadline) {\n        super(grpcDeadline);\n\n        /**\n         * @type {string}\n         * @private\n         */\n        this._address = address;\n\n        /**\n         * Flag indicating if the connection is ready (health check has passed)\n         * Set to true after the first successful health check\n         *\n         * @type {boolean}\n         * @private\n         */\n        this._isReady = false;\n    }\n\n    /**\n     * @override\n     * @returns {void}\n     */\n    close() {\n        // do nothing\n    }\n\n    /**\n     * Check if the gRPC-Web proxy is reachable and healthy\n     * Performs a POST request and verifies the response has gRPC-Web headers,\n     * which indicates the proxy is running and processing gRPC requests.\n     * Results are cached per address for the entire lifecycle.\n     *\n     * @param {Date} deadline - Deadline for the health check\n     * @returns {Promise<void>}\n     * @private\n     */\n    async _waitForReady(deadline) {\n        // Check if we've already validated this address\n        if (this._isReady) {\n            return; // Health check already passed for this address\n        }\n\n        const shouldUseHttps = !(\n            this._address.includes(\"localhost\") ||\n            this._address.includes(\"127.0.0.1\")\n        );\n\n        const address = shouldUseHttps\n            ? `https://${this._address}`\n            : `http://${this._address}`;\n\n        // Calculate remaining time until deadline\n        const timeoutMs = deadline.getTime() - Date.now();\n        if (timeoutMs <= 0) {\n            throw new GrpcServiceError(GrpcStatus.Timeout);\n        }\n\n        const abortController = new AbortController();\n        const timeoutId = setTimeout(() => abortController.abort(), timeoutMs);\n\n        try {\n            // Make a POST request to verify the gRPC-Web proxy is running\n            // We use a minimal gRPC-Web compatible request\n            //eslint-disable-next-line n/no-unsupported-features/node-builtins\n            const response = await fetch(address, {\n                method: \"POST\",\n                headers: {\n                    \"content-type\": \"application/grpc-web-text\",\n                    \"x-user-agent\": `${SDK_NAME}/${SDK_VERSION}`,\n                    \"x-grpc-web\": \"1\",\n                },\n                body: base64.encode(new Uint8Array(0)), // Empty body for health check\n                signal: abortController.signal,\n            });\n\n            clearTimeout(timeoutId);\n\n            // Check if response is successful (200) and has gRPC headers\n            if (response.status === 200) {\n                const grpcStatus = response.headers.get(\"grpc-status\");\n                const grpcMessage = response.headers.get(\"grpc-message\");\n\n                // If gRPC headers exist, the proxy is running and processing requests\n                if (grpcStatus != null || grpcMessage != null) {\n                    // Mark this connection as ready\n                    this._isReady = true;\n                    return; //  Healthy - gRPC-Web proxy is responding\n                }\n            }\n\n            // If we get here, either status isn't 200 or no gRPC headers present\n            // This means the proxy might not be configured correctly or not running\n            throw new GrpcServiceError(GrpcStatus.Unavailable);\n        } catch (error) {\n            clearTimeout(timeoutId);\n\n            if (error instanceof Error && error.name === \"AbortError\") {\n                throw new GrpcServiceError(GrpcStatus.Timeout);\n            }\n\n            if (error instanceof GrpcServiceError) {\n                throw error;\n            }\n\n            // Network error - server is not reachable\n            throw new GrpcServiceError(GrpcStatus.Unavailable);\n        }\n    }\n\n    /**\n     * @override\n     * @protected\n     * @param {string} serviceName\n     * @returns {import(\"protobufjs\").RPCImpl}\n     */\n    _createUnaryClient(serviceName) {\n        // eslint-disable-next-line @typescript-eslint/no-misused-promises\n        return async (method, requestData, callback) => {\n            // Calculate deadline for connection check\n            const deadline = new Date();\n            const milliseconds = this._grpcDeadline;\n\n            deadline.setMilliseconds(deadline.getMilliseconds() + milliseconds);\n\n            try {\n                // Wait for connection to be ready (similar to gRPC waitForReady)\n                await this._waitForReady(deadline);\n\n                const data = base64.encode(\n                    new Uint8Array(encodeRequest(requestData)),\n                );\n\n                const shouldUseHttps = !(\n                    this._address.includes(\"localhost\") ||\n                    this._address.includes(\"127.0.0.1\")\n                );\n\n                const address = shouldUseHttps\n                    ? `https://${this._address}`\n                    : `http://${this._address}`;\n                // this will be executed in react native environment sho\n                // fetch should be available\n                //eslint-disable-next-line n/no-unsupported-features/node-builtins\n                const response = await fetch(\n                    `${address}/proto.${serviceName}/${method.name}`,\n                    {\n                        method: \"POST\",\n                        headers: {\n                            \"content-type\": \"application/grpc-web-text\",\n                            \"x-user-agent\": `${SDK_NAME}/${SDK_VERSION}`,\n                            \"x-accept-content-transfer-encoding\": \"base64\",\n                            \"x-grpc-web\": \"1\",\n                        },\n                        body: data,\n                    },\n                );\n\n                if (!response.ok) {\n                    const error = new HttpError(\n                        HttpStatus._fromValue(response.status),\n                    );\n                    callback(error, null);\n                }\n\n                const blob = await response.blob();\n\n                /** @type {string} */\n                const responseData = await new Promise((resolve, reject) => {\n                    const reader = new FileReader();\n                    reader.readAsDataURL(blob);\n                    reader.onloadend = () => {\n                        resolve(/** @type {string} */ (reader.result));\n                    };\n                    reader.onerror = reject;\n                });\n\n                let responseBuffer;\n                if (\n                    responseData.startsWith(\n                        \"data:application/octet-stream;base64,\",\n                    )\n                ) {\n                    responseBuffer = base64.decode(\n                        responseData.split(\n                            \"data:application/octet-stream;base64,\",\n                        )[1],\n                    );\n                } else if (\n                    responseData.startsWith(\n                        \"data:application/grpc-web+proto;base64,\",\n                    )\n                ) {\n                    responseBuffer = base64.decode(\n                        responseData.split(\n                            \"data:application/grpc-web+proto;base64,\",\n                        )[1],\n                    );\n                } else {\n                    throw new Error(\n                        `Expected response data to be base64 encode with a 'data:application/octet-stream;base64,' or 'data:application/grpc-web+proto;base64,' prefix, but found: ${responseData}`,\n                    );\n                }\n\n                const unaryResponse = decodeUnaryResponse(\n                    // @ts-ignore\n                    responseBuffer.buffer,\n                    responseBuffer.byteOffset,\n                    responseBuffer.byteLength,\n                );\n\n                callback(null, unaryResponse);\n            } catch (error) {\n                if (error instanceof GrpcServiceError) {\n                    callback(error, null);\n                    return;\n                }\n\n                callback(/** @type {Error} */ (error), null);\n            }\n        };\n    }\n}\n"],"names":["NativeChannel","Channel","constructor","address","grpcDeadline","super","this","_address","_isReady","close","_waitForReady","deadline","includes","timeoutMs","getTime","Date","now","GrpcServiceError","GrpcStatus","Timeout","abortController","AbortController","timeoutId","setTimeout","abort","response","fetch","method","headers","SDK_NAME","SDK_VERSION","body","base64.encode","Uint8Array","signal","clearTimeout","status","grpcStatus","get","grpcMessage","Unavailable","error","Error","name","_createUnaryClient","serviceName","async","requestData","callback","milliseconds","_grpcDeadline","setMilliseconds","getMilliseconds","data","encodeRequest","ok","HttpError","HttpStatus","_fromValue","blob","responseData","Promise","resolve","reject","reader","FileReader","readAsDataURL","onloadend","onerror","responseBuffer","startsWith","base64.decode","split","decodeUnaryResponse","buffer","byteOffset","byteLength"],"mappings":"8VASe,MAAMA,UAAsBC,EAKvC,WAAAC,CAAYC,EAASC,GACjBC,MAAMD,GAMNE,KAAKC,SAAWJ,EAShBG,KAAKE,UAAW,CACxB,CAMI,KAAAC,GAEJ,CAYI,mBAAMC,CAAcC,GAEhB,GAAIL,KAAKE,SACL,OAGJ,MAKML,IAJFG,KAAKC,SAASK,SAAS,cACvBN,KAAKC,SAASK,SAAS,cAIrB,WAAWN,KAAKC,WAChB,UAAUD,KAAKC,WAGfM,EAAYF,EAASG,UAAYC,KAAKC,MAC5C,GAAIH,GAAa,EACb,MAAM,IAAII,EAAiBC,EAAWC,SAG1C,MAAMC,EAAkB,IAAIC,gBACtBC,EAAYC,WAAW,IAAMH,EAAgBI,QAASX,GAE5D,IAII,MAAMY,QAAiBC,MAAMvB,EAAS,CAClCwB,OAAQ,OACRC,QAAS,CACL,eAAgB,4BAChB,eAAgB,GAAGC,KAAYC,IAC/B,aAAc,KAElBC,KAAMC,EAAc,IAAIC,WAAW,IACnCC,OAAQd,EAAgBc,SAM5B,GAHAC,aAAab,GAGW,MAApBG,EAASW,OAAgB,CACzB,MAAMC,EAAaZ,EAASG,QAAQU,IAAI,eAClCC,EAAcd,EAASG,QAAQU,IAAI,gBAGzC,GAAkB,MAAdD,GAAqC,MAAfE,EAGtB,YADAjC,KAAKE,UAAW,EAGpC,CAIY,MAAM,IAAIS,EAAiBC,EAAWsB,YACzC,CAAC,MAAOC,GAGL,GAFAN,aAAab,GAETmB,aAAiBC,OAAwB,eAAfD,EAAME,KAChC,MAAM,IAAI1B,EAAiBC,EAAWC,SAG1C,GAAIsB,aAAiBxB,EACjB,MAAMwB,EAIV,MAAM,IAAIxB,EAAiBC,EAAWsB,YAClD,CACA,CAQI,kBAAAI,CAAmBC,GAEf,OAAOC,MAAOnB,EAAQoB,EAAaC,KAE/B,MAAMrC,EAAW,IAAII,KACfkC,EAAe3C,KAAK4C,cAE1BvC,EAASwC,gBAAgBxC,EAASyC,kBAAoBH,GAEtD,UAEU3C,KAAKI,cAAcC,GAEzB,MAAM0C,EAAOrB,EACT,IAAIC,WAAWqB,EAAcP,KAQ3B5C,IAJFG,KAAKC,SAASK,SAAS,cACvBN,KAAKC,SAASK,SAAS,cAIrB,WAAWN,KAAKC,WAChB,UAAUD,KAAKC,WAIfkB,QAAiBC,MACnB,GAAGvB,WAAiB0C,KAAelB,EAAOgB,OAC1C,CACIhB,OAAQ,OACRC,QAAS,CACL,eAAgB,4BAChB,eAAgB,GAAGC,KAAYC,IAC/B,qCAAsC,SACtC,aAAc,KAElBC,KAAMsB,IAId,IAAK5B,EAAS8B,GAAI,CAIdP,EAHc,IAAIQ,EACdC,EAAWC,WAAWjC,EAASW,SAEnB,KACpC,CAEgB,MAAMuB,QAAalC,EAASkC,OAGtBC,QAAqB,IAAIC,QAAQ,CAACC,EAASC,KAC7C,MAAMC,EAAS,IAAIC,WACnBD,EAAOE,cAAcP,GACrBK,EAAOG,UAAY,KACfL,EAA+BE,EAAa,SAEhDA,EAAOI,QAAUL,IAGrB,IAAIM,EACJ,GACIT,EAAaU,WACT,yCAGJD,EAAiBE,EACbX,EAAaY,MACT,yCACF,QAEH,KACHZ,EAAaU,WACT,2CASJ,MAAM,IAAI5B,MACN,6JAA6JkB,KAPjKS,EAAiBE,EACbX,EAAaY,MACT,2CACF,GAM1B,CASgBxB,EAAS,KAPayB,EAElBJ,EAAeK,OACfL,EAAeM,WACfN,EAAeO,YAItB,CAAC,MAAOnC,GACL,GAAIA,aAAiBxB,EAEjB,YADA+B,EAASP,EAAO,MAIpBO,EAAQ,EAA+B,KACvD,EAEA"}