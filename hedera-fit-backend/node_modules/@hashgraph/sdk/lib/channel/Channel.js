import*as e from"@hashgraph/proto";import{decode as t}from"../encoding/utf8.js";import{DEFAULT_GRPC_DEADLINE as r}from"../constants/ClientConstants.js";const{proto:n}=e;class s{constructor(e=r){this._crypto=null,this._smartContract=null,this._file=null,this._consensus=null,this._freeze=null,this._network=null,this._token=null,this._schedule=null,this._util=null,this._addressBook=null,this._grpcDeadline=e}setGrpcDeadline(e){this._grpcDeadline=e}get grpcDeadline(){return this._grpcDeadline}close(){throw new Error("not implemented")}get crypto(){return null!=this._crypto||(this._crypto=n.CryptoService.create(this._createUnaryClient("CryptoService"))),this._crypto}get smartContract(){return null!=this._smartContract||(this._smartContract=n.SmartContractService.create(this._createUnaryClient("SmartContractService"))),this._smartContract}get file(){return null!=this._file||(this._file=n.FileService.create(this._createUnaryClient("FileService"))),this._file}get consensus(){return null!=this._consensus||(this._consensus=n.ConsensusService.create(this._createUnaryClient("ConsensusService"))),this._consensus}get freeze(){return null!=this._freeze||(this._freeze=n.FreezeService.create(this._createUnaryClient("FreezeService"))),this._freeze}get network(){return null!=this._network||(this._network=n.NetworkService.create(this._createUnaryClient("NetworkService"))),this._network}get token(){return null!=this._token||(this._token=n.TokenService.create(this._createUnaryClient("TokenService"))),this._token}get schedule(){return null!=this._schedule||(this._schedule=n.ScheduleService.create(this._createUnaryClient("ScheduleService"))),this._schedule}get util(){return null!=this._util||(this._util=n.UtilService.create(this._createUnaryClient("UtilService"))),this._util}get addressBook(){return null!=this._addressBook||(this._addressBook=n.AddressBookService.create(this._createUnaryClient("AddressBookService"))),this._addressBook}_createUnaryClient(e){throw new Error("not implemented")}}function i(e){const t=new ArrayBuffer(e.byteLength+5);return new DataView(t,1,4).setUint32(0,e.length),new Uint8Array(t,5).set(e),t}function l(e,r=0,n=e.byteLength){const s=new DataView(e,r,n);let i=0,l=null,o=0;for(;i<s.byteLength;){const r=s.getUint8(i+0)>>7,n=s.getUint32(i+1),c=i+5;if(c+n>s.byteLength)throw new Error("(BUG) unexpected frame length past the boundary");const a=new Uint8Array(e,s.byteOffset+c,n);if(0===r){if(null!=l)throw new Error("(BUG) unexpectedly received more than one data frame");l=a}else{if(1!==r)throw new Error(`(BUG) unexpected frame type: ${r}`);{const e=t(a),[r,n]=e.split(":");if("grpc-status"!==r)throw new Error(`(BUG) unhandled trailer, ${e}`);o=parseInt(n)}}i+=n+5}if(0!==o)throw new Error(`(BUG) unhandled grpc-status: ${o}`);if(null==l)throw new Error("(BUG) unexpectedly received no response");return l}export{l as decodeUnaryResponse,s as default,i as encodeRequest};
//# sourceMappingURL=Channel.js.map
