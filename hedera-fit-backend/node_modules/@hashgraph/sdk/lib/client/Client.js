import e from"../account/AccountId.js";import t from"../account/AccountBalanceQuery.js";import r from"../Hbar.js";import s from"./Network.js";import i from"./MirrorNetwork.js";import n from"../PublicKey.js";import o from"../PrivateKey.js";import a from"../LedgerId.js";import u from"../file/FileId.js";import"pino";import"../logger/LogLevel.js";import{convertToNumber as h}from"../util.js";import l from"../network/AddressBookQuery.js";import{DEFAULT_REQUEST_TIMEOUT as d,DEFAULT_GRPC_DEADLINE as m}from"../constants/ClientConstants.js";class c{constructor(e){this._mirrorNetwork=new i(this._createMirrorNetworkChannel()),this._network=new s(this._createNetworkChannel()),this._operator=null,this._defaultMaxTransactionFee=null,this._defaultMaxQueryPayment=new r(1),null!=e&&null!=e.operator&&this.setOperator(e.operator.accountId,e.operator.privateKey),this._maxAttempts=null,this._signOnDemand=!1,this._autoValidateChecksums=!1,this._minBackoff=250,this._maxBackoff=8e3,this._defaultRegenerateTransactionId=!0,this._requestTimeout=d,this._grpcDeadline=m,this._isUpdatingNetwork=!1,this._networkUpdatePeriod=864e5,this._isShutdown=!1,this._shard=0,this._realm=0,null!=e&&!1!==e.scheduleNetworkUpdate&&this._scheduleNetworkUpdate(),null!=e&&null!=e.shard&&(this._shard=e.shard),null!=e&&null!=e.realm&&(this._realm=e.realm),null!=e&&null!=e.grpcDeadline&&this.setGrpcDeadline(e.grpcDeadline),null!=e&&null!=e.requestTimeout&&this.setRequestTimeout(e.requestTimeout),this._requestTimeout<=this._grpcDeadline&&console.warn(`DEPRECATION WARNING: requestTimeout (${this._requestTimeout}ms) should be larger than grpcDeadline (${this._grpcDeadline}ms). This configuration may cause operations to fail unexpectedly. This will throw an error in the next major version. Please adjust your timeout values.`),this._timer,this._logger=null}setNetworkName(e){return console.warn("Deprecated: Use `setLedgerId` instead"),this.setLedgerId(e)}get networkName(){return console.warn("Deprecated: Use `ledgerId` instead"),null!=this.ledgerId?this.ledgerId.toString():null}setLedgerId(e){return this._network.setLedgerId("string"==typeof e?a.fromString(e):e),this}get ledgerId(){return null!=this._network._ledgerId?this._network.ledgerId:null}setNetwork(e){throw new Error("not implemented")}setNetworkFromAddressBook(e){return this._network.setNetworkFromAddressBook(e),this}get network(){return this._network.network}get shard(){return this._shard}get realm(){return this._realm}setMirrorNetwork(e){throw new Error("not implemented")}get mirrorNetwork(){return this._mirrorNetwork.network}get mirrorRestApiBaseUrl(){return this._mirrorNetwork.mirrorRestApiBaseUrl}get signOnDemand(){return this._signOnDemand}setSignOnDemand(e){this._signOnDemand=e}isTransportSecurity(){return this._network.isTransportSecurity()}setTransportSecurity(e){return this._network.setTransportSecurity(e),this}setOperator(e,t){const r="string"==typeof t?o.fromStringDer(t):t;return this.setOperatorWith(e,r.publicKey,e=>Promise.resolve(r.sign(e)))}getOperator(){return this._operator}setOperatorWith(t,r,s){const i=t instanceof e?t:e.fromString(t);return null!=this._network._ledgerId&&i.validateChecksum(this),this._operator={transactionSigner:s,accountId:i,publicKey:r instanceof n?r:n.fromString(r)},this}setAutoValidateChecksums(e){return this._autoValidateChecksums=e,this}isAutoValidateChecksumsEnabled(){return this._autoValidateChecksums}get operatorAccountId(){return null!=this._operator?this._operator.accountId:null}get operatorPublicKey(){return null!=this._operator?this._operator.publicKey:null}get defaultMaxTransactionFee(){return this._defaultMaxTransactionFee}get maxTransactionFee(){return this.defaultMaxTransactionFee}setDefaultMaxTransactionFee(e){if(e.toTinybars().toInt()<0)throw new Error("defaultMaxTransactionFee must be non-negative");return this._defaultMaxTransactionFee=e,this}setMaxTransactionFee(e){return this.setDefaultMaxTransactionFee(e)}get defaultRegenerateTransactionId(){return this._defaultRegenerateTransactionId}setDefaultRegenerateTransactionId(e){return this._defaultRegenerateTransactionId=e,this}get defaultMaxQueryPayment(){return this._defaultMaxQueryPayment}get maxQueryPayment(){return this.defaultMaxQueryPayment}setDefaultMaxQueryPayment(e){if(h(e.toTinybars())<0)throw new Error("defaultMaxQueryPayment must be non-negative");return this._defaultMaxQueryPayment=e,this}setMaxQueryPayment(e){return this.setDefaultMaxQueryPayment(e)}get maxAttempts(){return null!=this._maxAttempts?this._maxAttempts:10}setMaxAttempts(e){return this._maxAttempts=e,this}get maxNodeAttempts(){return this._network.maxNodeAttempts}setMaxNodeAttempts(e){return this._network.setMaxNodeAttempts(e),this}get nodeWaitTime(){return this._network.minBackoff}setNodeWaitTime(e){return this._network.setMinBackoff(e),this}get maxNodesPerTransaction(){return this._network.maxNodesPerTransaction}setMaxNodesPerTransaction(e){return this._network.setMaxNodesPerTransaction(e),this}setMinBackoff(e){if(null==e)throw new Error("minBackoff cannot be null.");if(e>this._maxBackoff)throw new Error("minBackoff cannot be larger than maxBackoff.");return this._minBackoff=e,this}get minBackoff(){return this._minBackoff}setMaxBackoff(e){if(null==e)throw new Error("maxBackoff cannot be null.");if(e<this._minBackoff)throw new Error("maxBackoff cannot be smaller than minBackoff.");return this._maxBackoff=e,this}get maxBackoff(){return this._maxBackoff}setNodeMinBackoff(e){return this._network.setMinBackoff(e),this}get nodeMinBackoff(){return this._network.minBackoff}setNodeMaxBackoff(e){return this._network.setMaxBackoff(e),this}get nodeMaxBackoff(){return this._network.maxBackoff}setNodeMinReadmitPeriod(e){return this._network.setNodeMinReadmitPeriod(e),this}get nodeMinReadmitPeriod(){return this._network.nodeMinReadmitPeriod}setNodeMaxReadmitPeriod(e){return this._network.setNodeMaxReadmitPeriod(e),this}get nodeMaxReadmitPeriod(){return this._network.nodeMaxReadmitPeriod}setRequestTimeout(e){if(e<=0)throw new Error("requestTimeout must be a positive number");return e<=this._grpcDeadline&&console.warn(`DEPRECATION WARNING: requestTimeout (${e}ms) should be larger than grpcDeadline (${this._grpcDeadline}ms). This configuration may cause operations to fail unexpectedly. This will throw an error in the next major version. Please adjust your timeout values.`),this._requestTimeout=e,this}get requestTimeout(){return this._requestTimeout}setGrpcDeadline(e){if(e<=0)throw new Error("grpcDeadline must be a positive number");return e>=this._requestTimeout&&console.warn(`DEPRECATION WARNING: grpcDeadline (${e}ms) should be smaller than requestTimeout (${this._requestTimeout}ms). This configuration may cause operations to fail unexpectedly. This will throw an error in the next major version. Please adjust your timeout values.`),this._grpcDeadline=e,this}get grpcDeadline(){return this._grpcDeadline}get networkUpdatePeriod(){return this._networkUpdatePeriod}setNetworkUpdatePeriod(e){return clearTimeout(this._timer),this._networkUpdatePeriod=e,this._scheduleNetworkUpdate(),this}setLogger(e){return this._logger=e,this}get logger(){return this._logger}async ping(r){await new t({accountId:r}).setNodeAccountIds([r instanceof e?r:e.fromString(r)]).execute(this)}async pingAll(){for(const e of Object.values(this._network.network))await this.ping(e)}async updateNetwork(){if(this._isUpdatingNetwork)return this;this._isUpdatingNetwork=!0;try{const e=await(new l).setFileId(u.getAddressBookFileIdFor(this._shard,this._realm)).execute(this);this.setNetworkFromAddressBook(e)}catch(e){this._logger&&this._logger.trace(`failed to update client address book: ${e.toString()}`)}finally{this._isUpdatingNetwork=!1}return this}close(){this._network.close(),this._mirrorNetwork.close(),this._isShutdown=!0,clearTimeout(this._timer)}_createNetworkChannel(){return()=>{throw new Error("not implemented")}}_createMirrorNetworkChannel(){return()=>{throw new Error("not implemented")}}_scheduleNetworkUpdate(){this._timer=setTimeout(async()=>{await this.updateNetwork(),this._isShutdown||this._scheduleNetworkUpdate()},this._networkUpdatePeriod)}get isClientShutDown(){return this._isShutdown}static _validateNetworkConsistency(e){if(0===Object.keys(e).length)return;const[,t]=Object.entries(e)[0],r=t.toString(),[s,i]=r.split(".").map(Number),n=Object.values(e).every(e=>{const t=e.toString(),[r,n]=t.split(".").map(Number);return r===s&&n===i});if(!n)throw new Error("Network is not valid, all nodes must be in the same shard and realm")}static _extractShardRealm(e){const t=Object.entries(e);if(0===t.length)return{shard:0,realm:0};const[,r]=t[0],s=r.toString(),[i,n]=s.split(".").map(Number);return{shard:i,realm:n}}}export{c as default};
//# sourceMappingURL=Client.js.map
