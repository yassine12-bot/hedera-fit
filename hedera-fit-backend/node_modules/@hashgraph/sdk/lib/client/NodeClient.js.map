{"version":3,"file":"NodeClient.js","sources":["../../src/client/NodeClient.js"],"sourcesContent":["// SPDX-License-Identifier: Apache-2.0\n\nimport fs from \"fs\";\nimport util from \"util\";\nimport Client from \"./Client.js\";\nimport NodeChannel from \"../channel/NodeChannel.js\";\nimport NodeMirrorChannel from \"../channel/NodeMirrorChannel.js\";\nimport LedgerId from \"../LedgerId.js\";\nimport NodeAddressBook from \"../address_book/NodeAddressBook.js\";\nimport * as mainnet from \"./addressbooks/mainnet.js\";\nimport * as testnet from \"./addressbooks/testnet.js\";\nimport * as previewnet from \"./addressbooks/previewnet.js\";\nimport * as hex from \"../encoding/hex.js\";\nimport {\n    LocalNodeNetwork,\n    MirrorNetwork,\n} from \"../constants/ClientConstants.js\";\n\nconst readFileAsync = util.promisify(fs.readFile);\n\n/**\n * @typedef {import(\"./Client.js\").ClientConfiguration} ClientConfiguration\n * @typedef {import(\"../account/AccountId.js\").default} AccountId\n */\n\n/**\n * @augments {Client<NodeChannel, NodeMirrorChannel>}\n * Client for interacting with the Hedera network using Node.js.\n * Extends the base Client class with Node.js specific implementations.\n */\nexport default class NodeClient extends Client {\n    /**\n     * @param {ClientConfiguration} [props]\n     */\n    constructor(props) {\n        super(props);\n\n        if (props != null) {\n            if (typeof props.network === \"string\") {\n                this._setNetworkFromName(props.network);\n            } else if (props.network != null) {\n                Client._validateNetworkConsistency(props.network);\n\n                const { shard, realm } = Client._extractShardRealm(\n                    props.network,\n                );\n\n                // Shard and realm are inferred from the network, so we need to set them here\n                // to ensure that the client is properly configured.\n                this._shard = shard;\n                this._realm = realm;\n\n                this.setNetwork(props.network);\n            }\n\n            if (typeof props.mirrorNetwork === \"string\") {\n                switch (props.mirrorNetwork) {\n                    case \"mainnet\":\n                        this.setMirrorNetwork(MirrorNetwork.MAINNET);\n                        break;\n\n                    case \"testnet\":\n                        this.setMirrorNetwork(MirrorNetwork.TESTNET);\n                        break;\n\n                    case \"previewnet\":\n                        this.setMirrorNetwork(MirrorNetwork.PREVIEWNET);\n                        break;\n\n                    default:\n                        this.setMirrorNetwork([props.mirrorNetwork]);\n                        break;\n                }\n            } else if (props.mirrorNetwork != null) {\n                this.setMirrorNetwork(props.mirrorNetwork);\n            }\n        }\n    }\n\n    /**\n     * @param {string | ClientConfiguration} data\n     * @returns {NodeClient}\n     */\n    static fromConfig(data) {\n        return new NodeClient(\n            typeof data === \"string\"\n                ? /** @type {ClientConfiguration | undefined} */ (\n                      JSON.parse(data)\n                  )\n                : data,\n        );\n    }\n\n    /**\n     * @param {string} filename\n     * @returns {Promise<NodeClient>}\n     */\n    static async fromConfigFile(filename) {\n        return NodeClient.fromConfig(await readFileAsync(filename, \"utf8\"));\n    }\n\n    /**\n     * Construct a client for a specific network.\n     *\n     * It is the responsibility of the caller to ensure that all nodes in the map are part of the\n     * same Hedera network. Failure to do so will result in undefined behavior.\n     *\n     * The client will load balance all requests to Hedera using a simple round-robin scheme to\n     * chose nodes to send transactions to. For one transaction, at most 1/3 of the nodes will be\n     * tried.\n     *\n     * @param {{[key: string]: (string | AccountId)}} network\n     * @param {ClientConfiguration} [props]\n     * @returns {NodeClient}\n     */\n    static forNetwork(network, props) {\n        return new NodeClient({\n            network,\n            ...props,\n        });\n    }\n\n    /**\n     * @param {string} network\n     * @param {object} [props]\n     * @param {boolean} [props.scheduleNetworkUpdate]\n     * @returns {NodeClient}\n     */\n    static forName(network, props = {}) {\n        return new NodeClient({ network, ...props });\n    }\n\n    /**\n     * Construct a Hedera client pre-configured for Mainnet access.\n     *\n     * @param {object} [props]\n     * @param {boolean} [props.scheduleNetworkUpdate]\n     * @returns {NodeClient}\n     */\n    static forMainnet(props = {}) {\n        return new NodeClient({ network: \"mainnet\", ...props });\n    }\n\n    /**\n     * Construct a Hedera client pre-configured for Testnet access.\n     *\n     * @param {object} [props]\n     * @param {boolean} [props.scheduleNetworkUpdate]\n     * @returns {NodeClient}\n     */\n    static forTestnet(props = {}) {\n        return new NodeClient({ network: \"testnet\", ...props });\n    }\n\n    /**\n     * @param {string[] | string} mirrorNetwork\n     * @param {number} [shard]\n     * @param {number} [realm]\n     * @returns {Promise<NodeClient>}\n     */\n    static async forMirrorNetwork(mirrorNetwork, shard, realm) {\n        const client = new NodeClient({\n            mirrorNetwork,\n            shard,\n            realm,\n        });\n\n        await client.updateNetwork();\n\n        return client;\n    }\n\n    /**\n     * Construct a Hedera client pre-configured for Previewnet access.\n     *\n     * @param {object} [props]\n     * @param {boolean} [props.scheduleNetworkUpdate]\n     * @returns {NodeClient}\n     */\n    static forPreviewnet(props = {}) {\n        return new NodeClient({ network: \"previewnet\", ...props });\n    }\n\n    /**\n     * Construct a Hedera client pre-configured for local-node access.\n     *\n     * @param {object} [props]\n     * @param {boolean} [props.scheduleNetworkUpdate]\n     * @returns {NodeClient}\n     */\n    static forLocalNode(props = { scheduleNetworkUpdate: false }) {\n        return new NodeClient({\n            network: \"local-node\",\n            ...props,\n        });\n    }\n\n    /**\n     * Construct a Hedera client pre-configured for Mainnet access with network update.\n     *\n     * @param {object} [props]\n     * @param {boolean} [props.scheduleNetworkUpdate]\n     * @returns {Promise<NodeClient>}\n     */\n    static async forMainnetAsync(props = {}) {\n        return new NodeClient({ network: \"mainnet\", ...props }).updateNetwork();\n    }\n\n    /**\n     * Construct a Hedera client pre-configured for Testnet access with network update.\n     *\n     * @param {object} [props]\n     * @param {boolean} [props.scheduleNetworkUpdate]\n     * @returns {Promise<NodeClient>}\n     */\n    static async forTestnetAsync(props = {}) {\n        return new NodeClient({ network: \"testnet\", ...props }).updateNetwork();\n    }\n\n    /**\n     * Construct a Hedera client pre-configured for Previewnet access with network update.\n     *\n     * @param {object} [props]\n     * @param {boolean} [props.scheduleNetworkUpdate]\n     * @returns {Promise<NodeClient>}\n     */\n    static async forPreviewnetAsync(props = {}) {\n        return new NodeClient({\n            network: \"previewnet\",\n            ...props,\n        }).updateNetwork();\n    }\n\n    /**\n     * Construct a client for a specific network with optional network update.\n     * Updates network only if the network is not \"local-node\".\n     *\n     * @param {string} network\n     * @param {object} [props]\n     * @param {boolean} [props.scheduleNetworkUpdate]\n     * @returns {Promise<NodeClient>}\n     */\n    static async forNameAsync(network, props = {}) {\n        const client = new NodeClient({ network, ...props });\n\n        if (network !== \"local-node\") {\n            await client.updateNetwork();\n        }\n\n        return client;\n    }\n\n    /**\n     * @param {{[key: string]: (string | AccountId)} | string} network\n     * @returns {void}\n     */\n    setNetwork(network) {\n        if (typeof network === \"string\") {\n            this._setNetworkFromName(network);\n        } else {\n            this._network.setNetwork(network);\n        }\n    }\n\n    /**\n     * Available only for NodeClient\n     * Legacy method maintained for backward compatibility.\n     * This method now calls setGrpcDeadline internally to ensure proper validation.\n     * @deprecated Use setGrpcDeadline instead.\n     * @param {number} maxExecutionTime\n     * @returns {this}\n     */\n    setMaxExecutionTime(maxExecutionTime) {\n        // Use the parent class setGrpcDeadline method to ensure proper validation\n        // This ensures that maxExecutionTime follows the same validation rules as grpcDeadline\n        this.setGrpcDeadline(maxExecutionTime);\n        return this;\n    }\n\n    /**\n     * @private\n     * @param {string} name\n     * @returns {this}\n     */\n    _setNetworkFromName(name) {\n        switch (name) {\n            case \"mainnet\":\n                this.setNetworkFromAddressBook(\n                    NodeAddressBook.fromBytes(hex.decode(mainnet.addressBook)),\n                );\n                this.setMirrorNetwork(MirrorNetwork.MAINNET);\n                this.setLedgerId(LedgerId.MAINNET);\n                break;\n\n            case \"testnet\":\n                this.setNetworkFromAddressBook(\n                    NodeAddressBook.fromBytes(hex.decode(testnet.addressBook)),\n                );\n                this.setMirrorNetwork(MirrorNetwork.TESTNET);\n                this.setLedgerId(LedgerId.TESTNET);\n                break;\n\n            case \"previewnet\":\n                this.setNetworkFromAddressBook(\n                    NodeAddressBook.fromBytes(\n                        hex.decode(previewnet.addressBook),\n                    ),\n                );\n                this.setMirrorNetwork(MirrorNetwork.PREVIEWNET);\n                this.setLedgerId(LedgerId.PREVIEWNET);\n                break;\n\n            case \"local-node\":\n                this.setNetwork(LocalNodeNetwork);\n                this.setMirrorNetwork(MirrorNetwork.LOCAL_NODE);\n                this.setLedgerId(LedgerId.LOCAL_NODE);\n                break;\n\n            default:\n                throw new Error(\n                    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n                    `unknown network: ${name}`,\n                );\n        }\n        return this;\n    }\n\n    /**\n     * @param {string[] | string} mirrorNetwork\n     * @returns {this}\n     */\n    setMirrorNetwork(mirrorNetwork) {\n        if (typeof mirrorNetwork === \"string\") {\n            switch (mirrorNetwork) {\n                case \"local-node\":\n                    this._mirrorNetwork.setNetwork(MirrorNetwork.LOCAL_NODE);\n                    break;\n                case \"previewnet\":\n                    this._mirrorNetwork.setNetwork(MirrorNetwork.PREVIEWNET);\n                    break;\n                case \"testnet\":\n                    this._mirrorNetwork.setNetwork(MirrorNetwork.TESTNET);\n                    break;\n                case \"mainnet\":\n                    this._mirrorNetwork.setNetwork(MirrorNetwork.MAINNET);\n                    break;\n                default:\n                    this._mirrorNetwork.setNetwork([mirrorNetwork]);\n            }\n        } else {\n            this._mirrorNetwork.setNetwork(mirrorNetwork);\n        }\n\n        return this;\n    }\n\n    /**\n     * @override\n     * @returns {(address: string, cert?: string) => NodeChannel}\n     */\n    _createNetworkChannel() {\n        return (address) => new NodeChannel(address, this.grpcDeadline);\n    }\n\n    /**\n     * @override\n     * @returns {(address: string) => NodeMirrorChannel}\n     */\n    _createMirrorNetworkChannel() {\n        return (address) => new NodeMirrorChannel(address);\n    }\n}\n"],"names":["readFileAsync","util","promisify","fs","readFile","NodeClient","Client","constructor","props","super","network","this","_setNetworkFromName","_validateNetworkConsistency","shard","realm","_extractShardRealm","_shard","_realm","setNetwork","mirrorNetwork","setMirrorNetwork","MirrorNetwork","MAINNET","TESTNET","PREVIEWNET","fromConfig","data","JSON","parse","fromConfigFile","filename","forNetwork","forName","forMainnet","forTestnet","forMirrorNetwork","client","updateNetwork","forPreviewnet","forLocalNode","scheduleNetworkUpdate","forMainnetAsync","forTestnetAsync","forPreviewnetAsync","forNameAsync","_network","setMaxExecutionTime","maxExecutionTime","setGrpcDeadline","name","setNetworkFromAddressBook","NodeAddressBook","fromBytes","hex.decode","mainnet.addressBook","setLedgerId","LedgerId","testnet.addressBook","previewnet.addressBook","LocalNodeNetwork","LOCAL_NODE","Error","_mirrorNetwork","_createNetworkChannel","address","NodeChannel","grpcDeadline","_createMirrorNetworkChannel","NodeMirrorChannel"],"mappings":"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"}