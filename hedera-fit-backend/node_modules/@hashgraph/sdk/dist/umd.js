(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.sdk = {}));
})(this, (function (exports) { 'use strict';

  function _mergeNamespaces(n, m) {
    m.forEach(function (e) {
      e && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {
        if (k !== 'default' && !(k in n)) {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function () { return e[k]; }
          });
        }
      });
    });
    return Object.freeze(n);
  }

  /**
   * @license
   * Copyright 2009 The Closure Library Authors
   * Copyright 2020 Daniel Wirtz / The long.js Authors.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  // WebAssembly optimizations to do native i64 multiplication and divide
  var wasm = null;
  try {
    wasm = new WebAssembly.Instance(
      new WebAssembly.Module(
        new Uint8Array([
          // \0asm
          0, 97, 115, 109,
          // version 1
          1, 0, 0, 0,

          // section "type"
          1, 13, 2,
          // 0, () => i32
          96, 0, 1, 127,
          // 1, (i32, i32, i32, i32) => i32
          96, 4, 127, 127, 127, 127, 1, 127,

          // section "function"
          3, 7, 6,
          // 0, type 0
          0,
          // 1, type 1
          1,
          // 2, type 1
          1,
          // 3, type 1
          1,
          // 4, type 1
          1,
          // 5, type 1
          1,

          // section "global"
          6, 6, 1,
          // 0, "high", mutable i32
          127, 1, 65, 0, 11,

          // section "export"
          7, 50, 6,
          // 0, "mul"
          3, 109, 117, 108, 0, 1,
          // 1, "div_s"
          5, 100, 105, 118, 95, 115, 0, 2,
          // 2, "div_u"
          5, 100, 105, 118, 95, 117, 0, 3,
          // 3, "rem_s"
          5, 114, 101, 109, 95, 115, 0, 4,
          // 4, "rem_u"
          5, 114, 101, 109, 95, 117, 0, 5,
          // 5, "get_high"
          8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0,

          // section "code"
          10, 191, 1, 6,
          // 0, "get_high"
          4, 0, 35, 0, 11,
          // 1, "mul"
          36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32,
          3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4,
          167, 11,
          // 2, "div_s"
          36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32,
          3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4,
          167, 11,
          // 3, "div_u"
          36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32,
          3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4,
          167, 11,
          // 4, "rem_s"
          36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32,
          3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4,
          167, 11,
          // 5, "rem_u"
          36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32,
          3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4,
          167, 11,
        ]),
      ),
      {},
    ).exports;
  } catch {
    // no wasm support :(
  }

  /**
   * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
   *  See the from* functions below for more convenient ways of constructing Longs.
   * @exports Long
   * @class A Long class for representing a 64 bit two's-complement integer value.
   * @param {number} low The low (signed) 32 bits of the long
   * @param {number} high The high (signed) 32 bits of the long
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @constructor
   */
  function Long(low, high, unsigned) {
    /**
     * The low 32 bits as a signed value.
     * @type {number}
     */
    this.low = low | 0;

    /**
     * The high 32 bits as a signed value.
     * @type {number}
     */
    this.high = high | 0;

    /**
     * Whether unsigned or not.
     * @type {boolean}
     */
    this.unsigned = !!unsigned;
  }

  // The internal representation of a long is the two given signed, 32-bit values.
  // We use 32-bit pieces because these are the size of integers on which
  // Javascript performs bit-operations.  For operations like addition and
  // multiplication, we split each number into 16 bit pieces, which can easily be
  // multiplied within Javascript's floating-point representation without overflow
  // or change in sign.
  //
  // In the algorithms below, we frequently reduce the negative case to the
  // positive case by negating the input(s) and then post-processing the result.
  // Note that we must ALWAYS check specially whether those values are MIN_VALUE
  // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
  // a positive number, it overflows back into a negative).  Not handling this
  // case would often result in infinite recursion.
  //
  // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
  // methods on which they depend.

  /**
   * An indicator used to reliably determine if an object is a Long or not.
   * @type {boolean}
   * @const
   * @private
   */
  Long.prototype.__isLong__;

  Object.defineProperty(Long.prototype, "__isLong__", { value: true });

  /**
   * @function
   * @param {*} obj Object
   * @returns {boolean}
   * @inner
   */
  function isLong$1(obj) {
    return (obj && obj["__isLong__"]) === true;
  }

  /**
   * @function
   * @param {*} value number
   * @returns {number}
   * @inner
   */
  function ctz32(value) {
    var c = Math.clz32(value & -value);
    return value ? 31 - c : c;
  }

  /**
   * Tests if the specified object is a Long.
   * @function
   * @param {*} obj Object
   * @returns {boolean}
   */
  Long.isLong = isLong$1;

  /**
   * A cache of the Long representations of small integer values.
   * @type {!Object}
   * @inner
   */
  var INT_CACHE = {};

  /**
   * A cache of the Long representations of small unsigned integer values.
   * @type {!Object}
   * @inner
   */
  var UINT_CACHE = {};

  /**
   * @param {number} value
   * @param {boolean=} unsigned
   * @returns {!Long}
   * @inner
   */
  function fromInt(value, unsigned) {
    var obj, cachedObj, cache;
    if (unsigned) {
      value >>>= 0;
      if ((cache = 0 <= value && value < 256)) {
        cachedObj = UINT_CACHE[value];
        if (cachedObj) return cachedObj;
      }
      obj = fromBits(value, 0, true);
      if (cache) UINT_CACHE[value] = obj;
      return obj;
    } else {
      value |= 0;
      if ((cache = -128 <= value && value < 128)) {
        cachedObj = INT_CACHE[value];
        if (cachedObj) return cachedObj;
      }
      obj = fromBits(value, value < 0 ? -1 : 0, false);
      if (cache) INT_CACHE[value] = obj;
      return obj;
    }
  }

  /**
   * Returns a Long representing the given 32 bit integer value.
   * @function
   * @param {number} value The 32 bit integer in question
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {!Long} The corresponding Long value
   */
  Long.fromInt = fromInt;

  /**
   * @param {number} value
   * @param {boolean=} unsigned
   * @returns {!Long}
   * @inner
   */
  function fromNumber(value, unsigned) {
    if (isNaN(value)) return unsigned ? UZERO : ZERO;
    if (unsigned) {
      if (value < 0) return UZERO;
      if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;
    } else {
      if (value <= -9223372036854776e3) return MIN_VALUE;
      if (value + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;
    }
    if (value < 0) return fromNumber(-value, unsigned).neg();
    return fromBits(
      value % TWO_PWR_32_DBL | 0,
      (value / TWO_PWR_32_DBL) | 0,
      unsigned,
    );
  }

  /**
   * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
   * @function
   * @param {number} value The number in question
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {!Long} The corresponding Long value
   */
  Long.fromNumber = fromNumber;

  /**
   * @param {number} lowBits
   * @param {number} highBits
   * @param {boolean=} unsigned
   * @returns {!Long}
   * @inner
   */
  function fromBits(lowBits, highBits, unsigned) {
    return new Long(lowBits, highBits, unsigned);
  }

  /**
   * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
   *  assumed to use 32 bits.
   * @function
   * @param {number} lowBits The low 32 bits
   * @param {number} highBits The high 32 bits
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {!Long} The corresponding Long value
   */
  Long.fromBits = fromBits;

  /**
   * @function
   * @param {number} base
   * @param {number} exponent
   * @returns {number}
   * @inner
   */
  var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

  /**
   * @param {string} str
   * @param {(boolean|number)=} unsigned
   * @param {number=} radix
   * @returns {!Long}
   * @inner
   */
  function fromString$1(str, unsigned, radix) {
    if (str.length === 0) throw Error("empty string");
    if (typeof unsigned === "number") {
      // For goog.math.long compatibility
      radix = unsigned;
      unsigned = false;
    } else {
      unsigned = !!unsigned;
    }
    if (
      str === "NaN" ||
      str === "Infinity" ||
      str === "+Infinity" ||
      str === "-Infinity"
    )
      return unsigned ? UZERO : ZERO;
    radix = radix || 10;
    if (radix < 2 || 36 < radix) throw RangeError("radix");

    var p;
    if ((p = str.indexOf("-")) > 0) throw Error("interior hyphen");
    else if (p === 0) {
      return fromString$1(str.substring(1), unsigned, radix).neg();
    }

    // Do several (8) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 8));

    var result = ZERO;
    for (var i = 0; i < str.length; i += 8) {
      var size = Math.min(8, str.length - i),
        value = parseInt(str.substring(i, i + size), radix);
      if (size < 8) {
        var power = fromNumber(pow_dbl(radix, size));
        result = result.mul(power).add(fromNumber(value));
      } else {
        result = result.mul(radixToPower);
        result = result.add(fromNumber(value));
      }
    }
    result.unsigned = unsigned;
    return result;
  }

  /**
   * Returns a Long representation of the given string, written using the specified radix.
   * @function
   * @param {string} str The textual representation of the Long
   * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
   * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
   * @returns {!Long} The corresponding Long value
   */
  Long.fromString = fromString$1;

  /**
   * @function
   * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
   * @param {boolean=} unsigned
   * @returns {!Long}
   * @inner
   */
  function fromValue(val, unsigned) {
    if (typeof val === "number") return fromNumber(val, unsigned);
    if (typeof val === "string") return fromString$1(val, unsigned);
    // Throws for non-objects, converts non-instanceof Long:
    return fromBits(
      val.low,
      val.high,
      typeof unsigned === "boolean" ? unsigned : val.unsigned,
    );
  }

  /**
   * Converts the specified value to a Long using the appropriate from* function for its type.
   * @function
   * @param {!Long|number|bigint|string|!{low: number, high: number, unsigned: boolean}} val Value
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {!Long}
   */
  Long.fromValue = fromValue;

  // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
  // no runtime penalty for these.

  /**
   * @type {number}
   * @const
   * @inner
   */
  var TWO_PWR_16_DBL = 1 << 16;

  /**
   * @type {number}
   * @const
   * @inner
   */
  var TWO_PWR_24_DBL = 1 << 24;

  /**
   * @type {number}
   * @const
   * @inner
   */
  var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

  /**
   * @type {number}
   * @const
   * @inner
   */
  var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

  /**
   * @type {number}
   * @const
   * @inner
   */
  var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

  /**
   * @type {!Long}
   * @const
   * @inner
   */
  var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

  /**
   * @type {!Long}
   * @inner
   */
  var ZERO = fromInt(0);

  /**
   * Signed zero.
   * @type {!Long}
   */
  Long.ZERO = ZERO;

  /**
   * @type {!Long}
   * @inner
   */
  var UZERO = fromInt(0, true);

  /**
   * Unsigned zero.
   * @type {!Long}
   */
  Long.UZERO = UZERO;

  /**
   * @type {!Long}
   * @inner
   */
  var ONE = fromInt(1);

  /**
   * Signed one.
   * @type {!Long}
   */
  Long.ONE = ONE;

  /**
   * @type {!Long}
   * @inner
   */
  var UONE = fromInt(1, true);

  /**
   * Unsigned one.
   * @type {!Long}
   */
  Long.UONE = UONE;

  /**
   * @type {!Long}
   * @inner
   */
  var NEG_ONE = fromInt(-1);

  /**
   * Signed negative one.
   * @type {!Long}
   */
  Long.NEG_ONE = NEG_ONE;

  /**
   * @type {!Long}
   * @inner
   */
  var MAX_VALUE = fromBits(0xffffffff | 0, 0x7fffffff | 0, false);

  /**
   * Maximum signed value.
   * @type {!Long}
   */
  Long.MAX_VALUE = MAX_VALUE;

  /**
   * @type {!Long}
   * @inner
   */
  var MAX_UNSIGNED_VALUE = fromBits(0xffffffff | 0, 0xffffffff | 0, true);

  /**
   * Maximum unsigned value.
   * @type {!Long}
   */
  Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

  /**
   * @type {!Long}
   * @inner
   */
  var MIN_VALUE = fromBits(0, 0x80000000 | 0, false);

  /**
   * Minimum signed value.
   * @type {!Long}
   */
  Long.MIN_VALUE = MIN_VALUE;

  /**
   * @alias Long.prototype
   * @inner
   */
  var LongPrototype = Long.prototype;

  /**
   * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
   * @this {!Long}
   * @returns {number}
   */
  LongPrototype.toInt = function toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
  };

  /**
   * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
   * @this {!Long}
   * @returns {number}
   */
  LongPrototype.toNumber = function toNumber() {
    if (this.unsigned)
      return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
  };

  /**
   * Converts the Long to a string written in the specified radix.
   * @this {!Long}
   * @param {number=} radix Radix (2-36), defaults to 10
   * @returns {string}
   * @override
   * @throws {RangeError} If `radix` is out of range
   */
  LongPrototype.toString = function toString(radix) {
    radix = radix || 10;
    if (radix < 2 || 36 < radix) throw RangeError("radix");
    if (this.isZero()) return "0";
    if (this.isNegative()) {
      // Unsigned Longs are never negative
      if (this.eq(MIN_VALUE)) {
        // We need to change the Long value before it can be negated, so we remove
        // the bottom-most digit in this base and then recurse to do the rest.
        var radixLong = fromNumber(radix),
          div = this.div(radixLong),
          rem1 = div.mul(radixLong).sub(this);
        return div.toString(radix) + rem1.toInt().toString(radix);
      } else return "-" + this.neg().toString(radix);
    }

    // Do several (6) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
      rem = this;
    var result = "";
    while (true) {
      var remDiv = rem.div(radixToPower),
        intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
        digits = intval.toString(radix);
      rem = remDiv;
      if (rem.isZero()) return digits + result;
      else {
        while (digits.length < 6) digits = "0" + digits;
        result = "" + digits + result;
      }
    }
  };

  /**
   * Gets the high 32 bits as a signed integer.
   * @this {!Long}
   * @returns {number} Signed high bits
   */
  LongPrototype.getHighBits = function getHighBits() {
    return this.high;
  };

  /**
   * Gets the high 32 bits as an unsigned integer.
   * @this {!Long}
   * @returns {number} Unsigned high bits
   */
  LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
    return this.high >>> 0;
  };

  /**
   * Gets the low 32 bits as a signed integer.
   * @this {!Long}
   * @returns {number} Signed low bits
   */
  LongPrototype.getLowBits = function getLowBits() {
    return this.low;
  };

  /**
   * Gets the low 32 bits as an unsigned integer.
   * @this {!Long}
   * @returns {number} Unsigned low bits
   */
  LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
    return this.low >>> 0;
  };

  /**
   * Gets the number of bits needed to represent the absolute value of this Long.
   * @this {!Long}
   * @returns {number}
   */
  LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative())
      // Unsigned Longs are never negative
      return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val = this.high != 0 ? this.high : this.low;
    for (var bit = 31; bit > 0; bit--) if ((val & (1 << bit)) != 0) break;
    return this.high != 0 ? bit + 33 : bit + 1;
  };

  /**
   * Tests if this Long can be safely represented as a JavaScript number.
   * @this {!Long}
   * @returns {boolean}
   */
  LongPrototype.isSafeInteger = function isSafeInteger() {
    // 2^53-1 is the maximum safe value
    var top11Bits = this.high >> 21;
    // [0, 2^53-1]
    if (!top11Bits) return true;
    // > 2^53-1
    if (this.unsigned) return false;
    // [-2^53, -1] except -2^53
    return top11Bits === -1 && !(this.low === 0 && this.high === -2097152);
  };

  /**
   * Tests if this Long's value equals zero.
   * @this {!Long}
   * @returns {boolean}
   */
  LongPrototype.isZero = function isZero() {
    return this.high === 0 && this.low === 0;
  };

  /**
   * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
   * @returns {boolean}
   */
  LongPrototype.eqz = LongPrototype.isZero;

  /**
   * Tests if this Long's value is negative.
   * @this {!Long}
   * @returns {boolean}
   */
  LongPrototype.isNegative = function isNegative() {
    return !this.unsigned && this.high < 0;
  };

  /**
   * Tests if this Long's value is positive or zero.
   * @this {!Long}
   * @returns {boolean}
   */
  LongPrototype.isPositive = function isPositive() {
    return this.unsigned || this.high >= 0;
  };

  /**
   * Tests if this Long's value is odd.
   * @this {!Long}
   * @returns {boolean}
   */
  LongPrototype.isOdd = function isOdd() {
    return (this.low & 1) === 1;
  };

  /**
   * Tests if this Long's value is even.
   * @this {!Long}
   * @returns {boolean}
   */
  LongPrototype.isEven = function isEven() {
    return (this.low & 1) === 0;
  };

  /**
   * Tests if this Long's value equals the specified's.
   * @this {!Long}
   * @param {!Long|number|bigint|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.equals = function equals(other) {
    if (!isLong$1(other)) other = fromValue(other);
    if (
      this.unsigned !== other.unsigned &&
      this.high >>> 31 === 1 &&
      other.high >>> 31 === 1
    )
      return false;
    return this.high === other.high && this.low === other.low;
  };

  /**
   * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
   * @function
   * @param {!Long|number|bigint|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.eq = LongPrototype.equals;

  /**
   * Tests if this Long's value differs from the specified's.
   * @this {!Long}
   * @param {!Long|number|bigint|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.notEquals = function notEquals(other) {
    return !this.eq(/* validates */ other);
  };

  /**
   * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
   * @function
   * @param {!Long|number|bigint|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.neq = LongPrototype.notEquals;

  /**
   * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
   * @function
   * @param {!Long|number|bigint|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.ne = LongPrototype.notEquals;

  /**
   * Tests if this Long's value is less than the specified's.
   * @this {!Long}
   * @param {!Long|number|bigint|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.lessThan = function lessThan(other) {
    return this.comp(/* validates */ other) < 0;
  };

  /**
   * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
   * @function
   * @param {!Long|number|bigint|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.lt = LongPrototype.lessThan;

  /**
   * Tests if this Long's value is less than or equal the specified's.
   * @this {!Long}
   * @param {!Long|number|bigint|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
    return this.comp(/* validates */ other) <= 0;
  };

  /**
   * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
   * @function
   * @param {!Long|number|bigint|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.lte = LongPrototype.lessThanOrEqual;

  /**
   * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
   * @function
   * @param {!Long|number|bigint|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.le = LongPrototype.lessThanOrEqual;

  /**
   * Tests if this Long's value is greater than the specified's.
   * @this {!Long}
   * @param {!Long|number|bigint|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.greaterThan = function greaterThan(other) {
    return this.comp(/* validates */ other) > 0;
  };

  /**
   * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
   * @function
   * @param {!Long|number|bigint|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.gt = LongPrototype.greaterThan;

  /**
   * Tests if this Long's value is greater than or equal the specified's.
   * @this {!Long}
   * @param {!Long|number|bigint|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
    return this.comp(/* validates */ other) >= 0;
  };

  /**
   * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
   * @function
   * @param {!Long|number|bigint|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.gte = LongPrototype.greaterThanOrEqual;

  /**
   * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
   * @function
   * @param {!Long|number|bigint|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.ge = LongPrototype.greaterThanOrEqual;

  /**
   * Compares this Long's value with the specified's.
   * @this {!Long}
   * @param {!Long|number|bigint|string} other Other value
   * @returns {number} 0 if they are the same, 1 if the this is greater and -1
   *  if the given one is greater
   */
  LongPrototype.compare = function compare(other) {
    if (!isLong$1(other)) other = fromValue(other);
    if (this.eq(other)) return 0;
    var thisNeg = this.isNegative(),
      otherNeg = other.isNegative();
    if (thisNeg && !otherNeg) return -1;
    if (!thisNeg && otherNeg) return 1;
    // At this point the sign bits are the same
    if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1;
    // Both are positive if at least one is unsigned
    return other.high >>> 0 > this.high >>> 0 ||
      (other.high === this.high && other.low >>> 0 > this.low >>> 0)
      ? -1
      : 1;
  };

  /**
   * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
   * @function
   * @param {!Long|number|bigint|string} other Other value
   * @returns {number} 0 if they are the same, 1 if the this is greater and -1
   *  if the given one is greater
   */
  LongPrototype.comp = LongPrototype.compare;

  /**
   * Negates this Long's value.
   * @this {!Long}
   * @returns {!Long} Negated Long
   */
  LongPrototype.negate = function negate() {
    if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;
    return this.not().add(ONE);
  };

  /**
   * Negates this Long's value. This is an alias of {@link Long#negate}.
   * @function
   * @returns {!Long} Negated Long
   */
  LongPrototype.neg = LongPrototype.negate;

  /**
   * Returns the sum of this and the specified Long.
   * @this {!Long}
   * @param {!Long|number|bigint|string} addend Addend
   * @returns {!Long} Sum
   */
  LongPrototype.add = function add(addend) {
    if (!isLong$1(addend)) addend = fromValue(addend);

    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xffff;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xffff;

    var b48 = addend.high >>> 16;
    var b32 = addend.high & 0xffff;
    var b16 = addend.low >>> 16;
    var b00 = addend.low & 0xffff;

    var c48 = 0,
      c32 = 0,
      c16 = 0,
      c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 0xffff;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 0xffff;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 0xffff;
    c48 += a48 + b48;
    c48 &= 0xffff;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
  };

  /**
   * Returns the difference of this and the specified Long.
   * @this {!Long}
   * @param {!Long|number|bigint|string} subtrahend Subtrahend
   * @returns {!Long} Difference
   */
  LongPrototype.subtract = function subtract(subtrahend) {
    if (!isLong$1(subtrahend)) subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
  };

  /**
   * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
   * @function
   * @param {!Long|number|bigint|string} subtrahend Subtrahend
   * @returns {!Long} Difference
   */
  LongPrototype.sub = LongPrototype.subtract;

  /**
   * Returns the product of this and the specified Long.
   * @this {!Long}
   * @param {!Long|number|bigint|string} multiplier Multiplier
   * @returns {!Long} Product
   */
  LongPrototype.multiply = function multiply(multiplier) {
    if (this.isZero()) return this;
    if (!isLong$1(multiplier)) multiplier = fromValue(multiplier);

    // use wasm support if present
    if (wasm) {
      var low = wasm["mul"](this.low, this.high, multiplier.low, multiplier.high);
      return fromBits(low, wasm["get_high"](), this.unsigned);
    }

    if (multiplier.isZero()) return this.unsigned ? UZERO : ZERO;
    if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;

    if (this.isNegative()) {
      if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());
      else return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg();

    // If both longs are small, use float multiplication
    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
      return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
    // We can skip products that would overflow.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xffff;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xffff;

    var b48 = multiplier.high >>> 16;
    var b32 = multiplier.high & 0xffff;
    var b16 = multiplier.low >>> 16;
    var b00 = multiplier.low & 0xffff;

    var c48 = 0,
      c32 = 0,
      c16 = 0,
      c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 0xffff;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 0xffff;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 0xffff;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 0xffff;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 0xffff;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 0xffff;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 0xffff;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
  };

  /**
   * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
   * @function
   * @param {!Long|number|bigint|string} multiplier Multiplier
   * @returns {!Long} Product
   */
  LongPrototype.mul = LongPrototype.multiply;

  /**
   * Returns this Long divided by the specified. The result is signed if this Long is signed or
   *  unsigned if this Long is unsigned.
   * @this {!Long}
   * @param {!Long|number|bigint|string} divisor Divisor
   * @returns {!Long} Quotient
   */
  LongPrototype.divide = function divide(divisor) {
    if (!isLong$1(divisor)) divisor = fromValue(divisor);
    if (divisor.isZero()) throw Error("division by zero");

    // use wasm support if present
    if (wasm) {
      // guard against signed division overflow: the largest
      // negative number / -1 would be 1 larger than the largest
      // positive number, due to two's complement.
      if (
        !this.unsigned &&
        this.high === -2147483648 &&
        divisor.low === -1 &&
        divisor.high === -1
      ) {
        // be consistent with non-wasm code path
        return this;
      }
      var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(
        this.low,
        this.high,
        divisor.low,
        divisor.high,
      );
      return fromBits(low, wasm["get_high"](), this.unsigned);
    }

    if (this.isZero()) return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
    if (!this.unsigned) {
      // This section is only relevant for signed longs and is derived from the
      // closure library as a whole.
      if (this.eq(MIN_VALUE)) {
        if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
          return MIN_VALUE; // recall that -MIN_VALUE == MIN_VALUE
        else if (divisor.eq(MIN_VALUE)) return ONE;
        else {
          // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
          var halfThis = this.shr(1);
          approx = halfThis.div(divisor).shl(1);
          if (approx.eq(ZERO)) {
            return divisor.isNegative() ? ONE : NEG_ONE;
          } else {
            rem = this.sub(divisor.mul(approx));
            res = approx.add(rem.div(divisor));
            return res;
          }
        }
      } else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;
      if (this.isNegative()) {
        if (divisor.isNegative()) return this.neg().div(divisor.neg());
        return this.neg().div(divisor).neg();
      } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();
      res = ZERO;
    } else {
      // The algorithm below has not been made for unsigned longs. It's therefore
      // required to take special care of the MSB prior to running it.
      if (!divisor.unsigned) divisor = divisor.toUnsigned();
      if (divisor.gt(this)) return UZERO;
      if (divisor.gt(this.shru(1)))
        // 15 >>> 1 = 7 ; with divisor = 8 ; true
        return UONE;
      res = UZERO;
    }

    // Repeat the following until the remainder is less than other:  find a
    // floating-point that approximates remainder / other *from below*, add this
    // into the result, and subtract it from the remainder.  It is critical that
    // the approximate value is less than or equal to the real value so that the
    // remainder never becomes negative.
    rem = this;
    while (rem.gte(divisor)) {
      // Approximate the result of division. This may be a little greater or
      // smaller than the actual value.
      approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

      // We will tweak the approximate result by changing it in the 48-th digit or
      // the smallest non-fractional digit, whichever is larger.
      var log2 = Math.ceil(Math.log(approx) / Math.LN2),
        delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48),
        // Decrease the approximation until it is smaller than the remainder.  Note
        // that if it is too large, the product overflows and is negative.
        approxRes = fromNumber(approx),
        approxRem = approxRes.mul(divisor);
      while (approxRem.isNegative() || approxRem.gt(rem)) {
        approx -= delta;
        approxRes = fromNumber(approx, this.unsigned);
        approxRem = approxRes.mul(divisor);
      }

      // We know the answer can't be zero... and actually, zero would cause
      // infinite recursion since we would make no progress.
      if (approxRes.isZero()) approxRes = ONE;

      res = res.add(approxRes);
      rem = rem.sub(approxRem);
    }
    return res;
  };

  /**
   * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
   * @function
   * @param {!Long|number|bigint|string} divisor Divisor
   * @returns {!Long} Quotient
   */
  LongPrototype.div = LongPrototype.divide;

  /**
   * Returns this Long modulo the specified.
   * @this {!Long}
   * @param {!Long|number|bigint|string} divisor Divisor
   * @returns {!Long} Remainder
   */
  LongPrototype.modulo = function modulo(divisor) {
    if (!isLong$1(divisor)) divisor = fromValue(divisor);

    // use wasm support if present
    if (wasm) {
      var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(
        this.low,
        this.high,
        divisor.low,
        divisor.high,
      );
      return fromBits(low, wasm["get_high"](), this.unsigned);
    }

    return this.sub(this.div(divisor).mul(divisor));
  };

  /**
   * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
   * @function
   * @param {!Long|number|bigint|string} divisor Divisor
   * @returns {!Long} Remainder
   */
  LongPrototype.mod = LongPrototype.modulo;

  /**
   * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
   * @function
   * @param {!Long|number|bigint|string} divisor Divisor
   * @returns {!Long} Remainder
   */
  LongPrototype.rem = LongPrototype.modulo;

  /**
   * Returns the bitwise NOT of this Long.
   * @this {!Long}
   * @returns {!Long}
   */
  LongPrototype.not = function not() {
    return fromBits(~this.low, ~this.high, this.unsigned);
  };

  /**
   * Returns count leading zeros of this Long.
   * @this {!Long}
   * @returns {!number}
   */
  LongPrototype.countLeadingZeros = function countLeadingZeros() {
    return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
  };

  /**
   * Returns count leading zeros. This is an alias of {@link Long#countLeadingZeros}.
   * @function
   * @param {!Long}
   * @returns {!number}
   */
  LongPrototype.clz = LongPrototype.countLeadingZeros;

  /**
   * Returns count trailing zeros of this Long.
   * @this {!Long}
   * @returns {!number}
   */
  LongPrototype.countTrailingZeros = function countTrailingZeros() {
    return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
  };

  /**
   * Returns count trailing zeros. This is an alias of {@link Long#countTrailingZeros}.
   * @function
   * @param {!Long}
   * @returns {!number}
   */
  LongPrototype.ctz = LongPrototype.countTrailingZeros;

  /**
   * Returns the bitwise AND of this Long and the specified.
   * @this {!Long}
   * @param {!Long|number|bigint|string} other Other Long
   * @returns {!Long}
   */
  LongPrototype.and = function and(other) {
    if (!isLong$1(other)) other = fromValue(other);
    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
  };

  /**
   * Returns the bitwise OR of this Long and the specified.
   * @this {!Long}
   * @param {!Long|number|bigint|string} other Other Long
   * @returns {!Long}
   */
  LongPrototype.or = function or(other) {
    if (!isLong$1(other)) other = fromValue(other);
    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
  };

  /**
   * Returns the bitwise XOR of this Long and the given one.
   * @this {!Long}
   * @param {!Long|number|bigint|string} other Other Long
   * @returns {!Long}
   */
  LongPrototype.xor = function xor(other) {
    if (!isLong$1(other)) other = fromValue(other);
    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
  };

  /**
   * Returns this Long with bits shifted to the left by the given amount.
   * @this {!Long}
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
  LongPrototype.shiftLeft = function shiftLeft(numBits) {
    if (isLong$1(numBits)) numBits = numBits.toInt();
    if ((numBits &= 63) === 0) return this;
    else if (numBits < 32)
      return fromBits(
        this.low << numBits,
        (this.high << numBits) | (this.low >>> (32 - numBits)),
        this.unsigned,
      );
    else return fromBits(0, this.low << (numBits - 32), this.unsigned);
  };

  /**
   * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
   * @function
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
  LongPrototype.shl = LongPrototype.shiftLeft;

  /**
   * Returns this Long with bits arithmetically shifted to the right by the given amount.
   * @this {!Long}
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
  LongPrototype.shiftRight = function shiftRight(numBits) {
    if (isLong$1(numBits)) numBits = numBits.toInt();
    if ((numBits &= 63) === 0) return this;
    else if (numBits < 32)
      return fromBits(
        (this.low >>> numBits) | (this.high << (32 - numBits)),
        this.high >> numBits,
        this.unsigned,
      );
    else
      return fromBits(
        this.high >> (numBits - 32),
        this.high >= 0 ? 0 : -1,
        this.unsigned,
      );
  };

  /**
   * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
   * @function
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
  LongPrototype.shr = LongPrototype.shiftRight;

  /**
   * Returns this Long with bits logically shifted to the right by the given amount.
   * @this {!Long}
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
  LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
    if (isLong$1(numBits)) numBits = numBits.toInt();
    if ((numBits &= 63) === 0) return this;
    if (numBits < 32)
      return fromBits(
        (this.low >>> numBits) | (this.high << (32 - numBits)),
        this.high >>> numBits,
        this.unsigned,
      );
    if (numBits === 32) return fromBits(this.high, 0, this.unsigned);
    return fromBits(this.high >>> (numBits - 32), 0, this.unsigned);
  };

  /**
   * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
   * @function
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
  LongPrototype.shru = LongPrototype.shiftRightUnsigned;

  /**
   * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
   * @function
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
  LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;

  /**
   * Returns this Long with bits rotated to the left by the given amount.
   * @this {!Long}
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Rotated Long
   */
  LongPrototype.rotateLeft = function rotateLeft(numBits) {
    var b;
    if (isLong$1(numBits)) numBits = numBits.toInt();
    if ((numBits &= 63) === 0) return this;
    if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
    if (numBits < 32) {
      b = 32 - numBits;
      return fromBits(
        (this.low << numBits) | (this.high >>> b),
        (this.high << numBits) | (this.low >>> b),
        this.unsigned,
      );
    }
    numBits -= 32;
    b = 32 - numBits;
    return fromBits(
      (this.high << numBits) | (this.low >>> b),
      (this.low << numBits) | (this.high >>> b),
      this.unsigned,
    );
  };
  /**
   * Returns this Long with bits rotated to the left by the given amount. This is an alias of {@link Long#rotateLeft}.
   * @function
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Rotated Long
   */
  LongPrototype.rotl = LongPrototype.rotateLeft;

  /**
   * Returns this Long with bits rotated to the right by the given amount.
   * @this {!Long}
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Rotated Long
   */
  LongPrototype.rotateRight = function rotateRight(numBits) {
    var b;
    if (isLong$1(numBits)) numBits = numBits.toInt();
    if ((numBits &= 63) === 0) return this;
    if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
    if (numBits < 32) {
      b = 32 - numBits;
      return fromBits(
        (this.high << b) | (this.low >>> numBits),
        (this.low << b) | (this.high >>> numBits),
        this.unsigned,
      );
    }
    numBits -= 32;
    b = 32 - numBits;
    return fromBits(
      (this.low << b) | (this.high >>> numBits),
      (this.high << b) | (this.low >>> numBits),
      this.unsigned,
    );
  };
  /**
   * Returns this Long with bits rotated to the right by the given amount. This is an alias of {@link Long#rotateRight}.
   * @function
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Rotated Long
   */
  LongPrototype.rotr = LongPrototype.rotateRight;

  /**
   * Converts this Long to signed.
   * @this {!Long}
   * @returns {!Long} Signed long
   */
  LongPrototype.toSigned = function toSigned() {
    if (!this.unsigned) return this;
    return fromBits(this.low, this.high, false);
  };

  /**
   * Converts this Long to unsigned.
   * @this {!Long}
   * @returns {!Long} Unsigned long
   */
  LongPrototype.toUnsigned = function toUnsigned() {
    if (this.unsigned) return this;
    return fromBits(this.low, this.high, true);
  };

  /**
   * Converts this Long to its byte representation.
   * @param {boolean=} le Whether little or big endian, defaults to big endian
   * @this {!Long}
   * @returns {!Array.<number>} Byte representation
   */
  LongPrototype.toBytes = function toBytes(le) {
    return le ? this.toBytesLE() : this.toBytesBE();
  };

  /**
   * Converts this Long to its little endian byte representation.
   * @this {!Long}
   * @returns {!Array.<number>} Little endian byte representation
   */
  LongPrototype.toBytesLE = function toBytesLE() {
    var hi = this.high,
      lo = this.low;
    return [
      lo & 0xff,
      (lo >>> 8) & 0xff,
      (lo >>> 16) & 0xff,
      lo >>> 24,
      hi & 0xff,
      (hi >>> 8) & 0xff,
      (hi >>> 16) & 0xff,
      hi >>> 24,
    ];
  };

  /**
   * Converts this Long to its big endian byte representation.
   * @this {!Long}
   * @returns {!Array.<number>} Big endian byte representation
   */
  LongPrototype.toBytesBE = function toBytesBE() {
    var hi = this.high,
      lo = this.low;
    return [
      hi >>> 24,
      (hi >>> 16) & 0xff,
      (hi >>> 8) & 0xff,
      hi & 0xff,
      lo >>> 24,
      (lo >>> 16) & 0xff,
      (lo >>> 8) & 0xff,
      lo & 0xff,
    ];
  };

  /**
   * Creates a Long from its byte representation.
   * @param {!Array.<number>} bytes Byte representation
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @param {boolean=} le Whether little or big endian, defaults to big endian
   * @returns {Long} The corresponding Long value
   */
  Long.fromBytes = function fromBytes(bytes, unsigned, le) {
    return le
      ? Long.fromBytesLE(bytes, unsigned)
      : Long.fromBytesBE(bytes, unsigned);
  };

  /**
   * Creates a Long from its little endian byte representation.
   * @param {!Array.<number>} bytes Little endian byte representation
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {Long} The corresponding Long value
   */
  Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
    return new Long(
      bytes[0] | (bytes[1] << 8) | (bytes[2] << 16) | (bytes[3] << 24),
      bytes[4] | (bytes[5] << 8) | (bytes[6] << 16) | (bytes[7] << 24),
      unsigned,
    );
  };

  /**
   * Creates a Long from its big endian byte representation.
   * @param {!Array.<number>} bytes Big endian byte representation
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {Long} The corresponding Long value
   */
  Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
    return new Long(
      (bytes[4] << 24) | (bytes[5] << 16) | (bytes[6] << 8) | bytes[7],
      (bytes[0] << 24) | (bytes[1] << 16) | (bytes[2] << 8) | bytes[3],
      unsigned,
    );
  };

  // Support conversion to/from BigInt where available
  if (typeof BigInt === "function") {
    /**
     * Returns a Long representing the given big integer.
     * @function
     * @param {number} value The big integer value
     * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
     * @returns {!Long} The corresponding Long value
     */
    Long.fromBigInt = function fromBigInt(value, unsigned) {
      var lowBits = Number(BigInt.asIntN(32, value));
      var highBits = Number(BigInt.asIntN(32, value >> BigInt(32)));
      return fromBits(lowBits, highBits, unsigned);
    };

    // Override
    Long.fromValue = function fromValueWithBigInt(value, unsigned) {
      if (typeof value === "bigint") return fromBigInt(value, unsigned);
      return fromValue(value, unsigned);
    };

    /**
     * Converts the Long to its big integer representation.
     * @this {!Long}
     * @returns {bigint}
     */
    LongPrototype.toBigInt = function toBigInt() {
      var lowBigInt = BigInt(this.low >>> 0);
      var highBigInt = BigInt(this.unsigned ? this.high >>> 0 : this.high);
      return (highBigInt << BigInt(32)) | lowBigInt;
    };
  }

  // SPDX-License-Identifier: Apache-2.0

  /**
   * @type {string[]}
   */
  const byteToHex$1 = [];

  for (let n = 0; n <= 0xff; n += 1) {
      byteToHex$1.push(n.toString(16).padStart(2, "0"));
  }

  /**
   * @param {Uint8Array} data
   * @returns {string}
   */
  function encode$5(data) {
      let string = "";

      for (const byte of data) {
          string += byteToHex$1[byte];
      }

      return string;
  }

  /**
   * @param {string} text
   * @returns {Uint8Array}
   */
  function decode$8(text) {
      const str = text.startsWith("0x") ? text.substring(2) : text;
      const result = str.match(/.{1,2}/gu);

      return new Uint8Array(
          (result == null ? [] : result).map((byte) => parseInt(byte, 16)),
      );
  }

  /**
   * Check if a string is a valid hexadecimal string
   * @param {string} text - The string to check
   * @returns {boolean} - True if the string is a valid hex string, false otherwise
   */
  function isHexString$1(text) {
      if (typeof text !== "string") {
          return false;
      }

      const str = text.startsWith("0x") ? text.substring(2) : text;

      // Check if the string is empty after removing 0x prefix
      if (str.length === 0) {
          return false;
      }

      // Check if the string has even length (hex pairs)
      if (str.length % 2 !== 0) {
          return false;
      }

      // Check if all characters are valid hex digits
      const hexRegex = /^[0-9a-fA-F]+$/;
      return hexRegex.test(str);
  }

  // SPDX-License-Identifier: Apache-2.0

  class BadEntityIdError extends Error {
      /**
       * @param {Long} shard
       * @param {Long} realm
       * @param {Long} num
       * @param {string} presentChecksum
       * @param {string} expectedChecksum
       */
      constructor(shard, realm, num, presentChecksum, expectedChecksum) {
          super(
              `Entity ID ${shard.toString()}.${realm.toString()}.${num.toString()}-${presentChecksum} was incorrect.`,
          );

          this.name = "BadEntityIdException";

          this.shard = shard;
          this.realm = realm;
          this.num = num;
          this.presentChecksum = presentChecksum;
          this.expectedChecksum = expectedChecksum;
      }
  }

  /*
   *      bignumber.js v9.1.1
   *      A JavaScript library for arbitrary-precision arithmetic.
   *      https://github.com/MikeMcl/bignumber.js
   *      Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
   *      MIT Licensed.
   *
   *      BigNumber.prototype methods     |  BigNumber methods
   *                                      |
   *      absoluteValue            abs    |  clone
   *      comparedTo                      |  config               set
   *      decimalPlaces            dp     |      DECIMAL_PLACES
   *      dividedBy                div    |      ROUNDING_MODE
   *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT
   *      exponentiatedBy          pow    |      RANGE
   *      integerValue                    |      CRYPTO
   *      isEqualTo                eq     |      MODULO_MODE
   *      isFinite                        |      POW_PRECISION
   *      isGreaterThan            gt     |      FORMAT
   *      isGreaterThanOrEqualTo   gte    |      ALPHABET
   *      isInteger                       |  isBigNumber
   *      isLessThan               lt     |  maximum              max
   *      isLessThanOrEqualTo      lte    |  minimum              min
   *      isNaN                           |  random
   *      isNegative                      |  sum
   *      isPositive                      |
   *      isZero                          |
   *      minus                           |
   *      modulo                   mod    |
   *      multipliedBy             times  |
   *      negated                         |
   *      plus                            |
   *      precision                sd     |
   *      shiftedBy                       |
   *      squareRoot               sqrt   |
   *      toExponential                   |
   *      toFixed                         |
   *      toFormat                        |
   *      toFraction                      |
   *      toJSON                          |
   *      toNumber                        |
   *      toPrecision                     |
   *      toString                        |
   *      valueOf                         |
   *
   */


  var
    isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
    mathceil = Math.ceil,
    mathfloor = Math.floor,

    bignumberError = '[BigNumber Error] ',
    tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',

    BASE = 1e14,
    LOG_BASE = 14,
    MAX_SAFE_INTEGER$1 = 0x1fffffffffffff,         // 2^53 - 1
    // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
    POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
    SQRT_BASE = 1e7,

    // EDITABLE
    // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
    // the arguments to toExponential, toFixed, toFormat, and toPrecision.
    MAX = 1E9;                                   // 0 to MAX_INT32


  /*
   * Create and return a BigNumber constructor.
   */
  function clone(configObject) {
    var div, convertBase, parseNumeric,
      P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },
      ONE = new BigNumber(1),


      //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------


      // The default values below must be integers within the inclusive ranges stated.
      // The values can also be changed at run-time using BigNumber.set.

      // The maximum number of decimal places for operations involving division.
      DECIMAL_PLACES = 20,                     // 0 to MAX

      // The rounding mode used when rounding to the above decimal places, and when using
      // toExponential, toFixed, toFormat and toPrecision, and round (default value).
      // UP         0 Away from zero.
      // DOWN       1 Towards zero.
      // CEIL       2 Towards +Infinity.
      // FLOOR      3 Towards -Infinity.
      // HALF_UP    4 Towards nearest neighbour. If equidistant, up.
      // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
      // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
      // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
      // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
      ROUNDING_MODE = 4,                       // 0 to 8

      // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]

      // The exponent value at and beneath which toString returns exponential notation.
      // Number type: -7
      TO_EXP_NEG = -7,                         // 0 to -MAX

      // The exponent value at and above which toString returns exponential notation.
      // Number type: 21
      TO_EXP_POS = 21,                         // 0 to MAX

      // RANGE : [MIN_EXP, MAX_EXP]

      // The minimum exponent value, beneath which underflow to zero occurs.
      // Number type: -324  (5e-324)
      MIN_EXP = -1e7,                          // -1 to -MAX

      // The maximum exponent value, above which overflow to Infinity occurs.
      // Number type:  308  (1.7976931348623157e+308)
      // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
      MAX_EXP = 1e7,                           // 1 to MAX

      // Whether to use cryptographically-secure random number generation, if available.
      CRYPTO = false,                          // true or false

      // The modulo mode used when calculating the modulus: a mod n.
      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
      // The remainder (r) is calculated as: r = a - n * q.
      //
      // UP        0 The remainder is positive if the dividend is negative, else is negative.
      // DOWN      1 The remainder has the same sign as the dividend.
      //             This modulo mode is commonly known as 'truncated division' and is
      //             equivalent to (a % n) in JavaScript.
      // FLOOR     3 The remainder has the same sign as the divisor (Python %).
      // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
      // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
      //             The remainder is always positive.
      //
      // The truncated division, floored division, Euclidian division and IEEE 754 remainder
      // modes are commonly used for the modulus operation.
      // Although the other rounding modes can also be used, they may not give useful results.
      MODULO_MODE = 1,                         // 0 to 9

      // The maximum number of significant digits of the result of the exponentiatedBy operation.
      // If POW_PRECISION is 0, there will be unlimited significant digits.
      POW_PRECISION = 0,                       // 0 to MAX

      // The format specification used by the BigNumber.prototype.toFormat method.
      FORMAT = {
        prefix: '',
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ',',
        decimalSeparator: '.',
        fractionGroupSize: 0,
        fractionGroupSeparator: '\xA0',        // non-breaking space
        suffix: ''
      },

      // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',
      // '-', '.', whitespace, or repeated character.
      // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'
      ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz',
      alphabetHasNormalDecimalDigits = true;


    //------------------------------------------------------------------------------------------


    // CONSTRUCTOR


    /*
     * The BigNumber constructor and exported function.
     * Create and return a new instance of a BigNumber object.
     *
     * v {number|string|BigNumber} A numeric value.
     * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.
     */
    function BigNumber(v, b) {
      var alphabet, c, caseChanged, e, i, isNum, len, str,
        x = this;

      // Enable constructor call without `new`.
      if (!(x instanceof BigNumber)) return new BigNumber(v, b);

      if (b == null) {

        if (v && v._isBigNumber === true) {
          x.s = v.s;

          if (!v.c || v.e > MAX_EXP) {
            x.c = x.e = null;
          } else if (v.e < MIN_EXP) {
            x.c = [x.e = 0];
          } else {
            x.e = v.e;
            x.c = v.c.slice();
          }

          return;
        }

        if ((isNum = typeof v == 'number') && v * 0 == 0) {

          // Use `1 / n` to handle minus zero also.
          x.s = 1 / v < 0 ? (v = -v, -1) : 1;

          // Fast path for integers, where n < 2147483648 (2**31).
          if (v === ~~v) {
            for (e = 0, i = v; i >= 10; i /= 10, e++);

            if (e > MAX_EXP) {
              x.c = x.e = null;
            } else {
              x.e = e;
              x.c = [v];
            }

            return;
          }

          str = String(v);
        } else {

          if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);

          x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
        }

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

        // Exponential form?
        if ((i = str.search(/e/i)) > 0) {

          // Determine exponent.
          if (e < 0) e = i;
          e += +str.slice(i + 1);
          str = str.substring(0, i);
        } else if (e < 0) {

          // Integer.
          e = str.length;
        }

      } else {

        // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
        intCheck(b, 2, ALPHABET.length, 'Base');

        // Allow exponential notation to be used with base 10 argument, while
        // also rounding to DECIMAL_PLACES as with other bases.
        if (b == 10 && alphabetHasNormalDecimalDigits) {
          x = new BigNumber(v);
          return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
        }

        str = String(v);

        if (isNum = typeof v == 'number') {

          // Avoid potential interpretation of Infinity and NaN as base 44+ values.
          if (v * 0 != 0) return parseNumeric(x, str, isNum, b);

          x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;

          // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
          if (BigNumber.DEBUG && str.replace(/^0\.0*|\./, '').length > 15) {
            throw Error
             (tooManyDigits + v);
          }
        } else {
          x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
        }

        alphabet = ALPHABET.slice(0, b);
        e = i = 0;

        // Check that str is a valid base b number.
        // Don't use RegExp, so alphabet can contain special characters.
        for (len = str.length; i < len; i++) {
          if (alphabet.indexOf(c = str.charAt(i)) < 0) {
            if (c == '.') {

              // If '.' is not the first character and it has not be found before.
              if (i > e) {
                e = len;
                continue;
              }
            } else if (!caseChanged) {

              // Allow e.g. hexadecimal 'FF' as well as 'ff'.
              if (str == str.toUpperCase() && (str = str.toLowerCase()) ||
                  str == str.toLowerCase() && (str = str.toUpperCase())) {
                caseChanged = true;
                i = -1;
                e = 0;
                continue;
              }
            }

            return parseNumeric(x, String(v), isNum, b);
          }
        }

        // Prevent later check for length on converted number.
        isNum = false;
        str = convertBase(str, b, 10, x.s);

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');
        else e = str.length;
      }

      // Determine leading zeros.
      for (i = 0; str.charCodeAt(i) === 48; i++);

      // Determine trailing zeros.
      for (len = str.length; str.charCodeAt(--len) === 48;);

      if (str = str.slice(i, ++len)) {
        len -= i;

        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
        if (isNum && BigNumber.DEBUG &&
          len > 15 && (v > MAX_SAFE_INTEGER$1 || v !== mathfloor(v))) {
            throw Error
             (tooManyDigits + (x.s * v));
        }

         // Overflow?
        if ((e = e - i - 1) > MAX_EXP) {

          // Infinity.
          x.c = x.e = null;

        // Underflow?
        } else if (e < MIN_EXP) {

          // Zero.
          x.c = [x.e = 0];
        } else {
          x.e = e;
          x.c = [];

          // Transform base

          // e is the base 10 exponent.
          // i is where to slice str to get the first element of the coefficient array.
          i = (e + 1) % LOG_BASE;
          if (e < 0) i += LOG_BASE;  // i < 1

          if (i < len) {
            if (i) x.c.push(+str.slice(0, i));

            for (len -= LOG_BASE; i < len;) {
              x.c.push(+str.slice(i, i += LOG_BASE));
            }

            i = LOG_BASE - (str = str.slice(i)).length;
          } else {
            i -= len;
          }

          for (; i--; str += '0');
          x.c.push(+str);
        }
      } else {

        // Zero.
        x.c = [x.e = 0];
      }
    }


    // CONSTRUCTOR PROPERTIES


    BigNumber.clone = clone;

    BigNumber.ROUND_UP = 0;
    BigNumber.ROUND_DOWN = 1;
    BigNumber.ROUND_CEIL = 2;
    BigNumber.ROUND_FLOOR = 3;
    BigNumber.ROUND_HALF_UP = 4;
    BigNumber.ROUND_HALF_DOWN = 5;
    BigNumber.ROUND_HALF_EVEN = 6;
    BigNumber.ROUND_HALF_CEIL = 7;
    BigNumber.ROUND_HALF_FLOOR = 8;
    BigNumber.EUCLID = 9;


    /*
     * Configure infrequently-changing library-wide settings.
     *
     * Accept an object with the following optional properties (if the value of a property is
     * a number, it must be an integer within the inclusive range stated):
     *
     *   DECIMAL_PLACES   {number}           0 to MAX
     *   ROUNDING_MODE    {number}           0 to 8
     *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]
     *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]
     *   CRYPTO           {boolean}          true or false
     *   MODULO_MODE      {number}           0 to 9
     *   POW_PRECISION       {number}           0 to MAX
     *   ALPHABET         {string}           A string of two or more unique characters which does
     *                                       not contain '.'.
     *   FORMAT           {object}           An object with some of the following properties:
     *     prefix                 {string}
     *     groupSize              {number}
     *     secondaryGroupSize     {number}
     *     groupSeparator         {string}
     *     decimalSeparator       {string}
     *     fractionGroupSize      {number}
     *     fractionGroupSeparator {string}
     *     suffix                 {string}
     *
     * (The values assigned to the above FORMAT object properties are not checked for validity.)
     *
     * E.g.
     * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
     *
     * Ignore properties/parameters set to null or undefined, except for ALPHABET.
     *
     * Return an object with the properties current values.
     */
    BigNumber.config = BigNumber.set = function (obj) {
      var p, v;

      if (obj != null) {

        if (typeof obj == 'object') {

          // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            DECIMAL_PLACES = v;
          }

          // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
          // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {
            v = obj[p];
            intCheck(v, 0, 8, p);
            ROUNDING_MODE = v;
          }

          // EXPONENTIAL_AT {number|number[]}
          // Integer, -MAX to MAX inclusive or
          // [integer -MAX to 0 inclusive, 0 to MAX inclusive].
          // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -1e9, 0, p);
              intCheck(v[1], 0, MAX, p);
              TO_EXP_NEG = v[0];
              TO_EXP_POS = v[1];
            } else {
              intCheck(v, -1e9, MAX, p);
              TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
            }
          }

          // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
          // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
          // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'
          if (obj.hasOwnProperty(p = 'RANGE')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -1e9, -1, p);
              intCheck(v[1], 1, MAX, p);
              MIN_EXP = v[0];
              MAX_EXP = v[1];
            } else {
              intCheck(v, -1e9, MAX, p);
              if (v) {
                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
              } else {
                throw Error
                 (bignumberError + p + ' cannot be zero: ' + v);
              }
            }
          }

          // CRYPTO {boolean} true or false.
          // '[BigNumber Error] CRYPTO not true or false: {v}'
          // '[BigNumber Error] crypto unavailable'
          if (obj.hasOwnProperty(p = 'CRYPTO')) {
            v = obj[p];
            if (v === !!v) {
              if (v) {
                if (typeof crypto != 'undefined' && crypto &&
                 (crypto.getRandomValues || crypto.randomBytes)) {
                  CRYPTO = v;
                } else {
                  CRYPTO = !v;
                  throw Error
                   (bignumberError + 'crypto unavailable');
                }
              } else {
                CRYPTO = v;
              }
            } else {
              throw Error
               (bignumberError + p + ' not true or false: ' + v);
            }
          }

          // MODULO_MODE {number} Integer, 0 to 9 inclusive.
          // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'MODULO_MODE')) {
            v = obj[p];
            intCheck(v, 0, 9, p);
            MODULO_MODE = v;
          }

          // POW_PRECISION {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'POW_PRECISION')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            POW_PRECISION = v;
          }

          // FORMAT {object}
          // '[BigNumber Error] FORMAT not an object: {v}'
          if (obj.hasOwnProperty(p = 'FORMAT')) {
            v = obj[p];
            if (typeof v == 'object') FORMAT = v;
            else throw Error
             (bignumberError + p + ' not an object: ' + v);
          }

          // ALPHABET {string}
          // '[BigNumber Error] ALPHABET invalid: {v}'
          if (obj.hasOwnProperty(p = 'ALPHABET')) {
            v = obj[p];

            // Disallow if less than two characters,
            // or if it contains '+', '-', '.', whitespace, or a repeated character.
            if (typeof v == 'string' && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
              alphabetHasNormalDecimalDigits = v.slice(0, 10) == '0123456789';
              ALPHABET = v;
            } else {
              throw Error
               (bignumberError + p + ' invalid: ' + v);
            }
          }

        } else {

          // '[BigNumber Error] Object expected: {v}'
          throw Error
           (bignumberError + 'Object expected: ' + obj);
        }
      }

      return {
        DECIMAL_PLACES: DECIMAL_PLACES,
        ROUNDING_MODE: ROUNDING_MODE,
        EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
        RANGE: [MIN_EXP, MAX_EXP],
        CRYPTO: CRYPTO,
        MODULO_MODE: MODULO_MODE,
        POW_PRECISION: POW_PRECISION,
        FORMAT: FORMAT,
        ALPHABET: ALPHABET
      };
    };


    /*
     * Return true if v is a BigNumber instance, otherwise return false.
     *
     * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.
     *
     * v {any}
     *
     * '[BigNumber Error] Invalid BigNumber: {v}'
     */
    BigNumber.isBigNumber = function (v) {
      if (!v || v._isBigNumber !== true) return false;
      if (!BigNumber.DEBUG) return true;

      var i, n,
        c = v.c,
        e = v.e,
        s = v.s;

      out: if ({}.toString.call(c) == '[object Array]') {

        if ((s === 1 || s === -1) && e >= -1e9 && e <= MAX && e === mathfloor(e)) {

          // If the first element is zero, the BigNumber value must be zero.
          if (c[0] === 0) {
            if (e === 0 && c.length === 1) return true;
            break out;
          }

          // Calculate number of digits that c[0] should have, based on the exponent.
          i = (e + 1) % LOG_BASE;
          if (i < 1) i += LOG_BASE;

          // Calculate number of digits of c[0].
          //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {
          if (String(c[0]).length == i) {

            for (i = 0; i < c.length; i++) {
              n = c[i];
              if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
            }

            // Last element cannot be zero, unless it is the only element.
            if (n !== 0) return true;
          }
        }

      // Infinity/NaN
      } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
        return true;
      }

      throw Error
        (bignumberError + 'Invalid BigNumber: ' + v);
    };


    /*
     * Return a new BigNumber whose value is the maximum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.maximum = BigNumber.max = function () {
      return maxOrMin(arguments, P.lt);
    };


    /*
     * Return a new BigNumber whose value is the minimum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.minimum = BigNumber.min = function () {
      return maxOrMin(arguments, P.gt);
    };


    /*
     * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
     * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
     * zeros are produced).
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'
     * '[BigNumber Error] crypto unavailable'
     */
    BigNumber.random = (function () {
      var pow2_53 = 0x20000000000000;

      // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
      // Check if Math.random() produces more than 32 bits of randomness.
      // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
      // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
      var random53bitInt = (Math.random() * pow2_53) & 0x1fffff
       ? function () { return mathfloor(Math.random() * pow2_53); }
       : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +
         (Math.random() * 0x800000 | 0); };

      return function (dp) {
        var a, b, e, k, v,
          i = 0,
          c = [],
          rand = new BigNumber(ONE);

        if (dp == null) dp = DECIMAL_PLACES;
        else intCheck(dp, 0, MAX);

        k = mathceil(dp / LOG_BASE);

        if (CRYPTO) {

          // Browsers supporting crypto.getRandomValues.
          if (crypto.getRandomValues) {

            a = crypto.getRandomValues(new Uint32Array(k *= 2));

            for (; i < k;) {

              // 53 bits:
              // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
              // 11111 11111111 11111111 11111111 11100000 00000000 00000000
              // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
              //                                     11111 11111111 11111111
              // 0x20000 is 2^21.
              v = a[i] * 0x20000 + (a[i + 1] >>> 11);

              // Rejection sampling:
              // 0 <= v < 9007199254740992
              // Probability that v >= 9e15, is
              // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
              if (v >= 9e15) {
                b = crypto.getRandomValues(new Uint32Array(2));
                a[i] = b[0];
                a[i + 1] = b[1];
              } else {

                // 0 <= v <= 8999999999999999
                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 2;
              }
            }
            i = k / 2;

          // Node.js supporting crypto.randomBytes.
          } else if (crypto.randomBytes) {

            // buffer
            a = crypto.randomBytes(k *= 7);

            for (; i < k;) {

              // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
              // 0x100000000 is 2^32, 0x1000000 is 2^24
              // 11111 11111111 11111111 11111111 11111111 11111111 11111111
              // 0 <= v < 9007199254740992
              v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +
                 (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +
                 (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];

              if (v >= 9e15) {
                crypto.randomBytes(7).copy(a, i);
              } else {

                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 7;
              }
            }
            i = k / 7;
          } else {
            CRYPTO = false;
            throw Error
             (bignumberError + 'crypto unavailable');
          }
        }

        // Use Math.random.
        if (!CRYPTO) {

          for (; i < k;) {
            v = random53bitInt();
            if (v < 9e15) c[i++] = v % 1e14;
          }
        }

        k = c[--i];
        dp %= LOG_BASE;

        // Convert trailing digits to zeros according to dp.
        if (k && dp) {
          v = POWS_TEN[LOG_BASE - dp];
          c[i] = mathfloor(k / v) * v;
        }

        // Remove trailing elements which are zero.
        for (; c[i] === 0; c.pop(), i--);

        // Zero?
        if (i < 0) {
          c = [e = 0];
        } else {

          // Remove leading elements which are zero and adjust exponent accordingly.
          for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);

          // Count the digits of the first element of c to determine leading zeros, and...
          for (i = 1, v = c[0]; v >= 10; v /= 10, i++);

          // adjust the exponent accordingly.
          if (i < LOG_BASE) e -= LOG_BASE - i;
        }

        rand.e = e;
        rand.c = c;
        return rand;
      };
    })();


     /*
     * Return a BigNumber whose value is the sum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.sum = function () {
      var i = 1,
        args = arguments,
        sum = new BigNumber(args[0]);
      for (; i < args.length;) sum = sum.plus(args[i++]);
      return sum;
    };


    // PRIVATE FUNCTIONS


    // Called by BigNumber and BigNumber.prototype.toString.
    convertBase = (function () {
      var decimal = '0123456789';

      /*
       * Convert string of baseIn to an array of numbers of baseOut.
       * Eg. toBaseOut('255', 10, 16) returns [15, 15].
       * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].
       */
      function toBaseOut(str, baseIn, baseOut, alphabet) {
        var j,
          arr = [0],
          arrL,
          i = 0,
          len = str.length;

        for (; i < len;) {
          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);

          arr[0] += alphabet.indexOf(str.charAt(i++));

          for (j = 0; j < arr.length; j++) {

            if (arr[j] > baseOut - 1) {
              if (arr[j + 1] == null) arr[j + 1] = 0;
              arr[j + 1] += arr[j] / baseOut | 0;
              arr[j] %= baseOut;
            }
          }
        }

        return arr.reverse();
      }

      // Convert a numeric string of baseIn to a numeric string of baseOut.
      // If the caller is toString, we are converting from base 10 to baseOut.
      // If the caller is BigNumber, we are converting from baseIn to base 10.
      return function (str, baseIn, baseOut, sign, callerIsToString) {
        var alphabet, d, e, k, r, x, xc, y,
          i = str.indexOf('.'),
          dp = DECIMAL_PLACES,
          rm = ROUNDING_MODE;

        // Non-integer.
        if (i >= 0) {
          k = POW_PRECISION;

          // Unlimited precision.
          POW_PRECISION = 0;
          str = str.replace('.', '');
          y = new BigNumber(baseIn);
          x = y.pow(str.length - i);
          POW_PRECISION = k;

          // Convert str as if an integer, then restore the fraction part by dividing the
          // result by its base raised to a power.

          y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),
           10, baseOut, decimal);
          y.e = y.c.length;
        }

        // Convert the number as integer.

        xc = toBaseOut(str, baseIn, baseOut, callerIsToString
         ? (alphabet = ALPHABET, decimal)
         : (alphabet = decimal, ALPHABET));

        // xc now represents str as an integer and converted to baseOut. e is the exponent.
        e = k = xc.length;

        // Remove trailing zeros.
        for (; xc[--k] == 0; xc.pop());

        // Zero?
        if (!xc[0]) return alphabet.charAt(0);

        // Does str represent an integer? If so, no need for the division.
        if (i < 0) {
          --e;
        } else {
          x.c = xc;
          x.e = e;

          // The sign is needed for correct rounding.
          x.s = sign;
          x = div(x, y, dp, rm, baseOut);
          xc = x.c;
          r = x.r;
          e = x.e;
        }

        // xc now represents str converted to baseOut.

        // THe index of the rounding digit.
        d = e + dp + 1;

        // The rounding digit: the digit to the right of the digit that may be rounded up.
        i = xc[d];

        // Look at the rounding digits and mode to determine whether to round up.

        k = baseOut / 2;
        r = r || d < 0 || xc[d + 1] != null;

        r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
              : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||
               rm == (x.s < 0 ? 8 : 7));

        // If the index of the rounding digit is not greater than zero, or xc represents
        // zero, then the result of the base conversion is zero or, if rounding up, a value
        // such as 0.00001.
        if (d < 1 || !xc[0]) {

          // 1^-dp or 0
          str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
        } else {

          // Truncate xc to the required number of decimal places.
          xc.length = d;

          // Round up?
          if (r) {

            // Rounding up may mean the previous digit has to be rounded up and so on.
            for (--baseOut; ++xc[--d] > baseOut;) {
              xc[d] = 0;

              if (!d) {
                ++e;
                xc = [1].concat(xc);
              }
            }
          }

          // Determine trailing zeros.
          for (k = xc.length; !xc[--k];);

          // E.g. [4, 11, 15] becomes 4bf.
          for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));

          // Add leading zeros, decimal point and trailing zeros as required.
          str = toFixedPoint(str, e, alphabet.charAt(0));
        }

        // The caller will add the sign.
        return str;
      };
    })();


    // Perform division in the specified base. Called by div and convertBase.
    div = (function () {

      // Assume non-zero x and k.
      function multiply(x, k, base) {
        var m, temp, xlo, xhi,
          carry = 0,
          i = x.length,
          klo = k % SQRT_BASE,
          khi = k / SQRT_BASE | 0;

        for (x = x.slice(); i--;) {
          xlo = x[i] % SQRT_BASE;
          xhi = x[i] / SQRT_BASE | 0;
          m = khi * xlo + xhi * klo;
          temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;
          carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
          x[i] = temp % base;
        }

        if (carry) x = [carry].concat(x);

        return x;
      }

      function compare(a, b, aL, bL) {
        var i, cmp;

        if (aL != bL) {
          cmp = aL > bL ? 1 : -1;
        } else {

          for (i = cmp = 0; i < aL; i++) {

            if (a[i] != b[i]) {
              cmp = a[i] > b[i] ? 1 : -1;
              break;
            }
          }
        }

        return cmp;
      }

      function subtract(a, b, aL, base) {
        var i = 0;

        // Subtract b from a.
        for (; aL--;) {
          a[aL] -= i;
          i = a[aL] < b[aL] ? 1 : 0;
          a[aL] = i * base + a[aL] - b[aL];
        }

        // Remove leading zeros.
        for (; !a[0] && a.length > 1; a.splice(0, 1));
      }

      // x: dividend, y: divisor.
      return function (x, y, dp, rm, base) {
        var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,
          yL, yz,
          s = x.s == y.s ? 1 : -1,
          xc = x.c,
          yc = y.c;

        // Either NaN, Infinity or 0?
        if (!xc || !xc[0] || !yc || !yc[0]) {

          return new BigNumber(

           // Return NaN if either NaN, or both Infinity or 0.
           !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :

            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
            xc && xc[0] == 0 || !yc ? s * 0 : s / 0
         );
        }

        q = new BigNumber(s);
        qc = q.c = [];
        e = x.e - y.e;
        s = dp + e + 1;

        if (!base) {
          base = BASE;
          e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
          s = s / LOG_BASE | 0;
        }

        // Result exponent may be one less then the current value of e.
        // The coefficients of the BigNumbers from convertBase may have trailing zeros.
        for (i = 0; yc[i] == (xc[i] || 0); i++);

        if (yc[i] > (xc[i] || 0)) e--;

        if (s < 0) {
          qc.push(1);
          more = true;
        } else {
          xL = xc.length;
          yL = yc.length;
          i = 0;
          s += 2;

          // Normalise xc and yc so highest order digit of yc is >= base / 2.

          n = mathfloor(base / (yc[0] + 1));

          // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.
          // if (n > 1 || n++ == 1 && yc[0] < base / 2) {
          if (n > 1) {
            yc = multiply(yc, n, base);
            xc = multiply(xc, n, base);
            yL = yc.length;
            xL = xc.length;
          }

          xi = yL;
          rem = xc.slice(0, yL);
          remL = rem.length;

          // Add zeros to make remainder as long as divisor.
          for (; remL < yL; rem[remL++] = 0);
          yz = yc.slice();
          yz = [0].concat(yz);
          yc0 = yc[0];
          if (yc[1] >= base / 2) yc0++;
          // Not necessary, but to prevent trial digit n > base, when using base 3.
          // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;

          do {
            n = 0;

            // Compare divisor and remainder.
            cmp = compare(yc, rem, yL, remL);

            // If divisor < remainder.
            if (cmp < 0) {

              // Calculate trial digit, n.

              rem0 = rem[0];
              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

              // n is how many times the divisor goes into the current remainder.
              n = mathfloor(rem0 / yc0);

              //  Algorithm:
              //  product = divisor multiplied by trial digit (n).
              //  Compare product and remainder.
              //  If product is greater than remainder:
              //    Subtract divisor from product, decrement trial digit.
              //  Subtract product from remainder.
              //  If product was less than remainder at the last compare:
              //    Compare new remainder and divisor.
              //    If remainder is greater than divisor:
              //      Subtract divisor from remainder, increment trial digit.

              if (n > 1) {

                // n may be > base only when base is 3.
                if (n >= base) n = base - 1;

                // product = divisor * trial digit.
                prod = multiply(yc, n, base);
                prodL = prod.length;
                remL = rem.length;

                // Compare product and remainder.
                // If product > remainder then trial digit n too high.
                // n is 1 too high about 5% of the time, and is not known to have
                // ever been more than 1 too high.
                while (compare(prod, rem, prodL, remL) == 1) {
                  n--;

                  // Subtract divisor from product.
                  subtract(prod, yL < prodL ? yz : yc, prodL, base);
                  prodL = prod.length;
                  cmp = 1;
                }
              } else {

                // n is 0 or 1, cmp is -1.
                // If n is 0, there is no need to compare yc and rem again below,
                // so change cmp to 1 to avoid it.
                // If n is 1, leave cmp as -1, so yc and rem are compared again.
                if (n == 0) {

                  // divisor < remainder, so n must be at least 1.
                  cmp = n = 1;
                }

                // product = divisor
                prod = yc.slice();
                prodL = prod.length;
              }

              if (prodL < remL) prod = [0].concat(prod);

              // Subtract product from remainder.
              subtract(rem, prod, remL, base);
              remL = rem.length;

               // If product was < remainder.
              if (cmp == -1) {

                // Compare divisor and new remainder.
                // If divisor < new remainder, subtract divisor from remainder.
                // Trial digit n too low.
                // n is 1 too low about 5% of the time, and very rarely 2 too low.
                while (compare(yc, rem, yL, remL) < 1) {
                  n++;

                  // Subtract divisor from remainder.
                  subtract(rem, yL < remL ? yz : yc, remL, base);
                  remL = rem.length;
                }
              }
            } else if (cmp === 0) {
              n++;
              rem = [0];
            } // else cmp === 1 and n will be 0

            // Add the next digit, n, to the result array.
            qc[i++] = n;

            // Update the remainder.
            if (rem[0]) {
              rem[remL++] = xc[xi] || 0;
            } else {
              rem = [xc[xi]];
              remL = 1;
            }
          } while ((xi++ < xL || rem[0] != null) && s--);

          more = rem[0] != null;

          // Leading zero?
          if (!qc[0]) qc.splice(0, 1);
        }

        if (base == BASE) {

          // To calculate q.e, first get the number of digits of qc[0].
          for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);

          round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);

        // Caller is convertBase.
        } else {
          q.e = e;
          q.r = +more;
        }

        return q;
      };
    })();


    /*
     * Return a string representing the value of BigNumber n in fixed-point or exponential
     * notation rounded to the specified decimal places or significant digits.
     *
     * n: a BigNumber.
     * i: the index of the last digit required (i.e. the digit that may be rounded up).
     * rm: the rounding mode.
     * id: 1 (toExponential) or 2 (toPrecision).
     */
    function format(n, i, rm, id) {
      var c0, e, ne, len, str;

      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);

      if (!n.c) return n.toString();

      c0 = n.c[0];
      ne = n.e;

      if (i == null) {
        str = coeffToString(n.c);
        str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)
         ? toExponential(str, ne)
         : toFixedPoint(str, ne, '0');
      } else {
        n = round(new BigNumber(n), i, rm);

        // n.e may have changed if the value was rounded up.
        e = n.e;

        str = coeffToString(n.c);
        len = str.length;

        // toPrecision returns exponential notation if the number of significant digits
        // specified is less than the number of digits necessary to represent the integer
        // part of the value in fixed-point notation.

        // Exponential notation.
        if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {

          // Append zeros?
          for (; len < i; str += '0', len++);
          str = toExponential(str, e);

        // Fixed-point notation.
        } else {
          i -= ne;
          str = toFixedPoint(str, e, '0');

          // Append zeros?
          if (e + 1 > len) {
            if (--i > 0) for (str += '.'; i--; str += '0');
          } else {
            i += e - len;
            if (i > 0) {
              if (e + 1 == len) str += '.';
              for (; i--; str += '0');
            }
          }
        }
      }

      return n.s < 0 && c0 ? '-' + str : str;
    }


    // Handle BigNumber.max and BigNumber.min.
    function maxOrMin(args, method) {
      var n,
        i = 1,
        m = new BigNumber(args[0]);

      for (; i < args.length; i++) {
        n = new BigNumber(args[i]);

        // If any number is NaN, return NaN.
        if (!n.s) {
          m = n;
          break;
        } else if (method.call(m, n)) {
          m = n;
        }
      }

      return m;
    }


    /*
     * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
     * Called by minus, plus and times.
     */
    function normalise(n, c, e) {
      var i = 1,
        j = c.length;

       // Remove trailing zeros.
      for (; !c[--j]; c.pop());

      // Calculate the base 10 exponent. First get the number of digits of c[0].
      for (j = c[0]; j >= 10; j /= 10, i++);

      // Overflow?
      if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {

        // Infinity.
        n.c = n.e = null;

      // Underflow?
      } else if (e < MIN_EXP) {

        // Zero.
        n.c = [n.e = 0];
      } else {
        n.e = e;
        n.c = c;
      }

      return n;
    }


    // Handle values that fail the validity test in BigNumber.
    parseNumeric = (function () {
      var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
        dotAfter = /^([^.]+)\.$/,
        dotBefore = /^\.([^.]+)$/,
        isInfinityOrNaN = /^-?(Infinity|NaN)$/,
        whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;

      return function (x, str, isNum, b) {
        var base,
          s = isNum ? str : str.replace(whitespaceOrPlus, '');

        // No exception on Infinity or NaN.
        if (isInfinityOrNaN.test(s)) {
          x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
        } else {
          if (!isNum) {

            // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
            s = s.replace(basePrefix, function (m, p1, p2) {
              base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
              return !b || b == base ? p1 : m;
            });

            if (b) {
              base = b;

              // E.g. '1.' to '1', '.1' to '0.1'
              s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');
            }

            if (str != s) return new BigNumber(s, base);
          }

          // '[BigNumber Error] Not a number: {n}'
          // '[BigNumber Error] Not a base {b} number: {n}'
          if (BigNumber.DEBUG) {
            throw Error
              (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);
          }

          // NaN
          x.s = null;
        }

        x.c = x.e = null;
      }
    })();


    /*
     * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
     * If r is truthy, it is known that there are more digits after the rounding digit.
     */
    function round(x, sd, rm, r) {
      var d, i, j, k, n, ni, rd,
        xc = x.c,
        pows10 = POWS_TEN;

      // if x is not Infinity or NaN...
      if (xc) {

        // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
        // n is a base 1e14 number, the value of the element of array x.c containing rd.
        // ni is the index of n within x.c.
        // d is the number of digits of n.
        // i is the index of rd within n including leading zeros.
        // j is the actual index of rd within n (if < 0, rd is a leading zero).
        out: {

          // Get the number of digits of the first element of xc.
          for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);
          i = sd - d;

          // If the rounding digit is in the first element of xc...
          if (i < 0) {
            i += LOG_BASE;
            j = sd;
            n = xc[ni = 0];

            // Get the rounding digit at index j of n.
            rd = n / pows10[d - j - 1] % 10 | 0;
          } else {
            ni = mathceil((i + 1) / LOG_BASE);

            if (ni >= xc.length) {

              if (r) {

                // Needed by sqrt.
                for (; xc.length <= ni; xc.push(0));
                n = rd = 0;
                d = 1;
                i %= LOG_BASE;
                j = i - LOG_BASE + 1;
              } else {
                break out;
              }
            } else {
              n = k = xc[ni];

              // Get the number of digits of n.
              for (d = 1; k >= 10; k /= 10, d++);

              // Get the index of rd within n.
              i %= LOG_BASE;

              // Get the index of rd within n, adjusted for leading zeros.
              // The number of leading zeros of n is given by LOG_BASE - d.
              j = i - LOG_BASE + d;

              // Get the rounding digit at index j of n.
              rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
            }
          }

          r = r || sd < 0 ||

          // Are there any non-zero digits after the rounding digit?
          // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
          // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
           xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);

          r = rm < 4
           ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
           : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&

            // Check whether the digit to the left of the rounding digit is odd.
            ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||
             rm == (x.s < 0 ? 8 : 7));

          if (sd < 1 || !xc[0]) {
            xc.length = 0;

            if (r) {

              // Convert sd to decimal places.
              sd -= x.e + 1;

              // 1, 0.1, 0.01, 0.001, 0.0001 etc.
              xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
              x.e = -sd || 0;
            } else {

              // Zero.
              xc[0] = x.e = 0;
            }

            return x;
          }

          // Remove excess digits.
          if (i == 0) {
            xc.length = ni;
            k = 1;
            ni--;
          } else {
            xc.length = ni + 1;
            k = pows10[LOG_BASE - i];

            // E.g. 56700 becomes 56000 if 7 is the rounding digit.
            // j > 0 means i > number of leading zeros of n.
            xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
          }

          // Round up?
          if (r) {

            for (; ;) {

              // If the digit to be rounded up is in the first element of xc...
              if (ni == 0) {

                // i will be the length of xc[0] before k is added.
                for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);
                j = xc[0] += k;
                for (k = 1; j >= 10; j /= 10, k++);

                // if i != k the length has increased.
                if (i != k) {
                  x.e++;
                  if (xc[0] == BASE) xc[0] = 1;
                }

                break;
              } else {
                xc[ni] += k;
                if (xc[ni] != BASE) break;
                xc[ni--] = 0;
                k = 1;
              }
            }
          }

          // Remove trailing zeros.
          for (i = xc.length; xc[--i] === 0; xc.pop());
        }

        // Overflow? Infinity.
        if (x.e > MAX_EXP) {
          x.c = x.e = null;

        // Underflow? Zero.
        } else if (x.e < MIN_EXP) {
          x.c = [x.e = 0];
        }
      }

      return x;
    }


    function valueOf(n) {
      var str,
        e = n.e;

      if (e === null) return n.toString();

      str = coeffToString(n.c);

      str = e <= TO_EXP_NEG || e >= TO_EXP_POS
        ? toExponential(str, e)
        : toFixedPoint(str, e, '0');

      return n.s < 0 ? '-' + str : str;
    }


    // PROTOTYPE/INSTANCE METHODS


    /*
     * Return a new BigNumber whose value is the absolute value of this BigNumber.
     */
    P.absoluteValue = P.abs = function () {
      var x = new BigNumber(this);
      if (x.s < 0) x.s = 1;
      return x;
    };


    /*
     * Return
     *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
     *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
     *   0 if they have the same value,
     *   or null if the value of either is NaN.
     */
    P.comparedTo = function (y, b) {
      return compare$2(this, new BigNumber(y, b));
    };


    /*
     * If dp is undefined or null or true or false, return the number of decimal places of the
     * value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.
     *
     * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * [dp] {number} Decimal places: integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.decimalPlaces = P.dp = function (dp, rm) {
      var c, n, v,
        x = this;

      if (dp != null) {
        intCheck(dp, 0, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);

        return round(new BigNumber(x), dp + x.e + 1, rm);
      }

      if (!(c = x.c)) return null;
      n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;

      // Subtract the number of trailing zeros of the last number.
      if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);
      if (n < 0) n = 0;

      return n;
    };


    /*
     *  n / 0 = I
     *  n / N = N
     *  n / I = 0
     *  0 / n = 0
     *  0 / 0 = N
     *  0 / N = N
     *  0 / I = 0
     *  N / n = N
     *  N / 0 = N
     *  N / N = N
     *  N / I = N
     *  I / n = I
     *  I / 0 = I
     *  I / N = N
     *  I / I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
     * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.dividedBy = P.div = function (y, b) {
      return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);
    };


    /*
     * Return a new BigNumber whose value is the integer part of dividing the value of this
     * BigNumber by the value of BigNumber(y, b).
     */
    P.dividedToIntegerBy = P.idiv = function (y, b) {
      return div(this, new BigNumber(y, b), 0, 1);
    };


    /*
     * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.
     *
     * If m is present, return the result modulo m.
     * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
     * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.
     *
     * The modular power operation works efficiently when x, n, and m are integers, otherwise it
     * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.
     *
     * n {number|string|BigNumber} The exponent. An integer.
     * [m] {number|string|BigNumber} The modulus.
     *
     * '[BigNumber Error] Exponent not an integer: {n}'
     */
    P.exponentiatedBy = P.pow = function (n, m) {
      var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,
        x = this;

      n = new BigNumber(n);

      // Allow NaN and Infinity, but not other non-integers.
      if (n.c && !n.isInteger()) {
        throw Error
          (bignumberError + 'Exponent not an integer: ' + valueOf(n));
      }

      if (m != null) m = new BigNumber(m);

      // Exponent of MAX_SAFE_INTEGER is 15.
      nIsBig = n.e > 14;

      // If x is NaN, Infinity, 0 or 1, or n is Infinity, NaN or 0.
      if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {

        // The sign of the result of pow when x is negative depends on the evenness of n.
        // If +n overflows to Infinity, the evenness of n would be not be known.
        y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
        return m ? y.mod(m) : y;
      }

      nIsNeg = n.s < 0;

      if (m) {

        // x % m returns NaN if abs(m) is zero, or m is NaN.
        if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);

        isModExp = !nIsNeg && x.isInteger() && m.isInteger();

        if (isModExp) x = x.mod(m);

      // Overflow to Infinity: >=2**1e10 or >=1.0000024**1e15.
      // Underflow to 0: <=0.79**1e10 or <=0.9999975**1e15.
      } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0
        // [1, 240000000]
        ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7
        // [80000000000000]  [99999750000000]
        : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {

        // If x is negative and n is odd, k = -0, else k = 0.
        k = x.s < 0 && isOdd(n) ? -0 : 0;

        // If x >= 1, k = Infinity.
        if (x.e > -1) k = 1 / k;

        // If n is negative return 0, else return Infinity.
        return new BigNumber(nIsNeg ? 1 / k : k);

      } else if (POW_PRECISION) {

        // Truncating each coefficient array to a length of k after each multiplication
        // equates to truncating significant digits to POW_PRECISION + [28, 41],
        // i.e. there will be a minimum of 28 guard digits retained.
        k = mathceil(POW_PRECISION / LOG_BASE + 2);
      }

      if (nIsBig) {
        half = new BigNumber(0.5);
        if (nIsNeg) n.s = 1;
        nIsOdd = isOdd(n);
      } else {
        i = Math.abs(+valueOf(n));
        nIsOdd = i % 2;
      }

      y = new BigNumber(ONE);

      // Performs 54 loop iterations for n of 9007199254740991.
      for (; ;) {

        if (nIsOdd) {
          y = y.times(x);
          if (!y.c) break;

          if (k) {
            if (y.c.length > k) y.c.length = k;
          } else if (isModExp) {
            y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));
          }
        }

        if (i) {
          i = mathfloor(i / 2);
          if (i === 0) break;
          nIsOdd = i % 2;
        } else {
          n = n.times(half);
          round(n, n.e + 1, 1);

          if (n.e > 14) {
            nIsOdd = isOdd(n);
          } else {
            i = +valueOf(n);
            if (i === 0) break;
            nIsOdd = i % 2;
          }
        }

        x = x.times(x);

        if (k) {
          if (x.c && x.c.length > k) x.c.length = k;
        } else if (isModExp) {
          x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));
        }
      }

      if (isModExp) return y;
      if (nIsNeg) y = ONE.div(y);

      return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer
     * using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'
     */
    P.integerValue = function (rm) {
      var n = new BigNumber(this);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);
      return round(n, n.e + 1, rm);
    };


    /*
     * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isEqualTo = P.eq = function (y, b) {
      return compare$2(this, new BigNumber(y, b)) === 0;
    };


    /*
     * Return true if the value of this BigNumber is a finite number, otherwise return false.
     */
    P.isFinite = function () {
      return !!this.c;
    };


    /*
     * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isGreaterThan = P.gt = function (y, b) {
      return compare$2(this, new BigNumber(y, b)) > 0;
    };


    /*
     * Return true if the value of this BigNumber is greater than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isGreaterThanOrEqualTo = P.gte = function (y, b) {
      return (b = compare$2(this, new BigNumber(y, b))) === 1 || b === 0;

    };


    /*
     * Return true if the value of this BigNumber is an integer, otherwise return false.
     */
    P.isInteger = function () {
      return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
    };


    /*
     * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isLessThan = P.lt = function (y, b) {
      return compare$2(this, new BigNumber(y, b)) < 0;
    };


    /*
     * Return true if the value of this BigNumber is less than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isLessThanOrEqualTo = P.lte = function (y, b) {
      return (b = compare$2(this, new BigNumber(y, b))) === -1 || b === 0;
    };


    /*
     * Return true if the value of this BigNumber is NaN, otherwise return false.
     */
    P.isNaN = function () {
      return !this.s;
    };


    /*
     * Return true if the value of this BigNumber is negative, otherwise return false.
     */
    P.isNegative = function () {
      return this.s < 0;
    };


    /*
     * Return true if the value of this BigNumber is positive, otherwise return false.
     */
    P.isPositive = function () {
      return this.s > 0;
    };


    /*
     * Return true if the value of this BigNumber is 0 or -0, otherwise return false.
     */
    P.isZero = function () {
      return !!this.c && this.c[0] == 0;
    };


    /*
     *  n - 0 = n
     *  n - N = N
     *  n - I = -I
     *  0 - n = -n
     *  0 - 0 = 0
     *  0 - N = N
     *  0 - I = -I
     *  N - n = N
     *  N - 0 = N
     *  N - N = N
     *  N - I = N
     *  I - n = I
     *  I - 0 = I
     *  I - N = N
     *  I - I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber minus the value of
     * BigNumber(y, b).
     */
    P.minus = function (y, b) {
      var i, j, t, xLTy,
        x = this,
        a = x.s;

      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
      if (a != b) {
        y.s = -b;
        return x.plus(y);
      }

      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

      if (!xe || !ye) {

        // Either Infinity?
        if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);

        // Either zero?
        if (!xc[0] || !yc[0]) {

          // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
          return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :

           // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
           ROUNDING_MODE == 3 ? -0 : 0);
        }
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Determine which is the bigger number.
      if (a = xe - ye) {

        if (xLTy = a < 0) {
          a = -a;
          t = xc;
        } else {
          ye = xe;
          t = yc;
        }

        t.reverse();

        // Prepend zeros to equalise exponents.
        for (b = a; b--; t.push(0));
        t.reverse();
      } else {

        // Exponents equal. Check digit by digit.
        j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;

        for (a = b = 0; b < j; b++) {

          if (xc[b] != yc[b]) {
            xLTy = xc[b] < yc[b];
            break;
          }
        }
      }

      // x < y? Point xc to the array of the bigger number.
      if (xLTy) t = xc, xc = yc, yc = t, y.s = -y.s;

      b = (j = yc.length) - (i = xc.length);

      // Append zeros to xc if shorter.
      // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
      if (b > 0) for (; b--; xc[i++] = 0);
      b = BASE - 1;

      // Subtract yc from xc.
      for (; j > a;) {

        if (xc[--j] < yc[j]) {
          for (i = j; i && !xc[--i]; xc[i] = b);
          --xc[i];
          xc[j] += BASE;
        }

        xc[j] -= yc[j];
      }

      // Remove leading zeros and adjust exponent accordingly.
      for (; xc[0] == 0; xc.splice(0, 1), --ye);

      // Zero?
      if (!xc[0]) {

        // Following IEEE 754 (2008) 6.3,
        // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
        y.s = ROUNDING_MODE == 3 ? -1 : 1;
        y.c = [y.e = 0];
        return y;
      }

      // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
      // for finite x and y.
      return normalise(y, xc, ye);
    };


    /*
     *   n % 0 =  N
     *   n % N =  N
     *   n % I =  n
     *   0 % n =  0
     *  -0 % n = -0
     *   0 % 0 =  N
     *   0 % N =  N
     *   0 % I =  0
     *   N % n =  N
     *   N % 0 =  N
     *   N % N =  N
     *   N % I =  N
     *   I % n =  N
     *   I % 0 =  N
     *   I % N =  N
     *   I % I =  N
     *
     * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
     * BigNumber(y, b). The result depends on the value of MODULO_MODE.
     */
    P.modulo = P.mod = function (y, b) {
      var q, s,
        x = this;

      y = new BigNumber(y, b);

      // Return NaN if x is Infinity or NaN, or y is NaN or zero.
      if (!x.c || !y.s || y.c && !y.c[0]) {
        return new BigNumber(NaN);

      // Return x if y is Infinity or x is zero.
      } else if (!y.c || x.c && !x.c[0]) {
        return new BigNumber(x);
      }

      if (MODULO_MODE == 9) {

        // Euclidian division: q = sign(y) * floor(x / abs(y))
        // r = x - qy    where  0 <= r < abs(y)
        s = y.s;
        y.s = 1;
        q = div(x, y, 0, 3);
        y.s = s;
        q.s *= s;
      } else {
        q = div(x, y, 0, MODULO_MODE);
      }

      y = x.minus(q.times(y));

      // To match JavaScript %, ensure sign of zero is sign of dividend.
      if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;

      return y;
    };


    /*
     *  n * 0 = 0
     *  n * N = N
     *  n * I = I
     *  0 * n = 0
     *  0 * 0 = 0
     *  0 * N = N
     *  0 * I = N
     *  N * n = N
     *  N * 0 = N
     *  N * N = N
     *  N * I = N
     *  I * n = I
     *  I * 0 = N
     *  I * N = N
     *  I * I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value
     * of BigNumber(y, b).
     */
    P.multipliedBy = P.times = function (y, b) {
      var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,
        base, sqrtBase,
        x = this,
        xc = x.c,
        yc = (y = new BigNumber(y, b)).c;

      // Either NaN, Infinity or 0?
      if (!xc || !yc || !xc[0] || !yc[0]) {

        // Return NaN if either is NaN, or one is 0 and the other is Infinity.
        if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
          y.c = y.e = y.s = null;
        } else {
          y.s *= x.s;

          // Return Infinity if either is Infinity.
          if (!xc || !yc) {
            y.c = y.e = null;

          // Return 0 if either is 0.
          } else {
            y.c = [0];
            y.e = 0;
          }
        }

        return y;
      }

      e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
      y.s *= x.s;
      xcL = xc.length;
      ycL = yc.length;

      // Ensure xc points to longer array and xcL to its length.
      if (xcL < ycL) zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;

      // Initialise the result array with zeros.
      for (i = xcL + ycL, zc = []; i--; zc.push(0));

      base = BASE;
      sqrtBase = SQRT_BASE;

      for (i = ycL; --i >= 0;) {
        c = 0;
        ylo = yc[i] % sqrtBase;
        yhi = yc[i] / sqrtBase | 0;

        for (k = xcL, j = i + k; j > i;) {
          xlo = xc[--k] % sqrtBase;
          xhi = xc[k] / sqrtBase | 0;
          m = yhi * xlo + xhi * ylo;
          xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;
          c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
          zc[j--] = xlo % base;
        }

        zc[j] = c;
      }

      if (c) {
        ++e;
      } else {
        zc.splice(0, 1);
      }

      return normalise(y, zc, e);
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber negated,
     * i.e. multiplied by -1.
     */
    P.negated = function () {
      var x = new BigNumber(this);
      x.s = -x.s || null;
      return x;
    };


    /*
     *  n + 0 = n
     *  n + N = N
     *  n + I = I
     *  0 + n = n
     *  0 + 0 = 0
     *  0 + N = N
     *  0 + I = I
     *  N + n = N
     *  N + 0 = N
     *  N + N = N
     *  N + I = N
     *  I + n = I
     *  I + 0 = I
     *  I + N = N
     *  I + I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber plus the value of
     * BigNumber(y, b).
     */
    P.plus = function (y, b) {
      var t,
        x = this,
        a = x.s;

      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
       if (a != b) {
        y.s = -b;
        return x.minus(y);
      }

      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

      if (!xe || !ye) {

        // Return Infinity if either Infinity.
        if (!xc || !yc) return new BigNumber(a / 0);

        // Either zero?
        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
        if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
      if (a = xe - ye) {
        if (a > 0) {
          ye = xe;
          t = yc;
        } else {
          a = -a;
          t = xc;
        }

        t.reverse();
        for (; a--; t.push(0));
        t.reverse();
      }

      a = xc.length;
      b = yc.length;

      // Point xc to the longer array, and b to the shorter length.
      if (a - b < 0) t = yc, yc = xc, xc = t, b = a;

      // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
      for (a = 0; b;) {
        a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
        xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
      }

      if (a) {
        xc = [a].concat(xc);
        ++ye;
      }

      // No need to check for zero, as +x + +y != 0 && -x + -y != 0
      // ye = MAX_EXP + 1 possible
      return normalise(y, xc, ye);
    };


    /*
     * If sd is undefined or null or true or false, return the number of significant digits of
     * the value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.
     * If sd is true include integer-part trailing zeros in the count.
     *
     * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.
     *                     boolean: whether to count integer-part trailing zeros: true or false.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.precision = P.sd = function (sd, rm) {
      var c, n, v,
        x = this;

      if (sd != null && sd !== !!sd) {
        intCheck(sd, 1, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);

        return round(new BigNumber(x), sd, rm);
      }

      if (!(c = x.c)) return null;
      v = c.length - 1;
      n = v * LOG_BASE + 1;

      if (v = c[v]) {

        // Subtract the number of trailing zeros of the last element.
        for (; v % 10 == 0; v /= 10, n--);

        // Add the number of digits of the first element.
        for (v = c[0]; v >= 10; v /= 10, n++);
      }

      if (sd && x.e + 1 > n) n = x.e + 1;

      return n;
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
     * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
     *
     * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'
     */
    P.shiftedBy = function (k) {
      intCheck(k, -9007199254740991, MAX_SAFE_INTEGER$1);
      return this.times('1e' + k);
    };


    /*
     *  sqrt(-n) =  N
     *  sqrt(N) =  N
     *  sqrt(-I) =  N
     *  sqrt(I) =  I
     *  sqrt(0) =  0
     *  sqrt(-0) = -0
     *
     * Return a new BigNumber whose value is the square root of the value of this BigNumber,
     * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.squareRoot = P.sqrt = function () {
      var m, n, r, rep, t,
        x = this,
        c = x.c,
        s = x.s,
        e = x.e,
        dp = DECIMAL_PLACES + 4,
        half = new BigNumber('0.5');

      // Negative/NaN/Infinity/zero?
      if (s !== 1 || !c || !c[0]) {
        return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
      }

      // Initial estimate.
      s = Math.sqrt(+valueOf(x));

      // Math.sqrt underflow/overflow?
      // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
      if (s == 0 || s == 1 / 0) {
        n = coeffToString(c);
        if ((n.length + e) % 2 == 0) n += '0';
        s = Math.sqrt(+n);
        e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);

        if (s == 1 / 0) {
          n = '5e' + e;
        } else {
          n = s.toExponential();
          n = n.slice(0, n.indexOf('e') + 1) + e;
        }

        r = new BigNumber(n);
      } else {
        r = new BigNumber(s + '');
      }

      // Check for zero.
      // r could be zero if MIN_EXP is changed after the this value was created.
      // This would cause a division by zero (x/t) and hence Infinity below, which would cause
      // coeffToString to throw.
      if (r.c[0]) {
        e = r.e;
        s = e + dp;
        if (s < 3) s = 0;

        // Newton-Raphson iteration.
        for (; ;) {
          t = r;
          r = half.times(t.plus(div(x, t, dp, 1)));

          if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {

            // The exponent of r may here be one less than the final result exponent,
            // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits
            // are indexed correctly.
            if (r.e < e) --s;
            n = n.slice(s - 3, s + 1);

            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
            // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
            // iteration.
            if (n == '9999' || !rep && n == '4999') {

              // On the first iteration only, check to see if rounding up gives the
              // exact result as the nines may infinitely repeat.
              if (!rep) {
                round(t, t.e + DECIMAL_PLACES + 2, 0);

                if (t.times(t).eq(x)) {
                  r = t;
                  break;
                }
              }

              dp += 4;
              s += 4;
              rep = 1;
            } else {

              // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
              // result. If not, then there are further digits and m will be truthy.
              if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

                // Truncate to the first rounding digit.
                round(r, r.e + DECIMAL_PLACES + 2, 1);
                m = !r.times(r).eq(x);
              }

              break;
            }
          }
        }
      }

      return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
    };


    /*
     * Return a string representing the value of this BigNumber in exponential notation and
     * rounded using ROUNDING_MODE to dp fixed decimal places.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toExponential = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp++;
      }
      return format(this, dp, rm, 1);
    };


    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounding
     * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
     * but e.g. (-0.00001).toFixed(0) is '-0'.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toFixed = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp = dp + this.e + 1;
      }
      return format(this, dp, rm);
    };


    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounded
     * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
     * of the format or FORMAT object (see BigNumber.set).
     *
     * The formatting object may contain some or all of the properties shown below.
     *
     * FORMAT = {
     *   prefix: '',
     *   groupSize: 3,
     *   secondaryGroupSize: 0,
     *   groupSeparator: ',',
     *   decimalSeparator: '.',
     *   fractionGroupSize: 0,
     *   fractionGroupSeparator: '\xA0',      // non-breaking space
     *   suffix: ''
     * };
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     * [format] {object} Formatting options. See FORMAT pbject above.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     * '[BigNumber Error] Argument not an object: {format}'
     */
    P.toFormat = function (dp, rm, format) {
      var str,
        x = this;

      if (format == null) {
        if (dp != null && rm && typeof rm == 'object') {
          format = rm;
          rm = null;
        } else if (dp && typeof dp == 'object') {
          format = dp;
          dp = rm = null;
        } else {
          format = FORMAT;
        }
      } else if (typeof format != 'object') {
        throw Error
          (bignumberError + 'Argument not an object: ' + format);
      }

      str = x.toFixed(dp, rm);

      if (x.c) {
        var i,
          arr = str.split('.'),
          g1 = +format.groupSize,
          g2 = +format.secondaryGroupSize,
          groupSeparator = format.groupSeparator || '',
          intPart = arr[0],
          fractionPart = arr[1],
          isNeg = x.s < 0,
          intDigits = isNeg ? intPart.slice(1) : intPart,
          len = intDigits.length;

        if (g2) i = g1, g1 = g2, g2 = i, len -= i;

        if (g1 > 0 && len > 0) {
          i = len % g1 || g1;
          intPart = intDigits.substr(0, i);
          for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
          if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
          if (isNeg) intPart = '-' + intPart;
        }

        str = fractionPart
         ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)
          ? fractionPart.replace(new RegExp('\\d{' + g2 + '}\\B', 'g'),
           '$&' + (format.fractionGroupSeparator || ''))
          : fractionPart)
         : intPart;
      }

      return (format.prefix || '') + str + (format.suffix || '');
    };


    /*
     * Return an array of two BigNumbers representing the value of this BigNumber as a simple
     * fraction with an integer numerator and an integer denominator.
     * The denominator will be a positive non-zero value less than or equal to the specified
     * maximum denominator. If a maximum denominator is not specified, the denominator will be
     * the lowest value necessary to represent the number exactly.
     *
     * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.
     *
     * '[BigNumber Error] Argument {not an integer|out of range} : {md}'
     */
    P.toFraction = function (md) {
      var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,
        x = this,
        xc = x.c;

      if (md != null) {
        n = new BigNumber(md);

        // Throw if md is less than one or is not an integer, unless it is Infinity.
        if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
          throw Error
            (bignumberError + 'Argument ' +
              (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));
        }
      }

      if (!xc) return new BigNumber(x);

      d = new BigNumber(ONE);
      n1 = d0 = new BigNumber(ONE);
      d1 = n0 = new BigNumber(ONE);
      s = coeffToString(xc);

      // Determine initial denominator.
      // d is a power of 10 and the minimum max denominator that specifies the value exactly.
      e = d.e = s.length - x.e - 1;
      d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
      md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;

      exp = MAX_EXP;
      MAX_EXP = 1 / 0;
      n = new BigNumber(s);

      // n0 = d1 = 0
      n0.c[0] = 0;

      for (; ;)  {
        q = div(n, d, 0, 1);
        d2 = d0.plus(q.times(d1));
        if (d2.comparedTo(md) == 1) break;
        d0 = d1;
        d1 = d2;
        n1 = n0.plus(q.times(d2 = n1));
        n0 = d2;
        d = n.minus(q.times(d2 = d));
        n = d2;
      }

      d2 = div(md.minus(d0), d1, 0, 1);
      n0 = n0.plus(d2.times(n1));
      d0 = d0.plus(d2.times(d1));
      n0.s = n1.s = x.s;
      e = e * 2;

      // Determine which fraction is closer to x, n0/d0 or n1/d1
      r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
          div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];

      MAX_EXP = exp;

      return r;
    };


    /*
     * Return the value of this BigNumber converted to a number primitive.
     */
    P.toNumber = function () {
      return +valueOf(this);
    };


    /*
     * Return a string representing the value of this BigNumber rounded to sd significant digits
     * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
     * necessary to represent the integer part of the value in fixed-point notation, then use
     * exponential notation.
     *
     * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.toPrecision = function (sd, rm) {
      if (sd != null) intCheck(sd, 1, MAX);
      return format(this, sd, rm, 2);
    };


    /*
     * Return a string representing the value of this BigNumber in base b, or base 10 if b is
     * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
     * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
     * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
     * TO_EXP_NEG, return exponential notation.
     *
     * [b] {number} Integer, 2 to ALPHABET.length inclusive.
     *
     * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
     */
    P.toString = function (b) {
      var str,
        n = this,
        s = n.s,
        e = n.e;

      // Infinity or NaN?
      if (e === null) {
        if (s) {
          str = 'Infinity';
          if (s < 0) str = '-' + str;
        } else {
          str = 'NaN';
        }
      } else {
        if (b == null) {
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS
           ? toExponential(coeffToString(n.c), e)
           : toFixedPoint(coeffToString(n.c), e, '0');
        } else if (b === 10 && alphabetHasNormalDecimalDigits) {
          n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
          str = toFixedPoint(coeffToString(n.c), n.e, '0');
        } else {
          intCheck(b, 2, ALPHABET.length, 'Base');
          str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);
        }

        if (s < 0 && n.c[0]) str = '-' + str;
      }

      return str;
    };


    /*
     * Return as toString, but do not accept a base argument, and include the minus sign for
     * negative zero.
     */
    P.valueOf = P.toJSON = function () {
      return valueOf(this);
    };


    P._isBigNumber = true;

    P[Symbol.toStringTag] = 'BigNumber';

    // Node.js v10.12.0+
    P[Symbol.for('nodejs.util.inspect.custom')] = P.valueOf;

    if (configObject != null) BigNumber.set(configObject);

    return BigNumber;
  }


  // PRIVATE HELPER FUNCTIONS

  // These functions don't need access to variables,
  // e.g. DECIMAL_PLACES, in the scope of the `clone` function above.


  function bitFloor(n) {
    var i = n | 0;
    return n > 0 || n === i ? i : i - 1;
  }


  // Return a coefficient array as a string of base 10 digits.
  function coeffToString(a) {
    var s, z,
      i = 1,
      j = a.length,
      r = a[0] + '';

    for (; i < j;) {
      s = a[i++] + '';
      z = LOG_BASE - s.length;
      for (; z--; s = '0' + s);
      r += s;
    }

    // Determine trailing zeros.
    for (j = r.length; r.charCodeAt(--j) === 48;);

    return r.slice(0, j + 1 || 1);
  }


  // Compare the value of BigNumbers x and y.
  function compare$2(x, y) {
    var a, b,
      xc = x.c,
      yc = y.c,
      i = x.s,
      j = y.s,
      k = x.e,
      l = y.e;

    // Either NaN?
    if (!i || !j) return null;

    a = xc && !xc[0];
    b = yc && !yc[0];

    // Either zero?
    if (a || b) return a ? b ? 0 : -j : i;

    // Signs differ?
    if (i != j) return i;

    a = i < 0;
    b = k == l;

    // Either Infinity?
    if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;

    // Compare exponents.
    if (!b) return k > l ^ a ? 1 : -1;

    j = (k = xc.length) < (l = yc.length) ? k : l;

    // Compare digit by digit.
    for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;

    // Compare lengths.
    return k == l ? 0 : k > l ^ a ? 1 : -1;
  }


  /*
   * Check that n is a primitive number, an integer, and in range, otherwise throw.
   */
  function intCheck(n, min, max, name) {
    if (n < min || n > max || n !== mathfloor(n)) {
      throw Error
       (bignumberError + (name || 'Argument') + (typeof n == 'number'
         ? n < min || n > max ? ' out of range: ' : ' not an integer: '
         : ' not a primitive number: ') + String(n));
    }
  }


  // Assumes finite n.
  function isOdd(n) {
    var k = n.c.length - 1;
    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
  }


  function toExponential(str, e) {
    return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +
     (e < 0 ? 'e' : 'e+') + e;
  }


  function toFixedPoint(str, e, z) {
    var len, zs;

    // Negative exponent?
    if (e < 0) {

      // Prepend zeros.
      for (zs = z + '.'; ++e; zs += z);
      str = zs + str;

    // Positive exponent
    } else {
      len = str.length;

      // Append zeros.
      if (++e > len) {
        for (zs = z, e -= len; --e; zs += z);
        str += zs;
      } else if (e < len) {
        str = str.slice(0, e) + '.' + str.slice(e);
      }
    }

    return str;
  }


  // EXPORT


  var BigNumber$1 = clone();

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {import("./Hbar.js").default} Hbar
   */

  /**
   * Utility Error Messages
   */
  const REQUIRE_NON_NULL_ERROR = "This value cannot be null | undefined.";
  const REQUIRE_STRING_OR_UINT8ARRAY_ERROR =
      "This value must be a string or Uint8Array.";
  const REQUIRE_ARRAY_ERROR = "The provided variable must be an Array.";

  const FUNCTION_CONVERT_TO_BIGNUMBER_ERROR =
      "This value must be a String, Number, or BigNumber to be converted.";
  const FUNCTION_CONVERT_TO_NUMBER_ERROR =
      "This value must be a String, Number, or BigNumber to be converted.";
  const FUNCTION_CONVERT_TO_NUMBER_PARSE_ERROR =
      "Unable to parse given variable. Returns NaN.";

  //Soft Checks

  /**
   * Takes any param and returns false if null or undefined.
   *
   * @param {any | null | undefined} variable
   * @returns {boolean}
   */
  function isNonNull(variable) {
      return variable != null;
  }

  /**
   * Takes any param and returns true if param is not null and of type Uint8Array.
   *
   * @param {any | null | undefined} variable
   * @returns {boolean}
   */
  function isUint8Array(variable) {
      return isNonNull(variable) && variable instanceof Uint8Array;
  }

  /**
   * Takes any param and returns true if param is not null and of type Number.
   *
   * @param {any | null | undefined} variable
   * @returns {boolean}
   */
  function isNumber(variable) {
      return (
          isNonNull(variable) &&
          (typeof variable == "number" || variable instanceof Number)
      );
  }

  /**
   * Takes any param and returns true if param is not null and of type BigNumber.
   *
   * @param {any | null | undefined} variable
   * @returns {boolean}
   */
  function isBigNumber(variable) {
      return isNonNull(variable) && variable instanceof BigNumber$1;
  }

  /**
   * Takes any param and returns true if param is not null and of type BigNumber.
   *
   * @param {any | null | undefined} variable
   * @returns {boolean}
   */
  function isLong(variable) {
      return isNonNull(variable) && variable instanceof Long;
  }

  /**
   * Takes any param and returns true if param is not null and of type string.
   *
   * @param {any | null | undefined} variable
   * @returns {boolean}
   */
  function isString(variable) {
      return isNonNull(variable) && typeof variable == "string";
  }

  /**
   * Takes any param and returns true if param is not null and type string or Uint8Array.
   *
   * @param {any | null | undefined} variable
   * @returns {boolean}
   */
  function isStringOrUint8Array(variable) {
      return (
          isNonNull(variable) && (isString(variable) || isUint8Array(variable))
      );
  }

  /**
   * Takes an address as `Uint8Array` and returns whether or not this is a long-zero address
   *
   * @param {Uint8Array} address
   * @returns {boolean}
   */
  function isLongZeroAddress(address) {
      for (let i = 0; i < 12; i++) {
          if (address[i] != 0) {
              return false;
          }
      }
      return true;
  }

  /**
   * Takes any param and returns false if null or undefined.
   *
   * @template {Long | Hbar} T
   * @param {T} variable
   * @returns {T}
   */
  function requireNotNegative(variable) {
      if (variable.isNegative()) {
          throw new Error("negative value not allowed");
      }

      return variable;
  }

  /**
   * Takes any param and throws custom error if null or undefined.
   *
   * @param {any} variable
   * @returns {object}
   */
  function requireNonNull(variable) {
      if (!isNonNull(variable)) {
          throw new Error(REQUIRE_NON_NULL_ERROR);
      } else {
          // eslint-disable-next-line @typescript-eslint/no-unsafe-return
          return variable;
      }
  }

  /**
   * Takes any param and throws custom error if null or undefined and not a string or Uint8Array.
   *
   * @param {any | null | undefined} variable
   * @returns {string | Uint8Array}
   */
  function requireStringOrUint8Array(variable) {
      if (isStringOrUint8Array(requireNonNull(variable))) {
          // eslint-disable-next-line @typescript-eslint/no-unsafe-return
          return /** @type {string | Uint8Array} */ (variable);
      } else {
          throw new Error(REQUIRE_STRING_OR_UINT8ARRAY_ERROR);
      }
  }

  //Conversions

  /**
   * Converts number or string to BigNumber.
   *
   * @param {any | null | undefined} variable
   * @returns {BigNumber}
   */
  function convertToBigNumber(variable) {
      requireNonNull(variable);
      if (
          isBigNumber(variable) ||
          isString(variable) ||
          isNumber(variable) ||
          isLong(variable)
      ) {
          // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
          return new BigNumber$1(variable);
      }
      throw new Error(FUNCTION_CONVERT_TO_BIGNUMBER_ERROR);
  }

  /**
   * Converts amount (number, Long, BigNumber, or bigint) to Long.
   * This utility ensures consistent amount handling across the SDK.
   *
   * @param {number | Long | BigNumber | bigint} amount
   * @returns {Long}
   */
  function convertAmountToLong(amount) {
      requireNonNull(amount);

      // Preserve exact original behavior for existing types
      if (Long.isLong(amount)) {
          return amount;
      } else if (typeof amount === "number") {
          return Long.fromNumber(amount);
      } else if (BigNumber$1.isBigNumber(amount)) {
          return Long.fromValue(
              amount.integerValue(BigNumber$1.ROUND_DOWN).toString(),
          );
      } else if (typeof amount === "bigint") {
          return Long.fromValue(amount.toString());
      } else {
          // Handle other types that can be converted to string
          return Long.fromValue(String(amount));
      }
  }
  /**
   * Converts Array of Numbers or Strings to Array of BigNumbers.
   *
   * @param {any | null | undefined} variable
   * @returns {Array<BigNumber>}
   */
  function convertToBigNumberArray(variable) {
      if (variable instanceof Array) {
          return /** @type {Array<BigNumber>} */ (
              variable.map(convertToBigNumber)
          );
      } else {
          throw new Error(REQUIRE_ARRAY_ERROR);
      }
  }

  /**
   * @param {*} variable
   * @returns {number}
   */
  function convertToNumber(variable) {
      requireNonNull(variable);
      if (
          isBigNumber(variable) ||
          isString(variable) ||
          isNumber(variable) ||
          isLong(variable)
      ) {
          // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
          const num = parseInt(variable);
          if (isNaN(num)) {
              throw new Error(FUNCTION_CONVERT_TO_NUMBER_PARSE_ERROR);
          } else {
              return num;
          }
      } else {
          throw new Error(FUNCTION_CONVERT_TO_NUMBER_ERROR);
      }
  }

  /**
   * Creates a DataView on top of an Uint8Array that could be or not be pooled, ensuring that we don't get out of bounds.
   *
   * @param {Uint8Array | Int8Array} arr
   * @param {number | undefined} offset
   * @param {number | undefined} length
   * @returns {DataView}
   */
  function safeView(arr, offset = 0, length = arr.byteLength) {
      if (!(Number.isInteger(offset) && offset >= 0))
          throw new Error("Invalid offset!");
      if (!(Number.isInteger(length) && length >= 0))
          throw new Error("Invalid length!");
      return new DataView(
          arr.buffer,
          arr.byteOffset + offset,
          Math.min(length, arr.byteLength - offset),
      );
  }

  /**
   * @param {any} a
   * @param {any} b
   * @param {Set<string>=} ignore
   * @returns {boolean}
   */
  function compare$1(a, b, ignore = new Set()) {
      if (typeof a === "object" && typeof b === "object") {
          // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
          const aKeys = Object.keys(a);
          // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
          const bKeys = Object.keys(b);

          if (aKeys.length !== bKeys.length) {
              return false;
          }

          for (let i = 0; i < aKeys.length; i++) {
              if (aKeys[i] !== bKeys[i]) {
                  return false;
              }

              if (ignore.has(aKeys[i])) {
                  continue;
              }

              // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
              if (!compare$1(a[aKeys[i]], b[bKeys[i]], ignore)) {
                  return false;
              }
          }

          return true;
      } else if (typeof a === "number" && typeof b === "number") {
          return a === b;
      } else if (typeof a === "string" && typeof b === "string") {
          return a === b;
      } else if (typeof a === "boolean" && typeof b === "boolean") {
          return a === b;
      } else {
          return false;
      }
  }

  /**
   * https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array
   *
   * @template T
   * @param {Array<T>} array
   */
  function shuffle(array) {
      var currentIndex = array.length,
          temporaryValue,
          randomIndex;

      // While there remain elements to shuffle...
      while (0 !== currentIndex) {
          // Pick a remaining element...
          randomIndex = Math.floor(Math.random() * currentIndex);
          currentIndex -= 1;

          // And swap it with the current element.
          temporaryValue = array[currentIndex];
          array[currentIndex] = array[randomIndex];
          array[randomIndex] = temporaryValue;
      }
  }

  /**
   * @param {Uint8Array} array1
   * @param {Uint8Array} array2
   * @returns {boolean}
   */
  function arrayEqual$2(array1, array2) {
      if (array1 === array2) {
          return true;
      }

      if (array1.byteLength !== array2.byteLength) {
          return false;
      }

      const view1 = new DataView(
          array1.buffer,
          array1.byteOffset,
          array1.byteLength,
      );
      const view2 = new DataView(
          array2.buffer,
          array2.byteOffset,
          array2.byteLength,
      );

      let i = array1.byteLength;

      while (i--) {
          if (view1.getUint8(i) !== view2.getUint8(i)) {
              return false;
          }
      }

      return true;
  }

  /**
   * @description Function that delays an execution for a given time (in milliseconds)
   * @param {number} ms
   * @returns {Promise<void>}
   */
  function wait(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
  }

  /* eslint-disable @typescript-eslint/strict-boolean-expressions */
  function parse(string, encoding, opts) {
    var _opts$out;

    if (opts === void 0) {
      opts = {};
    }

    // Build the character lookup table:
    if (!encoding.codes) {
      encoding.codes = {};

      for (var i = 0; i < encoding.chars.length; ++i) {
        encoding.codes[encoding.chars[i]] = i;
      }
    } // The string must have a whole number of bytes:


    if (!opts.loose && string.length * encoding.bits & 7) {
      throw new SyntaxError('Invalid padding');
    } // Count the padding bytes:


    var end = string.length;

    while (string[end - 1] === '=') {
      --end; // If we get a whole number of bytes, there is too much padding:

      if (!opts.loose && !((string.length - end) * encoding.bits & 7)) {
        throw new SyntaxError('Invalid padding');
      }
    } // Allocate the output:


    var out = new ((_opts$out = opts.out) != null ? _opts$out : Uint8Array)(end * encoding.bits / 8 | 0); // Parse the data:

    var bits = 0; // Number of bits currently in the buffer

    var buffer = 0; // Bits waiting to be written out, MSB first

    var written = 0; // Next byte to write

    for (var _i = 0; _i < end; ++_i) {
      // Read one character from the string:
      var value = encoding.codes[string[_i]];

      if (value === undefined) {
        throw new SyntaxError('Invalid character ' + string[_i]);
      } // Append the bits to the buffer:


      buffer = buffer << encoding.bits | value;
      bits += encoding.bits; // Write out some bits if the buffer has a byte's worth:

      if (bits >= 8) {
        bits -= 8;
        out[written++] = 0xff & buffer >> bits;
      }
    } // Verify that we have received just enough bits:


    if (bits >= encoding.bits || 0xff & buffer << 8 - bits) {
      throw new SyntaxError('Unexpected end of data');
    }

    return out;
  }
  function stringify(data, encoding, opts) {
    if (opts === void 0) {
      opts = {};
    }

    var _opts = opts,
        _opts$pad = _opts.pad,
        pad = _opts$pad === void 0 ? true : _opts$pad;
    var mask = (1 << encoding.bits) - 1;
    var out = '';
    var bits = 0; // Number of bits currently in the buffer

    var buffer = 0; // Bits waiting to be written out, MSB first

    for (var i = 0; i < data.length; ++i) {
      // Slurp data into the buffer:
      buffer = buffer << 8 | 0xff & data[i];
      bits += 8; // Write out as much as we can:

      while (bits > encoding.bits) {
        bits -= encoding.bits;
        out += encoding.chars[mask & buffer >> bits];
      }
    } // Partial character:


    if (bits) {
      out += encoding.chars[mask & buffer << encoding.bits - bits];
    } // Add padding characters until we hit a byte boundary:


    if (pad) {
      while (out.length * encoding.bits & 7) {
        out += '=';
      }
    }

    return out;
  }
  var base32Encoding = {
    chars: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',
    bits: 5
  };
  var base32$1 = {
    parse: function parse$1(string, opts) {
      if (opts === void 0) {
        opts = {};
      }

      return parse(opts.loose ? string.toUpperCase().replace(/0/g, 'O').replace(/1/g, 'L').replace(/8/g, 'B') : string, base32Encoding, opts);
    },
    stringify: function stringify$1(data, opts) {
      return stringify(data, base32Encoding, opts);
    }
  };

  // SPDX-License-Identifier: Apache-2.0


  const decodeOpts = { loose: true };
  const encodeOpts = { pad: false };

  /**
   * Decodes the rfc4648 base32 string into a {@link Uint8Array}. If the input string is null, returns null.
   * @param {string} str  the base32 string.
   * @returns {Uint8Array | ''}
   */
  // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call
  const decode$7 = (str) => str && base32$1.parse(str, decodeOpts);

  /**
   * Encodes the byte array into a rfc4648 base32 string without padding. If the input is null, returns null. Note with
   * the rfc4648 loose = true option, it allows lower case letters, padding, and auto corrects 0 -> O, 1 -> L, 8 -> B
   * @param {Buffer|Uint8Array} data
   * @returns {string}
   */
  // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call
  const encode$4 = (data) => data && base32$1.stringify(data, encodeOpts);

  var base32 = {
      decode: decode$7,
      encode: encode$4,
  };

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function getDefaultExportFromCjs (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  function getAugmentedNamespace(n) {
    if (Object.prototype.hasOwnProperty.call(n, '__esModule')) return n;
    var f = n.default;
  	if (typeof f == "function") {
  		var a = function a () {
  			var isInstance = false;
        try {
          isInstance = this instanceof a;
        } catch {}
  			if (isInstance) {
          return Reflect.construct(f, arguments, this.constructor);
  			}
  			return f.apply(this, arguments);
  		};
  		a.prototype = f.prototype;
    } else a = {};
    Object.defineProperty(a, '__esModule', {value: true});
  	Object.keys(n).forEach(function (k) {
  		var d = Object.getOwnPropertyDescriptor(n, k);
  		Object.defineProperty(a, k, d.get ? d : {
  			enumerable: true,
  			get: function () {
  				return n[k];
  			}
  		});
  	});
  	return a;
  }

  var lib = {};

  var indexMinimal = {};

  var minimal$1 = {};

  var aspromise;
  var hasRequiredAspromise;

  function requireAspromise () {
  	if (hasRequiredAspromise) return aspromise;
  	hasRequiredAspromise = 1;
  	aspromise = asPromise;

  	/**
  	 * Callback as used by {@link util.asPromise}.
  	 * @typedef asPromiseCallback
  	 * @type {function}
  	 * @param {Error|null} error Error, if any
  	 * @param {...*} params Additional arguments
  	 * @returns {undefined}
  	 */

  	/**
  	 * Returns a promise from a node-style callback function.
  	 * @memberof util
  	 * @param {asPromiseCallback} fn Function to call
  	 * @param {*} ctx Function context
  	 * @param {...*} params Function arguments
  	 * @returns {Promise<*>} Promisified function
  	 */
  	function asPromise(fn, ctx/*, varargs */) {
  	    var params  = new Array(arguments.length - 1),
  	        offset  = 0,
  	        index   = 2,
  	        pending = true;
  	    while (index < arguments.length)
  	        params[offset++] = arguments[index++];
  	    return new Promise(function executor(resolve, reject) {
  	        params[offset] = function callback(err/*, varargs */) {
  	            if (pending) {
  	                pending = false;
  	                if (err)
  	                    reject(err);
  	                else {
  	                    var params = new Array(arguments.length - 1),
  	                        offset = 0;
  	                    while (offset < params.length)
  	                        params[offset++] = arguments[offset];
  	                    resolve.apply(null, params);
  	                }
  	            }
  	        };
  	        try {
  	            fn.apply(ctx || null, params);
  	        } catch (err) {
  	            if (pending) {
  	                pending = false;
  	                reject(err);
  	            }
  	        }
  	    });
  	}
  	return aspromise;
  }

  var base64 = {};

  var hasRequiredBase64;

  function requireBase64 () {
  	if (hasRequiredBase64) return base64;
  	hasRequiredBase64 = 1;
  	(function (exports) {

  		/**
  		 * A minimal base64 implementation for number arrays.
  		 * @memberof util
  		 * @namespace
  		 */
  		var base64 = exports;

  		/**
  		 * Calculates the byte length of a base64 encoded string.
  		 * @param {string} string Base64 encoded string
  		 * @returns {number} Byte length
  		 */
  		base64.length = function length(string) {
  		    var p = string.length;
  		    if (!p)
  		        return 0;
  		    var n = 0;
  		    while (--p % 4 > 1 && string.charAt(p) === "=")
  		        ++n;
  		    return Math.ceil(string.length * 3) / 4 - n;
  		};

  		// Base64 encoding table
  		var b64 = new Array(64);

  		// Base64 decoding table
  		var s64 = new Array(123);

  		// 65..90, 97..122, 48..57, 43, 47
  		for (var i = 0; i < 64;)
  		    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

  		/**
  		 * Encodes a buffer to a base64 encoded string.
  		 * @param {Uint8Array} buffer Source buffer
  		 * @param {number} start Source start
  		 * @param {number} end Source end
  		 * @returns {string} Base64 encoded string
  		 */
  		base64.encode = function encode(buffer, start, end) {
  		    var parts = null,
  		        chunk = [];
  		    var i = 0, // output index
  		        j = 0, // goto index
  		        t;     // temporary
  		    while (start < end) {
  		        var b = buffer[start++];
  		        switch (j) {
  		            case 0:
  		                chunk[i++] = b64[b >> 2];
  		                t = (b & 3) << 4;
  		                j = 1;
  		                break;
  		            case 1:
  		                chunk[i++] = b64[t | b >> 4];
  		                t = (b & 15) << 2;
  		                j = 2;
  		                break;
  		            case 2:
  		                chunk[i++] = b64[t | b >> 6];
  		                chunk[i++] = b64[b & 63];
  		                j = 0;
  		                break;
  		        }
  		        if (i > 8191) {
  		            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
  		            i = 0;
  		        }
  		    }
  		    if (j) {
  		        chunk[i++] = b64[t];
  		        chunk[i++] = 61;
  		        if (j === 1)
  		            chunk[i++] = 61;
  		    }
  		    if (parts) {
  		        if (i)
  		            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
  		        return parts.join("");
  		    }
  		    return String.fromCharCode.apply(String, chunk.slice(0, i));
  		};

  		var invalidEncoding = "invalid encoding";

  		/**
  		 * Decodes a base64 encoded string to a buffer.
  		 * @param {string} string Source string
  		 * @param {Uint8Array} buffer Destination buffer
  		 * @param {number} offset Destination offset
  		 * @returns {number} Number of bytes written
  		 * @throws {Error} If encoding is invalid
  		 */
  		base64.decode = function decode(string, buffer, offset) {
  		    var start = offset;
  		    var j = 0, // goto index
  		        t;     // temporary
  		    for (var i = 0; i < string.length;) {
  		        var c = string.charCodeAt(i++);
  		        if (c === 61 && j > 1)
  		            break;
  		        if ((c = s64[c]) === undefined)
  		            throw Error(invalidEncoding);
  		        switch (j) {
  		            case 0:
  		                t = c;
  		                j = 1;
  		                break;
  		            case 1:
  		                buffer[offset++] = t << 2 | (c & 48) >> 4;
  		                t = c;
  		                j = 2;
  		                break;
  		            case 2:
  		                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
  		                t = c;
  		                j = 3;
  		                break;
  		            case 3:
  		                buffer[offset++] = (t & 3) << 6 | c;
  		                j = 0;
  		                break;
  		        }
  		    }
  		    if (j === 1)
  		        throw Error(invalidEncoding);
  		    return offset - start;
  		};

  		/**
  		 * Tests if the specified string appears to be base64 encoded.
  		 * @param {string} string String to test
  		 * @returns {boolean} `true` if probably base64 encoded, otherwise false
  		 */
  		base64.test = function test(string) {
  		    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
  		}; 
  	} (base64));
  	return base64;
  }

  var eventemitter;
  var hasRequiredEventemitter;

  function requireEventemitter () {
  	if (hasRequiredEventemitter) return eventemitter;
  	hasRequiredEventemitter = 1;
  	eventemitter = EventEmitter;

  	/**
  	 * Constructs a new event emitter instance.
  	 * @classdesc A minimal event emitter.
  	 * @memberof util
  	 * @constructor
  	 */
  	function EventEmitter() {

  	    /**
  	     * Registered listeners.
  	     * @type {Object.<string,*>}
  	     * @private
  	     */
  	    this._listeners = {};
  	}

  	/**
  	 * Registers an event listener.
  	 * @param {string} evt Event name
  	 * @param {function} fn Listener
  	 * @param {*} [ctx] Listener context
  	 * @returns {util.EventEmitter} `this`
  	 */
  	EventEmitter.prototype.on = function on(evt, fn, ctx) {
  	    (this._listeners[evt] || (this._listeners[evt] = [])).push({
  	        fn  : fn,
  	        ctx : ctx || this
  	    });
  	    return this;
  	};

  	/**
  	 * Removes an event listener or any matching listeners if arguments are omitted.
  	 * @param {string} [evt] Event name. Removes all listeners if omitted.
  	 * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
  	 * @returns {util.EventEmitter} `this`
  	 */
  	EventEmitter.prototype.off = function off(evt, fn) {
  	    if (evt === undefined)
  	        this._listeners = {};
  	    else {
  	        if (fn === undefined)
  	            this._listeners[evt] = [];
  	        else {
  	            var listeners = this._listeners[evt];
  	            for (var i = 0; i < listeners.length;)
  	                if (listeners[i].fn === fn)
  	                    listeners.splice(i, 1);
  	                else
  	                    ++i;
  	        }
  	    }
  	    return this;
  	};

  	/**
  	 * Emits an event by calling its listeners with the specified arguments.
  	 * @param {string} evt Event name
  	 * @param {...*} args Arguments
  	 * @returns {util.EventEmitter} `this`
  	 */
  	EventEmitter.prototype.emit = function emit(evt) {
  	    var listeners = this._listeners[evt];
  	    if (listeners) {
  	        var args = [],
  	            i = 1;
  	        for (; i < arguments.length;)
  	            args.push(arguments[i++]);
  	        for (i = 0; i < listeners.length;)
  	            listeners[i].fn.apply(listeners[i++].ctx, args);
  	    }
  	    return this;
  	};
  	return eventemitter;
  }

  var float;
  var hasRequiredFloat;

  function requireFloat () {
  	if (hasRequiredFloat) return float;
  	hasRequiredFloat = 1;

  	float = factory(factory);

  	/**
  	 * Reads / writes floats / doubles from / to buffers.
  	 * @name util.float
  	 * @namespace
  	 */

  	/**
  	 * Writes a 32 bit float to a buffer using little endian byte order.
  	 * @name util.float.writeFloatLE
  	 * @function
  	 * @param {number} val Value to write
  	 * @param {Uint8Array} buf Target buffer
  	 * @param {number} pos Target buffer offset
  	 * @returns {undefined}
  	 */

  	/**
  	 * Writes a 32 bit float to a buffer using big endian byte order.
  	 * @name util.float.writeFloatBE
  	 * @function
  	 * @param {number} val Value to write
  	 * @param {Uint8Array} buf Target buffer
  	 * @param {number} pos Target buffer offset
  	 * @returns {undefined}
  	 */

  	/**
  	 * Reads a 32 bit float from a buffer using little endian byte order.
  	 * @name util.float.readFloatLE
  	 * @function
  	 * @param {Uint8Array} buf Source buffer
  	 * @param {number} pos Source buffer offset
  	 * @returns {number} Value read
  	 */

  	/**
  	 * Reads a 32 bit float from a buffer using big endian byte order.
  	 * @name util.float.readFloatBE
  	 * @function
  	 * @param {Uint8Array} buf Source buffer
  	 * @param {number} pos Source buffer offset
  	 * @returns {number} Value read
  	 */

  	/**
  	 * Writes a 64 bit double to a buffer using little endian byte order.
  	 * @name util.float.writeDoubleLE
  	 * @function
  	 * @param {number} val Value to write
  	 * @param {Uint8Array} buf Target buffer
  	 * @param {number} pos Target buffer offset
  	 * @returns {undefined}
  	 */

  	/**
  	 * Writes a 64 bit double to a buffer using big endian byte order.
  	 * @name util.float.writeDoubleBE
  	 * @function
  	 * @param {number} val Value to write
  	 * @param {Uint8Array} buf Target buffer
  	 * @param {number} pos Target buffer offset
  	 * @returns {undefined}
  	 */

  	/**
  	 * Reads a 64 bit double from a buffer using little endian byte order.
  	 * @name util.float.readDoubleLE
  	 * @function
  	 * @param {Uint8Array} buf Source buffer
  	 * @param {number} pos Source buffer offset
  	 * @returns {number} Value read
  	 */

  	/**
  	 * Reads a 64 bit double from a buffer using big endian byte order.
  	 * @name util.float.readDoubleBE
  	 * @function
  	 * @param {Uint8Array} buf Source buffer
  	 * @param {number} pos Source buffer offset
  	 * @returns {number} Value read
  	 */

  	// Factory function for the purpose of node-based testing in modified global environments
  	function factory(exports) {

  	    // float: typed array
  	    if (typeof Float32Array !== "undefined") (function() {

  	        var f32 = new Float32Array([ -0 ]),
  	            f8b = new Uint8Array(f32.buffer),
  	            le  = f8b[3] === 128;

  	        function writeFloat_f32_cpy(val, buf, pos) {
  	            f32[0] = val;
  	            buf[pos    ] = f8b[0];
  	            buf[pos + 1] = f8b[1];
  	            buf[pos + 2] = f8b[2];
  	            buf[pos + 3] = f8b[3];
  	        }

  	        function writeFloat_f32_rev(val, buf, pos) {
  	            f32[0] = val;
  	            buf[pos    ] = f8b[3];
  	            buf[pos + 1] = f8b[2];
  	            buf[pos + 2] = f8b[1];
  	            buf[pos + 3] = f8b[0];
  	        }

  	        /* istanbul ignore next */
  	        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
  	        /* istanbul ignore next */
  	        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

  	        function readFloat_f32_cpy(buf, pos) {
  	            f8b[0] = buf[pos    ];
  	            f8b[1] = buf[pos + 1];
  	            f8b[2] = buf[pos + 2];
  	            f8b[3] = buf[pos + 3];
  	            return f32[0];
  	        }

  	        function readFloat_f32_rev(buf, pos) {
  	            f8b[3] = buf[pos    ];
  	            f8b[2] = buf[pos + 1];
  	            f8b[1] = buf[pos + 2];
  	            f8b[0] = buf[pos + 3];
  	            return f32[0];
  	        }

  	        /* istanbul ignore next */
  	        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
  	        /* istanbul ignore next */
  	        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

  	    // float: ieee754
  	    })(); else (function() {

  	        function writeFloat_ieee754(writeUint, val, buf, pos) {
  	            var sign = val < 0 ? 1 : 0;
  	            if (sign)
  	                val = -val;
  	            if (val === 0)
  	                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
  	            else if (isNaN(val))
  	                writeUint(2143289344, buf, pos);
  	            else if (val > 3.4028234663852886e+38) // +-Infinity
  	                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
  	            else if (val < 1.1754943508222875e-38) // denormal
  	                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
  	            else {
  	                var exponent = Math.floor(Math.log(val) / Math.LN2),
  	                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
  	                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
  	            }
  	        }

  	        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
  	        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

  	        function readFloat_ieee754(readUint, buf, pos) {
  	            var uint = readUint(buf, pos),
  	                sign = (uint >> 31) * 2 + 1,
  	                exponent = uint >>> 23 & 255,
  	                mantissa = uint & 8388607;
  	            return exponent === 255
  	                ? mantissa
  	                ? NaN
  	                : sign * Infinity
  	                : exponent === 0 // denormal
  	                ? sign * 1.401298464324817e-45 * mantissa
  	                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
  	        }

  	        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
  	        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);

  	    })();

  	    // double: typed array
  	    if (typeof Float64Array !== "undefined") (function() {

  	        var f64 = new Float64Array([-0]),
  	            f8b = new Uint8Array(f64.buffer),
  	            le  = f8b[7] === 128;

  	        function writeDouble_f64_cpy(val, buf, pos) {
  	            f64[0] = val;
  	            buf[pos    ] = f8b[0];
  	            buf[pos + 1] = f8b[1];
  	            buf[pos + 2] = f8b[2];
  	            buf[pos + 3] = f8b[3];
  	            buf[pos + 4] = f8b[4];
  	            buf[pos + 5] = f8b[5];
  	            buf[pos + 6] = f8b[6];
  	            buf[pos + 7] = f8b[7];
  	        }

  	        function writeDouble_f64_rev(val, buf, pos) {
  	            f64[0] = val;
  	            buf[pos    ] = f8b[7];
  	            buf[pos + 1] = f8b[6];
  	            buf[pos + 2] = f8b[5];
  	            buf[pos + 3] = f8b[4];
  	            buf[pos + 4] = f8b[3];
  	            buf[pos + 5] = f8b[2];
  	            buf[pos + 6] = f8b[1];
  	            buf[pos + 7] = f8b[0];
  	        }

  	        /* istanbul ignore next */
  	        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
  	        /* istanbul ignore next */
  	        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

  	        function readDouble_f64_cpy(buf, pos) {
  	            f8b[0] = buf[pos    ];
  	            f8b[1] = buf[pos + 1];
  	            f8b[2] = buf[pos + 2];
  	            f8b[3] = buf[pos + 3];
  	            f8b[4] = buf[pos + 4];
  	            f8b[5] = buf[pos + 5];
  	            f8b[6] = buf[pos + 6];
  	            f8b[7] = buf[pos + 7];
  	            return f64[0];
  	        }

  	        function readDouble_f64_rev(buf, pos) {
  	            f8b[7] = buf[pos    ];
  	            f8b[6] = buf[pos + 1];
  	            f8b[5] = buf[pos + 2];
  	            f8b[4] = buf[pos + 3];
  	            f8b[3] = buf[pos + 4];
  	            f8b[2] = buf[pos + 5];
  	            f8b[1] = buf[pos + 6];
  	            f8b[0] = buf[pos + 7];
  	            return f64[0];
  	        }

  	        /* istanbul ignore next */
  	        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
  	        /* istanbul ignore next */
  	        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;

  	    // double: ieee754
  	    })(); else (function() {

  	        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
  	            var sign = val < 0 ? 1 : 0;
  	            if (sign)
  	                val = -val;
  	            if (val === 0) {
  	                writeUint(0, buf, pos + off0);
  	                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
  	            } else if (isNaN(val)) {
  	                writeUint(0, buf, pos + off0);
  	                writeUint(2146959360, buf, pos + off1);
  	            } else if (val > 1.7976931348623157e+308) { // +-Infinity
  	                writeUint(0, buf, pos + off0);
  	                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
  	            } else {
  	                var mantissa;
  	                if (val < 2.2250738585072014e-308) { // denormal
  	                    mantissa = val / 5e-324;
  	                    writeUint(mantissa >>> 0, buf, pos + off0);
  	                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
  	                } else {
  	                    var exponent = Math.floor(Math.log(val) / Math.LN2);
  	                    if (exponent === 1024)
  	                        exponent = 1023;
  	                    mantissa = val * Math.pow(2, -exponent);
  	                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
  	                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
  	                }
  	            }
  	        }

  	        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
  	        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

  	        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
  	            var lo = readUint(buf, pos + off0),
  	                hi = readUint(buf, pos + off1);
  	            var sign = (hi >> 31) * 2 + 1,
  	                exponent = hi >>> 20 & 2047,
  	                mantissa = 4294967296 * (hi & 1048575) + lo;
  	            return exponent === 2047
  	                ? mantissa
  	                ? NaN
  	                : sign * Infinity
  	                : exponent === 0 // denormal
  	                ? sign * 5e-324 * mantissa
  	                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
  	        }

  	        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
  	        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);

  	    })();

  	    return exports;
  	}

  	// uint helpers

  	function writeUintLE(val, buf, pos) {
  	    buf[pos    ] =  val        & 255;
  	    buf[pos + 1] =  val >>> 8  & 255;
  	    buf[pos + 2] =  val >>> 16 & 255;
  	    buf[pos + 3] =  val >>> 24;
  	}

  	function writeUintBE(val, buf, pos) {
  	    buf[pos    ] =  val >>> 24;
  	    buf[pos + 1] =  val >>> 16 & 255;
  	    buf[pos + 2] =  val >>> 8  & 255;
  	    buf[pos + 3] =  val        & 255;
  	}

  	function readUintLE(buf, pos) {
  	    return (buf[pos    ]
  	          | buf[pos + 1] << 8
  	          | buf[pos + 2] << 16
  	          | buf[pos + 3] << 24) >>> 0;
  	}

  	function readUintBE(buf, pos) {
  	    return (buf[pos    ] << 24
  	          | buf[pos + 1] << 16
  	          | buf[pos + 2] << 8
  	          | buf[pos + 3]) >>> 0;
  	}
  	return float;
  }

  var inquire_1;
  var hasRequiredInquire;

  function requireInquire () {
  	if (hasRequiredInquire) return inquire_1;
  	hasRequiredInquire = 1;
  	inquire_1 = inquire;

  	/**
  	 * Requires a module only if available.
  	 * @memberof util
  	 * @param {string} moduleName Module to require
  	 * @returns {?Object} Required module if available and not empty, otherwise `null`
  	 */
  	function inquire(moduleName) {
  	    try {
  	        var mod = eval("quire".replace(/^/,"re"))(moduleName); // eslint-disable-line no-eval
  	        if (mod && (mod.length || Object.keys(mod).length))
  	            return mod;
  	    } catch (e) {} // eslint-disable-line no-empty
  	    return null;
  	}
  	return inquire_1;
  }

  var utf8 = {};

  var hasRequiredUtf8;

  function requireUtf8 () {
  	if (hasRequiredUtf8) return utf8;
  	hasRequiredUtf8 = 1;
  	(function (exports) {

  		/**
  		 * A minimal UTF8 implementation for number arrays.
  		 * @memberof util
  		 * @namespace
  		 */
  		var utf8 = exports;

  		/**
  		 * Calculates the UTF8 byte length of a string.
  		 * @param {string} string String
  		 * @returns {number} Byte length
  		 */
  		utf8.length = function utf8_length(string) {
  		    var len = 0,
  		        c = 0;
  		    for (var i = 0; i < string.length; ++i) {
  		        c = string.charCodeAt(i);
  		        if (c < 128)
  		            len += 1;
  		        else if (c < 2048)
  		            len += 2;
  		        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
  		            ++i;
  		            len += 4;
  		        } else
  		            len += 3;
  		    }
  		    return len;
  		};

  		/**
  		 * Reads UTF8 bytes as a string.
  		 * @param {Uint8Array} buffer Source buffer
  		 * @param {number} start Source start
  		 * @param {number} end Source end
  		 * @returns {string} String read
  		 */
  		utf8.read = function utf8_read(buffer, start, end) {
  		    var len = end - start;
  		    if (len < 1)
  		        return "";
  		    var parts = null,
  		        chunk = [],
  		        i = 0, // char offset
  		        t;     // temporary
  		    while (start < end) {
  		        t = buffer[start++];
  		        if (t < 128)
  		            chunk[i++] = t;
  		        else if (t > 191 && t < 224)
  		            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
  		        else if (t > 239 && t < 365) {
  		            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
  		            chunk[i++] = 0xD800 + (t >> 10);
  		            chunk[i++] = 0xDC00 + (t & 1023);
  		        } else
  		            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
  		        if (i > 8191) {
  		            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
  		            i = 0;
  		        }
  		    }
  		    if (parts) {
  		        if (i)
  		            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
  		        return parts.join("");
  		    }
  		    return String.fromCharCode.apply(String, chunk.slice(0, i));
  		};

  		/**
  		 * Writes a string as UTF8 bytes.
  		 * @param {string} string Source string
  		 * @param {Uint8Array} buffer Destination buffer
  		 * @param {number} offset Destination offset
  		 * @returns {number} Bytes written
  		 */
  		utf8.write = function utf8_write(string, buffer, offset) {
  		    var start = offset,
  		        c1, // character 1
  		        c2; // character 2
  		    for (var i = 0; i < string.length; ++i) {
  		        c1 = string.charCodeAt(i);
  		        if (c1 < 128) {
  		            buffer[offset++] = c1;
  		        } else if (c1 < 2048) {
  		            buffer[offset++] = c1 >> 6       | 192;
  		            buffer[offset++] = c1       & 63 | 128;
  		        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
  		            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
  		            ++i;
  		            buffer[offset++] = c1 >> 18      | 240;
  		            buffer[offset++] = c1 >> 12 & 63 | 128;
  		            buffer[offset++] = c1 >> 6  & 63 | 128;
  		            buffer[offset++] = c1       & 63 | 128;
  		        } else {
  		            buffer[offset++] = c1 >> 12      | 224;
  		            buffer[offset++] = c1 >> 6  & 63 | 128;
  		            buffer[offset++] = c1       & 63 | 128;
  		        }
  		    }
  		    return offset - start;
  		}; 
  	} (utf8));
  	return utf8;
  }

  var pool_1;
  var hasRequiredPool;

  function requirePool () {
  	if (hasRequiredPool) return pool_1;
  	hasRequiredPool = 1;
  	pool_1 = pool;

  	/**
  	 * An allocator as used by {@link util.pool}.
  	 * @typedef PoolAllocator
  	 * @type {function}
  	 * @param {number} size Buffer size
  	 * @returns {Uint8Array} Buffer
  	 */

  	/**
  	 * A slicer as used by {@link util.pool}.
  	 * @typedef PoolSlicer
  	 * @type {function}
  	 * @param {number} start Start offset
  	 * @param {number} end End offset
  	 * @returns {Uint8Array} Buffer slice
  	 * @this {Uint8Array}
  	 */

  	/**
  	 * A general purpose buffer pool.
  	 * @memberof util
  	 * @function
  	 * @param {PoolAllocator} alloc Allocator
  	 * @param {PoolSlicer} slice Slicer
  	 * @param {number} [size=8192] Slab size
  	 * @returns {PoolAllocator} Pooled allocator
  	 */
  	function pool(alloc, slice, size) {
  	    var SIZE   = size || 8192;
  	    var MAX    = SIZE >>> 1;
  	    var slab   = null;
  	    var offset = SIZE;
  	    return function pool_alloc(size) {
  	        if (size < 1 || size > MAX)
  	            return alloc(size);
  	        if (offset + size > SIZE) {
  	            slab = alloc(SIZE);
  	            offset = 0;
  	        }
  	        var buf = slice.call(slab, offset, offset += size);
  	        if (offset & 7) // align to 32 bit
  	            offset = (offset | 7) + 1;
  	        return buf;
  	    };
  	}
  	return pool_1;
  }

  var longbits;
  var hasRequiredLongbits;

  function requireLongbits () {
  	if (hasRequiredLongbits) return longbits;
  	hasRequiredLongbits = 1;
  	longbits = LongBits;

  	var util = requireMinimal$1();

  	/**
  	 * Constructs new long bits.
  	 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
  	 * @memberof util
  	 * @constructor
  	 * @param {number} lo Low 32 bits, unsigned
  	 * @param {number} hi High 32 bits, unsigned
  	 */
  	function LongBits(lo, hi) {

  	    // note that the casts below are theoretically unnecessary as of today, but older statically
  	    // generated converter code might still call the ctor with signed 32bits. kept for compat.

  	    /**
  	     * Low bits.
  	     * @type {number}
  	     */
  	    this.lo = lo >>> 0;

  	    /**
  	     * High bits.
  	     * @type {number}
  	     */
  	    this.hi = hi >>> 0;
  	}

  	/**
  	 * Zero bits.
  	 * @memberof util.LongBits
  	 * @type {util.LongBits}
  	 */
  	var zero = LongBits.zero = new LongBits(0, 0);

  	zero.toNumber = function() { return 0; };
  	zero.zzEncode = zero.zzDecode = function() { return this; };
  	zero.length = function() { return 1; };

  	/**
  	 * Zero hash.
  	 * @memberof util.LongBits
  	 * @type {string}
  	 */
  	var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

  	/**
  	 * Constructs new long bits from the specified number.
  	 * @param {number} value Value
  	 * @returns {util.LongBits} Instance
  	 */
  	LongBits.fromNumber = function fromNumber(value) {
  	    if (value === 0)
  	        return zero;
  	    var sign = value < 0;
  	    if (sign)
  	        value = -value;
  	    var lo = value >>> 0,
  	        hi = (value - lo) / 4294967296 >>> 0;
  	    if (sign) {
  	        hi = ~hi >>> 0;
  	        lo = ~lo >>> 0;
  	        if (++lo > 4294967295) {
  	            lo = 0;
  	            if (++hi > 4294967295)
  	                hi = 0;
  	        }
  	    }
  	    return new LongBits(lo, hi);
  	};

  	/**
  	 * Constructs new long bits from a number, long or string.
  	 * @param {Long|number|string} value Value
  	 * @returns {util.LongBits} Instance
  	 */
  	LongBits.from = function from(value) {
  	    if (typeof value === "number")
  	        return LongBits.fromNumber(value);
  	    if (util.isString(value)) {
  	        /* istanbul ignore else */
  	        if (util.Long)
  	            value = util.Long.fromString(value);
  	        else
  	            return LongBits.fromNumber(parseInt(value, 10));
  	    }
  	    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
  	};

  	/**
  	 * Converts this long bits to a possibly unsafe JavaScript number.
  	 * @param {boolean} [unsigned=false] Whether unsigned or not
  	 * @returns {number} Possibly unsafe number
  	 */
  	LongBits.prototype.toNumber = function toNumber(unsigned) {
  	    if (!unsigned && this.hi >>> 31) {
  	        var lo = ~this.lo + 1 >>> 0,
  	            hi = ~this.hi     >>> 0;
  	        if (!lo)
  	            hi = hi + 1 >>> 0;
  	        return -(lo + hi * 4294967296);
  	    }
  	    return this.lo + this.hi * 4294967296;
  	};

  	/**
  	 * Converts this long bits to a long.
  	 * @param {boolean} [unsigned=false] Whether unsigned or not
  	 * @returns {Long} Long
  	 */
  	LongBits.prototype.toLong = function toLong(unsigned) {
  	    return util.Long
  	        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
  	        /* istanbul ignore next */
  	        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
  	};

  	var charCodeAt = String.prototype.charCodeAt;

  	/**
  	 * Constructs new long bits from the specified 8 characters long hash.
  	 * @param {string} hash Hash
  	 * @returns {util.LongBits} Bits
  	 */
  	LongBits.fromHash = function fromHash(hash) {
  	    if (hash === zeroHash)
  	        return zero;
  	    return new LongBits(
  	        ( charCodeAt.call(hash, 0)
  	        | charCodeAt.call(hash, 1) << 8
  	        | charCodeAt.call(hash, 2) << 16
  	        | charCodeAt.call(hash, 3) << 24) >>> 0
  	    ,
  	        ( charCodeAt.call(hash, 4)
  	        | charCodeAt.call(hash, 5) << 8
  	        | charCodeAt.call(hash, 6) << 16
  	        | charCodeAt.call(hash, 7) << 24) >>> 0
  	    );
  	};

  	/**
  	 * Converts this long bits to a 8 characters long hash.
  	 * @returns {string} Hash
  	 */
  	LongBits.prototype.toHash = function toHash() {
  	    return String.fromCharCode(
  	        this.lo        & 255,
  	        this.lo >>> 8  & 255,
  	        this.lo >>> 16 & 255,
  	        this.lo >>> 24      ,
  	        this.hi        & 255,
  	        this.hi >>> 8  & 255,
  	        this.hi >>> 16 & 255,
  	        this.hi >>> 24
  	    );
  	};

  	/**
  	 * Zig-zag encodes this long bits.
  	 * @returns {util.LongBits} `this`
  	 */
  	LongBits.prototype.zzEncode = function zzEncode() {
  	    var mask =   this.hi >> 31;
  	    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
  	    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;
  	    return this;
  	};

  	/**
  	 * Zig-zag decodes this long bits.
  	 * @returns {util.LongBits} `this`
  	 */
  	LongBits.prototype.zzDecode = function zzDecode() {
  	    var mask = -(this.lo & 1);
  	    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
  	    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;
  	    return this;
  	};

  	/**
  	 * Calculates the length of this longbits when encoded as a varint.
  	 * @returns {number} Length
  	 */
  	LongBits.prototype.length = function length() {
  	    var part0 =  this.lo,
  	        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
  	        part2 =  this.hi >>> 24;
  	    return part2 === 0
  	         ? part1 === 0
  	           ? part0 < 16384
  	             ? part0 < 128 ? 1 : 2
  	             : part0 < 2097152 ? 3 : 4
  	           : part1 < 16384
  	             ? part1 < 128 ? 5 : 6
  	             : part1 < 2097152 ? 7 : 8
  	         : part2 < 128 ? 9 : 10;
  	};
  	return longbits;
  }

  var hasRequiredMinimal$1;

  function requireMinimal$1 () {
  	if (hasRequiredMinimal$1) return minimal$1;
  	hasRequiredMinimal$1 = 1;
  	(function (exports) {
  		var util = exports;

  		// used to return a Promise where callback is omitted
  		util.asPromise = requireAspromise();

  		// converts to / from base64 encoded strings
  		util.base64 = requireBase64();

  		// base class of rpc.Service
  		util.EventEmitter = requireEventemitter();

  		// float handling accross browsers
  		util.float = requireFloat();

  		// requires modules optionally and hides the call from bundlers
  		util.inquire = requireInquire();

  		// converts to / from utf8 encoded strings
  		util.utf8 = requireUtf8();

  		// provides a node-like buffer pool in the browser
  		util.pool = requirePool();

  		// utility to work with the low and high bits of a 64 bit value
  		util.LongBits = requireLongbits();

  		/**
  		 * Whether running within node or not.
  		 * @memberof util
  		 * @type {boolean}
  		 */
  		util.isNode = Boolean(typeof commonjsGlobal !== "undefined"
  		                   && commonjsGlobal
  		                   && commonjsGlobal.process
  		                   && commonjsGlobal.process.versions
  		                   && commonjsGlobal.process.versions.node);

  		/**
  		 * Global object reference.
  		 * @memberof util
  		 * @type {Object}
  		 */
  		util.global = util.isNode && commonjsGlobal
  		           || typeof window !== "undefined" && window
  		           || typeof self   !== "undefined" && self
  		           || minimal$1; // eslint-disable-line no-invalid-this

  		/**
  		 * An immuable empty array.
  		 * @memberof util
  		 * @type {Array.<*>}
  		 * @const
  		 */
  		util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

  		/**
  		 * An immutable empty object.
  		 * @type {Object}
  		 * @const
  		 */
  		util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes

  		/**
  		 * Tests if the specified value is an integer.
  		 * @function
  		 * @param {*} value Value to test
  		 * @returns {boolean} `true` if the value is an integer
  		 */
  		util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
  		    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
  		};

  		/**
  		 * Tests if the specified value is a string.
  		 * @param {*} value Value to test
  		 * @returns {boolean} `true` if the value is a string
  		 */
  		util.isString = function isString(value) {
  		    return typeof value === "string" || value instanceof String;
  		};

  		/**
  		 * Tests if the specified value is a non-null object.
  		 * @param {*} value Value to test
  		 * @returns {boolean} `true` if the value is a non-null object
  		 */
  		util.isObject = function isObject(value) {
  		    return value && typeof value === "object";
  		};

  		/**
  		 * Checks if a property on a message is considered to be present.
  		 * This is an alias of {@link util.isSet}.
  		 * @function
  		 * @param {Object} obj Plain object or message instance
  		 * @param {string} prop Property name
  		 * @returns {boolean} `true` if considered to be present, otherwise `false`
  		 */
  		util.isset =

  		/**
  		 * Checks if a property on a message is considered to be present.
  		 * @param {Object} obj Plain object or message instance
  		 * @param {string} prop Property name
  		 * @returns {boolean} `true` if considered to be present, otherwise `false`
  		 */
  		util.isSet = function isSet(obj, prop) {
  		    var value = obj[prop];
  		    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
  		        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
  		    return false;
  		};

  		/**
  		 * Any compatible Buffer instance.
  		 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
  		 * @interface Buffer
  		 * @extends Uint8Array
  		 */

  		/**
  		 * Node's Buffer class if available.
  		 * @type {Constructor<Buffer>}
  		 */
  		util.Buffer = (function() {
  		    try {
  		        var Buffer = util.inquire("buffer").Buffer;
  		        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
  		        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
  		    } catch (e) {
  		        /* istanbul ignore next */
  		        return null;
  		    }
  		})();

  		// Internal alias of or polyfull for Buffer.from.
  		util._Buffer_from = null;

  		// Internal alias of or polyfill for Buffer.allocUnsafe.
  		util._Buffer_allocUnsafe = null;

  		/**
  		 * Creates a new buffer of whatever type supported by the environment.
  		 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
  		 * @returns {Uint8Array|Buffer} Buffer
  		 */
  		util.newBuffer = function newBuffer(sizeOrArray) {
  		    /* istanbul ignore next */
  		    return typeof sizeOrArray === "number"
  		        ? util.Buffer
  		            ? util._Buffer_allocUnsafe(sizeOrArray)
  		            : new util.Array(sizeOrArray)
  		        : util.Buffer
  		            ? util._Buffer_from(sizeOrArray)
  		            : typeof Uint8Array === "undefined"
  		                ? sizeOrArray
  		                : new Uint8Array(sizeOrArray);
  		};

  		/**
  		 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
  		 * @type {Constructor<Uint8Array>}
  		 */
  		util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

  		/**
  		 * Any compatible Long instance.
  		 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
  		 * @interface Long
  		 * @property {number} low Low bits
  		 * @property {number} high High bits
  		 * @property {boolean} unsigned Whether unsigned or not
  		 */

  		/**
  		 * Long.js's Long class if available.
  		 * @type {Constructor<Long>}
  		 */
  		util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long
  		         || /* istanbul ignore next */ util.global.Long
  		         || util.inquire("long");

  		/**
  		 * Regular expression used to verify 2 bit (`bool`) map keys.
  		 * @type {RegExp}
  		 * @const
  		 */
  		util.key2Re = /^true|false|0|1$/;

  		/**
  		 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
  		 * @type {RegExp}
  		 * @const
  		 */
  		util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

  		/**
  		 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
  		 * @type {RegExp}
  		 * @const
  		 */
  		util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

  		/**
  		 * Converts a number or long to an 8 characters long hash string.
  		 * @param {Long|number} value Value to convert
  		 * @returns {string} Hash
  		 */
  		util.longToHash = function longToHash(value) {
  		    return value
  		        ? util.LongBits.from(value).toHash()
  		        : util.LongBits.zeroHash;
  		};

  		/**
  		 * Converts an 8 characters long hash string to a long or number.
  		 * @param {string} hash Hash
  		 * @param {boolean} [unsigned=false] Whether unsigned or not
  		 * @returns {Long|number} Original value
  		 */
  		util.longFromHash = function longFromHash(hash, unsigned) {
  		    var bits = util.LongBits.fromHash(hash);
  		    if (util.Long)
  		        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
  		    return bits.toNumber(Boolean(unsigned));
  		};

  		/**
  		 * Merges the properties of the source object into the destination object.
  		 * @memberof util
  		 * @param {Object.<string,*>} dst Destination object
  		 * @param {Object.<string,*>} src Source object
  		 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
  		 * @returns {Object.<string,*>} Destination object
  		 */
  		function merge(dst, src, ifNotSet) { // used by converters
  		    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
  		        if (dst[keys[i]] === undefined || !ifNotSet)
  		            dst[keys[i]] = src[keys[i]];
  		    return dst;
  		}

  		util.merge = merge;

  		/**
  		 * Converts the first character of a string to lower case.
  		 * @param {string} str String to convert
  		 * @returns {string} Converted string
  		 */
  		util.lcFirst = function lcFirst(str) {
  		    return str.charAt(0).toLowerCase() + str.substring(1);
  		};

  		/**
  		 * Creates a custom error constructor.
  		 * @memberof util
  		 * @param {string} name Error name
  		 * @returns {Constructor<Error>} Custom error constructor
  		 */
  		function newError(name) {

  		    function CustomError(message, properties) {

  		        if (!(this instanceof CustomError))
  		            return new CustomError(message, properties);

  		        // Error.call(this, message);
  		        // ^ just returns a new error instance because the ctor can be called as a function

  		        Object.defineProperty(this, "message", { get: function() { return message; } });

  		        /* istanbul ignore next */
  		        if (Error.captureStackTrace) // node
  		            Error.captureStackTrace(this, CustomError);
  		        else
  		            Object.defineProperty(this, "stack", { value: new Error().stack || "" });

  		        if (properties)
  		            merge(this, properties);
  		    }

  		    CustomError.prototype = Object.create(Error.prototype, {
  		        constructor: {
  		            value: CustomError,
  		            writable: true,
  		            enumerable: false,
  		            configurable: true,
  		        },
  		        name: {
  		            get: function get() { return name; },
  		            set: undefined,
  		            enumerable: false,
  		            // configurable: false would accurately preserve the behavior of
  		            // the original, but I'm guessing that was not intentional.
  		            // For an actual error subclass, this property would
  		            // be configurable.
  		            configurable: true,
  		        },
  		        toString: {
  		            value: function value() { return this.name + ": " + this.message; },
  		            writable: true,
  		            enumerable: false,
  		            configurable: true,
  		        },
  		    });

  		    return CustomError;
  		}

  		util.newError = newError;

  		/**
  		 * Constructs a new protocol error.
  		 * @classdesc Error subclass indicating a protocol specifc error.
  		 * @memberof util
  		 * @extends Error
  		 * @template T extends Message<T>
  		 * @constructor
  		 * @param {string} message Error message
  		 * @param {Object.<string,*>} [properties] Additional properties
  		 * @example
  		 * try {
  		 *     MyMessage.decode(someBuffer); // throws if required fields are missing
  		 * } catch (e) {
  		 *     if (e instanceof ProtocolError && e.instance)
  		 *         console.log("decoded so far: " + JSON.stringify(e.instance));
  		 * }
  		 */
  		util.ProtocolError = newError("ProtocolError");

  		/**
  		 * So far decoded message instance.
  		 * @name util.ProtocolError#instance
  		 * @type {Message<T>}
  		 */

  		/**
  		 * A OneOf getter as returned by {@link util.oneOfGetter}.
  		 * @typedef OneOfGetter
  		 * @type {function}
  		 * @returns {string|undefined} Set field name, if any
  		 */

  		/**
  		 * Builds a getter for a oneof's present field name.
  		 * @param {string[]} fieldNames Field names
  		 * @returns {OneOfGetter} Unbound getter
  		 */
  		util.oneOfGetter = function getOneOf(fieldNames) {
  		    var fieldMap = {};
  		    for (var i = 0; i < fieldNames.length; ++i)
  		        fieldMap[fieldNames[i]] = 1;

  		    /**
  		     * @returns {string|undefined} Set field name, if any
  		     * @this Object
  		     * @ignore
  		     */
  		    return function() { // eslint-disable-line consistent-return
  		        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
  		            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
  		                return keys[i];
  		    };
  		};

  		/**
  		 * A OneOf setter as returned by {@link util.oneOfSetter}.
  		 * @typedef OneOfSetter
  		 * @type {function}
  		 * @param {string|undefined} value Field name
  		 * @returns {undefined}
  		 */

  		/**
  		 * Builds a setter for a oneof's present field name.
  		 * @param {string[]} fieldNames Field names
  		 * @returns {OneOfSetter} Unbound setter
  		 */
  		util.oneOfSetter = function setOneOf(fieldNames) {

  		    /**
  		     * @param {string} name Field name
  		     * @returns {undefined}
  		     * @this Object
  		     * @ignore
  		     */
  		    return function(name) {
  		        for (var i = 0; i < fieldNames.length; ++i)
  		            if (fieldNames[i] !== name)
  		                delete this[fieldNames[i]];
  		    };
  		};

  		/**
  		 * Default conversion options used for {@link Message#toJSON} implementations.
  		 *
  		 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
  		 *
  		 * - Longs become strings
  		 * - Enums become string keys
  		 * - Bytes become base64 encoded strings
  		 * - (Sub-)Messages become plain objects
  		 * - Maps become plain objects with all string keys
  		 * - Repeated fields become arrays
  		 * - NaN and Infinity for float and double fields become strings
  		 *
  		 * @type {IConversionOptions}
  		 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
  		 */
  		util.toJSONOptions = {
  		    longs: String,
  		    enums: String,
  		    bytes: String,
  		    json: true
  		};

  		// Sets up buffer utility according to the environment (called in index-minimal)
  		util._configure = function() {
  		    var Buffer = util.Buffer;
  		    /* istanbul ignore if */
  		    if (!Buffer) {
  		        util._Buffer_from = util._Buffer_allocUnsafe = null;
  		        return;
  		    }
  		    // because node 4.x buffers are incompatible & immutable
  		    // see: https://github.com/dcodeIO/protobuf.js/pull/665
  		    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
  		        /* istanbul ignore next */
  		        function Buffer_from(value, encoding) {
  		            return new Buffer(value, encoding);
  		        };
  		    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
  		        /* istanbul ignore next */
  		        function Buffer_allocUnsafe(size) {
  		            return new Buffer(size);
  		        };
  		}; 
  	} (minimal$1));
  	return minimal$1;
  }

  var writer;
  var hasRequiredWriter;

  function requireWriter () {
  	if (hasRequiredWriter) return writer;
  	hasRequiredWriter = 1;
  	writer = Writer;

  	var util      = requireMinimal$1();

  	var BufferWriter; // cyclic

  	var LongBits  = util.LongBits,
  	    base64    = util.base64,
  	    utf8      = util.utf8;

  	/**
  	 * Constructs a new writer operation instance.
  	 * @classdesc Scheduled writer operation.
  	 * @constructor
  	 * @param {function(*, Uint8Array, number)} fn Function to call
  	 * @param {number} len Value byte length
  	 * @param {*} val Value to write
  	 * @ignore
  	 */
  	function Op(fn, len, val) {

  	    /**
  	     * Function to call.
  	     * @type {function(Uint8Array, number, *)}
  	     */
  	    this.fn = fn;

  	    /**
  	     * Value byte length.
  	     * @type {number}
  	     */
  	    this.len = len;

  	    /**
  	     * Next operation.
  	     * @type {Writer.Op|undefined}
  	     */
  	    this.next = undefined;

  	    /**
  	     * Value to write.
  	     * @type {*}
  	     */
  	    this.val = val; // type varies
  	}

  	/* istanbul ignore next */
  	function noop() {} // eslint-disable-line no-empty-function

  	/**
  	 * Constructs a new writer state instance.
  	 * @classdesc Copied writer state.
  	 * @memberof Writer
  	 * @constructor
  	 * @param {Writer} writer Writer to copy state from
  	 * @ignore
  	 */
  	function State(writer) {

  	    /**
  	     * Current head.
  	     * @type {Writer.Op}
  	     */
  	    this.head = writer.head;

  	    /**
  	     * Current tail.
  	     * @type {Writer.Op}
  	     */
  	    this.tail = writer.tail;

  	    /**
  	     * Current buffer length.
  	     * @type {number}
  	     */
  	    this.len = writer.len;

  	    /**
  	     * Next state.
  	     * @type {State|null}
  	     */
  	    this.next = writer.states;
  	}

  	/**
  	 * Constructs a new writer instance.
  	 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
  	 * @constructor
  	 */
  	function Writer() {

  	    /**
  	     * Current length.
  	     * @type {number}
  	     */
  	    this.len = 0;

  	    /**
  	     * Operations head.
  	     * @type {Object}
  	     */
  	    this.head = new Op(noop, 0, 0);

  	    /**
  	     * Operations tail
  	     * @type {Object}
  	     */
  	    this.tail = this.head;

  	    /**
  	     * Linked forked states.
  	     * @type {Object|null}
  	     */
  	    this.states = null;

  	    // When a value is written, the writer calculates its byte length and puts it into a linked
  	    // list of operations to perform when finish() is called. This both allows us to allocate
  	    // buffers of the exact required size and reduces the amount of work we have to do compared
  	    // to first calculating over objects and then encoding over objects. In our case, the encoding
  	    // part is just a linked list walk calling operations with already prepared values.
  	}

  	var create = function create() {
  	    return util.Buffer
  	        ? function create_buffer_setup() {
  	            return (Writer.create = function create_buffer() {
  	                return new BufferWriter();
  	            })();
  	        }
  	        /* istanbul ignore next */
  	        : function create_array() {
  	            return new Writer();
  	        };
  	};

  	/**
  	 * Creates a new writer.
  	 * @function
  	 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
  	 */
  	Writer.create = create();

  	/**
  	 * Allocates a buffer of the specified size.
  	 * @param {number} size Buffer size
  	 * @returns {Uint8Array} Buffer
  	 */
  	Writer.alloc = function alloc(size) {
  	    return new util.Array(size);
  	};

  	// Use Uint8Array buffer pool in the browser, just like node does with buffers
  	/* istanbul ignore else */
  	if (util.Array !== Array)
  	    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);

  	/**
  	 * Pushes a new operation to the queue.
  	 * @param {function(Uint8Array, number, *)} fn Function to call
  	 * @param {number} len Value byte length
  	 * @param {number} val Value to write
  	 * @returns {Writer} `this`
  	 * @private
  	 */
  	Writer.prototype._push = function push(fn, len, val) {
  	    this.tail = this.tail.next = new Op(fn, len, val);
  	    this.len += len;
  	    return this;
  	};

  	function writeByte(val, buf, pos) {
  	    buf[pos] = val & 255;
  	}

  	function writeVarint32(val, buf, pos) {
  	    while (val > 127) {
  	        buf[pos++] = val & 127 | 128;
  	        val >>>= 7;
  	    }
  	    buf[pos] = val;
  	}

  	/**
  	 * Constructs a new varint writer operation instance.
  	 * @classdesc Scheduled varint writer operation.
  	 * @extends Op
  	 * @constructor
  	 * @param {number} len Value byte length
  	 * @param {number} val Value to write
  	 * @ignore
  	 */
  	function VarintOp(len, val) {
  	    this.len = len;
  	    this.next = undefined;
  	    this.val = val;
  	}

  	VarintOp.prototype = Object.create(Op.prototype);
  	VarintOp.prototype.fn = writeVarint32;

  	/**
  	 * Writes an unsigned 32 bit value as a varint.
  	 * @param {number} value Value to write
  	 * @returns {Writer} `this`
  	 */
  	Writer.prototype.uint32 = function write_uint32(value) {
  	    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
  	    // uint32 is by far the most frequently used operation and benefits significantly from this.
  	    this.len += (this.tail = this.tail.next = new VarintOp(
  	        (value = value >>> 0)
  	                < 128       ? 1
  	        : value < 16384     ? 2
  	        : value < 2097152   ? 3
  	        : value < 268435456 ? 4
  	        :                     5,
  	    value)).len;
  	    return this;
  	};

  	/**
  	 * Writes a signed 32 bit value as a varint.
  	 * @function
  	 * @param {number} value Value to write
  	 * @returns {Writer} `this`
  	 */
  	Writer.prototype.int32 = function write_int32(value) {
  	    return value < 0
  	        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
  	        : this.uint32(value);
  	};

  	/**
  	 * Writes a 32 bit value as a varint, zig-zag encoded.
  	 * @param {number} value Value to write
  	 * @returns {Writer} `this`
  	 */
  	Writer.prototype.sint32 = function write_sint32(value) {
  	    return this.uint32((value << 1 ^ value >> 31) >>> 0);
  	};

  	function writeVarint64(val, buf, pos) {
  	    while (val.hi) {
  	        buf[pos++] = val.lo & 127 | 128;
  	        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
  	        val.hi >>>= 7;
  	    }
  	    while (val.lo > 127) {
  	        buf[pos++] = val.lo & 127 | 128;
  	        val.lo = val.lo >>> 7;
  	    }
  	    buf[pos++] = val.lo;
  	}

  	/**
  	 * Writes an unsigned 64 bit value as a varint.
  	 * @param {Long|number|string} value Value to write
  	 * @returns {Writer} `this`
  	 * @throws {TypeError} If `value` is a string and no long library is present.
  	 */
  	Writer.prototype.uint64 = function write_uint64(value) {
  	    var bits = LongBits.from(value);
  	    return this._push(writeVarint64, bits.length(), bits);
  	};

  	/**
  	 * Writes a signed 64 bit value as a varint.
  	 * @function
  	 * @param {Long|number|string} value Value to write
  	 * @returns {Writer} `this`
  	 * @throws {TypeError} If `value` is a string and no long library is present.
  	 */
  	Writer.prototype.int64 = Writer.prototype.uint64;

  	/**
  	 * Writes a signed 64 bit value as a varint, zig-zag encoded.
  	 * @param {Long|number|string} value Value to write
  	 * @returns {Writer} `this`
  	 * @throws {TypeError} If `value` is a string and no long library is present.
  	 */
  	Writer.prototype.sint64 = function write_sint64(value) {
  	    var bits = LongBits.from(value).zzEncode();
  	    return this._push(writeVarint64, bits.length(), bits);
  	};

  	/**
  	 * Writes a boolish value as a varint.
  	 * @param {boolean} value Value to write
  	 * @returns {Writer} `this`
  	 */
  	Writer.prototype.bool = function write_bool(value) {
  	    return this._push(writeByte, 1, value ? 1 : 0);
  	};

  	function writeFixed32(val, buf, pos) {
  	    buf[pos    ] =  val         & 255;
  	    buf[pos + 1] =  val >>> 8   & 255;
  	    buf[pos + 2] =  val >>> 16  & 255;
  	    buf[pos + 3] =  val >>> 24;
  	}

  	/**
  	 * Writes an unsigned 32 bit value as fixed 32 bits.
  	 * @param {number} value Value to write
  	 * @returns {Writer} `this`
  	 */
  	Writer.prototype.fixed32 = function write_fixed32(value) {
  	    return this._push(writeFixed32, 4, value >>> 0);
  	};

  	/**
  	 * Writes a signed 32 bit value as fixed 32 bits.
  	 * @function
  	 * @param {number} value Value to write
  	 * @returns {Writer} `this`
  	 */
  	Writer.prototype.sfixed32 = Writer.prototype.fixed32;

  	/**
  	 * Writes an unsigned 64 bit value as fixed 64 bits.
  	 * @param {Long|number|string} value Value to write
  	 * @returns {Writer} `this`
  	 * @throws {TypeError} If `value` is a string and no long library is present.
  	 */
  	Writer.prototype.fixed64 = function write_fixed64(value) {
  	    var bits = LongBits.from(value);
  	    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
  	};

  	/**
  	 * Writes a signed 64 bit value as fixed 64 bits.
  	 * @function
  	 * @param {Long|number|string} value Value to write
  	 * @returns {Writer} `this`
  	 * @throws {TypeError} If `value` is a string and no long library is present.
  	 */
  	Writer.prototype.sfixed64 = Writer.prototype.fixed64;

  	/**
  	 * Writes a float (32 bit).
  	 * @function
  	 * @param {number} value Value to write
  	 * @returns {Writer} `this`
  	 */
  	Writer.prototype.float = function write_float(value) {
  	    return this._push(util.float.writeFloatLE, 4, value);
  	};

  	/**
  	 * Writes a double (64 bit float).
  	 * @function
  	 * @param {number} value Value to write
  	 * @returns {Writer} `this`
  	 */
  	Writer.prototype.double = function write_double(value) {
  	    return this._push(util.float.writeDoubleLE, 8, value);
  	};

  	var writeBytes = util.Array.prototype.set
  	    ? function writeBytes_set(val, buf, pos) {
  	        buf.set(val, pos); // also works for plain array values
  	    }
  	    /* istanbul ignore next */
  	    : function writeBytes_for(val, buf, pos) {
  	        for (var i = 0; i < val.length; ++i)
  	            buf[pos + i] = val[i];
  	    };

  	/**
  	 * Writes a sequence of bytes.
  	 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
  	 * @returns {Writer} `this`
  	 */
  	Writer.prototype.bytes = function write_bytes(value) {
  	    var len = value.length >>> 0;
  	    if (!len)
  	        return this._push(writeByte, 1, 0);
  	    if (util.isString(value)) {
  	        var buf = Writer.alloc(len = base64.length(value));
  	        base64.decode(value, buf, 0);
  	        value = buf;
  	    }
  	    return this.uint32(len)._push(writeBytes, len, value);
  	};

  	/**
  	 * Writes a string.
  	 * @param {string} value Value to write
  	 * @returns {Writer} `this`
  	 */
  	Writer.prototype.string = function write_string(value) {
  	    var len = utf8.length(value);
  	    return len
  	        ? this.uint32(len)._push(utf8.write, len, value)
  	        : this._push(writeByte, 1, 0);
  	};

  	/**
  	 * Forks this writer's state by pushing it to a stack.
  	 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
  	 * @returns {Writer} `this`
  	 */
  	Writer.prototype.fork = function fork() {
  	    this.states = new State(this);
  	    this.head = this.tail = new Op(noop, 0, 0);
  	    this.len = 0;
  	    return this;
  	};

  	/**
  	 * Resets this instance to the last state.
  	 * @returns {Writer} `this`
  	 */
  	Writer.prototype.reset = function reset() {
  	    if (this.states) {
  	        this.head   = this.states.head;
  	        this.tail   = this.states.tail;
  	        this.len    = this.states.len;
  	        this.states = this.states.next;
  	    } else {
  	        this.head = this.tail = new Op(noop, 0, 0);
  	        this.len  = 0;
  	    }
  	    return this;
  	};

  	/**
  	 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
  	 * @returns {Writer} `this`
  	 */
  	Writer.prototype.ldelim = function ldelim() {
  	    var head = this.head,
  	        tail = this.tail,
  	        len  = this.len;
  	    this.reset().uint32(len);
  	    if (len) {
  	        this.tail.next = head.next; // skip noop
  	        this.tail = tail;
  	        this.len += len;
  	    }
  	    return this;
  	};

  	/**
  	 * Finishes the write operation.
  	 * @returns {Uint8Array} Finished buffer
  	 */
  	Writer.prototype.finish = function finish() {
  	    var head = this.head.next, // skip noop
  	        buf  = this.constructor.alloc(this.len),
  	        pos  = 0;
  	    while (head) {
  	        head.fn(head.val, buf, pos);
  	        pos += head.len;
  	        head = head.next;
  	    }
  	    // this.head = this.tail = null;
  	    return buf;
  	};

  	Writer._configure = function(BufferWriter_) {
  	    BufferWriter = BufferWriter_;
  	    Writer.create = create();
  	    BufferWriter._configure();
  	};
  	return writer;
  }

  var writer_buffer;
  var hasRequiredWriter_buffer;

  function requireWriter_buffer () {
  	if (hasRequiredWriter_buffer) return writer_buffer;
  	hasRequiredWriter_buffer = 1;
  	writer_buffer = BufferWriter;

  	// extends Writer
  	var Writer = requireWriter();
  	(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;

  	var util = requireMinimal$1();

  	/**
  	 * Constructs a new buffer writer instance.
  	 * @classdesc Wire format writer using node buffers.
  	 * @extends Writer
  	 * @constructor
  	 */
  	function BufferWriter() {
  	    Writer.call(this);
  	}

  	BufferWriter._configure = function () {
  	    /**
  	     * Allocates a buffer of the specified size.
  	     * @function
  	     * @param {number} size Buffer size
  	     * @returns {Buffer} Buffer
  	     */
  	    BufferWriter.alloc = util._Buffer_allocUnsafe;

  	    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set"
  	        ? function writeBytesBuffer_set(val, buf, pos) {
  	          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
  	          // also works for plain array values
  	        }
  	        /* istanbul ignore next */
  	        : function writeBytesBuffer_copy(val, buf, pos) {
  	          if (val.copy) // Buffer values
  	            val.copy(buf, pos, 0, val.length);
  	          else for (var i = 0; i < val.length;) // plain array values
  	            buf[pos++] = val[i++];
  	        };
  	};


  	/**
  	 * @override
  	 */
  	BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
  	    if (util.isString(value))
  	        value = util._Buffer_from(value, "base64");
  	    var len = value.length >>> 0;
  	    this.uint32(len);
  	    if (len)
  	        this._push(BufferWriter.writeBytesBuffer, len, value);
  	    return this;
  	};

  	function writeStringBuffer(val, buf, pos) {
  	    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
  	        util.utf8.write(val, buf, pos);
  	    else if (buf.utf8Write)
  	        buf.utf8Write(val, pos);
  	    else
  	        buf.write(val, pos);
  	}

  	/**
  	 * @override
  	 */
  	BufferWriter.prototype.string = function write_string_buffer(value) {
  	    var len = util.Buffer.byteLength(value);
  	    this.uint32(len);
  	    if (len)
  	        this._push(writeStringBuffer, len, value);
  	    return this;
  	};


  	/**
  	 * Finishes the write operation.
  	 * @name BufferWriter#finish
  	 * @function
  	 * @returns {Buffer} Finished buffer
  	 */

  	BufferWriter._configure();
  	return writer_buffer;
  }

  var reader;
  var hasRequiredReader;

  function requireReader () {
  	if (hasRequiredReader) return reader;
  	hasRequiredReader = 1;
  	reader = Reader;

  	var util      = requireMinimal$1();

  	var BufferReader; // cyclic

  	var LongBits  = util.LongBits,
  	    utf8      = util.utf8;

  	/* istanbul ignore next */
  	function indexOutOfRange(reader, writeLength) {
  	    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
  	}

  	/**
  	 * Constructs a new reader instance using the specified buffer.
  	 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
  	 * @constructor
  	 * @param {Uint8Array} buffer Buffer to read from
  	 */
  	function Reader(buffer) {

  	    /**
  	     * Read buffer.
  	     * @type {Uint8Array}
  	     */
  	    this.buf = buffer;

  	    /**
  	     * Read buffer position.
  	     * @type {number}
  	     */
  	    this.pos = 0;

  	    /**
  	     * Read buffer length.
  	     * @type {number}
  	     */
  	    this.len = buffer.length;
  	}

  	var create_array = typeof Uint8Array !== "undefined"
  	    ? function create_typed_array(buffer) {
  	        if (buffer instanceof Uint8Array || Array.isArray(buffer))
  	            return new Reader(buffer);
  	        throw Error("illegal buffer");
  	    }
  	    /* istanbul ignore next */
  	    : function create_array(buffer) {
  	        if (Array.isArray(buffer))
  	            return new Reader(buffer);
  	        throw Error("illegal buffer");
  	    };

  	var create = function create() {
  	    return util.Buffer
  	        ? function create_buffer_setup(buffer) {
  	            return (Reader.create = function create_buffer(buffer) {
  	                return util.Buffer.isBuffer(buffer)
  	                    ? new BufferReader(buffer)
  	                    /* istanbul ignore next */
  	                    : create_array(buffer);
  	            })(buffer);
  	        }
  	        /* istanbul ignore next */
  	        : create_array;
  	};

  	/**
  	 * Creates a new reader using the specified buffer.
  	 * @function
  	 * @param {Uint8Array|Buffer} buffer Buffer to read from
  	 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
  	 * @throws {Error} If `buffer` is not a valid buffer
  	 */
  	Reader.create = create();

  	Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;

  	/**
  	 * Reads a varint as an unsigned 32 bit value.
  	 * @function
  	 * @returns {number} Value read
  	 */
  	Reader.prototype.uint32 = (function read_uint32_setup() {
  	    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
  	    return function read_uint32() {
  	        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
  	        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
  	        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
  	        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
  	        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

  	        /* istanbul ignore if */
  	        if ((this.pos += 5) > this.len) {
  	            this.pos = this.len;
  	            throw indexOutOfRange(this, 10);
  	        }
  	        return value;
  	    };
  	})();

  	/**
  	 * Reads a varint as a signed 32 bit value.
  	 * @returns {number} Value read
  	 */
  	Reader.prototype.int32 = function read_int32() {
  	    return this.uint32() | 0;
  	};

  	/**
  	 * Reads a zig-zag encoded varint as a signed 32 bit value.
  	 * @returns {number} Value read
  	 */
  	Reader.prototype.sint32 = function read_sint32() {
  	    var value = this.uint32();
  	    return value >>> 1 ^ -(value & 1) | 0;
  	};

  	/* eslint-disable no-invalid-this */

  	function readLongVarint() {
  	    // tends to deopt with local vars for octet etc.
  	    var bits = new LongBits(0, 0);
  	    var i = 0;
  	    if (this.len - this.pos > 4) { // fast route (lo)
  	        for (; i < 4; ++i) {
  	            // 1st..4th
  	            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
  	            if (this.buf[this.pos++] < 128)
  	                return bits;
  	        }
  	        // 5th
  	        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
  	        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
  	        if (this.buf[this.pos++] < 128)
  	            return bits;
  	        i = 0;
  	    } else {
  	        for (; i < 3; ++i) {
  	            /* istanbul ignore if */
  	            if (this.pos >= this.len)
  	                throw indexOutOfRange(this);
  	            // 1st..3th
  	            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
  	            if (this.buf[this.pos++] < 128)
  	                return bits;
  	        }
  	        // 4th
  	        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
  	        return bits;
  	    }
  	    if (this.len - this.pos > 4) { // fast route (hi)
  	        for (; i < 5; ++i) {
  	            // 6th..10th
  	            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
  	            if (this.buf[this.pos++] < 128)
  	                return bits;
  	        }
  	    } else {
  	        for (; i < 5; ++i) {
  	            /* istanbul ignore if */
  	            if (this.pos >= this.len)
  	                throw indexOutOfRange(this);
  	            // 6th..10th
  	            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
  	            if (this.buf[this.pos++] < 128)
  	                return bits;
  	        }
  	    }
  	    /* istanbul ignore next */
  	    throw Error("invalid varint encoding");
  	}

  	/* eslint-enable no-invalid-this */

  	/**
  	 * Reads a varint as a signed 64 bit value.
  	 * @name Reader#int64
  	 * @function
  	 * @returns {Long} Value read
  	 */

  	/**
  	 * Reads a varint as an unsigned 64 bit value.
  	 * @name Reader#uint64
  	 * @function
  	 * @returns {Long} Value read
  	 */

  	/**
  	 * Reads a zig-zag encoded varint as a signed 64 bit value.
  	 * @name Reader#sint64
  	 * @function
  	 * @returns {Long} Value read
  	 */

  	/**
  	 * Reads a varint as a boolean.
  	 * @returns {boolean} Value read
  	 */
  	Reader.prototype.bool = function read_bool() {
  	    return this.uint32() !== 0;
  	};

  	function readFixed32_end(buf, end) { // note that this uses `end`, not `pos`
  	    return (buf[end - 4]
  	          | buf[end - 3] << 8
  	          | buf[end - 2] << 16
  	          | buf[end - 1] << 24) >>> 0;
  	}

  	/**
  	 * Reads fixed 32 bits as an unsigned 32 bit integer.
  	 * @returns {number} Value read
  	 */
  	Reader.prototype.fixed32 = function read_fixed32() {

  	    /* istanbul ignore if */
  	    if (this.pos + 4 > this.len)
  	        throw indexOutOfRange(this, 4);

  	    return readFixed32_end(this.buf, this.pos += 4);
  	};

  	/**
  	 * Reads fixed 32 bits as a signed 32 bit integer.
  	 * @returns {number} Value read
  	 */
  	Reader.prototype.sfixed32 = function read_sfixed32() {

  	    /* istanbul ignore if */
  	    if (this.pos + 4 > this.len)
  	        throw indexOutOfRange(this, 4);

  	    return readFixed32_end(this.buf, this.pos += 4) | 0;
  	};

  	/* eslint-disable no-invalid-this */

  	function readFixed64(/* this: Reader */) {

  	    /* istanbul ignore if */
  	    if (this.pos + 8 > this.len)
  	        throw indexOutOfRange(this, 8);

  	    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
  	}

  	/* eslint-enable no-invalid-this */

  	/**
  	 * Reads fixed 64 bits.
  	 * @name Reader#fixed64
  	 * @function
  	 * @returns {Long} Value read
  	 */

  	/**
  	 * Reads zig-zag encoded fixed 64 bits.
  	 * @name Reader#sfixed64
  	 * @function
  	 * @returns {Long} Value read
  	 */

  	/**
  	 * Reads a float (32 bit) as a number.
  	 * @function
  	 * @returns {number} Value read
  	 */
  	Reader.prototype.float = function read_float() {

  	    /* istanbul ignore if */
  	    if (this.pos + 4 > this.len)
  	        throw indexOutOfRange(this, 4);

  	    var value = util.float.readFloatLE(this.buf, this.pos);
  	    this.pos += 4;
  	    return value;
  	};

  	/**
  	 * Reads a double (64 bit float) as a number.
  	 * @function
  	 * @returns {number} Value read
  	 */
  	Reader.prototype.double = function read_double() {

  	    /* istanbul ignore if */
  	    if (this.pos + 8 > this.len)
  	        throw indexOutOfRange(this, 4);

  	    var value = util.float.readDoubleLE(this.buf, this.pos);
  	    this.pos += 8;
  	    return value;
  	};

  	/**
  	 * Reads a sequence of bytes preceeded by its length as a varint.
  	 * @returns {Uint8Array} Value read
  	 */
  	Reader.prototype.bytes = function read_bytes() {
  	    var length = this.uint32(),
  	        start  = this.pos,
  	        end    = this.pos + length;

  	    /* istanbul ignore if */
  	    if (end > this.len)
  	        throw indexOutOfRange(this, length);

  	    this.pos += length;
  	    if (Array.isArray(this.buf)) // plain array
  	        return this.buf.slice(start, end);

  	    if (start === end) { // fix for IE 10/Win8 and others' subarray returning array of size 1
  	        var nativeBuffer = util.Buffer;
  	        return nativeBuffer
  	            ? nativeBuffer.alloc(0)
  	            : new this.buf.constructor(0);
  	    }
  	    return this._slice.call(this.buf, start, end);
  	};

  	/**
  	 * Reads a string preceeded by its byte length as a varint.
  	 * @returns {string} Value read
  	 */
  	Reader.prototype.string = function read_string() {
  	    var bytes = this.bytes();
  	    return utf8.read(bytes, 0, bytes.length);
  	};

  	/**
  	 * Skips the specified number of bytes if specified, otherwise skips a varint.
  	 * @param {number} [length] Length if known, otherwise a varint is assumed
  	 * @returns {Reader} `this`
  	 */
  	Reader.prototype.skip = function skip(length) {
  	    if (typeof length === "number") {
  	        /* istanbul ignore if */
  	        if (this.pos + length > this.len)
  	            throw indexOutOfRange(this, length);
  	        this.pos += length;
  	    } else {
  	        do {
  	            /* istanbul ignore if */
  	            if (this.pos >= this.len)
  	                throw indexOutOfRange(this);
  	        } while (this.buf[this.pos++] & 128);
  	    }
  	    return this;
  	};

  	/**
  	 * Skips the next element of the specified wire type.
  	 * @param {number} wireType Wire type received
  	 * @returns {Reader} `this`
  	 */
  	Reader.prototype.skipType = function(wireType) {
  	    switch (wireType) {
  	        case 0:
  	            this.skip();
  	            break;
  	        case 1:
  	            this.skip(8);
  	            break;
  	        case 2:
  	            this.skip(this.uint32());
  	            break;
  	        case 3:
  	            while ((wireType = this.uint32() & 7) !== 4) {
  	                this.skipType(wireType);
  	            }
  	            break;
  	        case 5:
  	            this.skip(4);
  	            break;

  	        /* istanbul ignore next */
  	        default:
  	            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
  	    }
  	    return this;
  	};

  	Reader._configure = function(BufferReader_) {
  	    BufferReader = BufferReader_;
  	    Reader.create = create();
  	    BufferReader._configure();

  	    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
  	    util.merge(Reader.prototype, {

  	        int64: function read_int64() {
  	            return readLongVarint.call(this)[fn](false);
  	        },

  	        uint64: function read_uint64() {
  	            return readLongVarint.call(this)[fn](true);
  	        },

  	        sint64: function read_sint64() {
  	            return readLongVarint.call(this).zzDecode()[fn](false);
  	        },

  	        fixed64: function read_fixed64() {
  	            return readFixed64.call(this)[fn](true);
  	        },

  	        sfixed64: function read_sfixed64() {
  	            return readFixed64.call(this)[fn](false);
  	        }

  	    });
  	};
  	return reader;
  }

  var reader_buffer;
  var hasRequiredReader_buffer;

  function requireReader_buffer () {
  	if (hasRequiredReader_buffer) return reader_buffer;
  	hasRequiredReader_buffer = 1;
  	reader_buffer = BufferReader;

  	// extends Reader
  	var Reader = requireReader();
  	(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;

  	var util = requireMinimal$1();

  	/**
  	 * Constructs a new buffer reader instance.
  	 * @classdesc Wire format reader using node buffers.
  	 * @extends Reader
  	 * @constructor
  	 * @param {Buffer} buffer Buffer to read from
  	 */
  	function BufferReader(buffer) {
  	    Reader.call(this, buffer);

  	    /**
  	     * Read buffer.
  	     * @name BufferReader#buf
  	     * @type {Buffer}
  	     */
  	}

  	BufferReader._configure = function () {
  	    /* istanbul ignore else */
  	    if (util.Buffer)
  	        BufferReader.prototype._slice = util.Buffer.prototype.slice;
  	};


  	/**
  	 * @override
  	 */
  	BufferReader.prototype.string = function read_string_buffer() {
  	    var len = this.uint32(); // modifies pos
  	    return this.buf.utf8Slice
  	        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))
  	        : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
  	};

  	/**
  	 * Reads a sequence of bytes preceeded by its length as a varint.
  	 * @name BufferReader#bytes
  	 * @function
  	 * @returns {Buffer} Value read
  	 */

  	BufferReader._configure();
  	return reader_buffer;
  }

  var rpc = {};

  var service;
  var hasRequiredService;

  function requireService () {
  	if (hasRequiredService) return service;
  	hasRequiredService = 1;
  	service = Service;

  	var util = requireMinimal$1();

  	// Extends EventEmitter
  	(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

  	/**
  	 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
  	 *
  	 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
  	 * @typedef rpc.ServiceMethodCallback
  	 * @template TRes extends Message<TRes>
  	 * @type {function}
  	 * @param {Error|null} error Error, if any
  	 * @param {TRes} [response] Response message
  	 * @returns {undefined}
  	 */

  	/**
  	 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
  	 * @typedef rpc.ServiceMethod
  	 * @template TReq extends Message<TReq>
  	 * @template TRes extends Message<TRes>
  	 * @type {function}
  	 * @param {TReq|Properties<TReq>} request Request message or plain object
  	 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
  	 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
  	 */

  	/**
  	 * Constructs a new RPC service instance.
  	 * @classdesc An RPC service as returned by {@link Service#create}.
  	 * @exports rpc.Service
  	 * @extends util.EventEmitter
  	 * @constructor
  	 * @param {RPCImpl} rpcImpl RPC implementation
  	 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
  	 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
  	 */
  	function Service(rpcImpl, requestDelimited, responseDelimited) {

  	    if (typeof rpcImpl !== "function")
  	        throw TypeError("rpcImpl must be a function");

  	    util.EventEmitter.call(this);

  	    /**
  	     * RPC implementation. Becomes `null` once the service is ended.
  	     * @type {RPCImpl|null}
  	     */
  	    this.rpcImpl = rpcImpl;

  	    /**
  	     * Whether requests are length-delimited.
  	     * @type {boolean}
  	     */
  	    this.requestDelimited = Boolean(requestDelimited);

  	    /**
  	     * Whether responses are length-delimited.
  	     * @type {boolean}
  	     */
  	    this.responseDelimited = Boolean(responseDelimited);
  	}

  	/**
  	 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
  	 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
  	 * @param {Constructor<TReq>} requestCtor Request constructor
  	 * @param {Constructor<TRes>} responseCtor Response constructor
  	 * @param {TReq|Properties<TReq>} request Request message or plain object
  	 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
  	 * @returns {undefined}
  	 * @template TReq extends Message<TReq>
  	 * @template TRes extends Message<TRes>
  	 */
  	Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

  	    if (!request)
  	        throw TypeError("request must be specified");

  	    var self = this;
  	    if (!callback)
  	        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

  	    if (!self.rpcImpl) {
  	        setTimeout(function() { callback(Error("already ended")); }, 0);
  	        return undefined;
  	    }

  	    try {
  	        return self.rpcImpl(
  	            method,
  	            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
  	            function rpcCallback(err, response) {

  	                if (err) {
  	                    self.emit("error", err, method);
  	                    return callback(err);
  	                }

  	                if (response === null) {
  	                    self.end(/* endedByRPC */ true);
  	                    return undefined;
  	                }

  	                if (!(response instanceof responseCtor)) {
  	                    try {
  	                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
  	                    } catch (err) {
  	                        self.emit("error", err, method);
  	                        return callback(err);
  	                    }
  	                }

  	                self.emit("data", response, method);
  	                return callback(null, response);
  	            }
  	        );
  	    } catch (err) {
  	        self.emit("error", err, method);
  	        setTimeout(function() { callback(err); }, 0);
  	        return undefined;
  	    }
  	};

  	/**
  	 * Ends this service and emits the `end` event.
  	 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
  	 * @returns {rpc.Service} `this`
  	 */
  	Service.prototype.end = function end(endedByRPC) {
  	    if (this.rpcImpl) {
  	        if (!endedByRPC) // signal end to rpcImpl
  	            this.rpcImpl(null, null, null);
  	        this.rpcImpl = null;
  	        this.emit("end").off();
  	    }
  	    return this;
  	};
  	return service;
  }

  var hasRequiredRpc;

  function requireRpc () {
  	if (hasRequiredRpc) return rpc;
  	hasRequiredRpc = 1;
  	(function (exports) {

  		/**
  		 * Streaming RPC helpers.
  		 * @namespace
  		 */
  		var rpc = exports;

  		/**
  		 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
  		 * @typedef RPCImpl
  		 * @type {function}
  		 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
  		 * @param {Uint8Array} requestData Request data
  		 * @param {RPCImplCallback} callback Callback function
  		 * @returns {undefined}
  		 * @example
  		 * function rpcImpl(method, requestData, callback) {
  		 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
  		 *         throw Error("no such method");
  		 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
  		 *         callback(err, responseData);
  		 *     });
  		 * }
  		 */

  		/**
  		 * Node-style callback as used by {@link RPCImpl}.
  		 * @typedef RPCImplCallback
  		 * @type {function}
  		 * @param {Error|null} error Error, if any, otherwise `null`
  		 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
  		 * @returns {undefined}
  		 */

  		rpc.Service = requireService(); 
  	} (rpc));
  	return rpc;
  }

  var roots;
  var hasRequiredRoots;

  function requireRoots () {
  	if (hasRequiredRoots) return roots;
  	hasRequiredRoots = 1;
  	roots = {};

  	/**
  	 * Named roots.
  	 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
  	 * Can also be used manually to make roots available across modules.
  	 * @name roots
  	 * @type {Object.<string,Root>}
  	 * @example
  	 * // pbjs -r myroot -o compiled.js ...
  	 *
  	 * // in another module:
  	 * require("./compiled.js");
  	 *
  	 * // in any subsequent module:
  	 * var root = protobuf.roots["myroot"];
  	 */
  	return roots;
  }

  var hasRequiredIndexMinimal;

  function requireIndexMinimal () {
  	if (hasRequiredIndexMinimal) return indexMinimal;
  	hasRequiredIndexMinimal = 1;
  	(function (exports) {
  		var protobuf = exports;

  		/**
  		 * Build type, one of `"full"`, `"light"` or `"minimal"`.
  		 * @name build
  		 * @type {string}
  		 * @const
  		 */
  		protobuf.build = "minimal";

  		// Serialization
  		protobuf.Writer       = requireWriter();
  		protobuf.BufferWriter = requireWriter_buffer();
  		protobuf.Reader       = requireReader();
  		protobuf.BufferReader = requireReader_buffer();

  		// Utility
  		protobuf.util         = requireMinimal$1();
  		protobuf.rpc          = requireRpc();
  		protobuf.roots        = requireRoots();
  		protobuf.configure    = configure;

  		/* istanbul ignore next */
  		/**
  		 * Reconfigures the library according to the environment.
  		 * @returns {undefined}
  		 */
  		function configure() {
  		    protobuf.util._configure();
  		    protobuf.Writer._configure(protobuf.BufferWriter);
  		    protobuf.Reader._configure(protobuf.BufferReader);
  		}

  		// Set up buffer utility according to the environment
  		configure(); 
  	} (indexMinimal));
  	return indexMinimal;
  }

  var minimal;
  var hasRequiredMinimal;

  function requireMinimal () {
  	if (hasRequiredMinimal) return minimal;
  	hasRequiredMinimal = 1;
  	minimal = requireIndexMinimal();
  	return minimal;
  }

  var umd$1 = {exports: {}};

  var umd = umd$1.exports;

  var hasRequiredUmd;

  function requireUmd () {
  	if (hasRequiredUmd) return umd$1.exports;
  	hasRequiredUmd = 1;
  	(function (module, exports) {
  		// GENERATED FILE. DO NOT EDIT.
  		(function (global, factory) {
  		  function unwrapDefault(exports) {
  		    return "default" in exports ? exports.default : exports;
  		  }
  		  {
  		    factory(exports);
  		    module.exports = unwrapDefault(exports);
  		  }
  		})(
  		  typeof globalThis !== "undefined"
  		    ? globalThis
  		    : typeof self !== "undefined"
  		      ? self
  		      : umd,
  		  function (_exports) {

  		    Object.defineProperty(_exports, "__esModule", {
  		      value: true,
  		    });
  		    _exports.default = void 0;
  		    /**
  		     * @license
  		     * Copyright 2009 The Closure Library Authors
  		     * Copyright 2020 Daniel Wirtz / The long.js Authors.
  		     *
  		     * Licensed under the Apache License, Version 2.0 (the "License");
  		     * you may not use this file except in compliance with the License.
  		     * You may obtain a copy of the License at
  		     *
  		     *     http://www.apache.org/licenses/LICENSE-2.0
  		     *
  		     * Unless required by applicable law or agreed to in writing, software
  		     * distributed under the License is distributed on an "AS IS" BASIS,
  		     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  		     * See the License for the specific language governing permissions and
  		     * limitations under the License.
  		     *
  		     * SPDX-License-Identifier: Apache-2.0
  		     */

  		    // WebAssembly optimizations to do native i64 multiplication and divide
  		    var wasm = null;
  		    try {
  		      wasm = new WebAssembly.Instance(
  		        new WebAssembly.Module(
  		          new Uint8Array([
  		            // \0asm
  		            0, 97, 115, 109,
  		            // version 1
  		            1, 0, 0, 0,
  		            // section "type"
  		            1, 13, 2,
  		            // 0, () => i32
  		            96, 0, 1, 127,
  		            // 1, (i32, i32, i32, i32) => i32
  		            96, 4, 127, 127, 127, 127, 1, 127,
  		            // section "function"
  		            3, 7, 6,
  		            // 0, type 0
  		            0,
  		            // 1, type 1
  		            1,
  		            // 2, type 1
  		            1,
  		            // 3, type 1
  		            1,
  		            // 4, type 1
  		            1,
  		            // 5, type 1
  		            1,
  		            // section "global"
  		            6, 6, 1,
  		            // 0, "high", mutable i32
  		            127, 1, 65, 0, 11,
  		            // section "export"
  		            7, 50, 6,
  		            // 0, "mul"
  		            3, 109, 117, 108, 0, 1,
  		            // 1, "div_s"
  		            5, 100, 105, 118, 95, 115, 0, 2,
  		            // 2, "div_u"
  		            5, 100, 105, 118, 95, 117, 0, 3,
  		            // 3, "rem_s"
  		            5, 114, 101, 109, 95, 115, 0, 4,
  		            // 4, "rem_u"
  		            5, 114, 101, 109, 95, 117, 0, 5,
  		            // 5, "get_high"
  		            8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0,
  		            // section "code"
  		            10, 191, 1, 6,
  		            // 0, "get_high"
  		            4, 0, 35, 0, 11,
  		            // 1, "mul"
  		            36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173,
  		            32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0,
  		            32, 4, 167, 11,
  		            // 2, "div_s"
  		            36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173,
  		            32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0,
  		            32, 4, 167, 11,
  		            // 3, "div_u"
  		            36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173,
  		            32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0,
  		            32, 4, 167, 11,
  		            // 4, "rem_s"
  		            36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173,
  		            32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0,
  		            32, 4, 167, 11,
  		            // 5, "rem_u"
  		            36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173,
  		            32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0,
  		            32, 4, 167, 11,
  		          ]),
  		        ),
  		        {},
  		      ).exports;
  		    } catch {
  		      // no wasm support :(
  		    }

  		    /**
  		     * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
  		     *  See the from* functions below for more convenient ways of constructing Longs.
  		     * @exports Long
  		     * @class A Long class for representing a 64 bit two's-complement integer value.
  		     * @param {number} low The low (signed) 32 bits of the long
  		     * @param {number} high The high (signed) 32 bits of the long
  		     * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
  		     * @constructor
  		     */
  		    function Long(low, high, unsigned) {
  		      /**
  		       * The low 32 bits as a signed value.
  		       * @type {number}
  		       */
  		      this.low = low | 0;

  		      /**
  		       * The high 32 bits as a signed value.
  		       * @type {number}
  		       */
  		      this.high = high | 0;

  		      /**
  		       * Whether unsigned or not.
  		       * @type {boolean}
  		       */
  		      this.unsigned = !!unsigned;
  		    }

  		    // The internal representation of a long is the two given signed, 32-bit values.
  		    // We use 32-bit pieces because these are the size of integers on which
  		    // Javascript performs bit-operations.  For operations like addition and
  		    // multiplication, we split each number into 16 bit pieces, which can easily be
  		    // multiplied within Javascript's floating-point representation without overflow
  		    // or change in sign.
  		    //
  		    // In the algorithms below, we frequently reduce the negative case to the
  		    // positive case by negating the input(s) and then post-processing the result.
  		    // Note that we must ALWAYS check specially whether those values are MIN_VALUE
  		    // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
  		    // a positive number, it overflows back into a negative).  Not handling this
  		    // case would often result in infinite recursion.
  		    //
  		    // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
  		    // methods on which they depend.

  		    /**
  		     * An indicator used to reliably determine if an object is a Long or not.
  		     * @type {boolean}
  		     * @const
  		     * @private
  		     */
  		    Long.prototype.__isLong__;
  		    Object.defineProperty(Long.prototype, "__isLong__", {
  		      value: true,
  		    });

  		    /**
  		     * @function
  		     * @param {*} obj Object
  		     * @returns {boolean}
  		     * @inner
  		     */
  		    function isLong(obj) {
  		      return (obj && obj["__isLong__"]) === true;
  		    }

  		    /**
  		     * @function
  		     * @param {*} value number
  		     * @returns {number}
  		     * @inner
  		     */
  		    function ctz32(value) {
  		      var c = Math.clz32(value & -value);
  		      return value ? 31 - c : c;
  		    }

  		    /**
  		     * Tests if the specified object is a Long.
  		     * @function
  		     * @param {*} obj Object
  		     * @returns {boolean}
  		     */
  		    Long.isLong = isLong;

  		    /**
  		     * A cache of the Long representations of small integer values.
  		     * @type {!Object}
  		     * @inner
  		     */
  		    var INT_CACHE = {};

  		    /**
  		     * A cache of the Long representations of small unsigned integer values.
  		     * @type {!Object}
  		     * @inner
  		     */
  		    var UINT_CACHE = {};

  		    /**
  		     * @param {number} value
  		     * @param {boolean=} unsigned
  		     * @returns {!Long}
  		     * @inner
  		     */
  		    function fromInt(value, unsigned) {
  		      var obj, cachedObj, cache;
  		      if (unsigned) {
  		        value >>>= 0;
  		        if ((cache = 0 <= value && value < 256)) {
  		          cachedObj = UINT_CACHE[value];
  		          if (cachedObj) return cachedObj;
  		        }
  		        obj = fromBits(value, 0, true);
  		        if (cache) UINT_CACHE[value] = obj;
  		        return obj;
  		      } else {
  		        value |= 0;
  		        if ((cache = -128 <= value && value < 128)) {
  		          cachedObj = INT_CACHE[value];
  		          if (cachedObj) return cachedObj;
  		        }
  		        obj = fromBits(value, value < 0 ? -1 : 0, false);
  		        if (cache) INT_CACHE[value] = obj;
  		        return obj;
  		      }
  		    }

  		    /**
  		     * Returns a Long representing the given 32 bit integer value.
  		     * @function
  		     * @param {number} value The 32 bit integer in question
  		     * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
  		     * @returns {!Long} The corresponding Long value
  		     */
  		    Long.fromInt = fromInt;

  		    /**
  		     * @param {number} value
  		     * @param {boolean=} unsigned
  		     * @returns {!Long}
  		     * @inner
  		     */
  		    function fromNumber(value, unsigned) {
  		      if (isNaN(value)) return unsigned ? UZERO : ZERO;
  		      if (unsigned) {
  		        if (value < 0) return UZERO;
  		        if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;
  		      } else {
  		        if (value <= -9223372036854776e3) return MIN_VALUE;
  		        if (value + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;
  		      }
  		      if (value < 0) return fromNumber(-value, unsigned).neg();
  		      return fromBits(
  		        value % TWO_PWR_32_DBL | 0,
  		        (value / TWO_PWR_32_DBL) | 0,
  		        unsigned,
  		      );
  		    }

  		    /**
  		     * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
  		     * @function
  		     * @param {number} value The number in question
  		     * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
  		     * @returns {!Long} The corresponding Long value
  		     */
  		    Long.fromNumber = fromNumber;

  		    /**
  		     * @param {number} lowBits
  		     * @param {number} highBits
  		     * @param {boolean=} unsigned
  		     * @returns {!Long}
  		     * @inner
  		     */
  		    function fromBits(lowBits, highBits, unsigned) {
  		      return new Long(lowBits, highBits, unsigned);
  		    }

  		    /**
  		     * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
  		     *  assumed to use 32 bits.
  		     * @function
  		     * @param {number} lowBits The low 32 bits
  		     * @param {number} highBits The high 32 bits
  		     * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
  		     * @returns {!Long} The corresponding Long value
  		     */
  		    Long.fromBits = fromBits;

  		    /**
  		     * @function
  		     * @param {number} base
  		     * @param {number} exponent
  		     * @returns {number}
  		     * @inner
  		     */
  		    var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

  		    /**
  		     * @param {string} str
  		     * @param {(boolean|number)=} unsigned
  		     * @param {number=} radix
  		     * @returns {!Long}
  		     * @inner
  		     */
  		    function fromString(str, unsigned, radix) {
  		      if (str.length === 0) throw Error("empty string");
  		      if (typeof unsigned === "number") {
  		        // For goog.math.long compatibility
  		        radix = unsigned;
  		        unsigned = false;
  		      } else {
  		        unsigned = !!unsigned;
  		      }
  		      if (
  		        str === "NaN" ||
  		        str === "Infinity" ||
  		        str === "+Infinity" ||
  		        str === "-Infinity"
  		      )
  		        return unsigned ? UZERO : ZERO;
  		      radix = radix || 10;
  		      if (radix < 2 || 36 < radix) throw RangeError("radix");
  		      var p;
  		      if ((p = str.indexOf("-")) > 0) throw Error("interior hyphen");
  		      else if (p === 0) {
  		        return fromString(str.substring(1), unsigned, radix).neg();
  		      }

  		      // Do several (8) digits each time through the loop, so as to
  		      // minimize the calls to the very expensive emulated div.
  		      var radixToPower = fromNumber(pow_dbl(radix, 8));
  		      var result = ZERO;
  		      for (var i = 0; i < str.length; i += 8) {
  		        var size = Math.min(8, str.length - i),
  		          value = parseInt(str.substring(i, i + size), radix);
  		        if (size < 8) {
  		          var power = fromNumber(pow_dbl(radix, size));
  		          result = result.mul(power).add(fromNumber(value));
  		        } else {
  		          result = result.mul(radixToPower);
  		          result = result.add(fromNumber(value));
  		        }
  		      }
  		      result.unsigned = unsigned;
  		      return result;
  		    }

  		    /**
  		     * Returns a Long representation of the given string, written using the specified radix.
  		     * @function
  		     * @param {string} str The textual representation of the Long
  		     * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
  		     * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
  		     * @returns {!Long} The corresponding Long value
  		     */
  		    Long.fromString = fromString;

  		    /**
  		     * @function
  		     * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
  		     * @param {boolean=} unsigned
  		     * @returns {!Long}
  		     * @inner
  		     */
  		    function fromValue(val, unsigned) {
  		      if (typeof val === "number") return fromNumber(val, unsigned);
  		      if (typeof val === "string") return fromString(val, unsigned);
  		      // Throws for non-objects, converts non-instanceof Long:
  		      return fromBits(
  		        val.low,
  		        val.high,
  		        typeof unsigned === "boolean" ? unsigned : val.unsigned,
  		      );
  		    }

  		    /**
  		     * Converts the specified value to a Long using the appropriate from* function for its type.
  		     * @function
  		     * @param {!Long|number|bigint|string|!{low: number, high: number, unsigned: boolean}} val Value
  		     * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
  		     * @returns {!Long}
  		     */
  		    Long.fromValue = fromValue;

  		    // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
  		    // no runtime penalty for these.

  		    /**
  		     * @type {number}
  		     * @const
  		     * @inner
  		     */
  		    var TWO_PWR_16_DBL = 1 << 16;

  		    /**
  		     * @type {number}
  		     * @const
  		     * @inner
  		     */
  		    var TWO_PWR_24_DBL = 1 << 24;

  		    /**
  		     * @type {number}
  		     * @const
  		     * @inner
  		     */
  		    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

  		    /**
  		     * @type {number}
  		     * @const
  		     * @inner
  		     */
  		    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

  		    /**
  		     * @type {number}
  		     * @const
  		     * @inner
  		     */
  		    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

  		    /**
  		     * @type {!Long}
  		     * @const
  		     * @inner
  		     */
  		    var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

  		    /**
  		     * @type {!Long}
  		     * @inner
  		     */
  		    var ZERO = fromInt(0);

  		    /**
  		     * Signed zero.
  		     * @type {!Long}
  		     */
  		    Long.ZERO = ZERO;

  		    /**
  		     * @type {!Long}
  		     * @inner
  		     */
  		    var UZERO = fromInt(0, true);

  		    /**
  		     * Unsigned zero.
  		     * @type {!Long}
  		     */
  		    Long.UZERO = UZERO;

  		    /**
  		     * @type {!Long}
  		     * @inner
  		     */
  		    var ONE = fromInt(1);

  		    /**
  		     * Signed one.
  		     * @type {!Long}
  		     */
  		    Long.ONE = ONE;

  		    /**
  		     * @type {!Long}
  		     * @inner
  		     */
  		    var UONE = fromInt(1, true);

  		    /**
  		     * Unsigned one.
  		     * @type {!Long}
  		     */
  		    Long.UONE = UONE;

  		    /**
  		     * @type {!Long}
  		     * @inner
  		     */
  		    var NEG_ONE = fromInt(-1);

  		    /**
  		     * Signed negative one.
  		     * @type {!Long}
  		     */
  		    Long.NEG_ONE = NEG_ONE;

  		    /**
  		     * @type {!Long}
  		     * @inner
  		     */
  		    var MAX_VALUE = fromBits(0xffffffff | 0, 0x7fffffff | 0, false);

  		    /**
  		     * Maximum signed value.
  		     * @type {!Long}
  		     */
  		    Long.MAX_VALUE = MAX_VALUE;

  		    /**
  		     * @type {!Long}
  		     * @inner
  		     */
  		    var MAX_UNSIGNED_VALUE = fromBits(0xffffffff | 0, 0xffffffff | 0, true);

  		    /**
  		     * Maximum unsigned value.
  		     * @type {!Long}
  		     */
  		    Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

  		    /**
  		     * @type {!Long}
  		     * @inner
  		     */
  		    var MIN_VALUE = fromBits(0, 0x80000000 | 0, false);

  		    /**
  		     * Minimum signed value.
  		     * @type {!Long}
  		     */
  		    Long.MIN_VALUE = MIN_VALUE;

  		    /**
  		     * @alias Long.prototype
  		     * @inner
  		     */
  		    var LongPrototype = Long.prototype;

  		    /**
  		     * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
  		     * @this {!Long}
  		     * @returns {number}
  		     */
  		    LongPrototype.toInt = function toInt() {
  		      return this.unsigned ? this.low >>> 0 : this.low;
  		    };

  		    /**
  		     * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
  		     * @this {!Long}
  		     * @returns {number}
  		     */
  		    LongPrototype.toNumber = function toNumber() {
  		      if (this.unsigned)
  		        return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
  		      return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
  		    };

  		    /**
  		     * Converts the Long to a string written in the specified radix.
  		     * @this {!Long}
  		     * @param {number=} radix Radix (2-36), defaults to 10
  		     * @returns {string}
  		     * @override
  		     * @throws {RangeError} If `radix` is out of range
  		     */
  		    LongPrototype.toString = function toString(radix) {
  		      radix = radix || 10;
  		      if (radix < 2 || 36 < radix) throw RangeError("radix");
  		      if (this.isZero()) return "0";
  		      if (this.isNegative()) {
  		        // Unsigned Longs are never negative
  		        if (this.eq(MIN_VALUE)) {
  		          // We need to change the Long value before it can be negated, so we remove
  		          // the bottom-most digit in this base and then recurse to do the rest.
  		          var radixLong = fromNumber(radix),
  		            div = this.div(radixLong),
  		            rem1 = div.mul(radixLong).sub(this);
  		          return div.toString(radix) + rem1.toInt().toString(radix);
  		        } else return "-" + this.neg().toString(radix);
  		      }

  		      // Do several (6) digits each time through the loop, so as to
  		      // minimize the calls to the very expensive emulated div.
  		      var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
  		        rem = this;
  		      var result = "";
  		      while (true) {
  		        var remDiv = rem.div(radixToPower),
  		          intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
  		          digits = intval.toString(radix);
  		        rem = remDiv;
  		        if (rem.isZero()) return digits + result;
  		        else {
  		          while (digits.length < 6) digits = "0" + digits;
  		          result = "" + digits + result;
  		        }
  		      }
  		    };

  		    /**
  		     * Gets the high 32 bits as a signed integer.
  		     * @this {!Long}
  		     * @returns {number} Signed high bits
  		     */
  		    LongPrototype.getHighBits = function getHighBits() {
  		      return this.high;
  		    };

  		    /**
  		     * Gets the high 32 bits as an unsigned integer.
  		     * @this {!Long}
  		     * @returns {number} Unsigned high bits
  		     */
  		    LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
  		      return this.high >>> 0;
  		    };

  		    /**
  		     * Gets the low 32 bits as a signed integer.
  		     * @this {!Long}
  		     * @returns {number} Signed low bits
  		     */
  		    LongPrototype.getLowBits = function getLowBits() {
  		      return this.low;
  		    };

  		    /**
  		     * Gets the low 32 bits as an unsigned integer.
  		     * @this {!Long}
  		     * @returns {number} Unsigned low bits
  		     */
  		    LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
  		      return this.low >>> 0;
  		    };

  		    /**
  		     * Gets the number of bits needed to represent the absolute value of this Long.
  		     * @this {!Long}
  		     * @returns {number}
  		     */
  		    LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
  		      if (this.isNegative())
  		        // Unsigned Longs are never negative
  		        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
  		      var val = this.high != 0 ? this.high : this.low;
  		      for (var bit = 31; bit > 0; bit--) if ((val & (1 << bit)) != 0) break;
  		      return this.high != 0 ? bit + 33 : bit + 1;
  		    };

  		    /**
  		     * Tests if this Long can be safely represented as a JavaScript number.
  		     * @this {!Long}
  		     * @returns {boolean}
  		     */
  		    LongPrototype.isSafeInteger = function isSafeInteger() {
  		      // 2^53-1 is the maximum safe value
  		      var top11Bits = this.high >> 21;
  		      // [0, 2^53-1]
  		      if (!top11Bits) return true;
  		      // > 2^53-1
  		      if (this.unsigned) return false;
  		      // [-2^53, -1] except -2^53
  		      return top11Bits === -1 && !(this.low === 0 && this.high === -2097152);
  		    };

  		    /**
  		     * Tests if this Long's value equals zero.
  		     * @this {!Long}
  		     * @returns {boolean}
  		     */
  		    LongPrototype.isZero = function isZero() {
  		      return this.high === 0 && this.low === 0;
  		    };

  		    /**
  		     * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
  		     * @returns {boolean}
  		     */
  		    LongPrototype.eqz = LongPrototype.isZero;

  		    /**
  		     * Tests if this Long's value is negative.
  		     * @this {!Long}
  		     * @returns {boolean}
  		     */
  		    LongPrototype.isNegative = function isNegative() {
  		      return !this.unsigned && this.high < 0;
  		    };

  		    /**
  		     * Tests if this Long's value is positive or zero.
  		     * @this {!Long}
  		     * @returns {boolean}
  		     */
  		    LongPrototype.isPositive = function isPositive() {
  		      return this.unsigned || this.high >= 0;
  		    };

  		    /**
  		     * Tests if this Long's value is odd.
  		     * @this {!Long}
  		     * @returns {boolean}
  		     */
  		    LongPrototype.isOdd = function isOdd() {
  		      return (this.low & 1) === 1;
  		    };

  		    /**
  		     * Tests if this Long's value is even.
  		     * @this {!Long}
  		     * @returns {boolean}
  		     */
  		    LongPrototype.isEven = function isEven() {
  		      return (this.low & 1) === 0;
  		    };

  		    /**
  		     * Tests if this Long's value equals the specified's.
  		     * @this {!Long}
  		     * @param {!Long|number|bigint|string} other Other value
  		     * @returns {boolean}
  		     */
  		    LongPrototype.equals = function equals(other) {
  		      if (!isLong(other)) other = fromValue(other);
  		      if (
  		        this.unsigned !== other.unsigned &&
  		        this.high >>> 31 === 1 &&
  		        other.high >>> 31 === 1
  		      )
  		        return false;
  		      return this.high === other.high && this.low === other.low;
  		    };

  		    /**
  		     * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
  		     * @function
  		     * @param {!Long|number|bigint|string} other Other value
  		     * @returns {boolean}
  		     */
  		    LongPrototype.eq = LongPrototype.equals;

  		    /**
  		     * Tests if this Long's value differs from the specified's.
  		     * @this {!Long}
  		     * @param {!Long|number|bigint|string} other Other value
  		     * @returns {boolean}
  		     */
  		    LongPrototype.notEquals = function notEquals(other) {
  		      return !this.eq(/* validates */ other);
  		    };

  		    /**
  		     * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
  		     * @function
  		     * @param {!Long|number|bigint|string} other Other value
  		     * @returns {boolean}
  		     */
  		    LongPrototype.neq = LongPrototype.notEquals;

  		    /**
  		     * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
  		     * @function
  		     * @param {!Long|number|bigint|string} other Other value
  		     * @returns {boolean}
  		     */
  		    LongPrototype.ne = LongPrototype.notEquals;

  		    /**
  		     * Tests if this Long's value is less than the specified's.
  		     * @this {!Long}
  		     * @param {!Long|number|bigint|string} other Other value
  		     * @returns {boolean}
  		     */
  		    LongPrototype.lessThan = function lessThan(other) {
  		      return this.comp(/* validates */ other) < 0;
  		    };

  		    /**
  		     * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
  		     * @function
  		     * @param {!Long|number|bigint|string} other Other value
  		     * @returns {boolean}
  		     */
  		    LongPrototype.lt = LongPrototype.lessThan;

  		    /**
  		     * Tests if this Long's value is less than or equal the specified's.
  		     * @this {!Long}
  		     * @param {!Long|number|bigint|string} other Other value
  		     * @returns {boolean}
  		     */
  		    LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
  		      return this.comp(/* validates */ other) <= 0;
  		    };

  		    /**
  		     * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
  		     * @function
  		     * @param {!Long|number|bigint|string} other Other value
  		     * @returns {boolean}
  		     */
  		    LongPrototype.lte = LongPrototype.lessThanOrEqual;

  		    /**
  		     * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
  		     * @function
  		     * @param {!Long|number|bigint|string} other Other value
  		     * @returns {boolean}
  		     */
  		    LongPrototype.le = LongPrototype.lessThanOrEqual;

  		    /**
  		     * Tests if this Long's value is greater than the specified's.
  		     * @this {!Long}
  		     * @param {!Long|number|bigint|string} other Other value
  		     * @returns {boolean}
  		     */
  		    LongPrototype.greaterThan = function greaterThan(other) {
  		      return this.comp(/* validates */ other) > 0;
  		    };

  		    /**
  		     * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
  		     * @function
  		     * @param {!Long|number|bigint|string} other Other value
  		     * @returns {boolean}
  		     */
  		    LongPrototype.gt = LongPrototype.greaterThan;

  		    /**
  		     * Tests if this Long's value is greater than or equal the specified's.
  		     * @this {!Long}
  		     * @param {!Long|number|bigint|string} other Other value
  		     * @returns {boolean}
  		     */
  		    LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
  		      return this.comp(/* validates */ other) >= 0;
  		    };

  		    /**
  		     * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
  		     * @function
  		     * @param {!Long|number|bigint|string} other Other value
  		     * @returns {boolean}
  		     */
  		    LongPrototype.gte = LongPrototype.greaterThanOrEqual;

  		    /**
  		     * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
  		     * @function
  		     * @param {!Long|number|bigint|string} other Other value
  		     * @returns {boolean}
  		     */
  		    LongPrototype.ge = LongPrototype.greaterThanOrEqual;

  		    /**
  		     * Compares this Long's value with the specified's.
  		     * @this {!Long}
  		     * @param {!Long|number|bigint|string} other Other value
  		     * @returns {number} 0 if they are the same, 1 if the this is greater and -1
  		     *  if the given one is greater
  		     */
  		    LongPrototype.compare = function compare(other) {
  		      if (!isLong(other)) other = fromValue(other);
  		      if (this.eq(other)) return 0;
  		      var thisNeg = this.isNegative(),
  		        otherNeg = other.isNegative();
  		      if (thisNeg && !otherNeg) return -1;
  		      if (!thisNeg && otherNeg) return 1;
  		      // At this point the sign bits are the same
  		      if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1;
  		      // Both are positive if at least one is unsigned
  		      return other.high >>> 0 > this.high >>> 0 ||
  		        (other.high === this.high && other.low >>> 0 > this.low >>> 0)
  		        ? -1
  		        : 1;
  		    };

  		    /**
  		     * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
  		     * @function
  		     * @param {!Long|number|bigint|string} other Other value
  		     * @returns {number} 0 if they are the same, 1 if the this is greater and -1
  		     *  if the given one is greater
  		     */
  		    LongPrototype.comp = LongPrototype.compare;

  		    /**
  		     * Negates this Long's value.
  		     * @this {!Long}
  		     * @returns {!Long} Negated Long
  		     */
  		    LongPrototype.negate = function negate() {
  		      if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;
  		      return this.not().add(ONE);
  		    };

  		    /**
  		     * Negates this Long's value. This is an alias of {@link Long#negate}.
  		     * @function
  		     * @returns {!Long} Negated Long
  		     */
  		    LongPrototype.neg = LongPrototype.negate;

  		    /**
  		     * Returns the sum of this and the specified Long.
  		     * @this {!Long}
  		     * @param {!Long|number|bigint|string} addend Addend
  		     * @returns {!Long} Sum
  		     */
  		    LongPrototype.add = function add(addend) {
  		      if (!isLong(addend)) addend = fromValue(addend);

  		      // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

  		      var a48 = this.high >>> 16;
  		      var a32 = this.high & 0xffff;
  		      var a16 = this.low >>> 16;
  		      var a00 = this.low & 0xffff;
  		      var b48 = addend.high >>> 16;
  		      var b32 = addend.high & 0xffff;
  		      var b16 = addend.low >>> 16;
  		      var b00 = addend.low & 0xffff;
  		      var c48 = 0,
  		        c32 = 0,
  		        c16 = 0,
  		        c00 = 0;
  		      c00 += a00 + b00;
  		      c16 += c00 >>> 16;
  		      c00 &= 0xffff;
  		      c16 += a16 + b16;
  		      c32 += c16 >>> 16;
  		      c16 &= 0xffff;
  		      c32 += a32 + b32;
  		      c48 += c32 >>> 16;
  		      c32 &= 0xffff;
  		      c48 += a48 + b48;
  		      c48 &= 0xffff;
  		      return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
  		    };

  		    /**
  		     * Returns the difference of this and the specified Long.
  		     * @this {!Long}
  		     * @param {!Long|number|bigint|string} subtrahend Subtrahend
  		     * @returns {!Long} Difference
  		     */
  		    LongPrototype.subtract = function subtract(subtrahend) {
  		      if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);
  		      return this.add(subtrahend.neg());
  		    };

  		    /**
  		     * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
  		     * @function
  		     * @param {!Long|number|bigint|string} subtrahend Subtrahend
  		     * @returns {!Long} Difference
  		     */
  		    LongPrototype.sub = LongPrototype.subtract;

  		    /**
  		     * Returns the product of this and the specified Long.
  		     * @this {!Long}
  		     * @param {!Long|number|bigint|string} multiplier Multiplier
  		     * @returns {!Long} Product
  		     */
  		    LongPrototype.multiply = function multiply(multiplier) {
  		      if (this.isZero()) return this;
  		      if (!isLong(multiplier)) multiplier = fromValue(multiplier);

  		      // use wasm support if present
  		      if (wasm) {
  		        var low = wasm["mul"](
  		          this.low,
  		          this.high,
  		          multiplier.low,
  		          multiplier.high,
  		        );
  		        return fromBits(low, wasm["get_high"](), this.unsigned);
  		      }
  		      if (multiplier.isZero()) return this.unsigned ? UZERO : ZERO;
  		      if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;
  		      if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;
  		      if (this.isNegative()) {
  		        if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());
  		        else return this.neg().mul(multiplier).neg();
  		      } else if (multiplier.isNegative())
  		        return this.mul(multiplier.neg()).neg();

  		      // If both longs are small, use float multiplication
  		      if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
  		        return fromNumber(
  		          this.toNumber() * multiplier.toNumber(),
  		          this.unsigned,
  		        );

  		      // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
  		      // We can skip products that would overflow.

  		      var a48 = this.high >>> 16;
  		      var a32 = this.high & 0xffff;
  		      var a16 = this.low >>> 16;
  		      var a00 = this.low & 0xffff;
  		      var b48 = multiplier.high >>> 16;
  		      var b32 = multiplier.high & 0xffff;
  		      var b16 = multiplier.low >>> 16;
  		      var b00 = multiplier.low & 0xffff;
  		      var c48 = 0,
  		        c32 = 0,
  		        c16 = 0,
  		        c00 = 0;
  		      c00 += a00 * b00;
  		      c16 += c00 >>> 16;
  		      c00 &= 0xffff;
  		      c16 += a16 * b00;
  		      c32 += c16 >>> 16;
  		      c16 &= 0xffff;
  		      c16 += a00 * b16;
  		      c32 += c16 >>> 16;
  		      c16 &= 0xffff;
  		      c32 += a32 * b00;
  		      c48 += c32 >>> 16;
  		      c32 &= 0xffff;
  		      c32 += a16 * b16;
  		      c48 += c32 >>> 16;
  		      c32 &= 0xffff;
  		      c32 += a00 * b32;
  		      c48 += c32 >>> 16;
  		      c32 &= 0xffff;
  		      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
  		      c48 &= 0xffff;
  		      return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
  		    };

  		    /**
  		     * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
  		     * @function
  		     * @param {!Long|number|bigint|string} multiplier Multiplier
  		     * @returns {!Long} Product
  		     */
  		    LongPrototype.mul = LongPrototype.multiply;

  		    /**
  		     * Returns this Long divided by the specified. The result is signed if this Long is signed or
  		     *  unsigned if this Long is unsigned.
  		     * @this {!Long}
  		     * @param {!Long|number|bigint|string} divisor Divisor
  		     * @returns {!Long} Quotient
  		     */
  		    LongPrototype.divide = function divide(divisor) {
  		      if (!isLong(divisor)) divisor = fromValue(divisor);
  		      if (divisor.isZero()) throw Error("division by zero");

  		      // use wasm support if present
  		      if (wasm) {
  		        // guard against signed division overflow: the largest
  		        // negative number / -1 would be 1 larger than the largest
  		        // positive number, due to two's complement.
  		        if (
  		          !this.unsigned &&
  		          this.high === -2147483648 &&
  		          divisor.low === -1 &&
  		          divisor.high === -1
  		        ) {
  		          // be consistent with non-wasm code path
  		          return this;
  		        }
  		        var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(
  		          this.low,
  		          this.high,
  		          divisor.low,
  		          divisor.high,
  		        );
  		        return fromBits(low, wasm["get_high"](), this.unsigned);
  		      }
  		      if (this.isZero()) return this.unsigned ? UZERO : ZERO;
  		      var approx, rem, res;
  		      if (!this.unsigned) {
  		        // This section is only relevant for signed longs and is derived from the
  		        // closure library as a whole.
  		        if (this.eq(MIN_VALUE)) {
  		          if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
  		            return MIN_VALUE; // recall that -MIN_VALUE == MIN_VALUE
  		          else if (divisor.eq(MIN_VALUE)) return ONE;
  		          else {
  		            // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
  		            var halfThis = this.shr(1);
  		            approx = halfThis.div(divisor).shl(1);
  		            if (approx.eq(ZERO)) {
  		              return divisor.isNegative() ? ONE : NEG_ONE;
  		            } else {
  		              rem = this.sub(divisor.mul(approx));
  		              res = approx.add(rem.div(divisor));
  		              return res;
  		            }
  		          }
  		        } else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;
  		        if (this.isNegative()) {
  		          if (divisor.isNegative()) return this.neg().div(divisor.neg());
  		          return this.neg().div(divisor).neg();
  		        } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();
  		        res = ZERO;
  		      } else {
  		        // The algorithm below has not been made for unsigned longs. It's therefore
  		        // required to take special care of the MSB prior to running it.
  		        if (!divisor.unsigned) divisor = divisor.toUnsigned();
  		        if (divisor.gt(this)) return UZERO;
  		        if (divisor.gt(this.shru(1)))
  		          // 15 >>> 1 = 7 ; with divisor = 8 ; true
  		          return UONE;
  		        res = UZERO;
  		      }

  		      // Repeat the following until the remainder is less than other:  find a
  		      // floating-point that approximates remainder / other *from below*, add this
  		      // into the result, and subtract it from the remainder.  It is critical that
  		      // the approximate value is less than or equal to the real value so that the
  		      // remainder never becomes negative.
  		      rem = this;
  		      while (rem.gte(divisor)) {
  		        // Approximate the result of division. This may be a little greater or
  		        // smaller than the actual value.
  		        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

  		        // We will tweak the approximate result by changing it in the 48-th digit or
  		        // the smallest non-fractional digit, whichever is larger.
  		        var log2 = Math.ceil(Math.log(approx) / Math.LN2),
  		          delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48),
  		          // Decrease the approximation until it is smaller than the remainder.  Note
  		          // that if it is too large, the product overflows and is negative.
  		          approxRes = fromNumber(approx),
  		          approxRem = approxRes.mul(divisor);
  		        while (approxRem.isNegative() || approxRem.gt(rem)) {
  		          approx -= delta;
  		          approxRes = fromNumber(approx, this.unsigned);
  		          approxRem = approxRes.mul(divisor);
  		        }

  		        // We know the answer can't be zero... and actually, zero would cause
  		        // infinite recursion since we would make no progress.
  		        if (approxRes.isZero()) approxRes = ONE;
  		        res = res.add(approxRes);
  		        rem = rem.sub(approxRem);
  		      }
  		      return res;
  		    };

  		    /**
  		     * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
  		     * @function
  		     * @param {!Long|number|bigint|string} divisor Divisor
  		     * @returns {!Long} Quotient
  		     */
  		    LongPrototype.div = LongPrototype.divide;

  		    /**
  		     * Returns this Long modulo the specified.
  		     * @this {!Long}
  		     * @param {!Long|number|bigint|string} divisor Divisor
  		     * @returns {!Long} Remainder
  		     */
  		    LongPrototype.modulo = function modulo(divisor) {
  		      if (!isLong(divisor)) divisor = fromValue(divisor);

  		      // use wasm support if present
  		      if (wasm) {
  		        var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(
  		          this.low,
  		          this.high,
  		          divisor.low,
  		          divisor.high,
  		        );
  		        return fromBits(low, wasm["get_high"](), this.unsigned);
  		      }
  		      return this.sub(this.div(divisor).mul(divisor));
  		    };

  		    /**
  		     * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
  		     * @function
  		     * @param {!Long|number|bigint|string} divisor Divisor
  		     * @returns {!Long} Remainder
  		     */
  		    LongPrototype.mod = LongPrototype.modulo;

  		    /**
  		     * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
  		     * @function
  		     * @param {!Long|number|bigint|string} divisor Divisor
  		     * @returns {!Long} Remainder
  		     */
  		    LongPrototype.rem = LongPrototype.modulo;

  		    /**
  		     * Returns the bitwise NOT of this Long.
  		     * @this {!Long}
  		     * @returns {!Long}
  		     */
  		    LongPrototype.not = function not() {
  		      return fromBits(~this.low, ~this.high, this.unsigned);
  		    };

  		    /**
  		     * Returns count leading zeros of this Long.
  		     * @this {!Long}
  		     * @returns {!number}
  		     */
  		    LongPrototype.countLeadingZeros = function countLeadingZeros() {
  		      return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
  		    };

  		    /**
  		     * Returns count leading zeros. This is an alias of {@link Long#countLeadingZeros}.
  		     * @function
  		     * @param {!Long}
  		     * @returns {!number}
  		     */
  		    LongPrototype.clz = LongPrototype.countLeadingZeros;

  		    /**
  		     * Returns count trailing zeros of this Long.
  		     * @this {!Long}
  		     * @returns {!number}
  		     */
  		    LongPrototype.countTrailingZeros = function countTrailingZeros() {
  		      return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
  		    };

  		    /**
  		     * Returns count trailing zeros. This is an alias of {@link Long#countTrailingZeros}.
  		     * @function
  		     * @param {!Long}
  		     * @returns {!number}
  		     */
  		    LongPrototype.ctz = LongPrototype.countTrailingZeros;

  		    /**
  		     * Returns the bitwise AND of this Long and the specified.
  		     * @this {!Long}
  		     * @param {!Long|number|bigint|string} other Other Long
  		     * @returns {!Long}
  		     */
  		    LongPrototype.and = function and(other) {
  		      if (!isLong(other)) other = fromValue(other);
  		      return fromBits(
  		        this.low & other.low,
  		        this.high & other.high,
  		        this.unsigned,
  		      );
  		    };

  		    /**
  		     * Returns the bitwise OR of this Long and the specified.
  		     * @this {!Long}
  		     * @param {!Long|number|bigint|string} other Other Long
  		     * @returns {!Long}
  		     */
  		    LongPrototype.or = function or(other) {
  		      if (!isLong(other)) other = fromValue(other);
  		      return fromBits(
  		        this.low | other.low,
  		        this.high | other.high,
  		        this.unsigned,
  		      );
  		    };

  		    /**
  		     * Returns the bitwise XOR of this Long and the given one.
  		     * @this {!Long}
  		     * @param {!Long|number|bigint|string} other Other Long
  		     * @returns {!Long}
  		     */
  		    LongPrototype.xor = function xor(other) {
  		      if (!isLong(other)) other = fromValue(other);
  		      return fromBits(
  		        this.low ^ other.low,
  		        this.high ^ other.high,
  		        this.unsigned,
  		      );
  		    };

  		    /**
  		     * Returns this Long with bits shifted to the left by the given amount.
  		     * @this {!Long}
  		     * @param {number|!Long} numBits Number of bits
  		     * @returns {!Long} Shifted Long
  		     */
  		    LongPrototype.shiftLeft = function shiftLeft(numBits) {
  		      if (isLong(numBits)) numBits = numBits.toInt();
  		      if ((numBits &= 63) === 0) return this;
  		      else if (numBits < 32)
  		        return fromBits(
  		          this.low << numBits,
  		          (this.high << numBits) | (this.low >>> (32 - numBits)),
  		          this.unsigned,
  		        );
  		      else return fromBits(0, this.low << (numBits - 32), this.unsigned);
  		    };

  		    /**
  		     * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
  		     * @function
  		     * @param {number|!Long} numBits Number of bits
  		     * @returns {!Long} Shifted Long
  		     */
  		    LongPrototype.shl = LongPrototype.shiftLeft;

  		    /**
  		     * Returns this Long with bits arithmetically shifted to the right by the given amount.
  		     * @this {!Long}
  		     * @param {number|!Long} numBits Number of bits
  		     * @returns {!Long} Shifted Long
  		     */
  		    LongPrototype.shiftRight = function shiftRight(numBits) {
  		      if (isLong(numBits)) numBits = numBits.toInt();
  		      if ((numBits &= 63) === 0) return this;
  		      else if (numBits < 32)
  		        return fromBits(
  		          (this.low >>> numBits) | (this.high << (32 - numBits)),
  		          this.high >> numBits,
  		          this.unsigned,
  		        );
  		      else
  		        return fromBits(
  		          this.high >> (numBits - 32),
  		          this.high >= 0 ? 0 : -1,
  		          this.unsigned,
  		        );
  		    };

  		    /**
  		     * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
  		     * @function
  		     * @param {number|!Long} numBits Number of bits
  		     * @returns {!Long} Shifted Long
  		     */
  		    LongPrototype.shr = LongPrototype.shiftRight;

  		    /**
  		     * Returns this Long with bits logically shifted to the right by the given amount.
  		     * @this {!Long}
  		     * @param {number|!Long} numBits Number of bits
  		     * @returns {!Long} Shifted Long
  		     */
  		    LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
  		      if (isLong(numBits)) numBits = numBits.toInt();
  		      if ((numBits &= 63) === 0) return this;
  		      if (numBits < 32)
  		        return fromBits(
  		          (this.low >>> numBits) | (this.high << (32 - numBits)),
  		          this.high >>> numBits,
  		          this.unsigned,
  		        );
  		      if (numBits === 32) return fromBits(this.high, 0, this.unsigned);
  		      return fromBits(this.high >>> (numBits - 32), 0, this.unsigned);
  		    };

  		    /**
  		     * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
  		     * @function
  		     * @param {number|!Long} numBits Number of bits
  		     * @returns {!Long} Shifted Long
  		     */
  		    LongPrototype.shru = LongPrototype.shiftRightUnsigned;

  		    /**
  		     * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
  		     * @function
  		     * @param {number|!Long} numBits Number of bits
  		     * @returns {!Long} Shifted Long
  		     */
  		    LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;

  		    /**
  		     * Returns this Long with bits rotated to the left by the given amount.
  		     * @this {!Long}
  		     * @param {number|!Long} numBits Number of bits
  		     * @returns {!Long} Rotated Long
  		     */
  		    LongPrototype.rotateLeft = function rotateLeft(numBits) {
  		      var b;
  		      if (isLong(numBits)) numBits = numBits.toInt();
  		      if ((numBits &= 63) === 0) return this;
  		      if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
  		      if (numBits < 32) {
  		        b = 32 - numBits;
  		        return fromBits(
  		          (this.low << numBits) | (this.high >>> b),
  		          (this.high << numBits) | (this.low >>> b),
  		          this.unsigned,
  		        );
  		      }
  		      numBits -= 32;
  		      b = 32 - numBits;
  		      return fromBits(
  		        (this.high << numBits) | (this.low >>> b),
  		        (this.low << numBits) | (this.high >>> b),
  		        this.unsigned,
  		      );
  		    };
  		    /**
  		     * Returns this Long with bits rotated to the left by the given amount. This is an alias of {@link Long#rotateLeft}.
  		     * @function
  		     * @param {number|!Long} numBits Number of bits
  		     * @returns {!Long} Rotated Long
  		     */
  		    LongPrototype.rotl = LongPrototype.rotateLeft;

  		    /**
  		     * Returns this Long with bits rotated to the right by the given amount.
  		     * @this {!Long}
  		     * @param {number|!Long} numBits Number of bits
  		     * @returns {!Long} Rotated Long
  		     */
  		    LongPrototype.rotateRight = function rotateRight(numBits) {
  		      var b;
  		      if (isLong(numBits)) numBits = numBits.toInt();
  		      if ((numBits &= 63) === 0) return this;
  		      if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
  		      if (numBits < 32) {
  		        b = 32 - numBits;
  		        return fromBits(
  		          (this.high << b) | (this.low >>> numBits),
  		          (this.low << b) | (this.high >>> numBits),
  		          this.unsigned,
  		        );
  		      }
  		      numBits -= 32;
  		      b = 32 - numBits;
  		      return fromBits(
  		        (this.low << b) | (this.high >>> numBits),
  		        (this.high << b) | (this.low >>> numBits),
  		        this.unsigned,
  		      );
  		    };
  		    /**
  		     * Returns this Long with bits rotated to the right by the given amount. This is an alias of {@link Long#rotateRight}.
  		     * @function
  		     * @param {number|!Long} numBits Number of bits
  		     * @returns {!Long} Rotated Long
  		     */
  		    LongPrototype.rotr = LongPrototype.rotateRight;

  		    /**
  		     * Converts this Long to signed.
  		     * @this {!Long}
  		     * @returns {!Long} Signed long
  		     */
  		    LongPrototype.toSigned = function toSigned() {
  		      if (!this.unsigned) return this;
  		      return fromBits(this.low, this.high, false);
  		    };

  		    /**
  		     * Converts this Long to unsigned.
  		     * @this {!Long}
  		     * @returns {!Long} Unsigned long
  		     */
  		    LongPrototype.toUnsigned = function toUnsigned() {
  		      if (this.unsigned) return this;
  		      return fromBits(this.low, this.high, true);
  		    };

  		    /**
  		     * Converts this Long to its byte representation.
  		     * @param {boolean=} le Whether little or big endian, defaults to big endian
  		     * @this {!Long}
  		     * @returns {!Array.<number>} Byte representation
  		     */
  		    LongPrototype.toBytes = function toBytes(le) {
  		      return le ? this.toBytesLE() : this.toBytesBE();
  		    };

  		    /**
  		     * Converts this Long to its little endian byte representation.
  		     * @this {!Long}
  		     * @returns {!Array.<number>} Little endian byte representation
  		     */
  		    LongPrototype.toBytesLE = function toBytesLE() {
  		      var hi = this.high,
  		        lo = this.low;
  		      return [
  		        lo & 0xff,
  		        (lo >>> 8) & 0xff,
  		        (lo >>> 16) & 0xff,
  		        lo >>> 24,
  		        hi & 0xff,
  		        (hi >>> 8) & 0xff,
  		        (hi >>> 16) & 0xff,
  		        hi >>> 24,
  		      ];
  		    };

  		    /**
  		     * Converts this Long to its big endian byte representation.
  		     * @this {!Long}
  		     * @returns {!Array.<number>} Big endian byte representation
  		     */
  		    LongPrototype.toBytesBE = function toBytesBE() {
  		      var hi = this.high,
  		        lo = this.low;
  		      return [
  		        hi >>> 24,
  		        (hi >>> 16) & 0xff,
  		        (hi >>> 8) & 0xff,
  		        hi & 0xff,
  		        lo >>> 24,
  		        (lo >>> 16) & 0xff,
  		        (lo >>> 8) & 0xff,
  		        lo & 0xff,
  		      ];
  		    };

  		    /**
  		     * Creates a Long from its byte representation.
  		     * @param {!Array.<number>} bytes Byte representation
  		     * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
  		     * @param {boolean=} le Whether little or big endian, defaults to big endian
  		     * @returns {Long} The corresponding Long value
  		     */
  		    Long.fromBytes = function fromBytes(bytes, unsigned, le) {
  		      return le
  		        ? Long.fromBytesLE(bytes, unsigned)
  		        : Long.fromBytesBE(bytes, unsigned);
  		    };

  		    /**
  		     * Creates a Long from its little endian byte representation.
  		     * @param {!Array.<number>} bytes Little endian byte representation
  		     * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
  		     * @returns {Long} The corresponding Long value
  		     */
  		    Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
  		      return new Long(
  		        bytes[0] | (bytes[1] << 8) | (bytes[2] << 16) | (bytes[3] << 24),
  		        bytes[4] | (bytes[5] << 8) | (bytes[6] << 16) | (bytes[7] << 24),
  		        unsigned,
  		      );
  		    };

  		    /**
  		     * Creates a Long from its big endian byte representation.
  		     * @param {!Array.<number>} bytes Big endian byte representation
  		     * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
  		     * @returns {Long} The corresponding Long value
  		     */
  		    Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
  		      return new Long(
  		        (bytes[4] << 24) | (bytes[5] << 16) | (bytes[6] << 8) | bytes[7],
  		        (bytes[0] << 24) | (bytes[1] << 16) | (bytes[2] << 8) | bytes[3],
  		        unsigned,
  		      );
  		    };

  		    // Support conversion to/from BigInt where available
  		    if (typeof BigInt === "function") {
  		      /**
  		       * Returns a Long representing the given big integer.
  		       * @function
  		       * @param {number} value The big integer value
  		       * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
  		       * @returns {!Long} The corresponding Long value
  		       */
  		      Long.fromBigInt = function fromBigInt(value, unsigned) {
  		        var lowBits = Number(BigInt.asIntN(32, value));
  		        var highBits = Number(BigInt.asIntN(32, value >> BigInt(32)));
  		        return fromBits(lowBits, highBits, unsigned);
  		      };

  		      // Override
  		      Long.fromValue = function fromValueWithBigInt(value, unsigned) {
  		        if (typeof value === "bigint") return fromBigInt(value, unsigned);
  		        return fromValue(value, unsigned);
  		      };

  		      /**
  		       * Converts the Long to its big integer representation.
  		       * @this {!Long}
  		       * @returns {bigint}
  		       */
  		      LongPrototype.toBigInt = function toBigInt() {
  		        var lowBigInt = BigInt(this.low >>> 0);
  		        var highBigInt = BigInt(this.unsigned ? this.high >>> 0 : this.high);
  		        return (highBigInt << BigInt(32)) | lowBigInt;
  		      };
  		    }
  		    (_exports.default = Long);
  		  },
  		); 
  	} (umd$1, umd$1.exports));
  	return umd$1.exports;
  }

  var proto$8 = {};

  var hasRequiredProto;

  function requireProto () {
  	if (hasRequiredProto) return proto$8;
  	hasRequiredProto = 1;
  Object.defineProperty(proto$8,"__esModule",{value:true});proto$8.proto=proto$8.google=proto$8.default=proto$8.com=void 0;var $protobuf=_interopRequireWildcard(requireMinimal());function _getRequireWildcardCache(e){if("function"!=typeof WeakMap)return null;var r=new WeakMap(),t=new WeakMap();return (_getRequireWildcardCache=function(e){return e?t:r;})(e);}function _interopRequireWildcard(e,r){if(e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return {default:e};var t=_getRequireWildcardCache(r);if(t&&t.has(e))return t.get(e);var n={__proto__:null},a=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var u in e)if("default"!==u&&Object.prototype.hasOwnProperty.call(e,u)){var i=a?Object.getOwnPropertyDescriptor(e,u):null;i&&(i.get||i.set)?Object.defineProperty(n,u,i):n[u]=e[u];}return n.default=e,t&&t.set(e,n),n;}const $Reader=$protobuf.Reader,$Writer=$protobuf.Writer,$util=$protobuf.util;const $root=proto$8.default=$protobuf.roots.hashgraph||($protobuf.roots.hashgraph={});proto$8.com=$root.com=(()=>{const com={};com.hedera=function(){const hedera={};hedera.mirror=function(){const mirror={};mirror.api=function(){const api={};api.proto=function(){const proto={};proto.ConsensusTopicQuery=function(){function ConsensusTopicQuery(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ConsensusTopicQuery.prototype.topicID=null;ConsensusTopicQuery.prototype.consensusStartTime=null;ConsensusTopicQuery.prototype.consensusEndTime=null;ConsensusTopicQuery.prototype.limit=$util.Long?$util.Long.fromBits(0,0,true):0;ConsensusTopicQuery.create=function create(properties){return new ConsensusTopicQuery(properties);};ConsensusTopicQuery.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.topicID!=null&&Object.hasOwnProperty.call(m,"topicID"))$root.proto.TopicID.encode(m.topicID,w.uint32(10).fork()).ldelim();if(m.consensusStartTime!=null&&Object.hasOwnProperty.call(m,"consensusStartTime"))$root.proto.Timestamp.encode(m.consensusStartTime,w.uint32(18).fork()).ldelim();if(m.consensusEndTime!=null&&Object.hasOwnProperty.call(m,"consensusEndTime"))$root.proto.Timestamp.encode(m.consensusEndTime,w.uint32(26).fork()).ldelim();if(m.limit!=null&&Object.hasOwnProperty.call(m,"limit"))w.uint32(32).uint64(m.limit);return w;};ConsensusTopicQuery.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.mirror.api.proto.ConsensusTopicQuery();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.topicID=$root.proto.TopicID.decode(r,r.uint32());break;}case 2:{m.consensusStartTime=$root.proto.Timestamp.decode(r,r.uint32());break;}case 3:{m.consensusEndTime=$root.proto.Timestamp.decode(r,r.uint32());break;}case 4:{m.limit=r.uint64();break;}default:r.skipType(t&7);break;}}return m;};ConsensusTopicQuery.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.mirror.api.proto.ConsensusTopicQuery";};return ConsensusTopicQuery;}();proto.ConsensusTopicResponse=function(){function ConsensusTopicResponse(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ConsensusTopicResponse.prototype.consensusTimestamp=null;ConsensusTopicResponse.prototype.message=$util.newBuffer([]);ConsensusTopicResponse.prototype.runningHash=$util.newBuffer([]);ConsensusTopicResponse.prototype.sequenceNumber=$util.Long?$util.Long.fromBits(0,0,true):0;ConsensusTopicResponse.prototype.runningHashVersion=$util.Long?$util.Long.fromBits(0,0,true):0;ConsensusTopicResponse.prototype.chunkInfo=null;ConsensusTopicResponse.create=function create(properties){return new ConsensusTopicResponse(properties);};ConsensusTopicResponse.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.consensusTimestamp!=null&&Object.hasOwnProperty.call(m,"consensusTimestamp"))$root.proto.Timestamp.encode(m.consensusTimestamp,w.uint32(10).fork()).ldelim();if(m.message!=null&&Object.hasOwnProperty.call(m,"message"))w.uint32(18).bytes(m.message);if(m.runningHash!=null&&Object.hasOwnProperty.call(m,"runningHash"))w.uint32(26).bytes(m.runningHash);if(m.sequenceNumber!=null&&Object.hasOwnProperty.call(m,"sequenceNumber"))w.uint32(32).uint64(m.sequenceNumber);if(m.runningHashVersion!=null&&Object.hasOwnProperty.call(m,"runningHashVersion"))w.uint32(40).uint64(m.runningHashVersion);if(m.chunkInfo!=null&&Object.hasOwnProperty.call(m,"chunkInfo"))$root.proto.ConsensusMessageChunkInfo.encode(m.chunkInfo,w.uint32(50).fork()).ldelim();return w;};ConsensusTopicResponse.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.mirror.api.proto.ConsensusTopicResponse();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.consensusTimestamp=$root.proto.Timestamp.decode(r,r.uint32());break;}case 2:{m.message=r.bytes();break;}case 3:{m.runningHash=r.bytes();break;}case 4:{m.sequenceNumber=r.uint64();break;}case 5:{m.runningHashVersion=r.uint64();break;}case 6:{m.chunkInfo=$root.proto.ConsensusMessageChunkInfo.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};ConsensusTopicResponse.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.mirror.api.proto.ConsensusTopicResponse";};return ConsensusTopicResponse;}();proto.ConsensusService=function(){function ConsensusService(rpcImpl,requestDelimited,responseDelimited){$protobuf.rpc.Service.call(this,rpcImpl,requestDelimited,responseDelimited);}(ConsensusService.prototype=Object.create($protobuf.rpc.Service.prototype)).constructor=ConsensusService;ConsensusService.create=function create(rpcImpl,requestDelimited,responseDelimited){return new this(rpcImpl,requestDelimited,responseDelimited);};Object.defineProperty(ConsensusService.prototype.subscribeTopic=function subscribeTopic(request,callback){return this.rpcCall(subscribeTopic,$root.com.hedera.mirror.api.proto.ConsensusTopicQuery,$root.com.hedera.mirror.api.proto.ConsensusTopicResponse,request,callback);},"name",{value:"subscribeTopic"});return ConsensusService;}();proto.AddressBookQuery=function(){function AddressBookQuery(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}AddressBookQuery.prototype.fileId=null;AddressBookQuery.prototype.limit=0;AddressBookQuery.create=function create(properties){return new AddressBookQuery(properties);};AddressBookQuery.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.fileId!=null&&Object.hasOwnProperty.call(m,"fileId"))$root.proto.FileID.encode(m.fileId,w.uint32(10).fork()).ldelim();if(m.limit!=null&&Object.hasOwnProperty.call(m,"limit"))w.uint32(16).int32(m.limit);return w;};AddressBookQuery.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.mirror.api.proto.AddressBookQuery();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.fileId=$root.proto.FileID.decode(r,r.uint32());break;}case 2:{m.limit=r.int32();break;}default:r.skipType(t&7);break;}}return m;};AddressBookQuery.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.mirror.api.proto.AddressBookQuery";};return AddressBookQuery;}();proto.NetworkService=function(){function NetworkService(rpcImpl,requestDelimited,responseDelimited){$protobuf.rpc.Service.call(this,rpcImpl,requestDelimited,responseDelimited);}(NetworkService.prototype=Object.create($protobuf.rpc.Service.prototype)).constructor=NetworkService;NetworkService.create=function create(rpcImpl,requestDelimited,responseDelimited){return new this(rpcImpl,requestDelimited,responseDelimited);};Object.defineProperty(NetworkService.prototype.getNodes=function getNodes(request,callback){return this.rpcCall(getNodes,$root.com.hedera.mirror.api.proto.AddressBookQuery,$root.proto.NodeAddress,request,callback);},"name",{value:"getNodes"});return NetworkService;}();return proto;}();return api;}();return mirror;}();hedera.hapi=function(){const hapi={};hapi.services=function(){const services={};services.auxiliary=function(){const auxiliary={};auxiliary.hints=function(){const hints={};hints.CrsPublicationTransactionBody=function(){function CrsPublicationTransactionBody(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}CrsPublicationTransactionBody.prototype.newCrs=$util.newBuffer([]);CrsPublicationTransactionBody.prototype.proof=$util.newBuffer([]);CrsPublicationTransactionBody.create=function create(properties){return new CrsPublicationTransactionBody(properties);};CrsPublicationTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.newCrs!=null&&Object.hasOwnProperty.call(m,"newCrs"))w.uint32(10).bytes(m.newCrs);if(m.proof!=null&&Object.hasOwnProperty.call(m,"proof"))w.uint32(18).bytes(m.proof);return w;};CrsPublicationTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.hapi.services.auxiliary.hints.CrsPublicationTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.newCrs=r.bytes();break;}case 2:{m.proof=r.bytes();break;}default:r.skipType(t&7);break;}}return m;};CrsPublicationTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.hapi.services.auxiliary.hints.CrsPublicationTransactionBody";};return CrsPublicationTransactionBody;}();hints.HintsKeyPublicationTransactionBody=function(){function HintsKeyPublicationTransactionBody(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}HintsKeyPublicationTransactionBody.prototype.partyId=0;HintsKeyPublicationTransactionBody.prototype.numParties=0;HintsKeyPublicationTransactionBody.prototype.hintsKey=$util.newBuffer([]);HintsKeyPublicationTransactionBody.create=function create(properties){return new HintsKeyPublicationTransactionBody(properties);};HintsKeyPublicationTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.partyId!=null&&Object.hasOwnProperty.call(m,"partyId"))w.uint32(8).uint32(m.partyId);if(m.numParties!=null&&Object.hasOwnProperty.call(m,"numParties"))w.uint32(16).uint32(m.numParties);if(m.hintsKey!=null&&Object.hasOwnProperty.call(m,"hintsKey"))w.uint32(26).bytes(m.hintsKey);return w;};HintsKeyPublicationTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.hapi.services.auxiliary.hints.HintsKeyPublicationTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.partyId=r.uint32();break;}case 2:{m.numParties=r.uint32();break;}case 3:{m.hintsKey=r.bytes();break;}default:r.skipType(t&7);break;}}return m;};HintsKeyPublicationTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.hapi.services.auxiliary.hints.HintsKeyPublicationTransactionBody";};return HintsKeyPublicationTransactionBody;}();hints.HintsPartialSignatureTransactionBody=function(){function HintsPartialSignatureTransactionBody(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}HintsPartialSignatureTransactionBody.prototype.constructionId=$util.Long?$util.Long.fromBits(0,0,true):0;HintsPartialSignatureTransactionBody.prototype.message=$util.newBuffer([]);HintsPartialSignatureTransactionBody.prototype.partialSignature=$util.newBuffer([]);HintsPartialSignatureTransactionBody.create=function create(properties){return new HintsPartialSignatureTransactionBody(properties);};HintsPartialSignatureTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.constructionId!=null&&Object.hasOwnProperty.call(m,"constructionId"))w.uint32(8).uint64(m.constructionId);if(m.message!=null&&Object.hasOwnProperty.call(m,"message"))w.uint32(18).bytes(m.message);if(m.partialSignature!=null&&Object.hasOwnProperty.call(m,"partialSignature"))w.uint32(26).bytes(m.partialSignature);return w;};HintsPartialSignatureTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.hapi.services.auxiliary.hints.HintsPartialSignatureTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.constructionId=r.uint64();break;}case 2:{m.message=r.bytes();break;}case 3:{m.partialSignature=r.bytes();break;}default:r.skipType(t&7);break;}}return m;};HintsPartialSignatureTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.hapi.services.auxiliary.hints.HintsPartialSignatureTransactionBody";};return HintsPartialSignatureTransactionBody;}();hints.HintsPreprocessingVoteTransactionBody=function(){function HintsPreprocessingVoteTransactionBody(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}HintsPreprocessingVoteTransactionBody.prototype.constructionId=$util.Long?$util.Long.fromBits(0,0,true):0;HintsPreprocessingVoteTransactionBody.prototype.vote=null;HintsPreprocessingVoteTransactionBody.create=function create(properties){return new HintsPreprocessingVoteTransactionBody(properties);};HintsPreprocessingVoteTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.constructionId!=null&&Object.hasOwnProperty.call(m,"constructionId"))w.uint32(8).uint64(m.constructionId);if(m.vote!=null&&Object.hasOwnProperty.call(m,"vote"))$root.com.hedera.hapi.node.state.hints.PreprocessingVote.encode(m.vote,w.uint32(18).fork()).ldelim();return w;};HintsPreprocessingVoteTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.hapi.services.auxiliary.hints.HintsPreprocessingVoteTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.constructionId=r.uint64();break;}case 2:{m.vote=$root.com.hedera.hapi.node.state.hints.PreprocessingVote.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};HintsPreprocessingVoteTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.hapi.services.auxiliary.hints.HintsPreprocessingVoteTransactionBody";};return HintsPreprocessingVoteTransactionBody;}();return hints;}();auxiliary.history=function(){const history={};history.HistoryProofKeyPublicationTransactionBody=function(){function HistoryProofKeyPublicationTransactionBody(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}HistoryProofKeyPublicationTransactionBody.prototype.proofKey=$util.newBuffer([]);HistoryProofKeyPublicationTransactionBody.create=function create(properties){return new HistoryProofKeyPublicationTransactionBody(properties);};HistoryProofKeyPublicationTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.proofKey!=null&&Object.hasOwnProperty.call(m,"proofKey"))w.uint32(10).bytes(m.proofKey);return w;};HistoryProofKeyPublicationTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.hapi.services.auxiliary.history.HistoryProofKeyPublicationTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.proofKey=r.bytes();break;}default:r.skipType(t&7);break;}}return m;};HistoryProofKeyPublicationTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.hapi.services.auxiliary.history.HistoryProofKeyPublicationTransactionBody";};return HistoryProofKeyPublicationTransactionBody;}();history.HistoryProofSignatureTransactionBody=function(){function HistoryProofSignatureTransactionBody(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}HistoryProofSignatureTransactionBody.prototype.constructionId=$util.Long?$util.Long.fromBits(0,0,true):0;HistoryProofSignatureTransactionBody.prototype.signature=null;HistoryProofSignatureTransactionBody.create=function create(properties){return new HistoryProofSignatureTransactionBody(properties);};HistoryProofSignatureTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.constructionId!=null&&Object.hasOwnProperty.call(m,"constructionId"))w.uint32(8).uint64(m.constructionId);if(m.signature!=null&&Object.hasOwnProperty.call(m,"signature"))$root.com.hedera.hapi.node.state.history.HistorySignature.encode(m.signature,w.uint32(18).fork()).ldelim();return w;};HistoryProofSignatureTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.hapi.services.auxiliary.history.HistoryProofSignatureTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.constructionId=r.uint64();break;}case 2:{m.signature=$root.com.hedera.hapi.node.state.history.HistorySignature.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};HistoryProofSignatureTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.hapi.services.auxiliary.history.HistoryProofSignatureTransactionBody";};return HistoryProofSignatureTransactionBody;}();history.HistoryProofVoteTransactionBody=function(){function HistoryProofVoteTransactionBody(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}HistoryProofVoteTransactionBody.prototype.constructionId=$util.Long?$util.Long.fromBits(0,0,true):0;HistoryProofVoteTransactionBody.prototype.vote=null;HistoryProofVoteTransactionBody.create=function create(properties){return new HistoryProofVoteTransactionBody(properties);};HistoryProofVoteTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.constructionId!=null&&Object.hasOwnProperty.call(m,"constructionId"))w.uint32(8).uint64(m.constructionId);if(m.vote!=null&&Object.hasOwnProperty.call(m,"vote"))$root.com.hedera.hapi.node.state.history.HistoryProofVote.encode(m.vote,w.uint32(18).fork()).ldelim();return w;};HistoryProofVoteTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.hapi.services.auxiliary.history.HistoryProofVoteTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.constructionId=r.uint64();break;}case 2:{m.vote=$root.com.hedera.hapi.node.state.history.HistoryProofVote.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};HistoryProofVoteTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.hapi.services.auxiliary.history.HistoryProofVoteTransactionBody";};return HistoryProofVoteTransactionBody;}();return history;}();auxiliary.tss=function(){const tss={};tss.TssEncryptionKeyTransactionBody=function(){function TssEncryptionKeyTransactionBody(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TssEncryptionKeyTransactionBody.prototype.publicTssEncryptionKey=$util.newBuffer([]);TssEncryptionKeyTransactionBody.create=function create(properties){return new TssEncryptionKeyTransactionBody(properties);};TssEncryptionKeyTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.publicTssEncryptionKey!=null&&Object.hasOwnProperty.call(m,"publicTssEncryptionKey"))w.uint32(10).bytes(m.publicTssEncryptionKey);return w;};TssEncryptionKeyTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.hapi.services.auxiliary.tss.TssEncryptionKeyTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.publicTssEncryptionKey=r.bytes();break;}default:r.skipType(t&7);break;}}return m;};TssEncryptionKeyTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.hapi.services.auxiliary.tss.TssEncryptionKeyTransactionBody";};return TssEncryptionKeyTransactionBody;}();tss.TssMessageTransactionBody=function(){function TssMessageTransactionBody(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TssMessageTransactionBody.prototype.sourceRosterHash=$util.newBuffer([]);TssMessageTransactionBody.prototype.targetRosterHash=$util.newBuffer([]);TssMessageTransactionBody.prototype.shareIndex=$util.Long?$util.Long.fromBits(0,0,true):0;TssMessageTransactionBody.prototype.tssMessage=$util.newBuffer([]);TssMessageTransactionBody.create=function create(properties){return new TssMessageTransactionBody(properties);};TssMessageTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.sourceRosterHash!=null&&Object.hasOwnProperty.call(m,"sourceRosterHash"))w.uint32(10).bytes(m.sourceRosterHash);if(m.targetRosterHash!=null&&Object.hasOwnProperty.call(m,"targetRosterHash"))w.uint32(18).bytes(m.targetRosterHash);if(m.shareIndex!=null&&Object.hasOwnProperty.call(m,"shareIndex"))w.uint32(24).uint64(m.shareIndex);if(m.tssMessage!=null&&Object.hasOwnProperty.call(m,"tssMessage"))w.uint32(34).bytes(m.tssMessage);return w;};TssMessageTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.hapi.services.auxiliary.tss.TssMessageTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.sourceRosterHash=r.bytes();break;}case 2:{m.targetRosterHash=r.bytes();break;}case 3:{m.shareIndex=r.uint64();break;}case 4:{m.tssMessage=r.bytes();break;}default:r.skipType(t&7);break;}}return m;};TssMessageTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.hapi.services.auxiliary.tss.TssMessageTransactionBody";};return TssMessageTransactionBody;}();tss.TssVoteTransactionBody=function(){function TssVoteTransactionBody(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TssVoteTransactionBody.prototype.sourceRosterHash=$util.newBuffer([]);TssVoteTransactionBody.prototype.targetRosterHash=$util.newBuffer([]);TssVoteTransactionBody.prototype.ledgerId=$util.newBuffer([]);TssVoteTransactionBody.prototype.nodeSignature=$util.newBuffer([]);TssVoteTransactionBody.prototype.tssVote=$util.newBuffer([]);TssVoteTransactionBody.create=function create(properties){return new TssVoteTransactionBody(properties);};TssVoteTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.sourceRosterHash!=null&&Object.hasOwnProperty.call(m,"sourceRosterHash"))w.uint32(10).bytes(m.sourceRosterHash);if(m.targetRosterHash!=null&&Object.hasOwnProperty.call(m,"targetRosterHash"))w.uint32(18).bytes(m.targetRosterHash);if(m.ledgerId!=null&&Object.hasOwnProperty.call(m,"ledgerId"))w.uint32(26).bytes(m.ledgerId);if(m.nodeSignature!=null&&Object.hasOwnProperty.call(m,"nodeSignature"))w.uint32(34).bytes(m.nodeSignature);if(m.tssVote!=null&&Object.hasOwnProperty.call(m,"tssVote"))w.uint32(42).bytes(m.tssVote);return w;};TssVoteTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.hapi.services.auxiliary.tss.TssVoteTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.sourceRosterHash=r.bytes();break;}case 2:{m.targetRosterHash=r.bytes();break;}case 3:{m.ledgerId=r.bytes();break;}case 4:{m.nodeSignature=r.bytes();break;}case 5:{m.tssVote=r.bytes();break;}default:r.skipType(t&7);break;}}return m;};TssVoteTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.hapi.services.auxiliary.tss.TssVoteTransactionBody";};return TssVoteTransactionBody;}();return tss;}();return auxiliary;}();return services;}();hapi.node=function(){const node={};node.state=function(){const state={};state.hints=function(){const hints={};hints.HintsPartyId=function(){function HintsPartyId(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}HintsPartyId.prototype.partyId=0;HintsPartyId.prototype.numParties=0;HintsPartyId.create=function create(properties){return new HintsPartyId(properties);};HintsPartyId.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.partyId!=null&&Object.hasOwnProperty.call(m,"partyId"))w.uint32(8).uint32(m.partyId);if(m.numParties!=null&&Object.hasOwnProperty.call(m,"numParties"))w.uint32(16).uint32(m.numParties);return w;};HintsPartyId.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.hapi.node.state.hints.HintsPartyId();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.partyId=r.uint32();break;}case 2:{m.numParties=r.uint32();break;}default:r.skipType(t&7);break;}}return m;};HintsPartyId.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.hapi.node.state.hints.HintsPartyId";};return HintsPartyId;}();hints.HintsKeySet=function(){function HintsKeySet(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}HintsKeySet.prototype.nodeId=$util.Long?$util.Long.fromBits(0,0,true):0;HintsKeySet.prototype.adoptionTime=null;HintsKeySet.prototype.key=$util.newBuffer([]);HintsKeySet.prototype.nextKey=$util.newBuffer([]);HintsKeySet.create=function create(properties){return new HintsKeySet(properties);};HintsKeySet.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.nodeId!=null&&Object.hasOwnProperty.call(m,"nodeId"))w.uint32(8).uint64(m.nodeId);if(m.adoptionTime!=null&&Object.hasOwnProperty.call(m,"adoptionTime"))$root.proto.Timestamp.encode(m.adoptionTime,w.uint32(18).fork()).ldelim();if(m.key!=null&&Object.hasOwnProperty.call(m,"key"))w.uint32(26).bytes(m.key);if(m.nextKey!=null&&Object.hasOwnProperty.call(m,"nextKey"))w.uint32(34).bytes(m.nextKey);return w;};HintsKeySet.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.hapi.node.state.hints.HintsKeySet();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.nodeId=r.uint64();break;}case 2:{m.adoptionTime=$root.proto.Timestamp.decode(r,r.uint32());break;}case 3:{m.key=r.bytes();break;}case 4:{m.nextKey=r.bytes();break;}default:r.skipType(t&7);break;}}return m;};HintsKeySet.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.hapi.node.state.hints.HintsKeySet";};return HintsKeySet;}();hints.PreprocessedKeys=function(){function PreprocessedKeys(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}PreprocessedKeys.prototype.aggregationKey=$util.newBuffer([]);PreprocessedKeys.prototype.verificationKey=$util.newBuffer([]);PreprocessedKeys.create=function create(properties){return new PreprocessedKeys(properties);};PreprocessedKeys.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.aggregationKey!=null&&Object.hasOwnProperty.call(m,"aggregationKey"))w.uint32(10).bytes(m.aggregationKey);if(m.verificationKey!=null&&Object.hasOwnProperty.call(m,"verificationKey"))w.uint32(18).bytes(m.verificationKey);return w;};PreprocessedKeys.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.hapi.node.state.hints.PreprocessedKeys();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.aggregationKey=r.bytes();break;}case 2:{m.verificationKey=r.bytes();break;}default:r.skipType(t&7);break;}}return m;};PreprocessedKeys.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.hapi.node.state.hints.PreprocessedKeys";};return PreprocessedKeys;}();hints.PreprocessingVoteId=function(){function PreprocessingVoteId(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}PreprocessingVoteId.prototype.constructionId=$util.Long?$util.Long.fromBits(0,0,true):0;PreprocessingVoteId.prototype.nodeId=$util.Long?$util.Long.fromBits(0,0,true):0;PreprocessingVoteId.create=function create(properties){return new PreprocessingVoteId(properties);};PreprocessingVoteId.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.constructionId!=null&&Object.hasOwnProperty.call(m,"constructionId"))w.uint32(8).uint64(m.constructionId);if(m.nodeId!=null&&Object.hasOwnProperty.call(m,"nodeId"))w.uint32(16).uint64(m.nodeId);return w;};PreprocessingVoteId.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.hapi.node.state.hints.PreprocessingVoteId();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.constructionId=r.uint64();break;}case 2:{m.nodeId=r.uint64();break;}default:r.skipType(t&7);break;}}return m;};PreprocessingVoteId.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.hapi.node.state.hints.PreprocessingVoteId";};return PreprocessingVoteId;}();hints.PreprocessingVote=function(){function PreprocessingVote(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}PreprocessingVote.prototype.preprocessedKeys=null;PreprocessingVote.prototype.congruentNodeId=null;let $oneOfFields;Object.defineProperty(PreprocessingVote.prototype,"vote",{get:$util.oneOfGetter($oneOfFields=["preprocessedKeys","congruentNodeId"]),set:$util.oneOfSetter($oneOfFields)});PreprocessingVote.create=function create(properties){return new PreprocessingVote(properties);};PreprocessingVote.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.preprocessedKeys!=null&&Object.hasOwnProperty.call(m,"preprocessedKeys"))$root.com.hedera.hapi.node.state.hints.PreprocessedKeys.encode(m.preprocessedKeys,w.uint32(10).fork()).ldelim();if(m.congruentNodeId!=null&&Object.hasOwnProperty.call(m,"congruentNodeId"))w.uint32(16).uint64(m.congruentNodeId);return w;};PreprocessingVote.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.hapi.node.state.hints.PreprocessingVote();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.preprocessedKeys=$root.com.hedera.hapi.node.state.hints.PreprocessedKeys.decode(r,r.uint32());break;}case 2:{m.congruentNodeId=r.uint64();break;}default:r.skipType(t&7);break;}}return m;};PreprocessingVote.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.hapi.node.state.hints.PreprocessingVote";};return PreprocessingVote;}();hints.NodePartyId=function(){function NodePartyId(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}NodePartyId.prototype.nodeId=$util.Long?$util.Long.fromBits(0,0,true):0;NodePartyId.prototype.partyId=0;NodePartyId.prototype.partyWeight=$util.Long?$util.Long.fromBits(0,0,true):0;NodePartyId.create=function create(properties){return new NodePartyId(properties);};NodePartyId.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.nodeId!=null&&Object.hasOwnProperty.call(m,"nodeId"))w.uint32(8).uint64(m.nodeId);if(m.partyId!=null&&Object.hasOwnProperty.call(m,"partyId"))w.uint32(16).uint32(m.partyId);if(m.partyWeight!=null&&Object.hasOwnProperty.call(m,"partyWeight"))w.uint32(24).uint64(m.partyWeight);return w;};NodePartyId.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.hapi.node.state.hints.NodePartyId();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.nodeId=r.uint64();break;}case 2:{m.partyId=r.uint32();break;}case 3:{m.partyWeight=r.uint64();break;}default:r.skipType(t&7);break;}}return m;};NodePartyId.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.hapi.node.state.hints.NodePartyId";};return NodePartyId;}();hints.HintsScheme=function(){function HintsScheme(p){this.nodePartyIds=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}HintsScheme.prototype.preprocessedKeys=null;HintsScheme.prototype.nodePartyIds=$util.emptyArray;HintsScheme.create=function create(properties){return new HintsScheme(properties);};HintsScheme.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.preprocessedKeys!=null&&Object.hasOwnProperty.call(m,"preprocessedKeys"))$root.com.hedera.hapi.node.state.hints.PreprocessedKeys.encode(m.preprocessedKeys,w.uint32(10).fork()).ldelim();if(m.nodePartyIds!=null&&m.nodePartyIds.length){for(var i=0;i<m.nodePartyIds.length;++i)$root.com.hedera.hapi.node.state.hints.NodePartyId.encode(m.nodePartyIds[i],w.uint32(18).fork()).ldelim();}return w;};HintsScheme.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.hapi.node.state.hints.HintsScheme();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.preprocessedKeys=$root.com.hedera.hapi.node.state.hints.PreprocessedKeys.decode(r,r.uint32());break;}case 2:{if(!(m.nodePartyIds&&m.nodePartyIds.length))m.nodePartyIds=[];m.nodePartyIds.push($root.com.hedera.hapi.node.state.hints.NodePartyId.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};HintsScheme.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.hapi.node.state.hints.HintsScheme";};return HintsScheme;}();hints.HintsConstruction=function(){function HintsConstruction(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}HintsConstruction.prototype.constructionId=$util.Long?$util.Long.fromBits(0,0,true):0;HintsConstruction.prototype.sourceRosterHash=$util.newBuffer([]);HintsConstruction.prototype.targetRosterHash=$util.newBuffer([]);HintsConstruction.prototype.gracePeriodEndTime=null;HintsConstruction.prototype.preprocessingStartTime=null;HintsConstruction.prototype.hintsScheme=null;let $oneOfFields;Object.defineProperty(HintsConstruction.prototype,"preprocessingState",{get:$util.oneOfGetter($oneOfFields=["gracePeriodEndTime","preprocessingStartTime","hintsScheme"]),set:$util.oneOfSetter($oneOfFields)});HintsConstruction.create=function create(properties){return new HintsConstruction(properties);};HintsConstruction.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.constructionId!=null&&Object.hasOwnProperty.call(m,"constructionId"))w.uint32(8).uint64(m.constructionId);if(m.sourceRosterHash!=null&&Object.hasOwnProperty.call(m,"sourceRosterHash"))w.uint32(18).bytes(m.sourceRosterHash);if(m.targetRosterHash!=null&&Object.hasOwnProperty.call(m,"targetRosterHash"))w.uint32(26).bytes(m.targetRosterHash);if(m.gracePeriodEndTime!=null&&Object.hasOwnProperty.call(m,"gracePeriodEndTime"))$root.proto.Timestamp.encode(m.gracePeriodEndTime,w.uint32(34).fork()).ldelim();if(m.preprocessingStartTime!=null&&Object.hasOwnProperty.call(m,"preprocessingStartTime"))$root.proto.Timestamp.encode(m.preprocessingStartTime,w.uint32(42).fork()).ldelim();if(m.hintsScheme!=null&&Object.hasOwnProperty.call(m,"hintsScheme"))$root.com.hedera.hapi.node.state.hints.HintsScheme.encode(m.hintsScheme,w.uint32(50).fork()).ldelim();return w;};HintsConstruction.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.hapi.node.state.hints.HintsConstruction();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.constructionId=r.uint64();break;}case 2:{m.sourceRosterHash=r.bytes();break;}case 3:{m.targetRosterHash=r.bytes();break;}case 4:{m.gracePeriodEndTime=$root.proto.Timestamp.decode(r,r.uint32());break;}case 5:{m.preprocessingStartTime=$root.proto.Timestamp.decode(r,r.uint32());break;}case 6:{m.hintsScheme=$root.com.hedera.hapi.node.state.hints.HintsScheme.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};HintsConstruction.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.hapi.node.state.hints.HintsConstruction";};return HintsConstruction;}();hints.CRSStage=function(){const valuesById={},values=Object.create(valuesById);values[valuesById[0]="GATHERING_CONTRIBUTIONS"]=0;values[valuesById[1]="WAITING_FOR_ADOPTING_FINAL_CRS"]=1;values[valuesById[2]="COMPLETED"]=2;return values;}();hints.CRSState=function(){function CRSState(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}CRSState.prototype.crs=$util.newBuffer([]);CRSState.prototype.stage=0;CRSState.prototype.nextContributingNodeId=null;CRSState.prototype.contributionEndTime=null;CRSState.create=function create(properties){return new CRSState(properties);};CRSState.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.crs!=null&&Object.hasOwnProperty.call(m,"crs"))w.uint32(10).bytes(m.crs);if(m.stage!=null&&Object.hasOwnProperty.call(m,"stage"))w.uint32(16).int32(m.stage);if(m.nextContributingNodeId!=null&&Object.hasOwnProperty.call(m,"nextContributingNodeId"))$root.google.protobuf.UInt64Value.encode(m.nextContributingNodeId,w.uint32(26).fork()).ldelim();if(m.contributionEndTime!=null&&Object.hasOwnProperty.call(m,"contributionEndTime"))$root.proto.Timestamp.encode(m.contributionEndTime,w.uint32(34).fork()).ldelim();return w;};CRSState.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.hapi.node.state.hints.CRSState();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.crs=r.bytes();break;}case 2:{m.stage=r.int32();break;}case 3:{m.nextContributingNodeId=$root.google.protobuf.UInt64Value.decode(r,r.uint32());break;}case 4:{m.contributionEndTime=$root.proto.Timestamp.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};CRSState.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.hapi.node.state.hints.CRSState";};return CRSState;}();return hints;}();state.history=function(){const history={};history.ProofKeySet=function(){function ProofKeySet(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ProofKeySet.prototype.adoptionTime=null;ProofKeySet.prototype.key=$util.newBuffer([]);ProofKeySet.prototype.nextKey=$util.newBuffer([]);ProofKeySet.create=function create(properties){return new ProofKeySet(properties);};ProofKeySet.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.adoptionTime!=null&&Object.hasOwnProperty.call(m,"adoptionTime"))$root.proto.Timestamp.encode(m.adoptionTime,w.uint32(18).fork()).ldelim();if(m.key!=null&&Object.hasOwnProperty.call(m,"key"))w.uint32(26).bytes(m.key);if(m.nextKey!=null&&Object.hasOwnProperty.call(m,"nextKey"))w.uint32(34).bytes(m.nextKey);return w;};ProofKeySet.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.hapi.node.state.history.ProofKeySet();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 2:{m.adoptionTime=$root.proto.Timestamp.decode(r,r.uint32());break;}case 3:{m.key=r.bytes();break;}case 4:{m.nextKey=r.bytes();break;}default:r.skipType(t&7);break;}}return m;};ProofKeySet.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.hapi.node.state.history.ProofKeySet";};return ProofKeySet;}();history.ProofKey=function(){function ProofKey(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ProofKey.prototype.nodeId=$util.Long?$util.Long.fromBits(0,0,true):0;ProofKey.prototype.key=$util.newBuffer([]);ProofKey.create=function create(properties){return new ProofKey(properties);};ProofKey.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.nodeId!=null&&Object.hasOwnProperty.call(m,"nodeId"))w.uint32(8).uint64(m.nodeId);if(m.key!=null&&Object.hasOwnProperty.call(m,"key"))w.uint32(18).bytes(m.key);return w;};ProofKey.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.hapi.node.state.history.ProofKey();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.nodeId=r.uint64();break;}case 2:{m.key=r.bytes();break;}default:r.skipType(t&7);break;}}return m;};ProofKey.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.hapi.node.state.history.ProofKey";};return ProofKey;}();history.History=function(){function History(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}History.prototype.addressBookHash=$util.newBuffer([]);History.prototype.metadata=$util.newBuffer([]);History.create=function create(properties){return new History(properties);};History.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.addressBookHash!=null&&Object.hasOwnProperty.call(m,"addressBookHash"))w.uint32(10).bytes(m.addressBookHash);if(m.metadata!=null&&Object.hasOwnProperty.call(m,"metadata"))w.uint32(18).bytes(m.metadata);return w;};History.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.hapi.node.state.history.History();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.addressBookHash=r.bytes();break;}case 2:{m.metadata=r.bytes();break;}default:r.skipType(t&7);break;}}return m;};History.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.hapi.node.state.history.History";};return History;}();history.HistoryProof=function(){function HistoryProof(p){this.targetProofKeys=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}HistoryProof.prototype.sourceAddressBookHash=$util.newBuffer([]);HistoryProof.prototype.targetProofKeys=$util.emptyArray;HistoryProof.prototype.targetHistory=null;HistoryProof.prototype.proof=$util.newBuffer([]);HistoryProof.create=function create(properties){return new HistoryProof(properties);};HistoryProof.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.sourceAddressBookHash!=null&&Object.hasOwnProperty.call(m,"sourceAddressBookHash"))w.uint32(10).bytes(m.sourceAddressBookHash);if(m.targetProofKeys!=null&&m.targetProofKeys.length){for(var i=0;i<m.targetProofKeys.length;++i)$root.com.hedera.hapi.node.state.history.ProofKey.encode(m.targetProofKeys[i],w.uint32(18).fork()).ldelim();}if(m.targetHistory!=null&&Object.hasOwnProperty.call(m,"targetHistory"))$root.com.hedera.hapi.node.state.history.History.encode(m.targetHistory,w.uint32(26).fork()).ldelim();if(m.proof!=null&&Object.hasOwnProperty.call(m,"proof"))w.uint32(34).bytes(m.proof);return w;};HistoryProof.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.hapi.node.state.history.HistoryProof();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.sourceAddressBookHash=r.bytes();break;}case 2:{if(!(m.targetProofKeys&&m.targetProofKeys.length))m.targetProofKeys=[];m.targetProofKeys.push($root.com.hedera.hapi.node.state.history.ProofKey.decode(r,r.uint32()));break;}case 3:{m.targetHistory=$root.com.hedera.hapi.node.state.history.History.decode(r,r.uint32());break;}case 4:{m.proof=r.bytes();break;}default:r.skipType(t&7);break;}}return m;};HistoryProof.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.hapi.node.state.history.HistoryProof";};return HistoryProof;}();history.HistoryProofConstruction=function(){function HistoryProofConstruction(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}HistoryProofConstruction.prototype.constructionId=$util.Long?$util.Long.fromBits(0,0,true):0;HistoryProofConstruction.prototype.sourceRosterHash=$util.newBuffer([]);HistoryProofConstruction.prototype.sourceProof=null;HistoryProofConstruction.prototype.targetRosterHash=$util.newBuffer([]);HistoryProofConstruction.prototype.gracePeriodEndTime=null;HistoryProofConstruction.prototype.assemblyStartTime=null;HistoryProofConstruction.prototype.targetProof=null;HistoryProofConstruction.prototype.failureReason=null;let $oneOfFields;Object.defineProperty(HistoryProofConstruction.prototype,"proofState",{get:$util.oneOfGetter($oneOfFields=["gracePeriodEndTime","assemblyStartTime","targetProof","failureReason"]),set:$util.oneOfSetter($oneOfFields)});HistoryProofConstruction.create=function create(properties){return new HistoryProofConstruction(properties);};HistoryProofConstruction.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.constructionId!=null&&Object.hasOwnProperty.call(m,"constructionId"))w.uint32(8).uint64(m.constructionId);if(m.sourceRosterHash!=null&&Object.hasOwnProperty.call(m,"sourceRosterHash"))w.uint32(18).bytes(m.sourceRosterHash);if(m.sourceProof!=null&&Object.hasOwnProperty.call(m,"sourceProof"))$root.com.hedera.hapi.node.state.history.HistoryProof.encode(m.sourceProof,w.uint32(26).fork()).ldelim();if(m.targetRosterHash!=null&&Object.hasOwnProperty.call(m,"targetRosterHash"))w.uint32(34).bytes(m.targetRosterHash);if(m.gracePeriodEndTime!=null&&Object.hasOwnProperty.call(m,"gracePeriodEndTime"))$root.proto.Timestamp.encode(m.gracePeriodEndTime,w.uint32(42).fork()).ldelim();if(m.assemblyStartTime!=null&&Object.hasOwnProperty.call(m,"assemblyStartTime"))$root.proto.Timestamp.encode(m.assemblyStartTime,w.uint32(50).fork()).ldelim();if(m.targetProof!=null&&Object.hasOwnProperty.call(m,"targetProof"))$root.com.hedera.hapi.node.state.history.HistoryProof.encode(m.targetProof,w.uint32(58).fork()).ldelim();if(m.failureReason!=null&&Object.hasOwnProperty.call(m,"failureReason"))w.uint32(66).string(m.failureReason);return w;};HistoryProofConstruction.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.hapi.node.state.history.HistoryProofConstruction();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.constructionId=r.uint64();break;}case 2:{m.sourceRosterHash=r.bytes();break;}case 3:{m.sourceProof=$root.com.hedera.hapi.node.state.history.HistoryProof.decode(r,r.uint32());break;}case 4:{m.targetRosterHash=r.bytes();break;}case 5:{m.gracePeriodEndTime=$root.proto.Timestamp.decode(r,r.uint32());break;}case 6:{m.assemblyStartTime=$root.proto.Timestamp.decode(r,r.uint32());break;}case 7:{m.targetProof=$root.com.hedera.hapi.node.state.history.HistoryProof.decode(r,r.uint32());break;}case 8:{m.failureReason=r.string();break;}default:r.skipType(t&7);break;}}return m;};HistoryProofConstruction.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.hapi.node.state.history.HistoryProofConstruction";};return HistoryProofConstruction;}();history.ConstructionNodeId=function(){function ConstructionNodeId(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ConstructionNodeId.prototype.constructionId=$util.Long?$util.Long.fromBits(0,0,true):0;ConstructionNodeId.prototype.nodeId=$util.Long?$util.Long.fromBits(0,0,true):0;ConstructionNodeId.create=function create(properties){return new ConstructionNodeId(properties);};ConstructionNodeId.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.constructionId!=null&&Object.hasOwnProperty.call(m,"constructionId"))w.uint32(8).uint64(m.constructionId);if(m.nodeId!=null&&Object.hasOwnProperty.call(m,"nodeId"))w.uint32(16).uint64(m.nodeId);return w;};ConstructionNodeId.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.hapi.node.state.history.ConstructionNodeId();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.constructionId=r.uint64();break;}case 2:{m.nodeId=r.uint64();break;}default:r.skipType(t&7);break;}}return m;};ConstructionNodeId.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.hapi.node.state.history.ConstructionNodeId";};return ConstructionNodeId;}();history.HistoryProofVote=function(){function HistoryProofVote(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}HistoryProofVote.prototype.proof=null;HistoryProofVote.prototype.congruentNodeId=null;let $oneOfFields;Object.defineProperty(HistoryProofVote.prototype,"vote",{get:$util.oneOfGetter($oneOfFields=["proof","congruentNodeId"]),set:$util.oneOfSetter($oneOfFields)});HistoryProofVote.create=function create(properties){return new HistoryProofVote(properties);};HistoryProofVote.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.proof!=null&&Object.hasOwnProperty.call(m,"proof"))$root.com.hedera.hapi.node.state.history.HistoryProof.encode(m.proof,w.uint32(10).fork()).ldelim();if(m.congruentNodeId!=null&&Object.hasOwnProperty.call(m,"congruentNodeId"))w.uint32(16).uint64(m.congruentNodeId);return w;};HistoryProofVote.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.hapi.node.state.history.HistoryProofVote();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.proof=$root.com.hedera.hapi.node.state.history.HistoryProof.decode(r,r.uint32());break;}case 2:{m.congruentNodeId=r.uint64();break;}default:r.skipType(t&7);break;}}return m;};HistoryProofVote.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.hapi.node.state.history.HistoryProofVote";};return HistoryProofVote;}();history.HistorySignature=function(){function HistorySignature(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}HistorySignature.prototype.history=null;HistorySignature.prototype.signature=$util.newBuffer([]);HistorySignature.create=function create(properties){return new HistorySignature(properties);};HistorySignature.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.history!=null&&Object.hasOwnProperty.call(m,"history"))$root.com.hedera.hapi.node.state.history.History.encode(m.history,w.uint32(10).fork()).ldelim();if(m.signature!=null&&Object.hasOwnProperty.call(m,"signature"))w.uint32(18).bytes(m.signature);return w;};HistorySignature.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.hapi.node.state.history.HistorySignature();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.history=$root.com.hedera.hapi.node.state.history.History.decode(r,r.uint32());break;}case 2:{m.signature=r.bytes();break;}default:r.skipType(t&7);break;}}return m;};HistorySignature.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.hapi.node.state.history.HistorySignature";};return HistorySignature;}();history.RecordedHistorySignature=function(){function RecordedHistorySignature(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}RecordedHistorySignature.prototype.signingTime=null;RecordedHistorySignature.prototype.historySignature=null;RecordedHistorySignature.create=function create(properties){return new RecordedHistorySignature(properties);};RecordedHistorySignature.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.signingTime!=null&&Object.hasOwnProperty.call(m,"signingTime"))$root.proto.Timestamp.encode(m.signingTime,w.uint32(10).fork()).ldelim();if(m.historySignature!=null&&Object.hasOwnProperty.call(m,"historySignature"))$root.com.hedera.hapi.node.state.history.HistorySignature.encode(m.historySignature,w.uint32(18).fork()).ldelim();return w;};RecordedHistorySignature.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.hapi.node.state.history.RecordedHistorySignature();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.signingTime=$root.proto.Timestamp.decode(r,r.uint32());break;}case 2:{m.historySignature=$root.com.hedera.hapi.node.state.history.HistorySignature.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};RecordedHistorySignature.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.hapi.node.state.history.RecordedHistorySignature";};return RecordedHistorySignature;}();return history;}();state.addressbook=function(){const addressbook={};addressbook.Node=function(){function Node(p){this.gossipEndpoint=[];this.serviceEndpoint=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}Node.prototype.nodeId=$util.Long?$util.Long.fromBits(0,0,true):0;Node.prototype.accountId=null;Node.prototype.description="";Node.prototype.gossipEndpoint=$util.emptyArray;Node.prototype.serviceEndpoint=$util.emptyArray;Node.prototype.gossipCaCertificate=$util.newBuffer([]);Node.prototype.grpcCertificateHash=$util.newBuffer([]);Node.prototype.weight=$util.Long?$util.Long.fromBits(0,0,true):0;Node.prototype.deleted=false;Node.prototype.adminKey=null;Node.prototype.declineReward=false;Node.prototype.grpcProxyEndpoint=null;Node.create=function create(properties){return new Node(properties);};Node.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.nodeId!=null&&Object.hasOwnProperty.call(m,"nodeId"))w.uint32(8).uint64(m.nodeId);if(m.accountId!=null&&Object.hasOwnProperty.call(m,"accountId"))$root.proto.AccountID.encode(m.accountId,w.uint32(18).fork()).ldelim();if(m.description!=null&&Object.hasOwnProperty.call(m,"description"))w.uint32(26).string(m.description);if(m.gossipEndpoint!=null&&m.gossipEndpoint.length){for(var i=0;i<m.gossipEndpoint.length;++i)$root.proto.ServiceEndpoint.encode(m.gossipEndpoint[i],w.uint32(34).fork()).ldelim();}if(m.serviceEndpoint!=null&&m.serviceEndpoint.length){for(var i=0;i<m.serviceEndpoint.length;++i)$root.proto.ServiceEndpoint.encode(m.serviceEndpoint[i],w.uint32(42).fork()).ldelim();}if(m.gossipCaCertificate!=null&&Object.hasOwnProperty.call(m,"gossipCaCertificate"))w.uint32(50).bytes(m.gossipCaCertificate);if(m.grpcCertificateHash!=null&&Object.hasOwnProperty.call(m,"grpcCertificateHash"))w.uint32(58).bytes(m.grpcCertificateHash);if(m.weight!=null&&Object.hasOwnProperty.call(m,"weight"))w.uint32(64).uint64(m.weight);if(m.deleted!=null&&Object.hasOwnProperty.call(m,"deleted"))w.uint32(72).bool(m.deleted);if(m.adminKey!=null&&Object.hasOwnProperty.call(m,"adminKey"))$root.proto.Key.encode(m.adminKey,w.uint32(82).fork()).ldelim();if(m.declineReward!=null&&Object.hasOwnProperty.call(m,"declineReward"))w.uint32(88).bool(m.declineReward);if(m.grpcProxyEndpoint!=null&&Object.hasOwnProperty.call(m,"grpcProxyEndpoint"))$root.proto.ServiceEndpoint.encode(m.grpcProxyEndpoint,w.uint32(98).fork()).ldelim();return w;};Node.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.hapi.node.state.addressbook.Node();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.nodeId=r.uint64();break;}case 2:{m.accountId=$root.proto.AccountID.decode(r,r.uint32());break;}case 3:{m.description=r.string();break;}case 4:{if(!(m.gossipEndpoint&&m.gossipEndpoint.length))m.gossipEndpoint=[];m.gossipEndpoint.push($root.proto.ServiceEndpoint.decode(r,r.uint32()));break;}case 5:{if(!(m.serviceEndpoint&&m.serviceEndpoint.length))m.serviceEndpoint=[];m.serviceEndpoint.push($root.proto.ServiceEndpoint.decode(r,r.uint32()));break;}case 6:{m.gossipCaCertificate=r.bytes();break;}case 7:{m.grpcCertificateHash=r.bytes();break;}case 8:{m.weight=r.uint64();break;}case 9:{m.deleted=r.bool();break;}case 10:{m.adminKey=$root.proto.Key.decode(r,r.uint32());break;}case 11:{m.declineReward=r.bool();break;}case 12:{m.grpcProxyEndpoint=$root.proto.ServiceEndpoint.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};Node.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.hapi.node.state.addressbook.Node";};return Node;}();return addressbook;}();state.blockstream=function(){const blockstream={};blockstream.BlockStreamInfo=function(){function BlockStreamInfo(p){this.rightmostPrecedingStateChangesTreeHashes=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}BlockStreamInfo.prototype.blockNumber=$util.Long?$util.Long.fromBits(0,0,true):0;BlockStreamInfo.prototype.blockTime=null;BlockStreamInfo.prototype.trailingOutputHashes=$util.newBuffer([]);BlockStreamInfo.prototype.trailingBlockHashes=$util.newBuffer([]);BlockStreamInfo.prototype.inputTreeRootHash=$util.newBuffer([]);BlockStreamInfo.prototype.startOfBlockStateHash=$util.newBuffer([]);BlockStreamInfo.prototype.numPrecedingStateChangesItems=0;BlockStreamInfo.prototype.rightmostPrecedingStateChangesTreeHashes=$util.emptyArray;BlockStreamInfo.prototype.blockEndTime=null;BlockStreamInfo.prototype.postUpgradeWorkDone=false;BlockStreamInfo.prototype.creationSoftwareVersion=null;BlockStreamInfo.prototype.lastIntervalProcessTime=null;BlockStreamInfo.prototype.lastHandleTime=null;BlockStreamInfo.prototype.consensusHeaderTreeRootHash=$util.newBuffer([]);BlockStreamInfo.prototype.traceDataTreeRootHash=$util.newBuffer([]);BlockStreamInfo.prototype.outputTreeRootHash=$util.newBuffer([]);BlockStreamInfo.create=function create(properties){return new BlockStreamInfo(properties);};BlockStreamInfo.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.blockNumber!=null&&Object.hasOwnProperty.call(m,"blockNumber"))w.uint32(8).uint64(m.blockNumber);if(m.blockTime!=null&&Object.hasOwnProperty.call(m,"blockTime"))$root.proto.Timestamp.encode(m.blockTime,w.uint32(18).fork()).ldelim();if(m.trailingOutputHashes!=null&&Object.hasOwnProperty.call(m,"trailingOutputHashes"))w.uint32(26).bytes(m.trailingOutputHashes);if(m.trailingBlockHashes!=null&&Object.hasOwnProperty.call(m,"trailingBlockHashes"))w.uint32(34).bytes(m.trailingBlockHashes);if(m.inputTreeRootHash!=null&&Object.hasOwnProperty.call(m,"inputTreeRootHash"))w.uint32(42).bytes(m.inputTreeRootHash);if(m.startOfBlockStateHash!=null&&Object.hasOwnProperty.call(m,"startOfBlockStateHash"))w.uint32(50).bytes(m.startOfBlockStateHash);if(m.numPrecedingStateChangesItems!=null&&Object.hasOwnProperty.call(m,"numPrecedingStateChangesItems"))w.uint32(56).uint32(m.numPrecedingStateChangesItems);if(m.rightmostPrecedingStateChangesTreeHashes!=null&&m.rightmostPrecedingStateChangesTreeHashes.length){for(var i=0;i<m.rightmostPrecedingStateChangesTreeHashes.length;++i)w.uint32(66).bytes(m.rightmostPrecedingStateChangesTreeHashes[i]);}if(m.blockEndTime!=null&&Object.hasOwnProperty.call(m,"blockEndTime"))$root.proto.Timestamp.encode(m.blockEndTime,w.uint32(74).fork()).ldelim();if(m.postUpgradeWorkDone!=null&&Object.hasOwnProperty.call(m,"postUpgradeWorkDone"))w.uint32(80).bool(m.postUpgradeWorkDone);if(m.creationSoftwareVersion!=null&&Object.hasOwnProperty.call(m,"creationSoftwareVersion"))$root.proto.SemanticVersion.encode(m.creationSoftwareVersion,w.uint32(90).fork()).ldelim();if(m.lastIntervalProcessTime!=null&&Object.hasOwnProperty.call(m,"lastIntervalProcessTime"))$root.proto.Timestamp.encode(m.lastIntervalProcessTime,w.uint32(98).fork()).ldelim();if(m.lastHandleTime!=null&&Object.hasOwnProperty.call(m,"lastHandleTime"))$root.proto.Timestamp.encode(m.lastHandleTime,w.uint32(106).fork()).ldelim();if(m.consensusHeaderTreeRootHash!=null&&Object.hasOwnProperty.call(m,"consensusHeaderTreeRootHash"))w.uint32(114).bytes(m.consensusHeaderTreeRootHash);if(m.traceDataTreeRootHash!=null&&Object.hasOwnProperty.call(m,"traceDataTreeRootHash"))w.uint32(122).bytes(m.traceDataTreeRootHash);if(m.outputTreeRootHash!=null&&Object.hasOwnProperty.call(m,"outputTreeRootHash"))w.uint32(130).bytes(m.outputTreeRootHash);return w;};BlockStreamInfo.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.hapi.node.state.blockstream.BlockStreamInfo();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.blockNumber=r.uint64();break;}case 2:{m.blockTime=$root.proto.Timestamp.decode(r,r.uint32());break;}case 3:{m.trailingOutputHashes=r.bytes();break;}case 4:{m.trailingBlockHashes=r.bytes();break;}case 5:{m.inputTreeRootHash=r.bytes();break;}case 6:{m.startOfBlockStateHash=r.bytes();break;}case 7:{m.numPrecedingStateChangesItems=r.uint32();break;}case 8:{if(!(m.rightmostPrecedingStateChangesTreeHashes&&m.rightmostPrecedingStateChangesTreeHashes.length))m.rightmostPrecedingStateChangesTreeHashes=[];m.rightmostPrecedingStateChangesTreeHashes.push(r.bytes());break;}case 9:{m.blockEndTime=$root.proto.Timestamp.decode(r,r.uint32());break;}case 10:{m.postUpgradeWorkDone=r.bool();break;}case 11:{m.creationSoftwareVersion=$root.proto.SemanticVersion.decode(r,r.uint32());break;}case 12:{m.lastIntervalProcessTime=$root.proto.Timestamp.decode(r,r.uint32());break;}case 13:{m.lastHandleTime=$root.proto.Timestamp.decode(r,r.uint32());break;}case 14:{m.consensusHeaderTreeRootHash=r.bytes();break;}case 15:{m.traceDataTreeRootHash=r.bytes();break;}case 16:{m.outputTreeRootHash=r.bytes();break;}default:r.skipType(t&7);break;}}return m;};BlockStreamInfo.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.hapi.node.state.blockstream.BlockStreamInfo";};return BlockStreamInfo;}();return blockstream;}();state.entity=function(){const entity={};entity.EntityCounts=function(){function EntityCounts(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}EntityCounts.prototype.numAccounts=$util.Long?$util.Long.fromBits(0,0,true):0;EntityCounts.prototype.numAliases=$util.Long?$util.Long.fromBits(0,0,true):0;EntityCounts.prototype.numTokens=$util.Long?$util.Long.fromBits(0,0,true):0;EntityCounts.prototype.numTokenRelations=$util.Long?$util.Long.fromBits(0,0,true):0;EntityCounts.prototype.numNfts=$util.Long?$util.Long.fromBits(0,0,true):0;EntityCounts.prototype.numAirdrops=$util.Long?$util.Long.fromBits(0,0,true):0;EntityCounts.prototype.numStakingInfos=$util.Long?$util.Long.fromBits(0,0,true):0;EntityCounts.prototype.numTopics=$util.Long?$util.Long.fromBits(0,0,true):0;EntityCounts.prototype.numFiles=$util.Long?$util.Long.fromBits(0,0,true):0;EntityCounts.prototype.numNodes=$util.Long?$util.Long.fromBits(0,0,true):0;EntityCounts.prototype.numSchedules=$util.Long?$util.Long.fromBits(0,0,true):0;EntityCounts.prototype.numContractStorageSlots=$util.Long?$util.Long.fromBits(0,0,true):0;EntityCounts.prototype.numContractBytecodes=$util.Long?$util.Long.fromBits(0,0,true):0;EntityCounts.create=function create(properties){return new EntityCounts(properties);};EntityCounts.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.numAccounts!=null&&Object.hasOwnProperty.call(m,"numAccounts"))w.uint32(8).uint64(m.numAccounts);if(m.numAliases!=null&&Object.hasOwnProperty.call(m,"numAliases"))w.uint32(16).uint64(m.numAliases);if(m.numTokens!=null&&Object.hasOwnProperty.call(m,"numTokens"))w.uint32(24).uint64(m.numTokens);if(m.numTokenRelations!=null&&Object.hasOwnProperty.call(m,"numTokenRelations"))w.uint32(32).uint64(m.numTokenRelations);if(m.numNfts!=null&&Object.hasOwnProperty.call(m,"numNfts"))w.uint32(40).uint64(m.numNfts);if(m.numAirdrops!=null&&Object.hasOwnProperty.call(m,"numAirdrops"))w.uint32(48).uint64(m.numAirdrops);if(m.numStakingInfos!=null&&Object.hasOwnProperty.call(m,"numStakingInfos"))w.uint32(56).uint64(m.numStakingInfos);if(m.numTopics!=null&&Object.hasOwnProperty.call(m,"numTopics"))w.uint32(64).uint64(m.numTopics);if(m.numFiles!=null&&Object.hasOwnProperty.call(m,"numFiles"))w.uint32(72).uint64(m.numFiles);if(m.numNodes!=null&&Object.hasOwnProperty.call(m,"numNodes"))w.uint32(80).uint64(m.numNodes);if(m.numSchedules!=null&&Object.hasOwnProperty.call(m,"numSchedules"))w.uint32(88).uint64(m.numSchedules);if(m.numContractStorageSlots!=null&&Object.hasOwnProperty.call(m,"numContractStorageSlots"))w.uint32(96).uint64(m.numContractStorageSlots);if(m.numContractBytecodes!=null&&Object.hasOwnProperty.call(m,"numContractBytecodes"))w.uint32(104).uint64(m.numContractBytecodes);return w;};EntityCounts.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.hapi.node.state.entity.EntityCounts();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.numAccounts=r.uint64();break;}case 2:{m.numAliases=r.uint64();break;}case 3:{m.numTokens=r.uint64();break;}case 4:{m.numTokenRelations=r.uint64();break;}case 5:{m.numNfts=r.uint64();break;}case 6:{m.numAirdrops=r.uint64();break;}case 7:{m.numStakingInfos=r.uint64();break;}case 8:{m.numTopics=r.uint64();break;}case 9:{m.numFiles=r.uint64();break;}case 10:{m.numNodes=r.uint64();break;}case 11:{m.numSchedules=r.uint64();break;}case 12:{m.numContractStorageSlots=r.uint64();break;}case 13:{m.numContractBytecodes=r.uint64();break;}default:r.skipType(t&7);break;}}return m;};EntityCounts.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.hapi.node.state.entity.EntityCounts";};return EntityCounts;}();return entity;}();state.roster=function(){const roster={};roster.LedgerId=function(){function LedgerId(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}LedgerId.prototype.ledgerId=$util.newBuffer([]);LedgerId.prototype.round=$util.Long?$util.Long.fromBits(0,0,true):0;LedgerId.prototype.ledgerSignature=$util.newBuffer([]);LedgerId.prototype.rosterSignatures=null;LedgerId.create=function create(properties){return new LedgerId(properties);};LedgerId.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.ledgerId!=null&&Object.hasOwnProperty.call(m,"ledgerId"))w.uint32(10).bytes(m.ledgerId);if(m.round!=null&&Object.hasOwnProperty.call(m,"round"))w.uint32(16).uint64(m.round);if(m.ledgerSignature!=null&&Object.hasOwnProperty.call(m,"ledgerSignature"))w.uint32(26).bytes(m.ledgerSignature);if(m.rosterSignatures!=null&&Object.hasOwnProperty.call(m,"rosterSignatures"))$root.com.hedera.hapi.node.state.roster.RosterSignatures.encode(m.rosterSignatures,w.uint32(34).fork()).ldelim();return w;};LedgerId.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.hapi.node.state.roster.LedgerId();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.ledgerId=r.bytes();break;}case 2:{m.round=r.uint64();break;}case 3:{m.ledgerSignature=r.bytes();break;}case 4:{m.rosterSignatures=$root.com.hedera.hapi.node.state.roster.RosterSignatures.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};LedgerId.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.hapi.node.state.roster.LedgerId";};return LedgerId;}();roster.RosterSignatures=function(){function RosterSignatures(p){this.nodeSignatures=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}RosterSignatures.prototype.rosterHash=$util.newBuffer([]);RosterSignatures.prototype.nodeSignatures=$util.emptyArray;RosterSignatures.create=function create(properties){return new RosterSignatures(properties);};RosterSignatures.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.rosterHash!=null&&Object.hasOwnProperty.call(m,"rosterHash"))w.uint32(10).bytes(m.rosterHash);if(m.nodeSignatures!=null&&m.nodeSignatures.length){for(var i=0;i<m.nodeSignatures.length;++i)$root.com.hedera.hapi.node.state.roster.NodeSignature.encode(m.nodeSignatures[i],w.uint32(18).fork()).ldelim();}return w;};RosterSignatures.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.hapi.node.state.roster.RosterSignatures();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.rosterHash=r.bytes();break;}case 2:{if(!(m.nodeSignatures&&m.nodeSignatures.length))m.nodeSignatures=[];m.nodeSignatures.push($root.com.hedera.hapi.node.state.roster.NodeSignature.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};RosterSignatures.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.hapi.node.state.roster.RosterSignatures";};return RosterSignatures;}();roster.NodeSignature=function(){function NodeSignature(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}NodeSignature.prototype.nodeId=$util.Long?$util.Long.fromBits(0,0,true):0;NodeSignature.prototype.nodeSignature=$util.newBuffer([]);NodeSignature.create=function create(properties){return new NodeSignature(properties);};NodeSignature.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.nodeId!=null&&Object.hasOwnProperty.call(m,"nodeId"))w.uint32(8).uint64(m.nodeId);if(m.nodeSignature!=null&&Object.hasOwnProperty.call(m,"nodeSignature"))w.uint32(18).bytes(m.nodeSignature);return w;};NodeSignature.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.hapi.node.state.roster.NodeSignature();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.nodeId=r.uint64();break;}case 2:{m.nodeSignature=r.bytes();break;}default:r.skipType(t&7);break;}}return m;};NodeSignature.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.hapi.node.state.roster.NodeSignature";};return NodeSignature;}();roster.RosterState=function(){function RosterState(p){this.roundRosterPairs=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}RosterState.prototype.candidateRosterHash=$util.newBuffer([]);RosterState.prototype.roundRosterPairs=$util.emptyArray;RosterState.prototype.transplantInProgress=false;RosterState.create=function create(properties){return new RosterState(properties);};RosterState.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.candidateRosterHash!=null&&Object.hasOwnProperty.call(m,"candidateRosterHash"))w.uint32(10).bytes(m.candidateRosterHash);if(m.roundRosterPairs!=null&&m.roundRosterPairs.length){for(var i=0;i<m.roundRosterPairs.length;++i)$root.com.hedera.hapi.node.state.roster.RoundRosterPair.encode(m.roundRosterPairs[i],w.uint32(18).fork()).ldelim();}if(m.transplantInProgress!=null&&Object.hasOwnProperty.call(m,"transplantInProgress"))w.uint32(24).bool(m.transplantInProgress);return w;};RosterState.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.hapi.node.state.roster.RosterState();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.candidateRosterHash=r.bytes();break;}case 2:{if(!(m.roundRosterPairs&&m.roundRosterPairs.length))m.roundRosterPairs=[];m.roundRosterPairs.push($root.com.hedera.hapi.node.state.roster.RoundRosterPair.decode(r,r.uint32()));break;}case 3:{m.transplantInProgress=r.bool();break;}default:r.skipType(t&7);break;}}return m;};RosterState.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.hapi.node.state.roster.RosterState";};return RosterState;}();roster.RoundRosterPair=function(){function RoundRosterPair(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}RoundRosterPair.prototype.roundNumber=$util.Long?$util.Long.fromBits(0,0,true):0;RoundRosterPair.prototype.activeRosterHash=$util.newBuffer([]);RoundRosterPair.create=function create(properties){return new RoundRosterPair(properties);};RoundRosterPair.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.roundNumber!=null&&Object.hasOwnProperty.call(m,"roundNumber"))w.uint32(8).uint64(m.roundNumber);if(m.activeRosterHash!=null&&Object.hasOwnProperty.call(m,"activeRosterHash"))w.uint32(18).bytes(m.activeRosterHash);return w;};RoundRosterPair.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.hapi.node.state.roster.RoundRosterPair();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.roundNumber=r.uint64();break;}case 2:{m.activeRosterHash=r.bytes();break;}default:r.skipType(t&7);break;}}return m;};RoundRosterPair.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.hapi.node.state.roster.RoundRosterPair";};return RoundRosterPair;}();roster.Roster=function(){function Roster(p){this.rosterEntries=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}Roster.prototype.rosterEntries=$util.emptyArray;Roster.create=function create(properties){return new Roster(properties);};Roster.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.rosterEntries!=null&&m.rosterEntries.length){for(var i=0;i<m.rosterEntries.length;++i)$root.com.hedera.hapi.node.state.roster.RosterEntry.encode(m.rosterEntries[i],w.uint32(10).fork()).ldelim();}return w;};Roster.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.hapi.node.state.roster.Roster();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{if(!(m.rosterEntries&&m.rosterEntries.length))m.rosterEntries=[];m.rosterEntries.push($root.com.hedera.hapi.node.state.roster.RosterEntry.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};Roster.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.hapi.node.state.roster.Roster";};return Roster;}();roster.RosterEntry=function(){function RosterEntry(p){this.gossipEndpoint=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}RosterEntry.prototype.nodeId=$util.Long?$util.Long.fromBits(0,0,true):0;RosterEntry.prototype.weight=$util.Long?$util.Long.fromBits(0,0,true):0;RosterEntry.prototype.gossipCaCertificate=$util.newBuffer([]);RosterEntry.prototype.gossipEndpoint=$util.emptyArray;RosterEntry.create=function create(properties){return new RosterEntry(properties);};RosterEntry.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.nodeId!=null&&Object.hasOwnProperty.call(m,"nodeId"))w.uint32(8).uint64(m.nodeId);if(m.weight!=null&&Object.hasOwnProperty.call(m,"weight"))w.uint32(16).uint64(m.weight);if(m.gossipCaCertificate!=null&&Object.hasOwnProperty.call(m,"gossipCaCertificate"))w.uint32(26).bytes(m.gossipCaCertificate);if(m.gossipEndpoint!=null&&m.gossipEndpoint.length){for(var i=0;i<m.gossipEndpoint.length;++i)$root.proto.ServiceEndpoint.encode(m.gossipEndpoint[i],w.uint32(42).fork()).ldelim();}return w;};RosterEntry.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.hapi.node.state.roster.RosterEntry();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.nodeId=r.uint64();break;}case 2:{m.weight=r.uint64();break;}case 3:{m.gossipCaCertificate=r.bytes();break;}case 5:{if(!(m.gossipEndpoint&&m.gossipEndpoint.length))m.gossipEndpoint=[];m.gossipEndpoint.push($root.proto.ServiceEndpoint.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};RosterEntry.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.hapi.node.state.roster.RosterEntry";};return RosterEntry;}();return roster;}();state.tss=function(){const tss={};tss.TssEncryptionKeys=function(){function TssEncryptionKeys(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TssEncryptionKeys.prototype.currentEncryptionKey=$util.newBuffer([]);TssEncryptionKeys.prototype.nextEncryptionKey=$util.newBuffer([]);TssEncryptionKeys.create=function create(properties){return new TssEncryptionKeys(properties);};TssEncryptionKeys.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.currentEncryptionKey!=null&&Object.hasOwnProperty.call(m,"currentEncryptionKey"))w.uint32(10).bytes(m.currentEncryptionKey);if(m.nextEncryptionKey!=null&&Object.hasOwnProperty.call(m,"nextEncryptionKey"))w.uint32(18).bytes(m.nextEncryptionKey);return w;};TssEncryptionKeys.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.hapi.node.state.tss.TssEncryptionKeys();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.currentEncryptionKey=r.bytes();break;}case 2:{m.nextEncryptionKey=r.bytes();break;}default:r.skipType(t&7);break;}}return m;};TssEncryptionKeys.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.hapi.node.state.tss.TssEncryptionKeys";};return TssEncryptionKeys;}();tss.TssMessageMapKey=function(){function TssMessageMapKey(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TssMessageMapKey.prototype.rosterHash=$util.newBuffer([]);TssMessageMapKey.prototype.sequenceNumber=$util.Long?$util.Long.fromBits(0,0,true):0;TssMessageMapKey.create=function create(properties){return new TssMessageMapKey(properties);};TssMessageMapKey.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.rosterHash!=null&&Object.hasOwnProperty.call(m,"rosterHash"))w.uint32(10).bytes(m.rosterHash);if(m.sequenceNumber!=null&&Object.hasOwnProperty.call(m,"sequenceNumber"))w.uint32(16).uint64(m.sequenceNumber);return w;};TssMessageMapKey.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.hapi.node.state.tss.TssMessageMapKey();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.rosterHash=r.bytes();break;}case 2:{m.sequenceNumber=r.uint64();break;}default:r.skipType(t&7);break;}}return m;};TssMessageMapKey.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.hapi.node.state.tss.TssMessageMapKey";};return TssMessageMapKey;}();tss.TssVoteMapKey=function(){function TssVoteMapKey(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TssVoteMapKey.prototype.rosterHash=$util.newBuffer([]);TssVoteMapKey.prototype.nodeId=$util.Long?$util.Long.fromBits(0,0,true):0;TssVoteMapKey.create=function create(properties){return new TssVoteMapKey(properties);};TssVoteMapKey.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.rosterHash!=null&&Object.hasOwnProperty.call(m,"rosterHash"))w.uint32(10).bytes(m.rosterHash);if(m.nodeId!=null&&Object.hasOwnProperty.call(m,"nodeId"))w.uint32(16).uint64(m.nodeId);return w;};TssVoteMapKey.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.hapi.node.state.tss.TssVoteMapKey();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.rosterHash=r.bytes();break;}case 2:{m.nodeId=r.uint64();break;}default:r.skipType(t&7);break;}}return m;};TssVoteMapKey.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.hapi.node.state.tss.TssVoteMapKey";};return TssVoteMapKey;}();return tss;}();return state;}();node.addressbook=function(){const addressbook={};addressbook.NodeCreateTransactionBody=function(){function NodeCreateTransactionBody(p){this.gossipEndpoint=[];this.serviceEndpoint=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}NodeCreateTransactionBody.prototype.accountId=null;NodeCreateTransactionBody.prototype.description="";NodeCreateTransactionBody.prototype.gossipEndpoint=$util.emptyArray;NodeCreateTransactionBody.prototype.serviceEndpoint=$util.emptyArray;NodeCreateTransactionBody.prototype.gossipCaCertificate=$util.newBuffer([]);NodeCreateTransactionBody.prototype.grpcCertificateHash=$util.newBuffer([]);NodeCreateTransactionBody.prototype.adminKey=null;NodeCreateTransactionBody.prototype.declineReward=false;NodeCreateTransactionBody.prototype.grpcProxyEndpoint=null;NodeCreateTransactionBody.create=function create(properties){return new NodeCreateTransactionBody(properties);};NodeCreateTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.accountId!=null&&Object.hasOwnProperty.call(m,"accountId"))$root.proto.AccountID.encode(m.accountId,w.uint32(10).fork()).ldelim();if(m.description!=null&&Object.hasOwnProperty.call(m,"description"))w.uint32(18).string(m.description);if(m.gossipEndpoint!=null&&m.gossipEndpoint.length){for(var i=0;i<m.gossipEndpoint.length;++i)$root.proto.ServiceEndpoint.encode(m.gossipEndpoint[i],w.uint32(26).fork()).ldelim();}if(m.serviceEndpoint!=null&&m.serviceEndpoint.length){for(var i=0;i<m.serviceEndpoint.length;++i)$root.proto.ServiceEndpoint.encode(m.serviceEndpoint[i],w.uint32(34).fork()).ldelim();}if(m.gossipCaCertificate!=null&&Object.hasOwnProperty.call(m,"gossipCaCertificate"))w.uint32(42).bytes(m.gossipCaCertificate);if(m.grpcCertificateHash!=null&&Object.hasOwnProperty.call(m,"grpcCertificateHash"))w.uint32(50).bytes(m.grpcCertificateHash);if(m.adminKey!=null&&Object.hasOwnProperty.call(m,"adminKey"))$root.proto.Key.encode(m.adminKey,w.uint32(58).fork()).ldelim();if(m.declineReward!=null&&Object.hasOwnProperty.call(m,"declineReward"))w.uint32(64).bool(m.declineReward);if(m.grpcProxyEndpoint!=null&&Object.hasOwnProperty.call(m,"grpcProxyEndpoint"))$root.proto.ServiceEndpoint.encode(m.grpcProxyEndpoint,w.uint32(74).fork()).ldelim();return w;};NodeCreateTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.hapi.node.addressbook.NodeCreateTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.accountId=$root.proto.AccountID.decode(r,r.uint32());break;}case 2:{m.description=r.string();break;}case 3:{if(!(m.gossipEndpoint&&m.gossipEndpoint.length))m.gossipEndpoint=[];m.gossipEndpoint.push($root.proto.ServiceEndpoint.decode(r,r.uint32()));break;}case 4:{if(!(m.serviceEndpoint&&m.serviceEndpoint.length))m.serviceEndpoint=[];m.serviceEndpoint.push($root.proto.ServiceEndpoint.decode(r,r.uint32()));break;}case 5:{m.gossipCaCertificate=r.bytes();break;}case 6:{m.grpcCertificateHash=r.bytes();break;}case 7:{m.adminKey=$root.proto.Key.decode(r,r.uint32());break;}case 8:{m.declineReward=r.bool();break;}case 9:{m.grpcProxyEndpoint=$root.proto.ServiceEndpoint.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};NodeCreateTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.hapi.node.addressbook.NodeCreateTransactionBody";};return NodeCreateTransactionBody;}();addressbook.NodeUpdateTransactionBody=function(){function NodeUpdateTransactionBody(p){this.gossipEndpoint=[];this.serviceEndpoint=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}NodeUpdateTransactionBody.prototype.nodeId=$util.Long?$util.Long.fromBits(0,0,true):0;NodeUpdateTransactionBody.prototype.accountId=null;NodeUpdateTransactionBody.prototype.description=null;NodeUpdateTransactionBody.prototype.gossipEndpoint=$util.emptyArray;NodeUpdateTransactionBody.prototype.serviceEndpoint=$util.emptyArray;NodeUpdateTransactionBody.prototype.gossipCaCertificate=null;NodeUpdateTransactionBody.prototype.grpcCertificateHash=null;NodeUpdateTransactionBody.prototype.adminKey=null;NodeUpdateTransactionBody.prototype.declineReward=null;NodeUpdateTransactionBody.prototype.grpcProxyEndpoint=null;NodeUpdateTransactionBody.create=function create(properties){return new NodeUpdateTransactionBody(properties);};NodeUpdateTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.nodeId!=null&&Object.hasOwnProperty.call(m,"nodeId"))w.uint32(8).uint64(m.nodeId);if(m.accountId!=null&&Object.hasOwnProperty.call(m,"accountId"))$root.proto.AccountID.encode(m.accountId,w.uint32(18).fork()).ldelim();if(m.description!=null&&Object.hasOwnProperty.call(m,"description"))$root.google.protobuf.StringValue.encode(m.description,w.uint32(26).fork()).ldelim();if(m.gossipEndpoint!=null&&m.gossipEndpoint.length){for(var i=0;i<m.gossipEndpoint.length;++i)$root.proto.ServiceEndpoint.encode(m.gossipEndpoint[i],w.uint32(34).fork()).ldelim();}if(m.serviceEndpoint!=null&&m.serviceEndpoint.length){for(var i=0;i<m.serviceEndpoint.length;++i)$root.proto.ServiceEndpoint.encode(m.serviceEndpoint[i],w.uint32(42).fork()).ldelim();}if(m.gossipCaCertificate!=null&&Object.hasOwnProperty.call(m,"gossipCaCertificate"))$root.google.protobuf.BytesValue.encode(m.gossipCaCertificate,w.uint32(50).fork()).ldelim();if(m.grpcCertificateHash!=null&&Object.hasOwnProperty.call(m,"grpcCertificateHash"))$root.google.protobuf.BytesValue.encode(m.grpcCertificateHash,w.uint32(58).fork()).ldelim();if(m.adminKey!=null&&Object.hasOwnProperty.call(m,"adminKey"))$root.proto.Key.encode(m.adminKey,w.uint32(66).fork()).ldelim();if(m.declineReward!=null&&Object.hasOwnProperty.call(m,"declineReward"))$root.google.protobuf.BoolValue.encode(m.declineReward,w.uint32(74).fork()).ldelim();if(m.grpcProxyEndpoint!=null&&Object.hasOwnProperty.call(m,"grpcProxyEndpoint"))$root.proto.ServiceEndpoint.encode(m.grpcProxyEndpoint,w.uint32(82).fork()).ldelim();return w;};NodeUpdateTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.hapi.node.addressbook.NodeUpdateTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.nodeId=r.uint64();break;}case 2:{m.accountId=$root.proto.AccountID.decode(r,r.uint32());break;}case 3:{m.description=$root.google.protobuf.StringValue.decode(r,r.uint32());break;}case 4:{if(!(m.gossipEndpoint&&m.gossipEndpoint.length))m.gossipEndpoint=[];m.gossipEndpoint.push($root.proto.ServiceEndpoint.decode(r,r.uint32()));break;}case 5:{if(!(m.serviceEndpoint&&m.serviceEndpoint.length))m.serviceEndpoint=[];m.serviceEndpoint.push($root.proto.ServiceEndpoint.decode(r,r.uint32()));break;}case 6:{m.gossipCaCertificate=$root.google.protobuf.BytesValue.decode(r,r.uint32());break;}case 7:{m.grpcCertificateHash=$root.google.protobuf.BytesValue.decode(r,r.uint32());break;}case 8:{m.adminKey=$root.proto.Key.decode(r,r.uint32());break;}case 9:{m.declineReward=$root.google.protobuf.BoolValue.decode(r,r.uint32());break;}case 10:{m.grpcProxyEndpoint=$root.proto.ServiceEndpoint.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};NodeUpdateTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.hapi.node.addressbook.NodeUpdateTransactionBody";};return NodeUpdateTransactionBody;}();addressbook.NodeDeleteTransactionBody=function(){function NodeDeleteTransactionBody(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}NodeDeleteTransactionBody.prototype.nodeId=$util.Long?$util.Long.fromBits(0,0,true):0;NodeDeleteTransactionBody.create=function create(properties){return new NodeDeleteTransactionBody(properties);};NodeDeleteTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.nodeId!=null&&Object.hasOwnProperty.call(m,"nodeId"))w.uint32(8).uint64(m.nodeId);return w;};NodeDeleteTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.hapi.node.addressbook.NodeDeleteTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.nodeId=r.uint64();break;}default:r.skipType(t&7);break;}}return m;};NodeDeleteTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.hapi.node.addressbook.NodeDeleteTransactionBody";};return NodeDeleteTransactionBody;}();return addressbook;}();return node;}();hapi.platform=function(){const platform={};platform.event=function(){const event={};event.EventConsensusData=function(){function EventConsensusData(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}EventConsensusData.prototype.consensusTimestamp=null;EventConsensusData.prototype.consensusOrder=$util.Long?$util.Long.fromBits(0,0,true):0;EventConsensusData.create=function create(properties){return new EventConsensusData(properties);};EventConsensusData.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.consensusTimestamp!=null&&Object.hasOwnProperty.call(m,"consensusTimestamp"))$root.proto.Timestamp.encode(m.consensusTimestamp,w.uint32(10).fork()).ldelim();if(m.consensusOrder!=null&&Object.hasOwnProperty.call(m,"consensusOrder"))w.uint32(16).uint64(m.consensusOrder);return w;};EventConsensusData.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.hapi.platform.event.EventConsensusData();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.consensusTimestamp=$root.proto.Timestamp.decode(r,r.uint32());break;}case 2:{m.consensusOrder=r.uint64();break;}default:r.skipType(t&7);break;}}return m;};EventConsensusData.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.hapi.platform.event.EventConsensusData";};return EventConsensusData;}();event.EventDescriptor=function(){function EventDescriptor(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}EventDescriptor.prototype.hash=$util.newBuffer([]);EventDescriptor.prototype.creatorNodeId=$util.Long?$util.Long.fromBits(0,0,false):0;EventDescriptor.prototype.birthRound=$util.Long?$util.Long.fromBits(0,0,false):0;EventDescriptor.create=function create(properties){return new EventDescriptor(properties);};EventDescriptor.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.hash!=null&&Object.hasOwnProperty.call(m,"hash"))w.uint32(10).bytes(m.hash);if(m.creatorNodeId!=null&&Object.hasOwnProperty.call(m,"creatorNodeId"))w.uint32(16).int64(m.creatorNodeId);if(m.birthRound!=null&&Object.hasOwnProperty.call(m,"birthRound"))w.uint32(24).int64(m.birthRound);return w;};EventDescriptor.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.hapi.platform.event.EventDescriptor();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.hash=r.bytes();break;}case 2:{m.creatorNodeId=r.int64();break;}case 3:{m.birthRound=r.int64();break;}default:r.skipType(t&7);break;}}return m;};EventDescriptor.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.hapi.platform.event.EventDescriptor";};return EventDescriptor;}();event.EventCore=function(){function EventCore(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}EventCore.prototype.creatorNodeId=$util.Long?$util.Long.fromBits(0,0,false):0;EventCore.prototype.birthRound=$util.Long?$util.Long.fromBits(0,0,false):0;EventCore.prototype.timeCreated=null;EventCore.create=function create(properties){return new EventCore(properties);};EventCore.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.creatorNodeId!=null&&Object.hasOwnProperty.call(m,"creatorNodeId"))w.uint32(8).int64(m.creatorNodeId);if(m.birthRound!=null&&Object.hasOwnProperty.call(m,"birthRound"))w.uint32(16).int64(m.birthRound);if(m.timeCreated!=null&&Object.hasOwnProperty.call(m,"timeCreated"))$root.proto.Timestamp.encode(m.timeCreated,w.uint32(26).fork()).ldelim();return w;};EventCore.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.hapi.platform.event.EventCore();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.creatorNodeId=r.int64();break;}case 2:{m.birthRound=r.int64();break;}case 3:{m.timeCreated=$root.proto.Timestamp.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};EventCore.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.hapi.platform.event.EventCore";};return EventCore;}();event.EventTransaction=function(){function EventTransaction(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}EventTransaction.prototype.applicationTransaction=null;EventTransaction.prototype.stateSignatureTransaction=null;let $oneOfFields;Object.defineProperty(EventTransaction.prototype,"transaction",{get:$util.oneOfGetter($oneOfFields=["applicationTransaction","stateSignatureTransaction"]),set:$util.oneOfSetter($oneOfFields)});EventTransaction.create=function create(properties){return new EventTransaction(properties);};EventTransaction.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.applicationTransaction!=null&&Object.hasOwnProperty.call(m,"applicationTransaction"))w.uint32(10).bytes(m.applicationTransaction);if(m.stateSignatureTransaction!=null&&Object.hasOwnProperty.call(m,"stateSignatureTransaction"))$root.com.hedera.hapi.platform.event.StateSignatureTransaction.encode(m.stateSignatureTransaction,w.uint32(18).fork()).ldelim();return w;};EventTransaction.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.hapi.platform.event.EventTransaction();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.applicationTransaction=r.bytes();break;}case 2:{m.stateSignatureTransaction=$root.com.hedera.hapi.platform.event.StateSignatureTransaction.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};EventTransaction.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.hapi.platform.event.EventTransaction";};return EventTransaction;}();event.StateSignatureTransaction=function(){function StateSignatureTransaction(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}StateSignatureTransaction.prototype.round=$util.Long?$util.Long.fromBits(0,0,false):0;StateSignatureTransaction.prototype.signature=$util.newBuffer([]);StateSignatureTransaction.prototype.hash=$util.newBuffer([]);StateSignatureTransaction.create=function create(properties){return new StateSignatureTransaction(properties);};StateSignatureTransaction.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.round!=null&&Object.hasOwnProperty.call(m,"round"))w.uint32(8).int64(m.round);if(m.signature!=null&&Object.hasOwnProperty.call(m,"signature"))w.uint32(18).bytes(m.signature);if(m.hash!=null&&Object.hasOwnProperty.call(m,"hash"))w.uint32(26).bytes(m.hash);return w;};StateSignatureTransaction.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.hapi.platform.event.StateSignatureTransaction();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.round=r.int64();break;}case 2:{m.signature=r.bytes();break;}case 3:{m.hash=r.bytes();break;}default:r.skipType(t&7);break;}}return m;};StateSignatureTransaction.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.hapi.platform.event.StateSignatureTransaction";};return StateSignatureTransaction;}();event.GossipEvent=function(){function GossipEvent(p){this.transactions=[];this.parents=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}GossipEvent.prototype.eventCore=null;GossipEvent.prototype.signature=$util.newBuffer([]);GossipEvent.prototype.transactions=$util.emptyArray;GossipEvent.prototype.parents=$util.emptyArray;GossipEvent.create=function create(properties){return new GossipEvent(properties);};GossipEvent.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.eventCore!=null&&Object.hasOwnProperty.call(m,"eventCore"))$root.com.hedera.hapi.platform.event.EventCore.encode(m.eventCore,w.uint32(10).fork()).ldelim();if(m.signature!=null&&Object.hasOwnProperty.call(m,"signature"))w.uint32(18).bytes(m.signature);if(m.transactions!=null&&m.transactions.length){for(var i=0;i<m.transactions.length;++i)w.uint32(34).bytes(m.transactions[i]);}if(m.parents!=null&&m.parents.length){for(var i=0;i<m.parents.length;++i)$root.com.hedera.hapi.platform.event.EventDescriptor.encode(m.parents[i],w.uint32(42).fork()).ldelim();}return w;};GossipEvent.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.com.hedera.hapi.platform.event.GossipEvent();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.eventCore=$root.com.hedera.hapi.platform.event.EventCore.decode(r,r.uint32());break;}case 2:{m.signature=r.bytes();break;}case 4:{if(!(m.transactions&&m.transactions.length))m.transactions=[];m.transactions.push(r.bytes());break;}case 5:{if(!(m.parents&&m.parents.length))m.parents=[];m.parents.push($root.com.hedera.hapi.platform.event.EventDescriptor.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};GossipEvent.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/com.hedera.hapi.platform.event.GossipEvent";};return GossipEvent;}();return event;}();return platform;}();return hapi;}();return hedera;}();return com;})();proto$8.proto=$root.proto=(()=>{const proto={};proto.ShardID=function(){function ShardID(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ShardID.prototype.shardNum=$util.Long?$util.Long.fromBits(0,0,false):0;ShardID.create=function create(properties){return new ShardID(properties);};ShardID.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.shardNum!=null&&Object.hasOwnProperty.call(m,"shardNum"))w.uint32(8).int64(m.shardNum);return w;};ShardID.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ShardID();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.shardNum=r.int64();break;}default:r.skipType(t&7);break;}}return m;};ShardID.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ShardID";};return ShardID;}();proto.RealmID=function(){function RealmID(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}RealmID.prototype.shardNum=$util.Long?$util.Long.fromBits(0,0,false):0;RealmID.prototype.realmNum=$util.Long?$util.Long.fromBits(0,0,false):0;RealmID.create=function create(properties){return new RealmID(properties);};RealmID.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.shardNum!=null&&Object.hasOwnProperty.call(m,"shardNum"))w.uint32(8).int64(m.shardNum);if(m.realmNum!=null&&Object.hasOwnProperty.call(m,"realmNum"))w.uint32(16).int64(m.realmNum);return w;};RealmID.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.RealmID();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.shardNum=r.int64();break;}case 2:{m.realmNum=r.int64();break;}default:r.skipType(t&7);break;}}return m;};RealmID.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.RealmID";};return RealmID;}();proto.TokenID=function(){function TokenID(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TokenID.prototype.shardNum=$util.Long?$util.Long.fromBits(0,0,false):0;TokenID.prototype.realmNum=$util.Long?$util.Long.fromBits(0,0,false):0;TokenID.prototype.tokenNum=$util.Long?$util.Long.fromBits(0,0,false):0;TokenID.create=function create(properties){return new TokenID(properties);};TokenID.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.shardNum!=null&&Object.hasOwnProperty.call(m,"shardNum"))w.uint32(8).int64(m.shardNum);if(m.realmNum!=null&&Object.hasOwnProperty.call(m,"realmNum"))w.uint32(16).int64(m.realmNum);if(m.tokenNum!=null&&Object.hasOwnProperty.call(m,"tokenNum"))w.uint32(24).int64(m.tokenNum);return w;};TokenID.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TokenID();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.shardNum=r.int64();break;}case 2:{m.realmNum=r.int64();break;}case 3:{m.tokenNum=r.int64();break;}default:r.skipType(t&7);break;}}return m;};TokenID.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TokenID";};return TokenID;}();proto.BlockHashAlgorithm=function(){const valuesById={},values=Object.create(valuesById);values[valuesById[0]="SHA2_384"]=0;return values;}();proto.AccountID=function(){function AccountID(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}AccountID.prototype.shardNum=$util.Long?$util.Long.fromBits(0,0,false):0;AccountID.prototype.realmNum=$util.Long?$util.Long.fromBits(0,0,false):0;AccountID.prototype.accountNum=null;AccountID.prototype.alias=null;let $oneOfFields;Object.defineProperty(AccountID.prototype,"account",{get:$util.oneOfGetter($oneOfFields=["accountNum","alias"]),set:$util.oneOfSetter($oneOfFields)});AccountID.create=function create(properties){return new AccountID(properties);};AccountID.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.shardNum!=null&&Object.hasOwnProperty.call(m,"shardNum"))w.uint32(8).int64(m.shardNum);if(m.realmNum!=null&&Object.hasOwnProperty.call(m,"realmNum"))w.uint32(16).int64(m.realmNum);if(m.accountNum!=null&&Object.hasOwnProperty.call(m,"accountNum"))w.uint32(24).int64(m.accountNum);if(m.alias!=null&&Object.hasOwnProperty.call(m,"alias"))w.uint32(34).bytes(m.alias);return w;};AccountID.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.AccountID();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.shardNum=r.int64();break;}case 2:{m.realmNum=r.int64();break;}case 3:{m.accountNum=r.int64();break;}case 4:{m.alias=r.bytes();break;}default:r.skipType(t&7);break;}}return m;};AccountID.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.AccountID";};return AccountID;}();proto.NftID=function(){function NftID(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}NftID.prototype.token_ID=null;NftID.prototype.serialNumber=$util.Long?$util.Long.fromBits(0,0,false):0;NftID.create=function create(properties){return new NftID(properties);};NftID.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.token_ID!=null&&Object.hasOwnProperty.call(m,"token_ID"))$root.proto.TokenID.encode(m.token_ID,w.uint32(10).fork()).ldelim();if(m.serialNumber!=null&&Object.hasOwnProperty.call(m,"serialNumber"))w.uint32(16).int64(m.serialNumber);return w;};NftID.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.NftID();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.token_ID=$root.proto.TokenID.decode(r,r.uint32());break;}case 2:{m.serialNumber=r.int64();break;}default:r.skipType(t&7);break;}}return m;};NftID.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.NftID";};return NftID;}();proto.FileID=function(){function FileID(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}FileID.prototype.shardNum=$util.Long?$util.Long.fromBits(0,0,false):0;FileID.prototype.realmNum=$util.Long?$util.Long.fromBits(0,0,false):0;FileID.prototype.fileNum=$util.Long?$util.Long.fromBits(0,0,false):0;FileID.create=function create(properties){return new FileID(properties);};FileID.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.shardNum!=null&&Object.hasOwnProperty.call(m,"shardNum"))w.uint32(8).int64(m.shardNum);if(m.realmNum!=null&&Object.hasOwnProperty.call(m,"realmNum"))w.uint32(16).int64(m.realmNum);if(m.fileNum!=null&&Object.hasOwnProperty.call(m,"fileNum"))w.uint32(24).int64(m.fileNum);return w;};FileID.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.FileID();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.shardNum=r.int64();break;}case 2:{m.realmNum=r.int64();break;}case 3:{m.fileNum=r.int64();break;}default:r.skipType(t&7);break;}}return m;};FileID.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.FileID";};return FileID;}();proto.ContractID=function(){function ContractID(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ContractID.prototype.shardNum=$util.Long?$util.Long.fromBits(0,0,false):0;ContractID.prototype.realmNum=$util.Long?$util.Long.fromBits(0,0,false):0;ContractID.prototype.contractNum=null;ContractID.prototype.evmAddress=null;let $oneOfFields;Object.defineProperty(ContractID.prototype,"contract",{get:$util.oneOfGetter($oneOfFields=["contractNum","evmAddress"]),set:$util.oneOfSetter($oneOfFields)});ContractID.create=function create(properties){return new ContractID(properties);};ContractID.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.shardNum!=null&&Object.hasOwnProperty.call(m,"shardNum"))w.uint32(8).int64(m.shardNum);if(m.realmNum!=null&&Object.hasOwnProperty.call(m,"realmNum"))w.uint32(16).int64(m.realmNum);if(m.contractNum!=null&&Object.hasOwnProperty.call(m,"contractNum"))w.uint32(24).int64(m.contractNum);if(m.evmAddress!=null&&Object.hasOwnProperty.call(m,"evmAddress"))w.uint32(34).bytes(m.evmAddress);return w;};ContractID.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ContractID();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.shardNum=r.int64();break;}case 2:{m.realmNum=r.int64();break;}case 3:{m.contractNum=r.int64();break;}case 4:{m.evmAddress=r.bytes();break;}default:r.skipType(t&7);break;}}return m;};ContractID.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ContractID";};return ContractID;}();proto.TopicID=function(){function TopicID(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TopicID.prototype.shardNum=$util.Long?$util.Long.fromBits(0,0,false):0;TopicID.prototype.realmNum=$util.Long?$util.Long.fromBits(0,0,false):0;TopicID.prototype.topicNum=$util.Long?$util.Long.fromBits(0,0,false):0;TopicID.create=function create(properties){return new TopicID(properties);};TopicID.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.shardNum!=null&&Object.hasOwnProperty.call(m,"shardNum"))w.uint32(8).int64(m.shardNum);if(m.realmNum!=null&&Object.hasOwnProperty.call(m,"realmNum"))w.uint32(16).int64(m.realmNum);if(m.topicNum!=null&&Object.hasOwnProperty.call(m,"topicNum"))w.uint32(24).int64(m.topicNum);return w;};TopicID.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TopicID();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.shardNum=r.int64();break;}case 2:{m.realmNum=r.int64();break;}case 3:{m.topicNum=r.int64();break;}default:r.skipType(t&7);break;}}return m;};TopicID.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TopicID";};return TopicID;}();proto.ScheduleID=function(){function ScheduleID(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ScheduleID.prototype.shardNum=$util.Long?$util.Long.fromBits(0,0,false):0;ScheduleID.prototype.realmNum=$util.Long?$util.Long.fromBits(0,0,false):0;ScheduleID.prototype.scheduleNum=$util.Long?$util.Long.fromBits(0,0,false):0;ScheduleID.create=function create(properties){return new ScheduleID(properties);};ScheduleID.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.shardNum!=null&&Object.hasOwnProperty.call(m,"shardNum"))w.uint32(8).int64(m.shardNum);if(m.realmNum!=null&&Object.hasOwnProperty.call(m,"realmNum"))w.uint32(16).int64(m.realmNum);if(m.scheduleNum!=null&&Object.hasOwnProperty.call(m,"scheduleNum"))w.uint32(24).int64(m.scheduleNum);return w;};ScheduleID.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ScheduleID();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.shardNum=r.int64();break;}case 2:{m.realmNum=r.int64();break;}case 3:{m.scheduleNum=r.int64();break;}default:r.skipType(t&7);break;}}return m;};ScheduleID.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ScheduleID";};return ScheduleID;}();proto.TransactionID=function(){function TransactionID(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TransactionID.prototype.transactionValidStart=null;TransactionID.prototype.accountID=null;TransactionID.prototype.scheduled=false;TransactionID.prototype.nonce=0;TransactionID.create=function create(properties){return new TransactionID(properties);};TransactionID.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.transactionValidStart!=null&&Object.hasOwnProperty.call(m,"transactionValidStart"))$root.proto.Timestamp.encode(m.transactionValidStart,w.uint32(10).fork()).ldelim();if(m.accountID!=null&&Object.hasOwnProperty.call(m,"accountID"))$root.proto.AccountID.encode(m.accountID,w.uint32(18).fork()).ldelim();if(m.scheduled!=null&&Object.hasOwnProperty.call(m,"scheduled"))w.uint32(24).bool(m.scheduled);if(m.nonce!=null&&Object.hasOwnProperty.call(m,"nonce"))w.uint32(32).int32(m.nonce);return w;};TransactionID.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TransactionID();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.transactionValidStart=$root.proto.Timestamp.decode(r,r.uint32());break;}case 2:{m.accountID=$root.proto.AccountID.decode(r,r.uint32());break;}case 3:{m.scheduled=r.bool();break;}case 4:{m.nonce=r.int32();break;}default:r.skipType(t&7);break;}}return m;};TransactionID.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TransactionID";};return TransactionID;}();proto.AccountAmount=function(){function AccountAmount(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}AccountAmount.prototype.accountID=null;AccountAmount.prototype.amount=$util.Long?$util.Long.fromBits(0,0,false):0;AccountAmount.prototype.isApproval=false;AccountAmount.create=function create(properties){return new AccountAmount(properties);};AccountAmount.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.accountID!=null&&Object.hasOwnProperty.call(m,"accountID"))$root.proto.AccountID.encode(m.accountID,w.uint32(10).fork()).ldelim();if(m.amount!=null&&Object.hasOwnProperty.call(m,"amount"))w.uint32(16).sint64(m.amount);if(m.isApproval!=null&&Object.hasOwnProperty.call(m,"isApproval"))w.uint32(24).bool(m.isApproval);return w;};AccountAmount.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.AccountAmount();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.accountID=$root.proto.AccountID.decode(r,r.uint32());break;}case 2:{m.amount=r.sint64();break;}case 3:{m.isApproval=r.bool();break;}default:r.skipType(t&7);break;}}return m;};AccountAmount.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.AccountAmount";};return AccountAmount;}();proto.TransferList=function(){function TransferList(p){this.accountAmounts=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TransferList.prototype.accountAmounts=$util.emptyArray;TransferList.create=function create(properties){return new TransferList(properties);};TransferList.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.accountAmounts!=null&&m.accountAmounts.length){for(var i=0;i<m.accountAmounts.length;++i)$root.proto.AccountAmount.encode(m.accountAmounts[i],w.uint32(10).fork()).ldelim();}return w;};TransferList.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TransferList();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{if(!(m.accountAmounts&&m.accountAmounts.length))m.accountAmounts=[];m.accountAmounts.push($root.proto.AccountAmount.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};TransferList.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TransferList";};return TransferList;}();proto.NftTransfer=function(){function NftTransfer(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}NftTransfer.prototype.senderAccountID=null;NftTransfer.prototype.receiverAccountID=null;NftTransfer.prototype.serialNumber=$util.Long?$util.Long.fromBits(0,0,false):0;NftTransfer.prototype.isApproval=false;NftTransfer.create=function create(properties){return new NftTransfer(properties);};NftTransfer.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.senderAccountID!=null&&Object.hasOwnProperty.call(m,"senderAccountID"))$root.proto.AccountID.encode(m.senderAccountID,w.uint32(10).fork()).ldelim();if(m.receiverAccountID!=null&&Object.hasOwnProperty.call(m,"receiverAccountID"))$root.proto.AccountID.encode(m.receiverAccountID,w.uint32(18).fork()).ldelim();if(m.serialNumber!=null&&Object.hasOwnProperty.call(m,"serialNumber"))w.uint32(24).int64(m.serialNumber);if(m.isApproval!=null&&Object.hasOwnProperty.call(m,"isApproval"))w.uint32(32).bool(m.isApproval);return w;};NftTransfer.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.NftTransfer();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.senderAccountID=$root.proto.AccountID.decode(r,r.uint32());break;}case 2:{m.receiverAccountID=$root.proto.AccountID.decode(r,r.uint32());break;}case 3:{m.serialNumber=r.int64();break;}case 4:{m.isApproval=r.bool();break;}default:r.skipType(t&7);break;}}return m;};NftTransfer.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.NftTransfer";};return NftTransfer;}();proto.TokenTransferList=function(){function TokenTransferList(p){this.transfers=[];this.nftTransfers=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TokenTransferList.prototype.token=null;TokenTransferList.prototype.transfers=$util.emptyArray;TokenTransferList.prototype.nftTransfers=$util.emptyArray;TokenTransferList.prototype.expectedDecimals=null;TokenTransferList.create=function create(properties){return new TokenTransferList(properties);};TokenTransferList.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.token!=null&&Object.hasOwnProperty.call(m,"token"))$root.proto.TokenID.encode(m.token,w.uint32(10).fork()).ldelim();if(m.transfers!=null&&m.transfers.length){for(var i=0;i<m.transfers.length;++i)$root.proto.AccountAmount.encode(m.transfers[i],w.uint32(18).fork()).ldelim();}if(m.nftTransfers!=null&&m.nftTransfers.length){for(var i=0;i<m.nftTransfers.length;++i)$root.proto.NftTransfer.encode(m.nftTransfers[i],w.uint32(26).fork()).ldelim();}if(m.expectedDecimals!=null&&Object.hasOwnProperty.call(m,"expectedDecimals"))$root.google.protobuf.UInt32Value.encode(m.expectedDecimals,w.uint32(34).fork()).ldelim();return w;};TokenTransferList.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TokenTransferList();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.token=$root.proto.TokenID.decode(r,r.uint32());break;}case 2:{if(!(m.transfers&&m.transfers.length))m.transfers=[];m.transfers.push($root.proto.AccountAmount.decode(r,r.uint32()));break;}case 3:{if(!(m.nftTransfers&&m.nftTransfers.length))m.nftTransfers=[];m.nftTransfers.push($root.proto.NftTransfer.decode(r,r.uint32()));break;}case 4:{m.expectedDecimals=$root.google.protobuf.UInt32Value.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};TokenTransferList.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TokenTransferList";};return TokenTransferList;}();proto.Fraction=function(){function Fraction(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}Fraction.prototype.numerator=$util.Long?$util.Long.fromBits(0,0,false):0;Fraction.prototype.denominator=$util.Long?$util.Long.fromBits(0,0,false):0;Fraction.create=function create(properties){return new Fraction(properties);};Fraction.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.numerator!=null&&Object.hasOwnProperty.call(m,"numerator"))w.uint32(8).int64(m.numerator);if(m.denominator!=null&&Object.hasOwnProperty.call(m,"denominator"))w.uint32(16).int64(m.denominator);return w;};Fraction.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.Fraction();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.numerator=r.int64();break;}case 2:{m.denominator=r.int64();break;}default:r.skipType(t&7);break;}}return m;};Fraction.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.Fraction";};return Fraction;}();proto.TokenType=function(){const valuesById={},values=Object.create(valuesById);values[valuesById[0]="FUNGIBLE_COMMON"]=0;values[valuesById[1]="NON_FUNGIBLE_UNIQUE"]=1;return values;}();proto.SubType=function(){const valuesById={},values=Object.create(valuesById);values[valuesById[0]="DEFAULT"]=0;values[valuesById[1]="TOKEN_FUNGIBLE_COMMON"]=1;values[valuesById[2]="TOKEN_NON_FUNGIBLE_UNIQUE"]=2;values[valuesById[3]="TOKEN_FUNGIBLE_COMMON_WITH_CUSTOM_FEES"]=3;values[valuesById[4]="TOKEN_NON_FUNGIBLE_UNIQUE_WITH_CUSTOM_FEES"]=4;values[valuesById[5]="SCHEDULE_CREATE_CONTRACT_CALL"]=5;values[valuesById[6]="TOPIC_CREATE_WITH_CUSTOM_FEES"]=6;values[valuesById[7]="SUBMIT_MESSAGE_WITH_CUSTOM_FEES"]=7;return values;}();proto.TokenSupplyType=function(){const valuesById={},values=Object.create(valuesById);values[valuesById[0]="INFINITE"]=0;values[valuesById[1]="FINITE"]=1;return values;}();proto.TokenKeyValidation=function(){const valuesById={},values=Object.create(valuesById);values[valuesById[0]="FULL_VALIDATION"]=0;values[valuesById[1]="NO_VALIDATION"]=1;return values;}();proto.TokenFreezeStatus=function(){const valuesById={},values=Object.create(valuesById);values[valuesById[0]="FreezeNotApplicable"]=0;values[valuesById[1]="Frozen"]=1;values[valuesById[2]="Unfrozen"]=2;return values;}();proto.TokenKycStatus=function(){const valuesById={},values=Object.create(valuesById);values[valuesById[0]="KycNotApplicable"]=0;values[valuesById[1]="Granted"]=1;values[valuesById[2]="Revoked"]=2;return values;}();proto.TokenPauseStatus=function(){const valuesById={},values=Object.create(valuesById);values[valuesById[0]="PauseNotApplicable"]=0;values[valuesById[1]="Paused"]=1;values[valuesById[2]="Unpaused"]=2;return values;}();proto.Key=function(){function Key(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}Key.prototype.contractID=null;Key.prototype.ed25519=null;Key.prototype.RSA_3072=null;Key.prototype.ECDSA_384=null;Key.prototype.thresholdKey=null;Key.prototype.keyList=null;Key.prototype.ECDSASecp256k1=null;Key.prototype.delegatableContractId=null;let $oneOfFields;Object.defineProperty(Key.prototype,"key",{get:$util.oneOfGetter($oneOfFields=["contractID","ed25519","RSA_3072","ECDSA_384","thresholdKey","keyList","ECDSASecp256k1","delegatableContractId"]),set:$util.oneOfSetter($oneOfFields)});Key.create=function create(properties){return new Key(properties);};Key.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.contractID!=null&&Object.hasOwnProperty.call(m,"contractID"))$root.proto.ContractID.encode(m.contractID,w.uint32(10).fork()).ldelim();if(m.ed25519!=null&&Object.hasOwnProperty.call(m,"ed25519"))w.uint32(18).bytes(m.ed25519);if(m.RSA_3072!=null&&Object.hasOwnProperty.call(m,"RSA_3072"))w.uint32(26).bytes(m.RSA_3072);if(m.ECDSA_384!=null&&Object.hasOwnProperty.call(m,"ECDSA_384"))w.uint32(34).bytes(m.ECDSA_384);if(m.thresholdKey!=null&&Object.hasOwnProperty.call(m,"thresholdKey"))$root.proto.ThresholdKey.encode(m.thresholdKey,w.uint32(42).fork()).ldelim();if(m.keyList!=null&&Object.hasOwnProperty.call(m,"keyList"))$root.proto.KeyList.encode(m.keyList,w.uint32(50).fork()).ldelim();if(m.ECDSASecp256k1!=null&&Object.hasOwnProperty.call(m,"ECDSASecp256k1"))w.uint32(58).bytes(m.ECDSASecp256k1);if(m.delegatableContractId!=null&&Object.hasOwnProperty.call(m,"delegatableContractId"))$root.proto.ContractID.encode(m.delegatableContractId,w.uint32(66).fork()).ldelim();return w;};Key.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.Key();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.contractID=$root.proto.ContractID.decode(r,r.uint32());break;}case 2:{m.ed25519=r.bytes();break;}case 3:{m.RSA_3072=r.bytes();break;}case 4:{m.ECDSA_384=r.bytes();break;}case 5:{m.thresholdKey=$root.proto.ThresholdKey.decode(r,r.uint32());break;}case 6:{m.keyList=$root.proto.KeyList.decode(r,r.uint32());break;}case 7:{m.ECDSASecp256k1=r.bytes();break;}case 8:{m.delegatableContractId=$root.proto.ContractID.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};Key.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.Key";};return Key;}();proto.ThresholdKey=function(){function ThresholdKey(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ThresholdKey.prototype.threshold=0;ThresholdKey.prototype.keys=null;ThresholdKey.create=function create(properties){return new ThresholdKey(properties);};ThresholdKey.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.threshold!=null&&Object.hasOwnProperty.call(m,"threshold"))w.uint32(8).uint32(m.threshold);if(m.keys!=null&&Object.hasOwnProperty.call(m,"keys"))$root.proto.KeyList.encode(m.keys,w.uint32(18).fork()).ldelim();return w;};ThresholdKey.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ThresholdKey();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.threshold=r.uint32();break;}case 2:{m.keys=$root.proto.KeyList.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};ThresholdKey.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ThresholdKey";};return ThresholdKey;}();proto.KeyList=function(){function KeyList(p){this.keys=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}KeyList.prototype.keys=$util.emptyArray;KeyList.create=function create(properties){return new KeyList(properties);};KeyList.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.keys!=null&&m.keys.length){for(var i=0;i<m.keys.length;++i)$root.proto.Key.encode(m.keys[i],w.uint32(10).fork()).ldelim();}return w;};KeyList.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.KeyList();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{if(!(m.keys&&m.keys.length))m.keys=[];m.keys.push($root.proto.Key.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};KeyList.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.KeyList";};return KeyList;}();proto.Signature=function(){function Signature(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}Signature.prototype.contract=null;Signature.prototype.ed25519=null;Signature.prototype.RSA_3072=null;Signature.prototype.ECDSA_384=null;Signature.prototype.thresholdSignature=null;Signature.prototype.signatureList=null;let $oneOfFields;Object.defineProperty(Signature.prototype,"signature",{get:$util.oneOfGetter($oneOfFields=["contract","ed25519","RSA_3072","ECDSA_384","thresholdSignature","signatureList"]),set:$util.oneOfSetter($oneOfFields)});Signature.create=function create(properties){return new Signature(properties);};Signature.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.contract!=null&&Object.hasOwnProperty.call(m,"contract"))w.uint32(10).bytes(m.contract);if(m.ed25519!=null&&Object.hasOwnProperty.call(m,"ed25519"))w.uint32(18).bytes(m.ed25519);if(m.RSA_3072!=null&&Object.hasOwnProperty.call(m,"RSA_3072"))w.uint32(26).bytes(m.RSA_3072);if(m.ECDSA_384!=null&&Object.hasOwnProperty.call(m,"ECDSA_384"))w.uint32(34).bytes(m.ECDSA_384);if(m.thresholdSignature!=null&&Object.hasOwnProperty.call(m,"thresholdSignature"))$root.proto.ThresholdSignature.encode(m.thresholdSignature,w.uint32(42).fork()).ldelim();if(m.signatureList!=null&&Object.hasOwnProperty.call(m,"signatureList"))$root.proto.SignatureList.encode(m.signatureList,w.uint32(50).fork()).ldelim();return w;};Signature.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.Signature();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.contract=r.bytes();break;}case 2:{m.ed25519=r.bytes();break;}case 3:{m.RSA_3072=r.bytes();break;}case 4:{m.ECDSA_384=r.bytes();break;}case 5:{m.thresholdSignature=$root.proto.ThresholdSignature.decode(r,r.uint32());break;}case 6:{m.signatureList=$root.proto.SignatureList.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};Signature.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.Signature";};return Signature;}();proto.ThresholdSignature=function(){function ThresholdSignature(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ThresholdSignature.prototype.sigs=null;ThresholdSignature.create=function create(properties){return new ThresholdSignature(properties);};ThresholdSignature.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.sigs!=null&&Object.hasOwnProperty.call(m,"sigs"))$root.proto.SignatureList.encode(m.sigs,w.uint32(18).fork()).ldelim();return w;};ThresholdSignature.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ThresholdSignature();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 2:{m.sigs=$root.proto.SignatureList.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};ThresholdSignature.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ThresholdSignature";};return ThresholdSignature;}();proto.SignatureList=function(){function SignatureList(p){this.sigs=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}SignatureList.prototype.sigs=$util.emptyArray;SignatureList.create=function create(properties){return new SignatureList(properties);};SignatureList.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.sigs!=null&&m.sigs.length){for(var i=0;i<m.sigs.length;++i)$root.proto.Signature.encode(m.sigs[i],w.uint32(18).fork()).ldelim();}return w;};SignatureList.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.SignatureList();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 2:{if(!(m.sigs&&m.sigs.length))m.sigs=[];m.sigs.push($root.proto.Signature.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};SignatureList.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.SignatureList";};return SignatureList;}();proto.SignaturePair=function(){function SignaturePair(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}SignaturePair.prototype.pubKeyPrefix=$util.newBuffer([]);SignaturePair.prototype.contract=null;SignaturePair.prototype.ed25519=null;SignaturePair.prototype.RSA_3072=null;SignaturePair.prototype.ECDSA_384=null;SignaturePair.prototype.ECDSASecp256k1=null;let $oneOfFields;Object.defineProperty(SignaturePair.prototype,"signature",{get:$util.oneOfGetter($oneOfFields=["contract","ed25519","RSA_3072","ECDSA_384","ECDSASecp256k1"]),set:$util.oneOfSetter($oneOfFields)});SignaturePair.create=function create(properties){return new SignaturePair(properties);};SignaturePair.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.pubKeyPrefix!=null&&Object.hasOwnProperty.call(m,"pubKeyPrefix"))w.uint32(10).bytes(m.pubKeyPrefix);if(m.contract!=null&&Object.hasOwnProperty.call(m,"contract"))w.uint32(18).bytes(m.contract);if(m.ed25519!=null&&Object.hasOwnProperty.call(m,"ed25519"))w.uint32(26).bytes(m.ed25519);if(m.RSA_3072!=null&&Object.hasOwnProperty.call(m,"RSA_3072"))w.uint32(34).bytes(m.RSA_3072);if(m.ECDSA_384!=null&&Object.hasOwnProperty.call(m,"ECDSA_384"))w.uint32(42).bytes(m.ECDSA_384);if(m.ECDSASecp256k1!=null&&Object.hasOwnProperty.call(m,"ECDSASecp256k1"))w.uint32(50).bytes(m.ECDSASecp256k1);return w;};SignaturePair.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.SignaturePair();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.pubKeyPrefix=r.bytes();break;}case 2:{m.contract=r.bytes();break;}case 3:{m.ed25519=r.bytes();break;}case 4:{m.RSA_3072=r.bytes();break;}case 5:{m.ECDSA_384=r.bytes();break;}case 6:{m.ECDSASecp256k1=r.bytes();break;}default:r.skipType(t&7);break;}}return m;};SignaturePair.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.SignaturePair";};return SignaturePair;}();proto.SignatureMap=function(){function SignatureMap(p){this.sigPair=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}SignatureMap.prototype.sigPair=$util.emptyArray;SignatureMap.create=function create(properties){return new SignatureMap(properties);};SignatureMap.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.sigPair!=null&&m.sigPair.length){for(var i=0;i<m.sigPair.length;++i)$root.proto.SignaturePair.encode(m.sigPair[i],w.uint32(10).fork()).ldelim();}return w;};SignatureMap.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.SignatureMap();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{if(!(m.sigPair&&m.sigPair.length))m.sigPair=[];m.sigPair.push($root.proto.SignaturePair.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};SignatureMap.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.SignatureMap";};return SignatureMap;}();proto.HederaFunctionality=function(){const valuesById={},values=Object.create(valuesById);values[valuesById[0]="NONE"]=0;values[valuesById[1]="CryptoTransfer"]=1;values[valuesById[2]="CryptoUpdate"]=2;values[valuesById[3]="CryptoDelete"]=3;values[valuesById[4]="CryptoAddLiveHash"]=4;values[valuesById[5]="CryptoDeleteLiveHash"]=5;values[valuesById[6]="ContractCall"]=6;values[valuesById[7]="ContractCreate"]=7;values[valuesById[8]="ContractUpdate"]=8;values[valuesById[9]="FileCreate"]=9;values[valuesById[10]="FileAppend"]=10;values[valuesById[11]="FileUpdate"]=11;values[valuesById[12]="FileDelete"]=12;values[valuesById[13]="CryptoGetAccountBalance"]=13;values[valuesById[14]="CryptoGetAccountRecords"]=14;values[valuesById[15]="CryptoGetInfo"]=15;values[valuesById[16]="ContractCallLocal"]=16;values[valuesById[17]="ContractGetInfo"]=17;values[valuesById[18]="ContractGetBytecode"]=18;values[valuesById[19]="GetBySolidityID"]=19;values[valuesById[20]="GetByKey"]=20;values[valuesById[21]="CryptoGetLiveHash"]=21;values[valuesById[22]="CryptoGetStakers"]=22;values[valuesById[23]="FileGetContents"]=23;values[valuesById[24]="FileGetInfo"]=24;values[valuesById[25]="TransactionGetRecord"]=25;values[valuesById[26]="ContractGetRecords"]=26;values[valuesById[27]="CryptoCreate"]=27;values[valuesById[28]="SystemDelete"]=28;values[valuesById[29]="SystemUndelete"]=29;values[valuesById[30]="ContractDelete"]=30;values[valuesById[31]="Freeze"]=31;values[valuesById[32]="CreateTransactionRecord"]=32;values[valuesById[33]="CryptoAccountAutoRenew"]=33;values[valuesById[34]="ContractAutoRenew"]=34;values[valuesById[35]="GetVersionInfo"]=35;values[valuesById[36]="TransactionGetReceipt"]=36;values[valuesById[50]="ConsensusCreateTopic"]=50;values[valuesById[51]="ConsensusUpdateTopic"]=51;values[valuesById[52]="ConsensusDeleteTopic"]=52;values[valuesById[53]="ConsensusGetTopicInfo"]=53;values[valuesById[54]="ConsensusSubmitMessage"]=54;values[valuesById[55]="UncheckedSubmit"]=55;values[valuesById[56]="TokenCreate"]=56;values[valuesById[58]="TokenGetInfo"]=58;values[valuesById[59]="TokenFreezeAccount"]=59;values[valuesById[60]="TokenUnfreezeAccount"]=60;values[valuesById[61]="TokenGrantKycToAccount"]=61;values[valuesById[62]="TokenRevokeKycFromAccount"]=62;values[valuesById[63]="TokenDelete"]=63;values[valuesById[64]="TokenUpdate"]=64;values[valuesById[65]="TokenMint"]=65;values[valuesById[66]="TokenBurn"]=66;values[valuesById[67]="TokenAccountWipe"]=67;values[valuesById[68]="TokenAssociateToAccount"]=68;values[valuesById[69]="TokenDissociateFromAccount"]=69;values[valuesById[70]="ScheduleCreate"]=70;values[valuesById[71]="ScheduleDelete"]=71;values[valuesById[72]="ScheduleSign"]=72;values[valuesById[73]="ScheduleGetInfo"]=73;values[valuesById[74]="TokenGetAccountNftInfos"]=74;values[valuesById[75]="TokenGetNftInfo"]=75;values[valuesById[76]="TokenGetNftInfos"]=76;values[valuesById[77]="TokenFeeScheduleUpdate"]=77;values[valuesById[78]="NetworkGetExecutionTime"]=78;values[valuesById[79]="TokenPause"]=79;values[valuesById[80]="TokenUnpause"]=80;values[valuesById[81]="CryptoApproveAllowance"]=81;values[valuesById[82]="CryptoDeleteAllowance"]=82;values[valuesById[83]="GetAccountDetails"]=83;values[valuesById[84]="EthereumTransaction"]=84;values[valuesById[85]="NodeStakeUpdate"]=85;values[valuesById[86]="UtilPrng"]=86;values[valuesById[87]="TransactionGetFastRecord"]=87;values[valuesById[88]="TokenUpdateNfts"]=88;values[valuesById[89]="NodeCreate"]=89;values[valuesById[90]="NodeUpdate"]=90;values[valuesById[91]="NodeDelete"]=91;values[valuesById[92]="TokenReject"]=92;values[valuesById[93]="TokenAirdrop"]=93;values[valuesById[94]="TokenCancelAirdrop"]=94;values[valuesById[95]="TokenClaimAirdrop"]=95;values[valuesById[100]="StateSignatureTransaction"]=100;values[valuesById[101]="HintsKeyPublication"]=101;values[valuesById[102]="HintsPreprocessingVote"]=102;values[valuesById[103]="HintsPartialSignature"]=103;values[valuesById[104]="HistoryAssemblySignature"]=104;values[valuesById[105]="HistoryProofKeyPublication"]=105;values[valuesById[106]="HistoryProofVote"]=106;values[valuesById[107]="CrsPublication"]=107;values[valuesById[108]="AtomicBatch"]=108;return values;}();proto.FeeComponents=function(){function FeeComponents(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}FeeComponents.prototype.min=$util.Long?$util.Long.fromBits(0,0,false):0;FeeComponents.prototype.max=$util.Long?$util.Long.fromBits(0,0,false):0;FeeComponents.prototype.constant=$util.Long?$util.Long.fromBits(0,0,false):0;FeeComponents.prototype.bpt=$util.Long?$util.Long.fromBits(0,0,false):0;FeeComponents.prototype.vpt=$util.Long?$util.Long.fromBits(0,0,false):0;FeeComponents.prototype.rbh=$util.Long?$util.Long.fromBits(0,0,false):0;FeeComponents.prototype.sbh=$util.Long?$util.Long.fromBits(0,0,false):0;FeeComponents.prototype.gas=$util.Long?$util.Long.fromBits(0,0,false):0;FeeComponents.prototype.tv=$util.Long?$util.Long.fromBits(0,0,false):0;FeeComponents.prototype.bpr=$util.Long?$util.Long.fromBits(0,0,false):0;FeeComponents.prototype.sbpr=$util.Long?$util.Long.fromBits(0,0,false):0;FeeComponents.create=function create(properties){return new FeeComponents(properties);};FeeComponents.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.min!=null&&Object.hasOwnProperty.call(m,"min"))w.uint32(8).int64(m.min);if(m.max!=null&&Object.hasOwnProperty.call(m,"max"))w.uint32(16).int64(m.max);if(m.constant!=null&&Object.hasOwnProperty.call(m,"constant"))w.uint32(24).int64(m.constant);if(m.bpt!=null&&Object.hasOwnProperty.call(m,"bpt"))w.uint32(32).int64(m.bpt);if(m.vpt!=null&&Object.hasOwnProperty.call(m,"vpt"))w.uint32(40).int64(m.vpt);if(m.rbh!=null&&Object.hasOwnProperty.call(m,"rbh"))w.uint32(48).int64(m.rbh);if(m.sbh!=null&&Object.hasOwnProperty.call(m,"sbh"))w.uint32(56).int64(m.sbh);if(m.gas!=null&&Object.hasOwnProperty.call(m,"gas"))w.uint32(64).int64(m.gas);if(m.tv!=null&&Object.hasOwnProperty.call(m,"tv"))w.uint32(72).int64(m.tv);if(m.bpr!=null&&Object.hasOwnProperty.call(m,"bpr"))w.uint32(80).int64(m.bpr);if(m.sbpr!=null&&Object.hasOwnProperty.call(m,"sbpr"))w.uint32(88).int64(m.sbpr);return w;};FeeComponents.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.FeeComponents();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.min=r.int64();break;}case 2:{m.max=r.int64();break;}case 3:{m.constant=r.int64();break;}case 4:{m.bpt=r.int64();break;}case 5:{m.vpt=r.int64();break;}case 6:{m.rbh=r.int64();break;}case 7:{m.sbh=r.int64();break;}case 8:{m.gas=r.int64();break;}case 9:{m.tv=r.int64();break;}case 10:{m.bpr=r.int64();break;}case 11:{m.sbpr=r.int64();break;}default:r.skipType(t&7);break;}}return m;};FeeComponents.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.FeeComponents";};return FeeComponents;}();proto.TransactionFeeSchedule=function(){function TransactionFeeSchedule(p){this.fees=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TransactionFeeSchedule.prototype.hederaFunctionality=0;TransactionFeeSchedule.prototype.feeData=null;TransactionFeeSchedule.prototype.fees=$util.emptyArray;TransactionFeeSchedule.create=function create(properties){return new TransactionFeeSchedule(properties);};TransactionFeeSchedule.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.hederaFunctionality!=null&&Object.hasOwnProperty.call(m,"hederaFunctionality"))w.uint32(8).int32(m.hederaFunctionality);if(m.feeData!=null&&Object.hasOwnProperty.call(m,"feeData"))$root.proto.FeeData.encode(m.feeData,w.uint32(18).fork()).ldelim();if(m.fees!=null&&m.fees.length){for(var i=0;i<m.fees.length;++i)$root.proto.FeeData.encode(m.fees[i],w.uint32(26).fork()).ldelim();}return w;};TransactionFeeSchedule.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TransactionFeeSchedule();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.hederaFunctionality=r.int32();break;}case 2:{m.feeData=$root.proto.FeeData.decode(r,r.uint32());break;}case 3:{if(!(m.fees&&m.fees.length))m.fees=[];m.fees.push($root.proto.FeeData.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};TransactionFeeSchedule.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TransactionFeeSchedule";};return TransactionFeeSchedule;}();proto.FeeData=function(){function FeeData(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}FeeData.prototype.nodedata=null;FeeData.prototype.networkdata=null;FeeData.prototype.servicedata=null;FeeData.prototype.subType=0;FeeData.create=function create(properties){return new FeeData(properties);};FeeData.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.nodedata!=null&&Object.hasOwnProperty.call(m,"nodedata"))$root.proto.FeeComponents.encode(m.nodedata,w.uint32(10).fork()).ldelim();if(m.networkdata!=null&&Object.hasOwnProperty.call(m,"networkdata"))$root.proto.FeeComponents.encode(m.networkdata,w.uint32(18).fork()).ldelim();if(m.servicedata!=null&&Object.hasOwnProperty.call(m,"servicedata"))$root.proto.FeeComponents.encode(m.servicedata,w.uint32(26).fork()).ldelim();if(m.subType!=null&&Object.hasOwnProperty.call(m,"subType"))w.uint32(32).int32(m.subType);return w;};FeeData.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.FeeData();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.nodedata=$root.proto.FeeComponents.decode(r,r.uint32());break;}case 2:{m.networkdata=$root.proto.FeeComponents.decode(r,r.uint32());break;}case 3:{m.servicedata=$root.proto.FeeComponents.decode(r,r.uint32());break;}case 4:{m.subType=r.int32();break;}default:r.skipType(t&7);break;}}return m;};FeeData.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.FeeData";};return FeeData;}();proto.FeeSchedule=function(){function FeeSchedule(p){this.transactionFeeSchedule=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}FeeSchedule.prototype.transactionFeeSchedule=$util.emptyArray;FeeSchedule.prototype.expiryTime=null;FeeSchedule.create=function create(properties){return new FeeSchedule(properties);};FeeSchedule.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.transactionFeeSchedule!=null&&m.transactionFeeSchedule.length){for(var i=0;i<m.transactionFeeSchedule.length;++i)$root.proto.TransactionFeeSchedule.encode(m.transactionFeeSchedule[i],w.uint32(10).fork()).ldelim();}if(m.expiryTime!=null&&Object.hasOwnProperty.call(m,"expiryTime"))$root.proto.TimestampSeconds.encode(m.expiryTime,w.uint32(18).fork()).ldelim();return w;};FeeSchedule.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.FeeSchedule();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{if(!(m.transactionFeeSchedule&&m.transactionFeeSchedule.length))m.transactionFeeSchedule=[];m.transactionFeeSchedule.push($root.proto.TransactionFeeSchedule.decode(r,r.uint32()));break;}case 2:{m.expiryTime=$root.proto.TimestampSeconds.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};FeeSchedule.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.FeeSchedule";};return FeeSchedule;}();proto.CurrentAndNextFeeSchedule=function(){function CurrentAndNextFeeSchedule(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}CurrentAndNextFeeSchedule.prototype.currentFeeSchedule=null;CurrentAndNextFeeSchedule.prototype.nextFeeSchedule=null;CurrentAndNextFeeSchedule.create=function create(properties){return new CurrentAndNextFeeSchedule(properties);};CurrentAndNextFeeSchedule.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.currentFeeSchedule!=null&&Object.hasOwnProperty.call(m,"currentFeeSchedule"))$root.proto.FeeSchedule.encode(m.currentFeeSchedule,w.uint32(10).fork()).ldelim();if(m.nextFeeSchedule!=null&&Object.hasOwnProperty.call(m,"nextFeeSchedule"))$root.proto.FeeSchedule.encode(m.nextFeeSchedule,w.uint32(18).fork()).ldelim();return w;};CurrentAndNextFeeSchedule.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.CurrentAndNextFeeSchedule();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.currentFeeSchedule=$root.proto.FeeSchedule.decode(r,r.uint32());break;}case 2:{m.nextFeeSchedule=$root.proto.FeeSchedule.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};CurrentAndNextFeeSchedule.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.CurrentAndNextFeeSchedule";};return CurrentAndNextFeeSchedule;}();proto.ServiceEndpoint=function(){function ServiceEndpoint(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ServiceEndpoint.prototype.ipAddressV4=$util.newBuffer([]);ServiceEndpoint.prototype.port=0;ServiceEndpoint.prototype.domainName="";ServiceEndpoint.create=function create(properties){return new ServiceEndpoint(properties);};ServiceEndpoint.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.ipAddressV4!=null&&Object.hasOwnProperty.call(m,"ipAddressV4"))w.uint32(10).bytes(m.ipAddressV4);if(m.port!=null&&Object.hasOwnProperty.call(m,"port"))w.uint32(16).int32(m.port);if(m.domainName!=null&&Object.hasOwnProperty.call(m,"domainName"))w.uint32(26).string(m.domainName);return w;};ServiceEndpoint.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ServiceEndpoint();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.ipAddressV4=r.bytes();break;}case 2:{m.port=r.int32();break;}case 3:{m.domainName=r.string();break;}default:r.skipType(t&7);break;}}return m;};ServiceEndpoint.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ServiceEndpoint";};return ServiceEndpoint;}();proto.NodeAddress=function(){function NodeAddress(p){this.serviceEndpoint=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}NodeAddress.prototype.ipAddress=$util.newBuffer([]);NodeAddress.prototype.portno=0;NodeAddress.prototype.memo=$util.newBuffer([]);NodeAddress.prototype.RSA_PubKey="";NodeAddress.prototype.nodeId=$util.Long?$util.Long.fromBits(0,0,false):0;NodeAddress.prototype.nodeAccountId=null;NodeAddress.prototype.nodeCertHash=$util.newBuffer([]);NodeAddress.prototype.serviceEndpoint=$util.emptyArray;NodeAddress.prototype.description="";NodeAddress.prototype.stake=$util.Long?$util.Long.fromBits(0,0,false):0;NodeAddress.create=function create(properties){return new NodeAddress(properties);};NodeAddress.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.ipAddress!=null&&Object.hasOwnProperty.call(m,"ipAddress"))w.uint32(10).bytes(m.ipAddress);if(m.portno!=null&&Object.hasOwnProperty.call(m,"portno"))w.uint32(16).int32(m.portno);if(m.memo!=null&&Object.hasOwnProperty.call(m,"memo"))w.uint32(26).bytes(m.memo);if(m.RSA_PubKey!=null&&Object.hasOwnProperty.call(m,"RSA_PubKey"))w.uint32(34).string(m.RSA_PubKey);if(m.nodeId!=null&&Object.hasOwnProperty.call(m,"nodeId"))w.uint32(40).int64(m.nodeId);if(m.nodeAccountId!=null&&Object.hasOwnProperty.call(m,"nodeAccountId"))$root.proto.AccountID.encode(m.nodeAccountId,w.uint32(50).fork()).ldelim();if(m.nodeCertHash!=null&&Object.hasOwnProperty.call(m,"nodeCertHash"))w.uint32(58).bytes(m.nodeCertHash);if(m.serviceEndpoint!=null&&m.serviceEndpoint.length){for(var i=0;i<m.serviceEndpoint.length;++i)$root.proto.ServiceEndpoint.encode(m.serviceEndpoint[i],w.uint32(66).fork()).ldelim();}if(m.description!=null&&Object.hasOwnProperty.call(m,"description"))w.uint32(74).string(m.description);if(m.stake!=null&&Object.hasOwnProperty.call(m,"stake"))w.uint32(80).int64(m.stake);return w;};NodeAddress.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.NodeAddress();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.ipAddress=r.bytes();break;}case 2:{m.portno=r.int32();break;}case 3:{m.memo=r.bytes();break;}case 4:{m.RSA_PubKey=r.string();break;}case 5:{m.nodeId=r.int64();break;}case 6:{m.nodeAccountId=$root.proto.AccountID.decode(r,r.uint32());break;}case 7:{m.nodeCertHash=r.bytes();break;}case 8:{if(!(m.serviceEndpoint&&m.serviceEndpoint.length))m.serviceEndpoint=[];m.serviceEndpoint.push($root.proto.ServiceEndpoint.decode(r,r.uint32()));break;}case 9:{m.description=r.string();break;}case 10:{m.stake=r.int64();break;}default:r.skipType(t&7);break;}}return m;};NodeAddress.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.NodeAddress";};return NodeAddress;}();proto.NodeAddressBook=function(){function NodeAddressBook(p){this.nodeAddress=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}NodeAddressBook.prototype.nodeAddress=$util.emptyArray;NodeAddressBook.create=function create(properties){return new NodeAddressBook(properties);};NodeAddressBook.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.nodeAddress!=null&&m.nodeAddress.length){for(var i=0;i<m.nodeAddress.length;++i)$root.proto.NodeAddress.encode(m.nodeAddress[i],w.uint32(10).fork()).ldelim();}return w;};NodeAddressBook.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.NodeAddressBook();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{if(!(m.nodeAddress&&m.nodeAddress.length))m.nodeAddress=[];m.nodeAddress.push($root.proto.NodeAddress.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};NodeAddressBook.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.NodeAddressBook";};return NodeAddressBook;}();proto.SemanticVersion=function(){function SemanticVersion(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}SemanticVersion.prototype.major=0;SemanticVersion.prototype.minor=0;SemanticVersion.prototype.patch=0;SemanticVersion.prototype.pre="";SemanticVersion.prototype.build="";SemanticVersion.create=function create(properties){return new SemanticVersion(properties);};SemanticVersion.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.major!=null&&Object.hasOwnProperty.call(m,"major"))w.uint32(8).int32(m.major);if(m.minor!=null&&Object.hasOwnProperty.call(m,"minor"))w.uint32(16).int32(m.minor);if(m.patch!=null&&Object.hasOwnProperty.call(m,"patch"))w.uint32(24).int32(m.patch);if(m.pre!=null&&Object.hasOwnProperty.call(m,"pre"))w.uint32(34).string(m.pre);if(m.build!=null&&Object.hasOwnProperty.call(m,"build"))w.uint32(42).string(m.build);return w;};SemanticVersion.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.SemanticVersion();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.major=r.int32();break;}case 2:{m.minor=r.int32();break;}case 3:{m.patch=r.int32();break;}case 4:{m.pre=r.string();break;}case 5:{m.build=r.string();break;}default:r.skipType(t&7);break;}}return m;};SemanticVersion.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.SemanticVersion";};return SemanticVersion;}();proto.Setting=function(){function Setting(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}Setting.prototype.name="";Setting.prototype.value="";Setting.prototype.data=$util.newBuffer([]);Setting.create=function create(properties){return new Setting(properties);};Setting.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.name!=null&&Object.hasOwnProperty.call(m,"name"))w.uint32(10).string(m.name);if(m.value!=null&&Object.hasOwnProperty.call(m,"value"))w.uint32(18).string(m.value);if(m.data!=null&&Object.hasOwnProperty.call(m,"data"))w.uint32(26).bytes(m.data);return w;};Setting.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.Setting();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.name=r.string();break;}case 2:{m.value=r.string();break;}case 3:{m.data=r.bytes();break;}default:r.skipType(t&7);break;}}return m;};Setting.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.Setting";};return Setting;}();proto.ServicesConfigurationList=function(){function ServicesConfigurationList(p){this.nameValue=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ServicesConfigurationList.prototype.nameValue=$util.emptyArray;ServicesConfigurationList.create=function create(properties){return new ServicesConfigurationList(properties);};ServicesConfigurationList.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.nameValue!=null&&m.nameValue.length){for(var i=0;i<m.nameValue.length;++i)$root.proto.Setting.encode(m.nameValue[i],w.uint32(10).fork()).ldelim();}return w;};ServicesConfigurationList.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ServicesConfigurationList();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{if(!(m.nameValue&&m.nameValue.length))m.nameValue=[];m.nameValue.push($root.proto.Setting.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};ServicesConfigurationList.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ServicesConfigurationList";};return ServicesConfigurationList;}();proto.TokenRelationship=function(){function TokenRelationship(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TokenRelationship.prototype.tokenId=null;TokenRelationship.prototype.symbol="";TokenRelationship.prototype.balance=$util.Long?$util.Long.fromBits(0,0,true):0;TokenRelationship.prototype.kycStatus=0;TokenRelationship.prototype.freezeStatus=0;TokenRelationship.prototype.decimals=0;TokenRelationship.prototype.automaticAssociation=false;TokenRelationship.create=function create(properties){return new TokenRelationship(properties);};TokenRelationship.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.tokenId!=null&&Object.hasOwnProperty.call(m,"tokenId"))$root.proto.TokenID.encode(m.tokenId,w.uint32(10).fork()).ldelim();if(m.symbol!=null&&Object.hasOwnProperty.call(m,"symbol"))w.uint32(18).string(m.symbol);if(m.balance!=null&&Object.hasOwnProperty.call(m,"balance"))w.uint32(24).uint64(m.balance);if(m.kycStatus!=null&&Object.hasOwnProperty.call(m,"kycStatus"))w.uint32(32).int32(m.kycStatus);if(m.freezeStatus!=null&&Object.hasOwnProperty.call(m,"freezeStatus"))w.uint32(40).int32(m.freezeStatus);if(m.decimals!=null&&Object.hasOwnProperty.call(m,"decimals"))w.uint32(48).uint32(m.decimals);if(m.automaticAssociation!=null&&Object.hasOwnProperty.call(m,"automaticAssociation"))w.uint32(56).bool(m.automaticAssociation);return w;};TokenRelationship.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TokenRelationship();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.tokenId=$root.proto.TokenID.decode(r,r.uint32());break;}case 2:{m.symbol=r.string();break;}case 3:{m.balance=r.uint64();break;}case 4:{m.kycStatus=r.int32();break;}case 5:{m.freezeStatus=r.int32();break;}case 6:{m.decimals=r.uint32();break;}case 7:{m.automaticAssociation=r.bool();break;}default:r.skipType(t&7);break;}}return m;};TokenRelationship.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TokenRelationship";};return TokenRelationship;}();proto.TokenBalance=function(){function TokenBalance(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TokenBalance.prototype.tokenId=null;TokenBalance.prototype.balance=$util.Long?$util.Long.fromBits(0,0,true):0;TokenBalance.prototype.decimals=0;TokenBalance.create=function create(properties){return new TokenBalance(properties);};TokenBalance.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.tokenId!=null&&Object.hasOwnProperty.call(m,"tokenId"))$root.proto.TokenID.encode(m.tokenId,w.uint32(10).fork()).ldelim();if(m.balance!=null&&Object.hasOwnProperty.call(m,"balance"))w.uint32(16).uint64(m.balance);if(m.decimals!=null&&Object.hasOwnProperty.call(m,"decimals"))w.uint32(24).uint32(m.decimals);return w;};TokenBalance.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TokenBalance();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.tokenId=$root.proto.TokenID.decode(r,r.uint32());break;}case 2:{m.balance=r.uint64();break;}case 3:{m.decimals=r.uint32();break;}default:r.skipType(t&7);break;}}return m;};TokenBalance.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TokenBalance";};return TokenBalance;}();proto.TokenBalances=function(){function TokenBalances(p){this.tokenBalances=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TokenBalances.prototype.tokenBalances=$util.emptyArray;TokenBalances.create=function create(properties){return new TokenBalances(properties);};TokenBalances.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.tokenBalances!=null&&m.tokenBalances.length){for(var i=0;i<m.tokenBalances.length;++i)$root.proto.TokenBalance.encode(m.tokenBalances[i],w.uint32(10).fork()).ldelim();}return w;};TokenBalances.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TokenBalances();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{if(!(m.tokenBalances&&m.tokenBalances.length))m.tokenBalances=[];m.tokenBalances.push($root.proto.TokenBalance.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};TokenBalances.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TokenBalances";};return TokenBalances;}();proto.TokenAssociation=function(){function TokenAssociation(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TokenAssociation.prototype.tokenId=null;TokenAssociation.prototype.accountId=null;TokenAssociation.create=function create(properties){return new TokenAssociation(properties);};TokenAssociation.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.tokenId!=null&&Object.hasOwnProperty.call(m,"tokenId"))$root.proto.TokenID.encode(m.tokenId,w.uint32(10).fork()).ldelim();if(m.accountId!=null&&Object.hasOwnProperty.call(m,"accountId"))$root.proto.AccountID.encode(m.accountId,w.uint32(18).fork()).ldelim();return w;};TokenAssociation.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TokenAssociation();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.tokenId=$root.proto.TokenID.decode(r,r.uint32());break;}case 2:{m.accountId=$root.proto.AccountID.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};TokenAssociation.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TokenAssociation";};return TokenAssociation;}();proto.StakingInfo=function(){function StakingInfo(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}StakingInfo.prototype.declineReward=false;StakingInfo.prototype.stakePeriodStart=null;StakingInfo.prototype.pendingReward=$util.Long?$util.Long.fromBits(0,0,false):0;StakingInfo.prototype.stakedToMe=$util.Long?$util.Long.fromBits(0,0,false):0;StakingInfo.prototype.stakedAccountId=null;StakingInfo.prototype.stakedNodeId=null;let $oneOfFields;Object.defineProperty(StakingInfo.prototype,"stakedId",{get:$util.oneOfGetter($oneOfFields=["stakedAccountId","stakedNodeId"]),set:$util.oneOfSetter($oneOfFields)});StakingInfo.create=function create(properties){return new StakingInfo(properties);};StakingInfo.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.declineReward!=null&&Object.hasOwnProperty.call(m,"declineReward"))w.uint32(8).bool(m.declineReward);if(m.stakePeriodStart!=null&&Object.hasOwnProperty.call(m,"stakePeriodStart"))$root.proto.Timestamp.encode(m.stakePeriodStart,w.uint32(18).fork()).ldelim();if(m.pendingReward!=null&&Object.hasOwnProperty.call(m,"pendingReward"))w.uint32(24).int64(m.pendingReward);if(m.stakedToMe!=null&&Object.hasOwnProperty.call(m,"stakedToMe"))w.uint32(32).int64(m.stakedToMe);if(m.stakedAccountId!=null&&Object.hasOwnProperty.call(m,"stakedAccountId"))$root.proto.AccountID.encode(m.stakedAccountId,w.uint32(42).fork()).ldelim();if(m.stakedNodeId!=null&&Object.hasOwnProperty.call(m,"stakedNodeId"))w.uint32(48).int64(m.stakedNodeId);return w;};StakingInfo.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.StakingInfo();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.declineReward=r.bool();break;}case 2:{m.stakePeriodStart=$root.proto.Timestamp.decode(r,r.uint32());break;}case 3:{m.pendingReward=r.int64();break;}case 4:{m.stakedToMe=r.int64();break;}case 5:{m.stakedAccountId=$root.proto.AccountID.decode(r,r.uint32());break;}case 6:{m.stakedNodeId=r.int64();break;}default:r.skipType(t&7);break;}}return m;};StakingInfo.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.StakingInfo";};return StakingInfo;}();proto.PendingAirdropId=function(){function PendingAirdropId(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}PendingAirdropId.prototype.senderId=null;PendingAirdropId.prototype.receiverId=null;PendingAirdropId.prototype.fungibleTokenType=null;PendingAirdropId.prototype.nonFungibleToken=null;let $oneOfFields;Object.defineProperty(PendingAirdropId.prototype,"tokenReference",{get:$util.oneOfGetter($oneOfFields=["fungibleTokenType","nonFungibleToken"]),set:$util.oneOfSetter($oneOfFields)});PendingAirdropId.create=function create(properties){return new PendingAirdropId(properties);};PendingAirdropId.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.senderId!=null&&Object.hasOwnProperty.call(m,"senderId"))$root.proto.AccountID.encode(m.senderId,w.uint32(10).fork()).ldelim();if(m.receiverId!=null&&Object.hasOwnProperty.call(m,"receiverId"))$root.proto.AccountID.encode(m.receiverId,w.uint32(18).fork()).ldelim();if(m.fungibleTokenType!=null&&Object.hasOwnProperty.call(m,"fungibleTokenType"))$root.proto.TokenID.encode(m.fungibleTokenType,w.uint32(26).fork()).ldelim();if(m.nonFungibleToken!=null&&Object.hasOwnProperty.call(m,"nonFungibleToken"))$root.proto.NftID.encode(m.nonFungibleToken,w.uint32(34).fork()).ldelim();return w;};PendingAirdropId.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.PendingAirdropId();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.senderId=$root.proto.AccountID.decode(r,r.uint32());break;}case 2:{m.receiverId=$root.proto.AccountID.decode(r,r.uint32());break;}case 3:{m.fungibleTokenType=$root.proto.TokenID.decode(r,r.uint32());break;}case 4:{m.nonFungibleToken=$root.proto.NftID.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};PendingAirdropId.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.PendingAirdropId";};return PendingAirdropId;}();proto.PendingAirdropValue=function(){function PendingAirdropValue(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}PendingAirdropValue.prototype.amount=$util.Long?$util.Long.fromBits(0,0,true):0;PendingAirdropValue.create=function create(properties){return new PendingAirdropValue(properties);};PendingAirdropValue.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.amount!=null&&Object.hasOwnProperty.call(m,"amount"))w.uint32(8).uint64(m.amount);return w;};PendingAirdropValue.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.PendingAirdropValue();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.amount=r.uint64();break;}default:r.skipType(t&7);break;}}return m;};PendingAirdropValue.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.PendingAirdropValue";};return PendingAirdropValue;}();proto.Timestamp=function(){function Timestamp(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}Timestamp.prototype.seconds=$util.Long?$util.Long.fromBits(0,0,false):0;Timestamp.prototype.nanos=0;Timestamp.create=function create(properties){return new Timestamp(properties);};Timestamp.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.seconds!=null&&Object.hasOwnProperty.call(m,"seconds"))w.uint32(8).int64(m.seconds);if(m.nanos!=null&&Object.hasOwnProperty.call(m,"nanos"))w.uint32(16).int32(m.nanos);return w;};Timestamp.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.Timestamp();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.seconds=r.int64();break;}case 2:{m.nanos=r.int32();break;}default:r.skipType(t&7);break;}}return m;};Timestamp.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.Timestamp";};return Timestamp;}();proto.TimestampSeconds=function(){function TimestampSeconds(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TimestampSeconds.prototype.seconds=$util.Long?$util.Long.fromBits(0,0,false):0;TimestampSeconds.create=function create(properties){return new TimestampSeconds(properties);};TimestampSeconds.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.seconds!=null&&Object.hasOwnProperty.call(m,"seconds"))w.uint32(8).int64(m.seconds);return w;};TimestampSeconds.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TimestampSeconds();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.seconds=r.int64();break;}default:r.skipType(t&7);break;}}return m;};TimestampSeconds.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TimestampSeconds";};return TimestampSeconds;}();proto.ConsensusMessageChunkInfo=function(){function ConsensusMessageChunkInfo(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ConsensusMessageChunkInfo.prototype.initialTransactionID=null;ConsensusMessageChunkInfo.prototype.total=0;ConsensusMessageChunkInfo.prototype.number=0;ConsensusMessageChunkInfo.create=function create(properties){return new ConsensusMessageChunkInfo(properties);};ConsensusMessageChunkInfo.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.initialTransactionID!=null&&Object.hasOwnProperty.call(m,"initialTransactionID"))$root.proto.TransactionID.encode(m.initialTransactionID,w.uint32(10).fork()).ldelim();if(m.total!=null&&Object.hasOwnProperty.call(m,"total"))w.uint32(16).int32(m.total);if(m.number!=null&&Object.hasOwnProperty.call(m,"number"))w.uint32(24).int32(m.number);return w;};ConsensusMessageChunkInfo.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ConsensusMessageChunkInfo();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.initialTransactionID=$root.proto.TransactionID.decode(r,r.uint32());break;}case 2:{m.total=r.int32();break;}case 3:{m.number=r.int32();break;}default:r.skipType(t&7);break;}}return m;};ConsensusMessageChunkInfo.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ConsensusMessageChunkInfo";};return ConsensusMessageChunkInfo;}();proto.ConsensusSubmitMessageTransactionBody=function(){function ConsensusSubmitMessageTransactionBody(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ConsensusSubmitMessageTransactionBody.prototype.topicID=null;ConsensusSubmitMessageTransactionBody.prototype.message=$util.newBuffer([]);ConsensusSubmitMessageTransactionBody.prototype.chunkInfo=null;ConsensusSubmitMessageTransactionBody.create=function create(properties){return new ConsensusSubmitMessageTransactionBody(properties);};ConsensusSubmitMessageTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.topicID!=null&&Object.hasOwnProperty.call(m,"topicID"))$root.proto.TopicID.encode(m.topicID,w.uint32(10).fork()).ldelim();if(m.message!=null&&Object.hasOwnProperty.call(m,"message"))w.uint32(18).bytes(m.message);if(m.chunkInfo!=null&&Object.hasOwnProperty.call(m,"chunkInfo"))$root.proto.ConsensusMessageChunkInfo.encode(m.chunkInfo,w.uint32(26).fork()).ldelim();return w;};ConsensusSubmitMessageTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ConsensusSubmitMessageTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.topicID=$root.proto.TopicID.decode(r,r.uint32());break;}case 2:{m.message=r.bytes();break;}case 3:{m.chunkInfo=$root.proto.ConsensusMessageChunkInfo.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};ConsensusSubmitMessageTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ConsensusSubmitMessageTransactionBody";};return ConsensusSubmitMessageTransactionBody;}();proto.TransactionList=function(){function TransactionList(p){this.transactionList=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TransactionList.prototype.transactionList=$util.emptyArray;TransactionList.create=function create(properties){return new TransactionList(properties);};TransactionList.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.transactionList!=null&&m.transactionList.length){for(var i=0;i<m.transactionList.length;++i)$root.proto.Transaction.encode(m.transactionList[i],w.uint32(10).fork()).ldelim();}return w;};TransactionList.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TransactionList();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{if(!(m.transactionList&&m.transactionList.length))m.transactionList=[];m.transactionList.push($root.proto.Transaction.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};TransactionList.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TransactionList";};return TransactionList;}();proto.EthereumTransactionBody=function(){function EthereumTransactionBody(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}EthereumTransactionBody.prototype.ethereumData=$util.newBuffer([]);EthereumTransactionBody.prototype.callData=null;EthereumTransactionBody.prototype.maxGasAllowance=$util.Long?$util.Long.fromBits(0,0,false):0;EthereumTransactionBody.create=function create(properties){return new EthereumTransactionBody(properties);};EthereumTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.ethereumData!=null&&Object.hasOwnProperty.call(m,"ethereumData"))w.uint32(10).bytes(m.ethereumData);if(m.callData!=null&&Object.hasOwnProperty.call(m,"callData"))$root.proto.FileID.encode(m.callData,w.uint32(18).fork()).ldelim();if(m.maxGasAllowance!=null&&Object.hasOwnProperty.call(m,"maxGasAllowance"))w.uint32(24).int64(m.maxGasAllowance);return w;};EthereumTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.EthereumTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.ethereumData=r.bytes();break;}case 2:{m.callData=$root.proto.FileID.decode(r,r.uint32());break;}case 3:{m.maxGasAllowance=r.int64();break;}default:r.skipType(t&7);break;}}return m;};EthereumTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.EthereumTransactionBody";};return EthereumTransactionBody;}();proto.AddressBookService=function(){function AddressBookService(rpcImpl,requestDelimited,responseDelimited){$protobuf.rpc.Service.call(this,rpcImpl,requestDelimited,responseDelimited);}(AddressBookService.prototype=Object.create($protobuf.rpc.Service.prototype)).constructor=AddressBookService;AddressBookService.create=function create(rpcImpl,requestDelimited,responseDelimited){return new this(rpcImpl,requestDelimited,responseDelimited);};Object.defineProperty(AddressBookService.prototype.createNode=function createNode(request,callback){return this.rpcCall(createNode,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"createNode"});Object.defineProperty(AddressBookService.prototype.deleteNode=function deleteNode(request,callback){return this.rpcCall(deleteNode,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"deleteNode"});Object.defineProperty(AddressBookService.prototype.updateNode=function updateNode(request,callback){return this.rpcCall(updateNode,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"updateNode"});return AddressBookService;}();proto.TransactionResponse=function(){function TransactionResponse(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TransactionResponse.prototype.nodeTransactionPrecheckCode=0;TransactionResponse.prototype.cost=$util.Long?$util.Long.fromBits(0,0,true):0;TransactionResponse.create=function create(properties){return new TransactionResponse(properties);};TransactionResponse.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.nodeTransactionPrecheckCode!=null&&Object.hasOwnProperty.call(m,"nodeTransactionPrecheckCode"))w.uint32(8).int32(m.nodeTransactionPrecheckCode);if(m.cost!=null&&Object.hasOwnProperty.call(m,"cost"))w.uint32(16).uint64(m.cost);return w;};TransactionResponse.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TransactionResponse();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.nodeTransactionPrecheckCode=r.int32();break;}case 2:{m.cost=r.uint64();break;}default:r.skipType(t&7);break;}}return m;};TransactionResponse.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TransactionResponse";};return TransactionResponse;}();proto.ResponseCodeEnum=function(){const valuesById={},values=Object.create(valuesById);values[valuesById[0]="OK"]=0;values[valuesById[1]="INVALID_TRANSACTION"]=1;values[valuesById[2]="PAYER_ACCOUNT_NOT_FOUND"]=2;values[valuesById[3]="INVALID_NODE_ACCOUNT"]=3;values[valuesById[4]="TRANSACTION_EXPIRED"]=4;values[valuesById[5]="INVALID_TRANSACTION_START"]=5;values[valuesById[6]="INVALID_TRANSACTION_DURATION"]=6;values[valuesById[7]="INVALID_SIGNATURE"]=7;values[valuesById[8]="MEMO_TOO_LONG"]=8;values[valuesById[9]="INSUFFICIENT_TX_FEE"]=9;values[valuesById[10]="INSUFFICIENT_PAYER_BALANCE"]=10;values[valuesById[11]="DUPLICATE_TRANSACTION"]=11;values[valuesById[12]="BUSY"]=12;values[valuesById[13]="NOT_SUPPORTED"]=13;values[valuesById[14]="INVALID_FILE_ID"]=14;values[valuesById[15]="INVALID_ACCOUNT_ID"]=15;values[valuesById[16]="INVALID_CONTRACT_ID"]=16;values[valuesById[17]="INVALID_TRANSACTION_ID"]=17;values[valuesById[18]="RECEIPT_NOT_FOUND"]=18;values[valuesById[19]="RECORD_NOT_FOUND"]=19;values[valuesById[20]="INVALID_SOLIDITY_ID"]=20;values[valuesById[21]="UNKNOWN"]=21;values[valuesById[22]="SUCCESS"]=22;values[valuesById[23]="FAIL_INVALID"]=23;values[valuesById[24]="FAIL_FEE"]=24;values[valuesById[25]="FAIL_BALANCE"]=25;values[valuesById[26]="KEY_REQUIRED"]=26;values[valuesById[27]="BAD_ENCODING"]=27;values[valuesById[28]="INSUFFICIENT_ACCOUNT_BALANCE"]=28;values[valuesById[29]="INVALID_SOLIDITY_ADDRESS"]=29;values[valuesById[30]="INSUFFICIENT_GAS"]=30;values[valuesById[31]="CONTRACT_SIZE_LIMIT_EXCEEDED"]=31;values[valuesById[32]="LOCAL_CALL_MODIFICATION_EXCEPTION"]=32;values[valuesById[33]="CONTRACT_REVERT_EXECUTED"]=33;values[valuesById[34]="CONTRACT_EXECUTION_EXCEPTION"]=34;values[valuesById[35]="INVALID_RECEIVING_NODE_ACCOUNT"]=35;values[valuesById[36]="MISSING_QUERY_HEADER"]=36;values[valuesById[37]="ACCOUNT_UPDATE_FAILED"]=37;values[valuesById[38]="INVALID_KEY_ENCODING"]=38;values[valuesById[39]="NULL_SOLIDITY_ADDRESS"]=39;values[valuesById[40]="CONTRACT_UPDATE_FAILED"]=40;values[valuesById[41]="INVALID_QUERY_HEADER"]=41;values[valuesById[42]="INVALID_FEE_SUBMITTED"]=42;values[valuesById[43]="INVALID_PAYER_SIGNATURE"]=43;values[valuesById[44]="KEY_NOT_PROVIDED"]=44;values[valuesById[45]="INVALID_EXPIRATION_TIME"]=45;values[valuesById[46]="NO_WACL_KEY"]=46;values[valuesById[47]="FILE_CONTENT_EMPTY"]=47;values[valuesById[48]="INVALID_ACCOUNT_AMOUNTS"]=48;values[valuesById[49]="EMPTY_TRANSACTION_BODY"]=49;values[valuesById[50]="INVALID_TRANSACTION_BODY"]=50;values[valuesById[51]="INVALID_SIGNATURE_TYPE_MISMATCHING_KEY"]=51;values[valuesById[52]="INVALID_SIGNATURE_COUNT_MISMATCHING_KEY"]=52;values[valuesById[53]="EMPTY_LIVE_HASH_BODY"]=53;values[valuesById[54]="EMPTY_LIVE_HASH"]=54;values[valuesById[55]="EMPTY_LIVE_HASH_KEYS"]=55;values[valuesById[56]="INVALID_LIVE_HASH_SIZE"]=56;values[valuesById[57]="EMPTY_QUERY_BODY"]=57;values[valuesById[58]="EMPTY_LIVE_HASH_QUERY"]=58;values[valuesById[59]="LIVE_HASH_NOT_FOUND"]=59;values[valuesById[60]="ACCOUNT_ID_DOES_NOT_EXIST"]=60;values[valuesById[61]="LIVE_HASH_ALREADY_EXISTS"]=61;values[valuesById[62]="INVALID_FILE_WACL"]=62;values[valuesById[63]="SERIALIZATION_FAILED"]=63;values[valuesById[64]="TRANSACTION_OVERSIZE"]=64;values[valuesById[65]="TRANSACTION_TOO_MANY_LAYERS"]=65;values[valuesById[66]="CONTRACT_DELETED"]=66;values[valuesById[67]="PLATFORM_NOT_ACTIVE"]=67;values[valuesById[68]="KEY_PREFIX_MISMATCH"]=68;values[valuesById[69]="PLATFORM_TRANSACTION_NOT_CREATED"]=69;values[valuesById[70]="INVALID_RENEWAL_PERIOD"]=70;values[valuesById[71]="INVALID_PAYER_ACCOUNT_ID"]=71;values[valuesById[72]="ACCOUNT_DELETED"]=72;values[valuesById[73]="FILE_DELETED"]=73;values[valuesById[74]="ACCOUNT_REPEATED_IN_ACCOUNT_AMOUNTS"]=74;values[valuesById[75]="SETTING_NEGATIVE_ACCOUNT_BALANCE"]=75;values[valuesById[76]="OBTAINER_REQUIRED"]=76;values[valuesById[77]="OBTAINER_SAME_CONTRACT_ID"]=77;values[valuesById[78]="OBTAINER_DOES_NOT_EXIST"]=78;values[valuesById[79]="MODIFYING_IMMUTABLE_CONTRACT"]=79;values[valuesById[80]="FILE_SYSTEM_EXCEPTION"]=80;values[valuesById[81]="AUTORENEW_DURATION_NOT_IN_RANGE"]=81;values[valuesById[82]="ERROR_DECODING_BYTESTRING"]=82;values[valuesById[83]="CONTRACT_FILE_EMPTY"]=83;values[valuesById[84]="CONTRACT_BYTECODE_EMPTY"]=84;values[valuesById[85]="INVALID_INITIAL_BALANCE"]=85;values[valuesById[86]="INVALID_RECEIVE_RECORD_THRESHOLD"]=86;values[valuesById[87]="INVALID_SEND_RECORD_THRESHOLD"]=87;values[valuesById[88]="ACCOUNT_IS_NOT_GENESIS_ACCOUNT"]=88;values[valuesById[89]="PAYER_ACCOUNT_UNAUTHORIZED"]=89;values[valuesById[90]="INVALID_FREEZE_TRANSACTION_BODY"]=90;values[valuesById[91]="FREEZE_TRANSACTION_BODY_NOT_FOUND"]=91;values[valuesById[92]="TRANSFER_LIST_SIZE_LIMIT_EXCEEDED"]=92;values[valuesById[93]="RESULT_SIZE_LIMIT_EXCEEDED"]=93;values[valuesById[94]="NOT_SPECIAL_ACCOUNT"]=94;values[valuesById[95]="CONTRACT_NEGATIVE_GAS"]=95;values[valuesById[96]="CONTRACT_NEGATIVE_VALUE"]=96;values[valuesById[97]="INVALID_FEE_FILE"]=97;values[valuesById[98]="INVALID_EXCHANGE_RATE_FILE"]=98;values[valuesById[99]="INSUFFICIENT_LOCAL_CALL_GAS"]=99;values[valuesById[100]="ENTITY_NOT_ALLOWED_TO_DELETE"]=100;values[valuesById[101]="AUTHORIZATION_FAILED"]=101;values[valuesById[102]="FILE_UPLOADED_PROTO_INVALID"]=102;values[valuesById[103]="FILE_UPLOADED_PROTO_NOT_SAVED_TO_DISK"]=103;values[valuesById[104]="FEE_SCHEDULE_FILE_PART_UPLOADED"]=104;values[valuesById[105]="EXCHANGE_RATE_CHANGE_LIMIT_EXCEEDED"]=105;values[valuesById[106]="MAX_CONTRACT_STORAGE_EXCEEDED"]=106;values[valuesById[107]="TRANSFER_ACCOUNT_SAME_AS_DELETE_ACCOUNT"]=107;values[valuesById[108]="TOTAL_LEDGER_BALANCE_INVALID"]=108;values[valuesById[110]="EXPIRATION_REDUCTION_NOT_ALLOWED"]=110;values[valuesById[111]="MAX_GAS_LIMIT_EXCEEDED"]=111;values[valuesById[112]="MAX_FILE_SIZE_EXCEEDED"]=112;values[valuesById[113]="RECEIVER_SIG_REQUIRED"]=113;values[valuesById[150]="INVALID_TOPIC_ID"]=150;values[valuesById[155]="INVALID_ADMIN_KEY"]=155;values[valuesById[156]="INVALID_SUBMIT_KEY"]=156;values[valuesById[157]="UNAUTHORIZED"]=157;values[valuesById[158]="INVALID_TOPIC_MESSAGE"]=158;values[valuesById[159]="INVALID_AUTORENEW_ACCOUNT"]=159;values[valuesById[160]="AUTORENEW_ACCOUNT_NOT_ALLOWED"]=160;values[valuesById[162]="TOPIC_EXPIRED"]=162;values[valuesById[163]="INVALID_CHUNK_NUMBER"]=163;values[valuesById[164]="INVALID_CHUNK_TRANSACTION_ID"]=164;values[valuesById[165]="ACCOUNT_FROZEN_FOR_TOKEN"]=165;values[valuesById[166]="TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED"]=166;values[valuesById[167]="INVALID_TOKEN_ID"]=167;values[valuesById[168]="INVALID_TOKEN_DECIMALS"]=168;values[valuesById[169]="INVALID_TOKEN_INITIAL_SUPPLY"]=169;values[valuesById[170]="INVALID_TREASURY_ACCOUNT_FOR_TOKEN"]=170;values[valuesById[171]="INVALID_TOKEN_SYMBOL"]=171;values[valuesById[172]="TOKEN_HAS_NO_FREEZE_KEY"]=172;values[valuesById[173]="TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN"]=173;values[valuesById[174]="MISSING_TOKEN_SYMBOL"]=174;values[valuesById[175]="TOKEN_SYMBOL_TOO_LONG"]=175;values[valuesById[176]="ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN"]=176;values[valuesById[177]="TOKEN_HAS_NO_KYC_KEY"]=177;values[valuesById[178]="INSUFFICIENT_TOKEN_BALANCE"]=178;values[valuesById[179]="TOKEN_WAS_DELETED"]=179;values[valuesById[180]="TOKEN_HAS_NO_SUPPLY_KEY"]=180;values[valuesById[181]="TOKEN_HAS_NO_WIPE_KEY"]=181;values[valuesById[182]="INVALID_TOKEN_MINT_AMOUNT"]=182;values[valuesById[183]="INVALID_TOKEN_BURN_AMOUNT"]=183;values[valuesById[184]="TOKEN_NOT_ASSOCIATED_TO_ACCOUNT"]=184;values[valuesById[185]="CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT"]=185;values[valuesById[186]="INVALID_KYC_KEY"]=186;values[valuesById[187]="INVALID_WIPE_KEY"]=187;values[valuesById[188]="INVALID_FREEZE_KEY"]=188;values[valuesById[189]="INVALID_SUPPLY_KEY"]=189;values[valuesById[190]="MISSING_TOKEN_NAME"]=190;values[valuesById[191]="TOKEN_NAME_TOO_LONG"]=191;values[valuesById[192]="INVALID_WIPING_AMOUNT"]=192;values[valuesById[193]="TOKEN_IS_IMMUTABLE"]=193;values[valuesById[194]="TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT"]=194;values[valuesById[195]="TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES"]=195;values[valuesById[196]="ACCOUNT_IS_TREASURY"]=196;values[valuesById[197]="TOKEN_ID_REPEATED_IN_TOKEN_LIST"]=197;values[valuesById[198]="TOKEN_TRANSFER_LIST_SIZE_LIMIT_EXCEEDED"]=198;values[valuesById[199]="EMPTY_TOKEN_TRANSFER_BODY"]=199;values[valuesById[200]="EMPTY_TOKEN_TRANSFER_ACCOUNT_AMOUNTS"]=200;values[valuesById[201]="INVALID_SCHEDULE_ID"]=201;values[valuesById[202]="SCHEDULE_IS_IMMUTABLE"]=202;values[valuesById[203]="INVALID_SCHEDULE_PAYER_ID"]=203;values[valuesById[204]="INVALID_SCHEDULE_ACCOUNT_ID"]=204;values[valuesById[205]="NO_NEW_VALID_SIGNATURES"]=205;values[valuesById[206]="UNRESOLVABLE_REQUIRED_SIGNERS"]=206;values[valuesById[207]="SCHEDULED_TRANSACTION_NOT_IN_WHITELIST"]=207;values[valuesById[208]="SOME_SIGNATURES_WERE_INVALID"]=208;values[valuesById[209]="TRANSACTION_ID_FIELD_NOT_ALLOWED"]=209;values[valuesById[210]="IDENTICAL_SCHEDULE_ALREADY_CREATED"]=210;values[valuesById[211]="INVALID_ZERO_BYTE_IN_STRING"]=211;values[valuesById[212]="SCHEDULE_ALREADY_DELETED"]=212;values[valuesById[213]="SCHEDULE_ALREADY_EXECUTED"]=213;values[valuesById[214]="MESSAGE_SIZE_TOO_LARGE"]=214;values[valuesById[215]="OPERATION_REPEATED_IN_BUCKET_GROUPS"]=215;values[valuesById[216]="BUCKET_CAPACITY_OVERFLOW"]=216;values[valuesById[217]="NODE_CAPACITY_NOT_SUFFICIENT_FOR_OPERATION"]=217;values[valuesById[218]="BUCKET_HAS_NO_THROTTLE_GROUPS"]=218;values[valuesById[219]="THROTTLE_GROUP_HAS_ZERO_OPS_PER_SEC"]=219;values[valuesById[220]="SUCCESS_BUT_MISSING_EXPECTED_OPERATION"]=220;values[valuesById[221]="UNPARSEABLE_THROTTLE_DEFINITIONS"]=221;values[valuesById[222]="INVALID_THROTTLE_DEFINITIONS"]=222;values[valuesById[223]="ACCOUNT_EXPIRED_AND_PENDING_REMOVAL"]=223;values[valuesById[224]="INVALID_TOKEN_MAX_SUPPLY"]=224;values[valuesById[225]="INVALID_TOKEN_NFT_SERIAL_NUMBER"]=225;values[valuesById[226]="INVALID_NFT_ID"]=226;values[valuesById[227]="METADATA_TOO_LONG"]=227;values[valuesById[228]="BATCH_SIZE_LIMIT_EXCEEDED"]=228;values[valuesById[229]="INVALID_QUERY_RANGE"]=229;values[valuesById[230]="FRACTION_DIVIDES_BY_ZERO"]=230;values[valuesById[231]="INSUFFICIENT_PAYER_BALANCE_FOR_CUSTOM_FEE"]=231;values[valuesById[232]="CUSTOM_FEES_LIST_TOO_LONG"]=232;values[valuesById[233]="INVALID_CUSTOM_FEE_COLLECTOR"]=233;values[valuesById[234]="INVALID_TOKEN_ID_IN_CUSTOM_FEES"]=234;values[valuesById[235]="TOKEN_NOT_ASSOCIATED_TO_FEE_COLLECTOR"]=235;values[valuesById[236]="TOKEN_MAX_SUPPLY_REACHED"]=236;values[valuesById[237]="SENDER_DOES_NOT_OWN_NFT_SERIAL_NO"]=237;values[valuesById[238]="CUSTOM_FEE_NOT_FULLY_SPECIFIED"]=238;values[valuesById[239]="CUSTOM_FEE_MUST_BE_POSITIVE"]=239;values[valuesById[240]="TOKEN_HAS_NO_FEE_SCHEDULE_KEY"]=240;values[valuesById[241]="CUSTOM_FEE_OUTSIDE_NUMERIC_RANGE"]=241;values[valuesById[242]="ROYALTY_FRACTION_CANNOT_EXCEED_ONE"]=242;values[valuesById[243]="FRACTIONAL_FEE_MAX_AMOUNT_LESS_THAN_MIN_AMOUNT"]=243;values[valuesById[244]="CUSTOM_SCHEDULE_ALREADY_HAS_NO_FEES"]=244;values[valuesById[245]="CUSTOM_FEE_DENOMINATION_MUST_BE_FUNGIBLE_COMMON"]=245;values[valuesById[246]="CUSTOM_FRACTIONAL_FEE_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON"]=246;values[valuesById[247]="INVALID_CUSTOM_FEE_SCHEDULE_KEY"]=247;values[valuesById[248]="INVALID_TOKEN_MINT_METADATA"]=248;values[valuesById[249]="INVALID_TOKEN_BURN_METADATA"]=249;values[valuesById[250]="CURRENT_TREASURY_STILL_OWNS_NFTS"]=250;values[valuesById[251]="ACCOUNT_STILL_OWNS_NFTS"]=251;values[valuesById[252]="TREASURY_MUST_OWN_BURNED_NFT"]=252;values[valuesById[253]="ACCOUNT_DOES_NOT_OWN_WIPED_NFT"]=253;values[valuesById[254]="ACCOUNT_AMOUNT_TRANSFERS_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON"]=254;values[valuesById[255]="MAX_NFTS_IN_PRICE_REGIME_HAVE_BEEN_MINTED"]=255;values[valuesById[256]="PAYER_ACCOUNT_DELETED"]=256;values[valuesById[257]="CUSTOM_FEE_CHARGING_EXCEEDED_MAX_RECURSION_DEPTH"]=257;values[valuesById[258]="CUSTOM_FEE_CHARGING_EXCEEDED_MAX_ACCOUNT_AMOUNTS"]=258;values[valuesById[259]="INSUFFICIENT_SENDER_ACCOUNT_BALANCE_FOR_CUSTOM_FEE"]=259;values[valuesById[260]="SERIAL_NUMBER_LIMIT_REACHED"]=260;values[valuesById[261]="CUSTOM_ROYALTY_FEE_ONLY_ALLOWED_FOR_NON_FUNGIBLE_UNIQUE"]=261;values[valuesById[262]="NO_REMAINING_AUTOMATIC_ASSOCIATIONS"]=262;values[valuesById[263]="EXISTING_AUTOMATIC_ASSOCIATIONS_EXCEED_GIVEN_LIMIT"]=263;values[valuesById[264]="REQUESTED_NUM_AUTOMATIC_ASSOCIATIONS_EXCEEDS_ASSOCIATION_LIMIT"]=264;values[valuesById[265]="TOKEN_IS_PAUSED"]=265;values[valuesById[266]="TOKEN_HAS_NO_PAUSE_KEY"]=266;values[valuesById[267]="INVALID_PAUSE_KEY"]=267;values[valuesById[268]="FREEZE_UPDATE_FILE_DOES_NOT_EXIST"]=268;values[valuesById[269]="FREEZE_UPDATE_FILE_HASH_DOES_NOT_MATCH"]=269;values[valuesById[270]="NO_UPGRADE_HAS_BEEN_PREPARED"]=270;values[valuesById[271]="NO_FREEZE_IS_SCHEDULED"]=271;values[valuesById[272]="UPDATE_FILE_HASH_CHANGED_SINCE_PREPARE_UPGRADE"]=272;values[valuesById[273]="FREEZE_START_TIME_MUST_BE_FUTURE"]=273;values[valuesById[274]="PREPARED_UPDATE_FILE_IS_IMMUTABLE"]=274;values[valuesById[275]="FREEZE_ALREADY_SCHEDULED"]=275;values[valuesById[276]="FREEZE_UPGRADE_IN_PROGRESS"]=276;values[valuesById[277]="UPDATE_FILE_ID_DOES_NOT_MATCH_PREPARED"]=277;values[valuesById[278]="UPDATE_FILE_HASH_DOES_NOT_MATCH_PREPARED"]=278;values[valuesById[279]="CONSENSUS_GAS_EXHAUSTED"]=279;values[valuesById[280]="REVERTED_SUCCESS"]=280;values[valuesById[281]="MAX_STORAGE_IN_PRICE_REGIME_HAS_BEEN_USED"]=281;values[valuesById[282]="INVALID_ALIAS_KEY"]=282;values[valuesById[283]="UNEXPECTED_TOKEN_DECIMALS"]=283;values[valuesById[284]="INVALID_PROXY_ACCOUNT_ID"]=284;values[valuesById[285]="INVALID_TRANSFER_ACCOUNT_ID"]=285;values[valuesById[286]="INVALID_FEE_COLLECTOR_ACCOUNT_ID"]=286;values[valuesById[287]="ALIAS_IS_IMMUTABLE"]=287;values[valuesById[288]="SPENDER_ACCOUNT_SAME_AS_OWNER"]=288;values[valuesById[289]="AMOUNT_EXCEEDS_TOKEN_MAX_SUPPLY"]=289;values[valuesById[290]="NEGATIVE_ALLOWANCE_AMOUNT"]=290;values[valuesById[291]="CANNOT_APPROVE_FOR_ALL_FUNGIBLE_COMMON"]=291;values[valuesById[292]="SPENDER_DOES_NOT_HAVE_ALLOWANCE"]=292;values[valuesById[293]="AMOUNT_EXCEEDS_ALLOWANCE"]=293;values[valuesById[294]="MAX_ALLOWANCES_EXCEEDED"]=294;values[valuesById[295]="EMPTY_ALLOWANCES"]=295;values[valuesById[296]="SPENDER_ACCOUNT_REPEATED_IN_ALLOWANCES"]=296;values[valuesById[297]="REPEATED_SERIAL_NUMS_IN_NFT_ALLOWANCES"]=297;values[valuesById[298]="FUNGIBLE_TOKEN_IN_NFT_ALLOWANCES"]=298;values[valuesById[299]="NFT_IN_FUNGIBLE_TOKEN_ALLOWANCES"]=299;values[valuesById[300]="INVALID_ALLOWANCE_OWNER_ID"]=300;values[valuesById[301]="INVALID_ALLOWANCE_SPENDER_ID"]=301;values[valuesById[302]="REPEATED_ALLOWANCES_TO_DELETE"]=302;values[valuesById[303]="INVALID_DELEGATING_SPENDER"]=303;values[valuesById[304]="DELEGATING_SPENDER_CANNOT_GRANT_APPROVE_FOR_ALL"]=304;values[valuesById[305]="DELEGATING_SPENDER_DOES_NOT_HAVE_APPROVE_FOR_ALL"]=305;values[valuesById[306]="SCHEDULE_EXPIRATION_TIME_TOO_FAR_IN_FUTURE"]=306;values[valuesById[307]="SCHEDULE_EXPIRATION_TIME_MUST_BE_HIGHER_THAN_CONSENSUS_TIME"]=307;values[valuesById[308]="SCHEDULE_FUTURE_THROTTLE_EXCEEDED"]=308;values[valuesById[309]="SCHEDULE_FUTURE_GAS_LIMIT_EXCEEDED"]=309;values[valuesById[310]="INVALID_ETHEREUM_TRANSACTION"]=310;values[valuesById[311]="WRONG_CHAIN_ID"]=311;values[valuesById[312]="WRONG_NONCE"]=312;values[valuesById[313]="ACCESS_LIST_UNSUPPORTED"]=313;values[valuesById[314]="SCHEDULE_PENDING_EXPIRATION"]=314;values[valuesById[315]="CONTRACT_IS_TOKEN_TREASURY"]=315;values[valuesById[316]="CONTRACT_HAS_NON_ZERO_TOKEN_BALANCES"]=316;values[valuesById[317]="CONTRACT_EXPIRED_AND_PENDING_REMOVAL"]=317;values[valuesById[318]="CONTRACT_HAS_NO_AUTO_RENEW_ACCOUNT"]=318;values[valuesById[319]="PERMANENT_REMOVAL_REQUIRES_SYSTEM_INITIATION"]=319;values[valuesById[320]="PROXY_ACCOUNT_ID_FIELD_IS_DEPRECATED"]=320;values[valuesById[321]="SELF_STAKING_IS_NOT_ALLOWED"]=321;values[valuesById[322]="INVALID_STAKING_ID"]=322;values[valuesById[323]="STAKING_NOT_ENABLED"]=323;values[valuesById[324]="INVALID_PRNG_RANGE"]=324;values[valuesById[325]="MAX_ENTITIES_IN_PRICE_REGIME_HAVE_BEEN_CREATED"]=325;values[valuesById[326]="INVALID_FULL_PREFIX_SIGNATURE_FOR_PRECOMPILE"]=326;values[valuesById[327]="INSUFFICIENT_BALANCES_FOR_STORAGE_RENT"]=327;values[valuesById[328]="MAX_CHILD_RECORDS_EXCEEDED"]=328;values[valuesById[329]="INSUFFICIENT_BALANCES_FOR_RENEWAL_FEES"]=329;values[valuesById[330]="TRANSACTION_HAS_UNKNOWN_FIELDS"]=330;values[valuesById[331]="ACCOUNT_IS_IMMUTABLE"]=331;values[valuesById[332]="ALIAS_ALREADY_ASSIGNED"]=332;values[valuesById[333]="INVALID_METADATA_KEY"]=333;values[valuesById[334]="TOKEN_HAS_NO_METADATA_KEY"]=334;values[valuesById[335]="MISSING_TOKEN_METADATA"]=335;values[valuesById[336]="MISSING_SERIAL_NUMBERS"]=336;values[valuesById[337]="TOKEN_HAS_NO_ADMIN_KEY"]=337;values[valuesById[338]="NODE_DELETED"]=338;values[valuesById[339]="INVALID_NODE_ID"]=339;values[valuesById[340]="INVALID_GOSSIP_ENDPOINT"]=340;values[valuesById[341]="INVALID_NODE_ACCOUNT_ID"]=341;values[valuesById[342]="INVALID_NODE_DESCRIPTION"]=342;values[valuesById[343]="INVALID_SERVICE_ENDPOINT"]=343;values[valuesById[344]="INVALID_GOSSIP_CA_CERTIFICATE"]=344;values[valuesById[345]="INVALID_GRPC_CERTIFICATE"]=345;values[valuesById[346]="INVALID_MAX_AUTO_ASSOCIATIONS"]=346;values[valuesById[347]="MAX_NODES_CREATED"]=347;values[valuesById[348]="IP_FQDN_CANNOT_BE_SET_FOR_SAME_ENDPOINT"]=348;values[valuesById[349]="GOSSIP_ENDPOINT_CANNOT_HAVE_FQDN"]=349;values[valuesById[350]="FQDN_SIZE_TOO_LARGE"]=350;values[valuesById[351]="INVALID_ENDPOINT"]=351;values[valuesById[352]="GOSSIP_ENDPOINTS_EXCEEDED_LIMIT"]=352;values[valuesById[353]="TOKEN_REFERENCE_REPEATED"]=353;values[valuesById[354]="INVALID_OWNER_ID"]=354;values[valuesById[355]="TOKEN_REFERENCE_LIST_SIZE_LIMIT_EXCEEDED"]=355;values[valuesById[356]="SERVICE_ENDPOINTS_EXCEEDED_LIMIT"]=356;values[valuesById[357]="INVALID_IPV4_ADDRESS"]=357;values[valuesById[358]="EMPTY_TOKEN_REFERENCE_LIST"]=358;values[valuesById[359]="UPDATE_NODE_ACCOUNT_NOT_ALLOWED"]=359;values[valuesById[360]="TOKEN_HAS_NO_METADATA_OR_SUPPLY_KEY"]=360;values[valuesById[361]="EMPTY_PENDING_AIRDROP_ID_LIST"]=361;values[valuesById[362]="PENDING_AIRDROP_ID_REPEATED"]=362;values[valuesById[363]="PENDING_AIRDROP_ID_LIST_TOO_LONG"]=363;values[valuesById[364]="PENDING_NFT_AIRDROP_ALREADY_EXISTS"]=364;values[valuesById[365]="ACCOUNT_HAS_PENDING_AIRDROPS"]=365;values[valuesById[366]="THROTTLED_AT_CONSENSUS"]=366;values[valuesById[367]="INVALID_PENDING_AIRDROP_ID"]=367;values[valuesById[368]="TOKEN_AIRDROP_WITH_FALLBACK_ROYALTY"]=368;values[valuesById[369]="INVALID_TOKEN_IN_PENDING_AIRDROP"]=369;values[valuesById[370]="SCHEDULE_EXPIRY_IS_BUSY"]=370;values[valuesById[371]="INVALID_GRPC_CERTIFICATE_HASH"]=371;values[valuesById[372]="MISSING_EXPIRY_TIME"]=372;values[valuesById[373]="NO_SCHEDULING_ALLOWED_AFTER_SCHEDULED_RECURSION"]=373;values[valuesById[374]="RECURSIVE_SCHEDULING_LIMIT_REACHED"]=374;values[valuesById[375]="WAITING_FOR_LEDGER_ID"]=375;values[valuesById[376]="MAX_ENTRIES_FOR_FEE_EXEMPT_KEY_LIST_EXCEEDED"]=376;values[valuesById[377]="FEE_EXEMPT_KEY_LIST_CONTAINS_DUPLICATED_KEYS"]=377;values[valuesById[378]="INVALID_KEY_IN_FEE_EXEMPT_KEY_LIST"]=378;values[valuesById[379]="INVALID_FEE_SCHEDULE_KEY"]=379;values[valuesById[380]="FEE_SCHEDULE_KEY_CANNOT_BE_UPDATED"]=380;values[valuesById[381]="FEE_SCHEDULE_KEY_NOT_SET"]=381;values[valuesById[382]="MAX_CUSTOM_FEE_LIMIT_EXCEEDED"]=382;values[valuesById[383]="NO_VALID_MAX_CUSTOM_FEE"]=383;values[valuesById[384]="INVALID_MAX_CUSTOM_FEES"]=384;values[valuesById[385]="DUPLICATE_DENOMINATION_IN_MAX_CUSTOM_FEE_LIST"]=385;values[valuesById[386]="DUPLICATE_ACCOUNT_ID_IN_MAX_CUSTOM_FEE_LIST"]=386;values[valuesById[387]="MAX_CUSTOM_FEES_IS_NOT_SUPPORTED"]=387;values[valuesById[388]="BATCH_LIST_EMPTY"]=388;values[valuesById[389]="BATCH_LIST_CONTAINS_DUPLICATES"]=389;values[valuesById[390]="BATCH_TRANSACTION_IN_BLACKLIST"]=390;values[valuesById[391]="INNER_TRANSACTION_FAILED"]=391;values[valuesById[392]="MISSING_BATCH_KEY"]=392;values[valuesById[393]="BATCH_KEY_SET_ON_NON_INNER_TRANSACTION"]=393;values[valuesById[394]="INVALID_BATCH_KEY"]=394;values[valuesById[395]="SCHEDULE_EXPIRY_NOT_CONFIGURABLE"]=395;values[valuesById[396]="CREATING_SYSTEM_ENTITIES"]=396;values[valuesById[397]="THROTTLE_GROUP_LCM_OVERFLOW"]=397;values[valuesById[398]="AIRDROP_CONTAINS_MULTIPLE_SENDERS_FOR_A_TOKEN"]=398;values[valuesById[399]="GRPC_WEB_PROXY_NOT_SUPPORTED"]=399;values[valuesById[400]="NFT_TRANSFERS_ONLY_ALLOWED_FOR_NON_FUNGIBLE_UNIQUE"]=400;return values;}();proto.ConsensusCreateTopicTransactionBody=function(){function ConsensusCreateTopicTransactionBody(p){this.feeExemptKeyList=[];this.customFees=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ConsensusCreateTopicTransactionBody.prototype.memo="";ConsensusCreateTopicTransactionBody.prototype.adminKey=null;ConsensusCreateTopicTransactionBody.prototype.submitKey=null;ConsensusCreateTopicTransactionBody.prototype.autoRenewPeriod=null;ConsensusCreateTopicTransactionBody.prototype.autoRenewAccount=null;ConsensusCreateTopicTransactionBody.prototype.feeScheduleKey=null;ConsensusCreateTopicTransactionBody.prototype.feeExemptKeyList=$util.emptyArray;ConsensusCreateTopicTransactionBody.prototype.customFees=$util.emptyArray;ConsensusCreateTopicTransactionBody.create=function create(properties){return new ConsensusCreateTopicTransactionBody(properties);};ConsensusCreateTopicTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.memo!=null&&Object.hasOwnProperty.call(m,"memo"))w.uint32(10).string(m.memo);if(m.adminKey!=null&&Object.hasOwnProperty.call(m,"adminKey"))$root.proto.Key.encode(m.adminKey,w.uint32(18).fork()).ldelim();if(m.submitKey!=null&&Object.hasOwnProperty.call(m,"submitKey"))$root.proto.Key.encode(m.submitKey,w.uint32(26).fork()).ldelim();if(m.autoRenewPeriod!=null&&Object.hasOwnProperty.call(m,"autoRenewPeriod"))$root.proto.Duration.encode(m.autoRenewPeriod,w.uint32(50).fork()).ldelim();if(m.autoRenewAccount!=null&&Object.hasOwnProperty.call(m,"autoRenewAccount"))$root.proto.AccountID.encode(m.autoRenewAccount,w.uint32(58).fork()).ldelim();if(m.feeScheduleKey!=null&&Object.hasOwnProperty.call(m,"feeScheduleKey"))$root.proto.Key.encode(m.feeScheduleKey,w.uint32(66).fork()).ldelim();if(m.feeExemptKeyList!=null&&m.feeExemptKeyList.length){for(var i=0;i<m.feeExemptKeyList.length;++i)$root.proto.Key.encode(m.feeExemptKeyList[i],w.uint32(74).fork()).ldelim();}if(m.customFees!=null&&m.customFees.length){for(var i=0;i<m.customFees.length;++i)$root.proto.FixedCustomFee.encode(m.customFees[i],w.uint32(82).fork()).ldelim();}return w;};ConsensusCreateTopicTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ConsensusCreateTopicTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.memo=r.string();break;}case 2:{m.adminKey=$root.proto.Key.decode(r,r.uint32());break;}case 3:{m.submitKey=$root.proto.Key.decode(r,r.uint32());break;}case 6:{m.autoRenewPeriod=$root.proto.Duration.decode(r,r.uint32());break;}case 7:{m.autoRenewAccount=$root.proto.AccountID.decode(r,r.uint32());break;}case 8:{m.feeScheduleKey=$root.proto.Key.decode(r,r.uint32());break;}case 9:{if(!(m.feeExemptKeyList&&m.feeExemptKeyList.length))m.feeExemptKeyList=[];m.feeExemptKeyList.push($root.proto.Key.decode(r,r.uint32()));break;}case 10:{if(!(m.customFees&&m.customFees.length))m.customFees=[];m.customFees.push($root.proto.FixedCustomFee.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};ConsensusCreateTopicTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ConsensusCreateTopicTransactionBody";};return ConsensusCreateTopicTransactionBody;}();proto.FractionalFee=function(){function FractionalFee(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}FractionalFee.prototype.fractionalAmount=null;FractionalFee.prototype.minimumAmount=$util.Long?$util.Long.fromBits(0,0,false):0;FractionalFee.prototype.maximumAmount=$util.Long?$util.Long.fromBits(0,0,false):0;FractionalFee.prototype.netOfTransfers=false;FractionalFee.create=function create(properties){return new FractionalFee(properties);};FractionalFee.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.fractionalAmount!=null&&Object.hasOwnProperty.call(m,"fractionalAmount"))$root.proto.Fraction.encode(m.fractionalAmount,w.uint32(10).fork()).ldelim();if(m.minimumAmount!=null&&Object.hasOwnProperty.call(m,"minimumAmount"))w.uint32(16).int64(m.minimumAmount);if(m.maximumAmount!=null&&Object.hasOwnProperty.call(m,"maximumAmount"))w.uint32(24).int64(m.maximumAmount);if(m.netOfTransfers!=null&&Object.hasOwnProperty.call(m,"netOfTransfers"))w.uint32(32).bool(m.netOfTransfers);return w;};FractionalFee.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.FractionalFee();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.fractionalAmount=$root.proto.Fraction.decode(r,r.uint32());break;}case 2:{m.minimumAmount=r.int64();break;}case 3:{m.maximumAmount=r.int64();break;}case 4:{m.netOfTransfers=r.bool();break;}default:r.skipType(t&7);break;}}return m;};FractionalFee.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.FractionalFee";};return FractionalFee;}();proto.FixedFee=function(){function FixedFee(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}FixedFee.prototype.amount=$util.Long?$util.Long.fromBits(0,0,false):0;FixedFee.prototype.denominatingTokenId=null;FixedFee.create=function create(properties){return new FixedFee(properties);};FixedFee.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.amount!=null&&Object.hasOwnProperty.call(m,"amount"))w.uint32(8).int64(m.amount);if(m.denominatingTokenId!=null&&Object.hasOwnProperty.call(m,"denominatingTokenId"))$root.proto.TokenID.encode(m.denominatingTokenId,w.uint32(18).fork()).ldelim();return w;};FixedFee.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.FixedFee();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.amount=r.int64();break;}case 2:{m.denominatingTokenId=$root.proto.TokenID.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};FixedFee.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.FixedFee";};return FixedFee;}();proto.RoyaltyFee=function(){function RoyaltyFee(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}RoyaltyFee.prototype.exchangeValueFraction=null;RoyaltyFee.prototype.fallbackFee=null;RoyaltyFee.create=function create(properties){return new RoyaltyFee(properties);};RoyaltyFee.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.exchangeValueFraction!=null&&Object.hasOwnProperty.call(m,"exchangeValueFraction"))$root.proto.Fraction.encode(m.exchangeValueFraction,w.uint32(10).fork()).ldelim();if(m.fallbackFee!=null&&Object.hasOwnProperty.call(m,"fallbackFee"))$root.proto.FixedFee.encode(m.fallbackFee,w.uint32(18).fork()).ldelim();return w;};RoyaltyFee.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.RoyaltyFee();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.exchangeValueFraction=$root.proto.Fraction.decode(r,r.uint32());break;}case 2:{m.fallbackFee=$root.proto.FixedFee.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};RoyaltyFee.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.RoyaltyFee";};return RoyaltyFee;}();proto.CustomFee=function(){function CustomFee(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}CustomFee.prototype.fixedFee=null;CustomFee.prototype.fractionalFee=null;CustomFee.prototype.royaltyFee=null;CustomFee.prototype.feeCollectorAccountId=null;CustomFee.prototype.allCollectorsAreExempt=false;let $oneOfFields;Object.defineProperty(CustomFee.prototype,"fee",{get:$util.oneOfGetter($oneOfFields=["fixedFee","fractionalFee","royaltyFee"]),set:$util.oneOfSetter($oneOfFields)});CustomFee.create=function create(properties){return new CustomFee(properties);};CustomFee.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.fixedFee!=null&&Object.hasOwnProperty.call(m,"fixedFee"))$root.proto.FixedFee.encode(m.fixedFee,w.uint32(10).fork()).ldelim();if(m.fractionalFee!=null&&Object.hasOwnProperty.call(m,"fractionalFee"))$root.proto.FractionalFee.encode(m.fractionalFee,w.uint32(18).fork()).ldelim();if(m.feeCollectorAccountId!=null&&Object.hasOwnProperty.call(m,"feeCollectorAccountId"))$root.proto.AccountID.encode(m.feeCollectorAccountId,w.uint32(26).fork()).ldelim();if(m.royaltyFee!=null&&Object.hasOwnProperty.call(m,"royaltyFee"))$root.proto.RoyaltyFee.encode(m.royaltyFee,w.uint32(34).fork()).ldelim();if(m.allCollectorsAreExempt!=null&&Object.hasOwnProperty.call(m,"allCollectorsAreExempt"))w.uint32(40).bool(m.allCollectorsAreExempt);return w;};CustomFee.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.CustomFee();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.fixedFee=$root.proto.FixedFee.decode(r,r.uint32());break;}case 2:{m.fractionalFee=$root.proto.FractionalFee.decode(r,r.uint32());break;}case 4:{m.royaltyFee=$root.proto.RoyaltyFee.decode(r,r.uint32());break;}case 3:{m.feeCollectorAccountId=$root.proto.AccountID.decode(r,r.uint32());break;}case 5:{m.allCollectorsAreExempt=r.bool();break;}default:r.skipType(t&7);break;}}return m;};CustomFee.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.CustomFee";};return CustomFee;}();proto.AssessedCustomFee=function(){function AssessedCustomFee(p){this.effectivePayerAccountId=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}AssessedCustomFee.prototype.amount=$util.Long?$util.Long.fromBits(0,0,false):0;AssessedCustomFee.prototype.tokenId=null;AssessedCustomFee.prototype.feeCollectorAccountId=null;AssessedCustomFee.prototype.effectivePayerAccountId=$util.emptyArray;AssessedCustomFee.create=function create(properties){return new AssessedCustomFee(properties);};AssessedCustomFee.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.amount!=null&&Object.hasOwnProperty.call(m,"amount"))w.uint32(8).int64(m.amount);if(m.tokenId!=null&&Object.hasOwnProperty.call(m,"tokenId"))$root.proto.TokenID.encode(m.tokenId,w.uint32(18).fork()).ldelim();if(m.feeCollectorAccountId!=null&&Object.hasOwnProperty.call(m,"feeCollectorAccountId"))$root.proto.AccountID.encode(m.feeCollectorAccountId,w.uint32(26).fork()).ldelim();if(m.effectivePayerAccountId!=null&&m.effectivePayerAccountId.length){for(var i=0;i<m.effectivePayerAccountId.length;++i)$root.proto.AccountID.encode(m.effectivePayerAccountId[i],w.uint32(34).fork()).ldelim();}return w;};AssessedCustomFee.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.AssessedCustomFee();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.amount=r.int64();break;}case 2:{m.tokenId=$root.proto.TokenID.decode(r,r.uint32());break;}case 3:{m.feeCollectorAccountId=$root.proto.AccountID.decode(r,r.uint32());break;}case 4:{if(!(m.effectivePayerAccountId&&m.effectivePayerAccountId.length))m.effectivePayerAccountId=[];m.effectivePayerAccountId.push($root.proto.AccountID.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};AssessedCustomFee.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.AssessedCustomFee";};return AssessedCustomFee;}();proto.FixedCustomFee=function(){function FixedCustomFee(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}FixedCustomFee.prototype.fixedFee=null;FixedCustomFee.prototype.feeCollectorAccountId=null;FixedCustomFee.create=function create(properties){return new FixedCustomFee(properties);};FixedCustomFee.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.fixedFee!=null&&Object.hasOwnProperty.call(m,"fixedFee"))$root.proto.FixedFee.encode(m.fixedFee,w.uint32(10).fork()).ldelim();if(m.feeCollectorAccountId!=null&&Object.hasOwnProperty.call(m,"feeCollectorAccountId"))$root.proto.AccountID.encode(m.feeCollectorAccountId,w.uint32(18).fork()).ldelim();return w;};FixedCustomFee.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.FixedCustomFee();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.fixedFee=$root.proto.FixedFee.decode(r,r.uint32());break;}case 2:{m.feeCollectorAccountId=$root.proto.AccountID.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};FixedCustomFee.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.FixedCustomFee";};return FixedCustomFee;}();proto.FixedCustomFeeList=function(){function FixedCustomFeeList(p){this.fees=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}FixedCustomFeeList.prototype.fees=$util.emptyArray;FixedCustomFeeList.create=function create(properties){return new FixedCustomFeeList(properties);};FixedCustomFeeList.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.fees!=null&&m.fees.length){for(var i=0;i<m.fees.length;++i)$root.proto.FixedCustomFee.encode(m.fees[i],w.uint32(10).fork()).ldelim();}return w;};FixedCustomFeeList.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.FixedCustomFeeList();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{if(!(m.fees&&m.fees.length))m.fees=[];m.fees.push($root.proto.FixedCustomFee.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};FixedCustomFeeList.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.FixedCustomFeeList";};return FixedCustomFeeList;}();proto.FeeExemptKeyList=function(){function FeeExemptKeyList(p){this.keys=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}FeeExemptKeyList.prototype.keys=$util.emptyArray;FeeExemptKeyList.create=function create(properties){return new FeeExemptKeyList(properties);};FeeExemptKeyList.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.keys!=null&&m.keys.length){for(var i=0;i<m.keys.length;++i)$root.proto.Key.encode(m.keys[i],w.uint32(10).fork()).ldelim();}return w;};FeeExemptKeyList.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.FeeExemptKeyList();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{if(!(m.keys&&m.keys.length))m.keys=[];m.keys.push($root.proto.Key.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};FeeExemptKeyList.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.FeeExemptKeyList";};return FeeExemptKeyList;}();proto.CustomFeeLimit=function(){function CustomFeeLimit(p){this.fees=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}CustomFeeLimit.prototype.accountId=null;CustomFeeLimit.prototype.fees=$util.emptyArray;CustomFeeLimit.create=function create(properties){return new CustomFeeLimit(properties);};CustomFeeLimit.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.accountId!=null&&Object.hasOwnProperty.call(m,"accountId"))$root.proto.AccountID.encode(m.accountId,w.uint32(10).fork()).ldelim();if(m.fees!=null&&m.fees.length){for(var i=0;i<m.fees.length;++i)$root.proto.FixedFee.encode(m.fees[i],w.uint32(18).fork()).ldelim();}return w;};CustomFeeLimit.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.CustomFeeLimit();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.accountId=$root.proto.AccountID.decode(r,r.uint32());break;}case 2:{if(!(m.fees&&m.fees.length))m.fees=[];m.fees.push($root.proto.FixedFee.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};CustomFeeLimit.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.CustomFeeLimit";};return CustomFeeLimit;}();proto.Duration=function(){function Duration(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}Duration.prototype.seconds=$util.Long?$util.Long.fromBits(0,0,false):0;Duration.create=function create(properties){return new Duration(properties);};Duration.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.seconds!=null&&Object.hasOwnProperty.call(m,"seconds"))w.uint32(8).int64(m.seconds);return w;};Duration.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.Duration();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.seconds=r.int64();break;}default:r.skipType(t&7);break;}}return m;};Duration.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.Duration";};return Duration;}();proto.ConsensusDeleteTopicTransactionBody=function(){function ConsensusDeleteTopicTransactionBody(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ConsensusDeleteTopicTransactionBody.prototype.topicID=null;ConsensusDeleteTopicTransactionBody.create=function create(properties){return new ConsensusDeleteTopicTransactionBody(properties);};ConsensusDeleteTopicTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.topicID!=null&&Object.hasOwnProperty.call(m,"topicID"))$root.proto.TopicID.encode(m.topicID,w.uint32(10).fork()).ldelim();return w;};ConsensusDeleteTopicTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ConsensusDeleteTopicTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.topicID=$root.proto.TopicID.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};ConsensusDeleteTopicTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ConsensusDeleteTopicTransactionBody";};return ConsensusDeleteTopicTransactionBody;}();proto.ConsensusGetTopicInfoQuery=function(){function ConsensusGetTopicInfoQuery(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ConsensusGetTopicInfoQuery.prototype.header=null;ConsensusGetTopicInfoQuery.prototype.topicID=null;ConsensusGetTopicInfoQuery.create=function create(properties){return new ConsensusGetTopicInfoQuery(properties);};ConsensusGetTopicInfoQuery.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.header!=null&&Object.hasOwnProperty.call(m,"header"))$root.proto.QueryHeader.encode(m.header,w.uint32(10).fork()).ldelim();if(m.topicID!=null&&Object.hasOwnProperty.call(m,"topicID"))$root.proto.TopicID.encode(m.topicID,w.uint32(18).fork()).ldelim();return w;};ConsensusGetTopicInfoQuery.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ConsensusGetTopicInfoQuery();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.header=$root.proto.QueryHeader.decode(r,r.uint32());break;}case 2:{m.topicID=$root.proto.TopicID.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};ConsensusGetTopicInfoQuery.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ConsensusGetTopicInfoQuery";};return ConsensusGetTopicInfoQuery;}();proto.ConsensusGetTopicInfoResponse=function(){function ConsensusGetTopicInfoResponse(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ConsensusGetTopicInfoResponse.prototype.header=null;ConsensusGetTopicInfoResponse.prototype.topicID=null;ConsensusGetTopicInfoResponse.prototype.topicInfo=null;ConsensusGetTopicInfoResponse.create=function create(properties){return new ConsensusGetTopicInfoResponse(properties);};ConsensusGetTopicInfoResponse.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.header!=null&&Object.hasOwnProperty.call(m,"header"))$root.proto.ResponseHeader.encode(m.header,w.uint32(10).fork()).ldelim();if(m.topicID!=null&&Object.hasOwnProperty.call(m,"topicID"))$root.proto.TopicID.encode(m.topicID,w.uint32(18).fork()).ldelim();if(m.topicInfo!=null&&Object.hasOwnProperty.call(m,"topicInfo"))$root.proto.ConsensusTopicInfo.encode(m.topicInfo,w.uint32(42).fork()).ldelim();return w;};ConsensusGetTopicInfoResponse.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ConsensusGetTopicInfoResponse();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.header=$root.proto.ResponseHeader.decode(r,r.uint32());break;}case 2:{m.topicID=$root.proto.TopicID.decode(r,r.uint32());break;}case 5:{m.topicInfo=$root.proto.ConsensusTopicInfo.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};ConsensusGetTopicInfoResponse.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ConsensusGetTopicInfoResponse";};return ConsensusGetTopicInfoResponse;}();proto.ResponseType=function(){const valuesById={},values=Object.create(valuesById);values[valuesById[0]="ANSWER_ONLY"]=0;values[valuesById[1]="ANSWER_STATE_PROOF"]=1;values[valuesById[2]="COST_ANSWER"]=2;values[valuesById[3]="COST_ANSWER_STATE_PROOF"]=3;return values;}();proto.QueryHeader=function(){function QueryHeader(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}QueryHeader.prototype.payment=null;QueryHeader.prototype.responseType=0;QueryHeader.create=function create(properties){return new QueryHeader(properties);};QueryHeader.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.payment!=null&&Object.hasOwnProperty.call(m,"payment"))$root.proto.Transaction.encode(m.payment,w.uint32(10).fork()).ldelim();if(m.responseType!=null&&Object.hasOwnProperty.call(m,"responseType"))w.uint32(16).int32(m.responseType);return w;};QueryHeader.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.QueryHeader();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.payment=$root.proto.Transaction.decode(r,r.uint32());break;}case 2:{m.responseType=r.int32();break;}default:r.skipType(t&7);break;}}return m;};QueryHeader.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.QueryHeader";};return QueryHeader;}();proto.ResponseHeader=function(){function ResponseHeader(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ResponseHeader.prototype.nodeTransactionPrecheckCode=0;ResponseHeader.prototype.responseType=0;ResponseHeader.prototype.cost=$util.Long?$util.Long.fromBits(0,0,true):0;ResponseHeader.prototype.stateProof=$util.newBuffer([]);ResponseHeader.create=function create(properties){return new ResponseHeader(properties);};ResponseHeader.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.nodeTransactionPrecheckCode!=null&&Object.hasOwnProperty.call(m,"nodeTransactionPrecheckCode"))w.uint32(8).int32(m.nodeTransactionPrecheckCode);if(m.responseType!=null&&Object.hasOwnProperty.call(m,"responseType"))w.uint32(16).int32(m.responseType);if(m.cost!=null&&Object.hasOwnProperty.call(m,"cost"))w.uint32(24).uint64(m.cost);if(m.stateProof!=null&&Object.hasOwnProperty.call(m,"stateProof"))w.uint32(34).bytes(m.stateProof);return w;};ResponseHeader.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ResponseHeader();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.nodeTransactionPrecheckCode=r.int32();break;}case 2:{m.responseType=r.int32();break;}case 3:{m.cost=r.uint64();break;}case 4:{m.stateProof=r.bytes();break;}default:r.skipType(t&7);break;}}return m;};ResponseHeader.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ResponseHeader";};return ResponseHeader;}();proto.ConsensusTopicInfo=function(){function ConsensusTopicInfo(p){this.feeExemptKeyList=[];this.customFees=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ConsensusTopicInfo.prototype.memo="";ConsensusTopicInfo.prototype.runningHash=$util.newBuffer([]);ConsensusTopicInfo.prototype.sequenceNumber=$util.Long?$util.Long.fromBits(0,0,true):0;ConsensusTopicInfo.prototype.expirationTime=null;ConsensusTopicInfo.prototype.adminKey=null;ConsensusTopicInfo.prototype.submitKey=null;ConsensusTopicInfo.prototype.autoRenewPeriod=null;ConsensusTopicInfo.prototype.autoRenewAccount=null;ConsensusTopicInfo.prototype.ledgerId=$util.newBuffer([]);ConsensusTopicInfo.prototype.feeScheduleKey=null;ConsensusTopicInfo.prototype.feeExemptKeyList=$util.emptyArray;ConsensusTopicInfo.prototype.customFees=$util.emptyArray;ConsensusTopicInfo.create=function create(properties){return new ConsensusTopicInfo(properties);};ConsensusTopicInfo.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.memo!=null&&Object.hasOwnProperty.call(m,"memo"))w.uint32(10).string(m.memo);if(m.runningHash!=null&&Object.hasOwnProperty.call(m,"runningHash"))w.uint32(18).bytes(m.runningHash);if(m.sequenceNumber!=null&&Object.hasOwnProperty.call(m,"sequenceNumber"))w.uint32(24).uint64(m.sequenceNumber);if(m.expirationTime!=null&&Object.hasOwnProperty.call(m,"expirationTime"))$root.proto.Timestamp.encode(m.expirationTime,w.uint32(34).fork()).ldelim();if(m.adminKey!=null&&Object.hasOwnProperty.call(m,"adminKey"))$root.proto.Key.encode(m.adminKey,w.uint32(42).fork()).ldelim();if(m.submitKey!=null&&Object.hasOwnProperty.call(m,"submitKey"))$root.proto.Key.encode(m.submitKey,w.uint32(50).fork()).ldelim();if(m.autoRenewPeriod!=null&&Object.hasOwnProperty.call(m,"autoRenewPeriod"))$root.proto.Duration.encode(m.autoRenewPeriod,w.uint32(58).fork()).ldelim();if(m.autoRenewAccount!=null&&Object.hasOwnProperty.call(m,"autoRenewAccount"))$root.proto.AccountID.encode(m.autoRenewAccount,w.uint32(66).fork()).ldelim();if(m.ledgerId!=null&&Object.hasOwnProperty.call(m,"ledgerId"))w.uint32(74).bytes(m.ledgerId);if(m.feeScheduleKey!=null&&Object.hasOwnProperty.call(m,"feeScheduleKey"))$root.proto.Key.encode(m.feeScheduleKey,w.uint32(82).fork()).ldelim();if(m.feeExemptKeyList!=null&&m.feeExemptKeyList.length){for(var i=0;i<m.feeExemptKeyList.length;++i)$root.proto.Key.encode(m.feeExemptKeyList[i],w.uint32(90).fork()).ldelim();}if(m.customFees!=null&&m.customFees.length){for(var i=0;i<m.customFees.length;++i)$root.proto.FixedCustomFee.encode(m.customFees[i],w.uint32(98).fork()).ldelim();}return w;};ConsensusTopicInfo.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ConsensusTopicInfo();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.memo=r.string();break;}case 2:{m.runningHash=r.bytes();break;}case 3:{m.sequenceNumber=r.uint64();break;}case 4:{m.expirationTime=$root.proto.Timestamp.decode(r,r.uint32());break;}case 5:{m.adminKey=$root.proto.Key.decode(r,r.uint32());break;}case 6:{m.submitKey=$root.proto.Key.decode(r,r.uint32());break;}case 7:{m.autoRenewPeriod=$root.proto.Duration.decode(r,r.uint32());break;}case 8:{m.autoRenewAccount=$root.proto.AccountID.decode(r,r.uint32());break;}case 9:{m.ledgerId=r.bytes();break;}case 10:{m.feeScheduleKey=$root.proto.Key.decode(r,r.uint32());break;}case 11:{if(!(m.feeExemptKeyList&&m.feeExemptKeyList.length))m.feeExemptKeyList=[];m.feeExemptKeyList.push($root.proto.Key.decode(r,r.uint32()));break;}case 12:{if(!(m.customFees&&m.customFees.length))m.customFees=[];m.customFees.push($root.proto.FixedCustomFee.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};ConsensusTopicInfo.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ConsensusTopicInfo";};return ConsensusTopicInfo;}();proto.ConsensusService=function(){function ConsensusService(rpcImpl,requestDelimited,responseDelimited){$protobuf.rpc.Service.call(this,rpcImpl,requestDelimited,responseDelimited);}(ConsensusService.prototype=Object.create($protobuf.rpc.Service.prototype)).constructor=ConsensusService;ConsensusService.create=function create(rpcImpl,requestDelimited,responseDelimited){return new this(rpcImpl,requestDelimited,responseDelimited);};Object.defineProperty(ConsensusService.prototype.createTopic=function createTopic(request,callback){return this.rpcCall(createTopic,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"createTopic"});Object.defineProperty(ConsensusService.prototype.updateTopic=function updateTopic(request,callback){return this.rpcCall(updateTopic,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"updateTopic"});Object.defineProperty(ConsensusService.prototype.deleteTopic=function deleteTopic(request,callback){return this.rpcCall(deleteTopic,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"deleteTopic"});Object.defineProperty(ConsensusService.prototype.submitMessage=function submitMessage(request,callback){return this.rpcCall(submitMessage,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"submitMessage"});Object.defineProperty(ConsensusService.prototype.getTopicInfo=function getTopicInfo(request,callback){return this.rpcCall(getTopicInfo,$root.proto.Query,$root.proto.Response,request,callback);},"name",{value:"getTopicInfo"});return ConsensusService;}();proto.Query=function(){function Query(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}Query.prototype.getByKey=null;Query.prototype.getBySolidityID=null;Query.prototype.contractCallLocal=null;Query.prototype.contractGetInfo=null;Query.prototype.contractGetBytecode=null;Query.prototype.ContractGetRecords=null;Query.prototype.cryptogetAccountBalance=null;Query.prototype.cryptoGetAccountRecords=null;Query.prototype.cryptoGetInfo=null;Query.prototype.cryptoGetLiveHash=null;Query.prototype.cryptoGetProxyStakers=null;Query.prototype.fileGetContents=null;Query.prototype.fileGetInfo=null;Query.prototype.transactionGetReceipt=null;Query.prototype.transactionGetRecord=null;Query.prototype.transactionGetFastRecord=null;Query.prototype.consensusGetTopicInfo=null;Query.prototype.networkGetVersionInfo=null;Query.prototype.tokenGetInfo=null;Query.prototype.scheduleGetInfo=null;Query.prototype.tokenGetAccountNftInfos=null;Query.prototype.tokenGetNftInfo=null;Query.prototype.tokenGetNftInfos=null;Query.prototype.networkGetExecutionTime=null;Query.prototype.accountDetails=null;let $oneOfFields;Object.defineProperty(Query.prototype,"query",{get:$util.oneOfGetter($oneOfFields=["getByKey","getBySolidityID","contractCallLocal","contractGetInfo","contractGetBytecode","ContractGetRecords","cryptogetAccountBalance","cryptoGetAccountRecords","cryptoGetInfo","cryptoGetLiveHash","cryptoGetProxyStakers","fileGetContents","fileGetInfo","transactionGetReceipt","transactionGetRecord","transactionGetFastRecord","consensusGetTopicInfo","networkGetVersionInfo","tokenGetInfo","scheduleGetInfo","tokenGetAccountNftInfos","tokenGetNftInfo","tokenGetNftInfos","networkGetExecutionTime","accountDetails"]),set:$util.oneOfSetter($oneOfFields)});Query.create=function create(properties){return new Query(properties);};Query.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.getByKey!=null&&Object.hasOwnProperty.call(m,"getByKey"))$root.proto.GetByKeyQuery.encode(m.getByKey,w.uint32(10).fork()).ldelim();if(m.getBySolidityID!=null&&Object.hasOwnProperty.call(m,"getBySolidityID"))$root.proto.GetBySolidityIDQuery.encode(m.getBySolidityID,w.uint32(18).fork()).ldelim();if(m.contractCallLocal!=null&&Object.hasOwnProperty.call(m,"contractCallLocal"))$root.proto.ContractCallLocalQuery.encode(m.contractCallLocal,w.uint32(26).fork()).ldelim();if(m.contractGetInfo!=null&&Object.hasOwnProperty.call(m,"contractGetInfo"))$root.proto.ContractGetInfoQuery.encode(m.contractGetInfo,w.uint32(34).fork()).ldelim();if(m.contractGetBytecode!=null&&Object.hasOwnProperty.call(m,"contractGetBytecode"))$root.proto.ContractGetBytecodeQuery.encode(m.contractGetBytecode,w.uint32(42).fork()).ldelim();if(m.ContractGetRecords!=null&&Object.hasOwnProperty.call(m,"ContractGetRecords"))$root.proto.ContractGetRecordsQuery.encode(m.ContractGetRecords,w.uint32(50).fork()).ldelim();if(m.cryptogetAccountBalance!=null&&Object.hasOwnProperty.call(m,"cryptogetAccountBalance"))$root.proto.CryptoGetAccountBalanceQuery.encode(m.cryptogetAccountBalance,w.uint32(58).fork()).ldelim();if(m.cryptoGetAccountRecords!=null&&Object.hasOwnProperty.call(m,"cryptoGetAccountRecords"))$root.proto.CryptoGetAccountRecordsQuery.encode(m.cryptoGetAccountRecords,w.uint32(66).fork()).ldelim();if(m.cryptoGetInfo!=null&&Object.hasOwnProperty.call(m,"cryptoGetInfo"))$root.proto.CryptoGetInfoQuery.encode(m.cryptoGetInfo,w.uint32(74).fork()).ldelim();if(m.cryptoGetLiveHash!=null&&Object.hasOwnProperty.call(m,"cryptoGetLiveHash"))$root.proto.CryptoGetLiveHashQuery.encode(m.cryptoGetLiveHash,w.uint32(82).fork()).ldelim();if(m.cryptoGetProxyStakers!=null&&Object.hasOwnProperty.call(m,"cryptoGetProxyStakers"))$root.proto.CryptoGetStakersQuery.encode(m.cryptoGetProxyStakers,w.uint32(90).fork()).ldelim();if(m.fileGetContents!=null&&Object.hasOwnProperty.call(m,"fileGetContents"))$root.proto.FileGetContentsQuery.encode(m.fileGetContents,w.uint32(98).fork()).ldelim();if(m.fileGetInfo!=null&&Object.hasOwnProperty.call(m,"fileGetInfo"))$root.proto.FileGetInfoQuery.encode(m.fileGetInfo,w.uint32(106).fork()).ldelim();if(m.transactionGetReceipt!=null&&Object.hasOwnProperty.call(m,"transactionGetReceipt"))$root.proto.TransactionGetReceiptQuery.encode(m.transactionGetReceipt,w.uint32(114).fork()).ldelim();if(m.transactionGetRecord!=null&&Object.hasOwnProperty.call(m,"transactionGetRecord"))$root.proto.TransactionGetRecordQuery.encode(m.transactionGetRecord,w.uint32(122).fork()).ldelim();if(m.transactionGetFastRecord!=null&&Object.hasOwnProperty.call(m,"transactionGetFastRecord"))$root.proto.TransactionGetFastRecordQuery.encode(m.transactionGetFastRecord,w.uint32(130).fork()).ldelim();if(m.consensusGetTopicInfo!=null&&Object.hasOwnProperty.call(m,"consensusGetTopicInfo"))$root.proto.ConsensusGetTopicInfoQuery.encode(m.consensusGetTopicInfo,w.uint32(402).fork()).ldelim();if(m.networkGetVersionInfo!=null&&Object.hasOwnProperty.call(m,"networkGetVersionInfo"))$root.proto.NetworkGetVersionInfoQuery.encode(m.networkGetVersionInfo,w.uint32(410).fork()).ldelim();if(m.tokenGetInfo!=null&&Object.hasOwnProperty.call(m,"tokenGetInfo"))$root.proto.TokenGetInfoQuery.encode(m.tokenGetInfo,w.uint32(418).fork()).ldelim();if(m.scheduleGetInfo!=null&&Object.hasOwnProperty.call(m,"scheduleGetInfo"))$root.proto.ScheduleGetInfoQuery.encode(m.scheduleGetInfo,w.uint32(426).fork()).ldelim();if(m.tokenGetAccountNftInfos!=null&&Object.hasOwnProperty.call(m,"tokenGetAccountNftInfos"))$root.proto.TokenGetAccountNftInfosQuery.encode(m.tokenGetAccountNftInfos,w.uint32(434).fork()).ldelim();if(m.tokenGetNftInfo!=null&&Object.hasOwnProperty.call(m,"tokenGetNftInfo"))$root.proto.TokenGetNftInfoQuery.encode(m.tokenGetNftInfo,w.uint32(442).fork()).ldelim();if(m.tokenGetNftInfos!=null&&Object.hasOwnProperty.call(m,"tokenGetNftInfos"))$root.proto.TokenGetNftInfosQuery.encode(m.tokenGetNftInfos,w.uint32(450).fork()).ldelim();if(m.networkGetExecutionTime!=null&&Object.hasOwnProperty.call(m,"networkGetExecutionTime"))$root.proto.NetworkGetExecutionTimeQuery.encode(m.networkGetExecutionTime,w.uint32(458).fork()).ldelim();if(m.accountDetails!=null&&Object.hasOwnProperty.call(m,"accountDetails"))$root.proto.GetAccountDetailsQuery.encode(m.accountDetails,w.uint32(466).fork()).ldelim();return w;};Query.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.Query();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.getByKey=$root.proto.GetByKeyQuery.decode(r,r.uint32());break;}case 2:{m.getBySolidityID=$root.proto.GetBySolidityIDQuery.decode(r,r.uint32());break;}case 3:{m.contractCallLocal=$root.proto.ContractCallLocalQuery.decode(r,r.uint32());break;}case 4:{m.contractGetInfo=$root.proto.ContractGetInfoQuery.decode(r,r.uint32());break;}case 5:{m.contractGetBytecode=$root.proto.ContractGetBytecodeQuery.decode(r,r.uint32());break;}case 6:{m.ContractGetRecords=$root.proto.ContractGetRecordsQuery.decode(r,r.uint32());break;}case 7:{m.cryptogetAccountBalance=$root.proto.CryptoGetAccountBalanceQuery.decode(r,r.uint32());break;}case 8:{m.cryptoGetAccountRecords=$root.proto.CryptoGetAccountRecordsQuery.decode(r,r.uint32());break;}case 9:{m.cryptoGetInfo=$root.proto.CryptoGetInfoQuery.decode(r,r.uint32());break;}case 10:{m.cryptoGetLiveHash=$root.proto.CryptoGetLiveHashQuery.decode(r,r.uint32());break;}case 11:{m.cryptoGetProxyStakers=$root.proto.CryptoGetStakersQuery.decode(r,r.uint32());break;}case 12:{m.fileGetContents=$root.proto.FileGetContentsQuery.decode(r,r.uint32());break;}case 13:{m.fileGetInfo=$root.proto.FileGetInfoQuery.decode(r,r.uint32());break;}case 14:{m.transactionGetReceipt=$root.proto.TransactionGetReceiptQuery.decode(r,r.uint32());break;}case 15:{m.transactionGetRecord=$root.proto.TransactionGetRecordQuery.decode(r,r.uint32());break;}case 16:{m.transactionGetFastRecord=$root.proto.TransactionGetFastRecordQuery.decode(r,r.uint32());break;}case 50:{m.consensusGetTopicInfo=$root.proto.ConsensusGetTopicInfoQuery.decode(r,r.uint32());break;}case 51:{m.networkGetVersionInfo=$root.proto.NetworkGetVersionInfoQuery.decode(r,r.uint32());break;}case 52:{m.tokenGetInfo=$root.proto.TokenGetInfoQuery.decode(r,r.uint32());break;}case 53:{m.scheduleGetInfo=$root.proto.ScheduleGetInfoQuery.decode(r,r.uint32());break;}case 54:{m.tokenGetAccountNftInfos=$root.proto.TokenGetAccountNftInfosQuery.decode(r,r.uint32());break;}case 55:{m.tokenGetNftInfo=$root.proto.TokenGetNftInfoQuery.decode(r,r.uint32());break;}case 56:{m.tokenGetNftInfos=$root.proto.TokenGetNftInfosQuery.decode(r,r.uint32());break;}case 57:{m.networkGetExecutionTime=$root.proto.NetworkGetExecutionTimeQuery.decode(r,r.uint32());break;}case 58:{m.accountDetails=$root.proto.GetAccountDetailsQuery.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};Query.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.Query";};return Query;}();proto.GetByKeyQuery=function(){function GetByKeyQuery(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}GetByKeyQuery.prototype.header=null;GetByKeyQuery.prototype.key=null;GetByKeyQuery.create=function create(properties){return new GetByKeyQuery(properties);};GetByKeyQuery.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.header!=null&&Object.hasOwnProperty.call(m,"header"))$root.proto.QueryHeader.encode(m.header,w.uint32(10).fork()).ldelim();if(m.key!=null&&Object.hasOwnProperty.call(m,"key"))$root.proto.Key.encode(m.key,w.uint32(18).fork()).ldelim();return w;};GetByKeyQuery.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.GetByKeyQuery();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.header=$root.proto.QueryHeader.decode(r,r.uint32());break;}case 2:{m.key=$root.proto.Key.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};GetByKeyQuery.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.GetByKeyQuery";};return GetByKeyQuery;}();proto.EntityID=function(){function EntityID(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}EntityID.prototype.accountID=null;EntityID.prototype.liveHash=null;EntityID.prototype.fileID=null;EntityID.prototype.contractID=null;let $oneOfFields;Object.defineProperty(EntityID.prototype,"entity",{get:$util.oneOfGetter($oneOfFields=["accountID","liveHash","fileID","contractID"]),set:$util.oneOfSetter($oneOfFields)});EntityID.create=function create(properties){return new EntityID(properties);};EntityID.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.accountID!=null&&Object.hasOwnProperty.call(m,"accountID"))$root.proto.AccountID.encode(m.accountID,w.uint32(10).fork()).ldelim();if(m.liveHash!=null&&Object.hasOwnProperty.call(m,"liveHash"))$root.proto.LiveHash.encode(m.liveHash,w.uint32(18).fork()).ldelim();if(m.fileID!=null&&Object.hasOwnProperty.call(m,"fileID"))$root.proto.FileID.encode(m.fileID,w.uint32(26).fork()).ldelim();if(m.contractID!=null&&Object.hasOwnProperty.call(m,"contractID"))$root.proto.ContractID.encode(m.contractID,w.uint32(34).fork()).ldelim();return w;};EntityID.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.EntityID();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.accountID=$root.proto.AccountID.decode(r,r.uint32());break;}case 2:{m.liveHash=$root.proto.LiveHash.decode(r,r.uint32());break;}case 3:{m.fileID=$root.proto.FileID.decode(r,r.uint32());break;}case 4:{m.contractID=$root.proto.ContractID.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};EntityID.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.EntityID";};return EntityID;}();proto.GetByKeyResponse=function(){function GetByKeyResponse(p){this.entities=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}GetByKeyResponse.prototype.header=null;GetByKeyResponse.prototype.entities=$util.emptyArray;GetByKeyResponse.create=function create(properties){return new GetByKeyResponse(properties);};GetByKeyResponse.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.header!=null&&Object.hasOwnProperty.call(m,"header"))$root.proto.ResponseHeader.encode(m.header,w.uint32(10).fork()).ldelim();if(m.entities!=null&&m.entities.length){for(var i=0;i<m.entities.length;++i)$root.proto.EntityID.encode(m.entities[i],w.uint32(18).fork()).ldelim();}return w;};GetByKeyResponse.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.GetByKeyResponse();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.header=$root.proto.ResponseHeader.decode(r,r.uint32());break;}case 2:{if(!(m.entities&&m.entities.length))m.entities=[];m.entities.push($root.proto.EntityID.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};GetByKeyResponse.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.GetByKeyResponse";};return GetByKeyResponse;}();proto.LiveHash=function(){function LiveHash(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}LiveHash.prototype.accountId=null;LiveHash.prototype.hash=$util.newBuffer([]);LiveHash.prototype.keys=null;LiveHash.prototype.duration=null;LiveHash.create=function create(properties){return new LiveHash(properties);};LiveHash.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.accountId!=null&&Object.hasOwnProperty.call(m,"accountId"))$root.proto.AccountID.encode(m.accountId,w.uint32(10).fork()).ldelim();if(m.hash!=null&&Object.hasOwnProperty.call(m,"hash"))w.uint32(18).bytes(m.hash);if(m.keys!=null&&Object.hasOwnProperty.call(m,"keys"))$root.proto.KeyList.encode(m.keys,w.uint32(26).fork()).ldelim();if(m.duration!=null&&Object.hasOwnProperty.call(m,"duration"))$root.proto.Duration.encode(m.duration,w.uint32(42).fork()).ldelim();return w;};LiveHash.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.LiveHash();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.accountId=$root.proto.AccountID.decode(r,r.uint32());break;}case 2:{m.hash=r.bytes();break;}case 3:{m.keys=$root.proto.KeyList.decode(r,r.uint32());break;}case 5:{m.duration=$root.proto.Duration.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};LiveHash.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.LiveHash";};return LiveHash;}();proto.CryptoAddLiveHashTransactionBody=function(){function CryptoAddLiveHashTransactionBody(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}CryptoAddLiveHashTransactionBody.prototype.liveHash=null;CryptoAddLiveHashTransactionBody.create=function create(properties){return new CryptoAddLiveHashTransactionBody(properties);};CryptoAddLiveHashTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.liveHash!=null&&Object.hasOwnProperty.call(m,"liveHash"))$root.proto.LiveHash.encode(m.liveHash,w.uint32(26).fork()).ldelim();return w;};CryptoAddLiveHashTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.CryptoAddLiveHashTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 3:{m.liveHash=$root.proto.LiveHash.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};CryptoAddLiveHashTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.CryptoAddLiveHashTransactionBody";};return CryptoAddLiveHashTransactionBody;}();proto.GetBySolidityIDQuery=function(){function GetBySolidityIDQuery(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}GetBySolidityIDQuery.prototype.header=null;GetBySolidityIDQuery.prototype.solidityID="";GetBySolidityIDQuery.create=function create(properties){return new GetBySolidityIDQuery(properties);};GetBySolidityIDQuery.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.header!=null&&Object.hasOwnProperty.call(m,"header"))$root.proto.QueryHeader.encode(m.header,w.uint32(10).fork()).ldelim();if(m.solidityID!=null&&Object.hasOwnProperty.call(m,"solidityID"))w.uint32(18).string(m.solidityID);return w;};GetBySolidityIDQuery.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.GetBySolidityIDQuery();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.header=$root.proto.QueryHeader.decode(r,r.uint32());break;}case 2:{m.solidityID=r.string();break;}default:r.skipType(t&7);break;}}return m;};GetBySolidityIDQuery.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.GetBySolidityIDQuery";};return GetBySolidityIDQuery;}();proto.GetBySolidityIDResponse=function(){function GetBySolidityIDResponse(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}GetBySolidityIDResponse.prototype.header=null;GetBySolidityIDResponse.prototype.accountID=null;GetBySolidityIDResponse.prototype.fileID=null;GetBySolidityIDResponse.prototype.contractID=null;GetBySolidityIDResponse.create=function create(properties){return new GetBySolidityIDResponse(properties);};GetBySolidityIDResponse.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.header!=null&&Object.hasOwnProperty.call(m,"header"))$root.proto.ResponseHeader.encode(m.header,w.uint32(10).fork()).ldelim();if(m.accountID!=null&&Object.hasOwnProperty.call(m,"accountID"))$root.proto.AccountID.encode(m.accountID,w.uint32(18).fork()).ldelim();if(m.fileID!=null&&Object.hasOwnProperty.call(m,"fileID"))$root.proto.FileID.encode(m.fileID,w.uint32(26).fork()).ldelim();if(m.contractID!=null&&Object.hasOwnProperty.call(m,"contractID"))$root.proto.ContractID.encode(m.contractID,w.uint32(34).fork()).ldelim();return w;};GetBySolidityIDResponse.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.GetBySolidityIDResponse();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.header=$root.proto.ResponseHeader.decode(r,r.uint32());break;}case 2:{m.accountID=$root.proto.AccountID.decode(r,r.uint32());break;}case 3:{m.fileID=$root.proto.FileID.decode(r,r.uint32());break;}case 4:{m.contractID=$root.proto.ContractID.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};GetBySolidityIDResponse.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.GetBySolidityIDResponse";};return GetBySolidityIDResponse;}();proto.ContractCallLocalQuery=function(){function ContractCallLocalQuery(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ContractCallLocalQuery.prototype.header=null;ContractCallLocalQuery.prototype.contractID=null;ContractCallLocalQuery.prototype.gas=$util.Long?$util.Long.fromBits(0,0,false):0;ContractCallLocalQuery.prototype.functionParameters=$util.newBuffer([]);ContractCallLocalQuery.prototype.maxResultSize=$util.Long?$util.Long.fromBits(0,0,false):0;ContractCallLocalQuery.prototype.senderId=null;ContractCallLocalQuery.create=function create(properties){return new ContractCallLocalQuery(properties);};ContractCallLocalQuery.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.header!=null&&Object.hasOwnProperty.call(m,"header"))$root.proto.QueryHeader.encode(m.header,w.uint32(10).fork()).ldelim();if(m.contractID!=null&&Object.hasOwnProperty.call(m,"contractID"))$root.proto.ContractID.encode(m.contractID,w.uint32(18).fork()).ldelim();if(m.gas!=null&&Object.hasOwnProperty.call(m,"gas"))w.uint32(24).int64(m.gas);if(m.functionParameters!=null&&Object.hasOwnProperty.call(m,"functionParameters"))w.uint32(34).bytes(m.functionParameters);if(m.maxResultSize!=null&&Object.hasOwnProperty.call(m,"maxResultSize"))w.uint32(40).int64(m.maxResultSize);if(m.senderId!=null&&Object.hasOwnProperty.call(m,"senderId"))$root.proto.AccountID.encode(m.senderId,w.uint32(50).fork()).ldelim();return w;};ContractCallLocalQuery.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ContractCallLocalQuery();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.header=$root.proto.QueryHeader.decode(r,r.uint32());break;}case 2:{m.contractID=$root.proto.ContractID.decode(r,r.uint32());break;}case 3:{m.gas=r.int64();break;}case 4:{m.functionParameters=r.bytes();break;}case 5:{m.maxResultSize=r.int64();break;}case 6:{m.senderId=$root.proto.AccountID.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};ContractCallLocalQuery.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ContractCallLocalQuery";};return ContractCallLocalQuery;}();proto.ContractCallLocalResponse=function(){function ContractCallLocalResponse(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ContractCallLocalResponse.prototype.header=null;ContractCallLocalResponse.prototype.functionResult=null;ContractCallLocalResponse.create=function create(properties){return new ContractCallLocalResponse(properties);};ContractCallLocalResponse.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.header!=null&&Object.hasOwnProperty.call(m,"header"))$root.proto.ResponseHeader.encode(m.header,w.uint32(10).fork()).ldelim();if(m.functionResult!=null&&Object.hasOwnProperty.call(m,"functionResult"))$root.proto.ContractFunctionResult.encode(m.functionResult,w.uint32(18).fork()).ldelim();return w;};ContractCallLocalResponse.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ContractCallLocalResponse();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.header=$root.proto.ResponseHeader.decode(r,r.uint32());break;}case 2:{m.functionResult=$root.proto.ContractFunctionResult.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};ContractCallLocalResponse.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ContractCallLocalResponse";};return ContractCallLocalResponse;}();proto.InternalCallContext=function(){function InternalCallContext(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}InternalCallContext.prototype.gas=$util.Long?$util.Long.fromBits(0,0,true):0;InternalCallContext.prototype.value=$util.Long?$util.Long.fromBits(0,0,true):0;InternalCallContext.prototype.callData=$util.newBuffer([]);InternalCallContext.create=function create(properties){return new InternalCallContext(properties);};InternalCallContext.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.gas!=null&&Object.hasOwnProperty.call(m,"gas"))w.uint32(8).uint64(m.gas);if(m.value!=null&&Object.hasOwnProperty.call(m,"value"))w.uint32(16).uint64(m.value);if(m.callData!=null&&Object.hasOwnProperty.call(m,"callData"))w.uint32(26).bytes(m.callData);return w;};InternalCallContext.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.InternalCallContext();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.gas=r.uint64();break;}case 2:{m.value=r.uint64();break;}case 3:{m.callData=r.bytes();break;}default:r.skipType(t&7);break;}}return m;};InternalCallContext.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.InternalCallContext";};return InternalCallContext;}();proto.EvmTransactionResult=function(){function EvmTransactionResult(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}EvmTransactionResult.prototype.senderId=null;EvmTransactionResult.prototype.contractId=null;EvmTransactionResult.prototype.resultData=$util.newBuffer([]);EvmTransactionResult.prototype.errorMessage="";EvmTransactionResult.prototype.gasUsed=$util.Long?$util.Long.fromBits(0,0,true):0;EvmTransactionResult.prototype.internalCallContext=null;EvmTransactionResult.create=function create(properties){return new EvmTransactionResult(properties);};EvmTransactionResult.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.senderId!=null&&Object.hasOwnProperty.call(m,"senderId"))$root.proto.AccountID.encode(m.senderId,w.uint32(10).fork()).ldelim();if(m.contractId!=null&&Object.hasOwnProperty.call(m,"contractId"))$root.proto.ContractID.encode(m.contractId,w.uint32(18).fork()).ldelim();if(m.resultData!=null&&Object.hasOwnProperty.call(m,"resultData"))w.uint32(26).bytes(m.resultData);if(m.errorMessage!=null&&Object.hasOwnProperty.call(m,"errorMessage"))w.uint32(34).string(m.errorMessage);if(m.gasUsed!=null&&Object.hasOwnProperty.call(m,"gasUsed"))w.uint32(40).uint64(m.gasUsed);if(m.internalCallContext!=null&&Object.hasOwnProperty.call(m,"internalCallContext"))$root.proto.InternalCallContext.encode(m.internalCallContext,w.uint32(50).fork()).ldelim();return w;};EvmTransactionResult.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.EvmTransactionResult();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.senderId=$root.proto.AccountID.decode(r,r.uint32());break;}case 2:{m.contractId=$root.proto.ContractID.decode(r,r.uint32());break;}case 3:{m.resultData=r.bytes();break;}case 4:{m.errorMessage=r.string();break;}case 5:{m.gasUsed=r.uint64();break;}case 6:{m.internalCallContext=$root.proto.InternalCallContext.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};EvmTransactionResult.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.EvmTransactionResult";};return EvmTransactionResult;}();proto.ContractNonceInfo=function(){function ContractNonceInfo(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ContractNonceInfo.prototype.contractId=null;ContractNonceInfo.prototype.nonce=$util.Long?$util.Long.fromBits(0,0,false):0;ContractNonceInfo.create=function create(properties){return new ContractNonceInfo(properties);};ContractNonceInfo.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.contractId!=null&&Object.hasOwnProperty.call(m,"contractId"))$root.proto.ContractID.encode(m.contractId,w.uint32(10).fork()).ldelim();if(m.nonce!=null&&Object.hasOwnProperty.call(m,"nonce"))w.uint32(16).int64(m.nonce);return w;};ContractNonceInfo.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ContractNonceInfo();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.contractId=$root.proto.ContractID.decode(r,r.uint32());break;}case 2:{m.nonce=r.int64();break;}default:r.skipType(t&7);break;}}return m;};ContractNonceInfo.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ContractNonceInfo";};return ContractNonceInfo;}();proto.ContractLoginfo=function(){function ContractLoginfo(p){this.topic=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ContractLoginfo.prototype.contractID=null;ContractLoginfo.prototype.bloom=$util.newBuffer([]);ContractLoginfo.prototype.topic=$util.emptyArray;ContractLoginfo.prototype.data=$util.newBuffer([]);ContractLoginfo.create=function create(properties){return new ContractLoginfo(properties);};ContractLoginfo.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.contractID!=null&&Object.hasOwnProperty.call(m,"contractID"))$root.proto.ContractID.encode(m.contractID,w.uint32(10).fork()).ldelim();if(m.bloom!=null&&Object.hasOwnProperty.call(m,"bloom"))w.uint32(18).bytes(m.bloom);if(m.topic!=null&&m.topic.length){for(var i=0;i<m.topic.length;++i)w.uint32(26).bytes(m.topic[i]);}if(m.data!=null&&Object.hasOwnProperty.call(m,"data"))w.uint32(34).bytes(m.data);return w;};ContractLoginfo.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ContractLoginfo();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.contractID=$root.proto.ContractID.decode(r,r.uint32());break;}case 2:{m.bloom=r.bytes();break;}case 3:{if(!(m.topic&&m.topic.length))m.topic=[];m.topic.push(r.bytes());break;}case 4:{m.data=r.bytes();break;}default:r.skipType(t&7);break;}}return m;};ContractLoginfo.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ContractLoginfo";};return ContractLoginfo;}();proto.ContractFunctionResult=function(){function ContractFunctionResult(p){this.logInfo=[];this.createdContractIDs=[];this.contractNonces=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ContractFunctionResult.prototype.contractID=null;ContractFunctionResult.prototype.contractCallResult=$util.newBuffer([]);ContractFunctionResult.prototype.errorMessage="";ContractFunctionResult.prototype.bloom=$util.newBuffer([]);ContractFunctionResult.prototype.gasUsed=$util.Long?$util.Long.fromBits(0,0,true):0;ContractFunctionResult.prototype.logInfo=$util.emptyArray;ContractFunctionResult.prototype.createdContractIDs=$util.emptyArray;ContractFunctionResult.prototype.evmAddress=null;ContractFunctionResult.prototype.gas=$util.Long?$util.Long.fromBits(0,0,false):0;ContractFunctionResult.prototype.amount=$util.Long?$util.Long.fromBits(0,0,false):0;ContractFunctionResult.prototype.functionParameters=$util.newBuffer([]);ContractFunctionResult.prototype.senderId=null;ContractFunctionResult.prototype.contractNonces=$util.emptyArray;ContractFunctionResult.prototype.signerNonce=null;ContractFunctionResult.create=function create(properties){return new ContractFunctionResult(properties);};ContractFunctionResult.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.contractID!=null&&Object.hasOwnProperty.call(m,"contractID"))$root.proto.ContractID.encode(m.contractID,w.uint32(10).fork()).ldelim();if(m.contractCallResult!=null&&Object.hasOwnProperty.call(m,"contractCallResult"))w.uint32(18).bytes(m.contractCallResult);if(m.errorMessage!=null&&Object.hasOwnProperty.call(m,"errorMessage"))w.uint32(26).string(m.errorMessage);if(m.bloom!=null&&Object.hasOwnProperty.call(m,"bloom"))w.uint32(34).bytes(m.bloom);if(m.gasUsed!=null&&Object.hasOwnProperty.call(m,"gasUsed"))w.uint32(40).uint64(m.gasUsed);if(m.logInfo!=null&&m.logInfo.length){for(var i=0;i<m.logInfo.length;++i)$root.proto.ContractLoginfo.encode(m.logInfo[i],w.uint32(50).fork()).ldelim();}if(m.createdContractIDs!=null&&m.createdContractIDs.length){for(var i=0;i<m.createdContractIDs.length;++i)$root.proto.ContractID.encode(m.createdContractIDs[i],w.uint32(58).fork()).ldelim();}if(m.evmAddress!=null&&Object.hasOwnProperty.call(m,"evmAddress"))$root.google.protobuf.BytesValue.encode(m.evmAddress,w.uint32(74).fork()).ldelim();if(m.gas!=null&&Object.hasOwnProperty.call(m,"gas"))w.uint32(80).int64(m.gas);if(m.amount!=null&&Object.hasOwnProperty.call(m,"amount"))w.uint32(88).int64(m.amount);if(m.functionParameters!=null&&Object.hasOwnProperty.call(m,"functionParameters"))w.uint32(98).bytes(m.functionParameters);if(m.senderId!=null&&Object.hasOwnProperty.call(m,"senderId"))$root.proto.AccountID.encode(m.senderId,w.uint32(106).fork()).ldelim();if(m.contractNonces!=null&&m.contractNonces.length){for(var i=0;i<m.contractNonces.length;++i)$root.proto.ContractNonceInfo.encode(m.contractNonces[i],w.uint32(114).fork()).ldelim();}if(m.signerNonce!=null&&Object.hasOwnProperty.call(m,"signerNonce"))$root.google.protobuf.Int64Value.encode(m.signerNonce,w.uint32(122).fork()).ldelim();return w;};ContractFunctionResult.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ContractFunctionResult();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.contractID=$root.proto.ContractID.decode(r,r.uint32());break;}case 2:{m.contractCallResult=r.bytes();break;}case 3:{m.errorMessage=r.string();break;}case 4:{m.bloom=r.bytes();break;}case 5:{m.gasUsed=r.uint64();break;}case 6:{if(!(m.logInfo&&m.logInfo.length))m.logInfo=[];m.logInfo.push($root.proto.ContractLoginfo.decode(r,r.uint32()));break;}case 7:{if(!(m.createdContractIDs&&m.createdContractIDs.length))m.createdContractIDs=[];m.createdContractIDs.push($root.proto.ContractID.decode(r,r.uint32()));break;}case 9:{m.evmAddress=$root.google.protobuf.BytesValue.decode(r,r.uint32());break;}case 10:{m.gas=r.int64();break;}case 11:{m.amount=r.int64();break;}case 12:{m.functionParameters=r.bytes();break;}case 13:{m.senderId=$root.proto.AccountID.decode(r,r.uint32());break;}case 14:{if(!(m.contractNonces&&m.contractNonces.length))m.contractNonces=[];m.contractNonces.push($root.proto.ContractNonceInfo.decode(r,r.uint32()));break;}case 15:{m.signerNonce=$root.google.protobuf.Int64Value.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};ContractFunctionResult.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ContractFunctionResult";};return ContractFunctionResult;}();proto.ContractGetInfoQuery=function(){function ContractGetInfoQuery(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ContractGetInfoQuery.prototype.header=null;ContractGetInfoQuery.prototype.contractID=null;ContractGetInfoQuery.create=function create(properties){return new ContractGetInfoQuery(properties);};ContractGetInfoQuery.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.header!=null&&Object.hasOwnProperty.call(m,"header"))$root.proto.QueryHeader.encode(m.header,w.uint32(10).fork()).ldelim();if(m.contractID!=null&&Object.hasOwnProperty.call(m,"contractID"))$root.proto.ContractID.encode(m.contractID,w.uint32(18).fork()).ldelim();return w;};ContractGetInfoQuery.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ContractGetInfoQuery();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.header=$root.proto.QueryHeader.decode(r,r.uint32());break;}case 2:{m.contractID=$root.proto.ContractID.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};ContractGetInfoQuery.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ContractGetInfoQuery";};return ContractGetInfoQuery;}();proto.ContractGetInfoResponse=function(){function ContractGetInfoResponse(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ContractGetInfoResponse.prototype.header=null;ContractGetInfoResponse.prototype.contractInfo=null;ContractGetInfoResponse.create=function create(properties){return new ContractGetInfoResponse(properties);};ContractGetInfoResponse.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.header!=null&&Object.hasOwnProperty.call(m,"header"))$root.proto.ResponseHeader.encode(m.header,w.uint32(10).fork()).ldelim();if(m.contractInfo!=null&&Object.hasOwnProperty.call(m,"contractInfo"))$root.proto.ContractGetInfoResponse.ContractInfo.encode(m.contractInfo,w.uint32(18).fork()).ldelim();return w;};ContractGetInfoResponse.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ContractGetInfoResponse();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.header=$root.proto.ResponseHeader.decode(r,r.uint32());break;}case 2:{m.contractInfo=$root.proto.ContractGetInfoResponse.ContractInfo.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};ContractGetInfoResponse.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ContractGetInfoResponse";};ContractGetInfoResponse.ContractInfo=function(){function ContractInfo(p){this.tokenRelationships=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ContractInfo.prototype.contractID=null;ContractInfo.prototype.accountID=null;ContractInfo.prototype.contractAccountID="";ContractInfo.prototype.adminKey=null;ContractInfo.prototype.expirationTime=null;ContractInfo.prototype.autoRenewPeriod=null;ContractInfo.prototype.storage=$util.Long?$util.Long.fromBits(0,0,false):0;ContractInfo.prototype.memo="";ContractInfo.prototype.balance=$util.Long?$util.Long.fromBits(0,0,true):0;ContractInfo.prototype.deleted=false;ContractInfo.prototype.tokenRelationships=$util.emptyArray;ContractInfo.prototype.ledgerId=$util.newBuffer([]);ContractInfo.prototype.autoRenewAccountId=null;ContractInfo.prototype.maxAutomaticTokenAssociations=0;ContractInfo.prototype.stakingInfo=null;ContractInfo.create=function create(properties){return new ContractInfo(properties);};ContractInfo.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.contractID!=null&&Object.hasOwnProperty.call(m,"contractID"))$root.proto.ContractID.encode(m.contractID,w.uint32(10).fork()).ldelim();if(m.accountID!=null&&Object.hasOwnProperty.call(m,"accountID"))$root.proto.AccountID.encode(m.accountID,w.uint32(18).fork()).ldelim();if(m.contractAccountID!=null&&Object.hasOwnProperty.call(m,"contractAccountID"))w.uint32(26).string(m.contractAccountID);if(m.adminKey!=null&&Object.hasOwnProperty.call(m,"adminKey"))$root.proto.Key.encode(m.adminKey,w.uint32(34).fork()).ldelim();if(m.expirationTime!=null&&Object.hasOwnProperty.call(m,"expirationTime"))$root.proto.Timestamp.encode(m.expirationTime,w.uint32(42).fork()).ldelim();if(m.autoRenewPeriod!=null&&Object.hasOwnProperty.call(m,"autoRenewPeriod"))$root.proto.Duration.encode(m.autoRenewPeriod,w.uint32(50).fork()).ldelim();if(m.storage!=null&&Object.hasOwnProperty.call(m,"storage"))w.uint32(56).int64(m.storage);if(m.memo!=null&&Object.hasOwnProperty.call(m,"memo"))w.uint32(66).string(m.memo);if(m.balance!=null&&Object.hasOwnProperty.call(m,"balance"))w.uint32(72).uint64(m.balance);if(m.deleted!=null&&Object.hasOwnProperty.call(m,"deleted"))w.uint32(80).bool(m.deleted);if(m.tokenRelationships!=null&&m.tokenRelationships.length){for(var i=0;i<m.tokenRelationships.length;++i)$root.proto.TokenRelationship.encode(m.tokenRelationships[i],w.uint32(90).fork()).ldelim();}if(m.ledgerId!=null&&Object.hasOwnProperty.call(m,"ledgerId"))w.uint32(98).bytes(m.ledgerId);if(m.autoRenewAccountId!=null&&Object.hasOwnProperty.call(m,"autoRenewAccountId"))$root.proto.AccountID.encode(m.autoRenewAccountId,w.uint32(106).fork()).ldelim();if(m.maxAutomaticTokenAssociations!=null&&Object.hasOwnProperty.call(m,"maxAutomaticTokenAssociations"))w.uint32(112).int32(m.maxAutomaticTokenAssociations);if(m.stakingInfo!=null&&Object.hasOwnProperty.call(m,"stakingInfo"))$root.proto.StakingInfo.encode(m.stakingInfo,w.uint32(122).fork()).ldelim();return w;};ContractInfo.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ContractGetInfoResponse.ContractInfo();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.contractID=$root.proto.ContractID.decode(r,r.uint32());break;}case 2:{m.accountID=$root.proto.AccountID.decode(r,r.uint32());break;}case 3:{m.contractAccountID=r.string();break;}case 4:{m.adminKey=$root.proto.Key.decode(r,r.uint32());break;}case 5:{m.expirationTime=$root.proto.Timestamp.decode(r,r.uint32());break;}case 6:{m.autoRenewPeriod=$root.proto.Duration.decode(r,r.uint32());break;}case 7:{m.storage=r.int64();break;}case 8:{m.memo=r.string();break;}case 9:{m.balance=r.uint64();break;}case 10:{m.deleted=r.bool();break;}case 11:{if(!(m.tokenRelationships&&m.tokenRelationships.length))m.tokenRelationships=[];m.tokenRelationships.push($root.proto.TokenRelationship.decode(r,r.uint32()));break;}case 12:{m.ledgerId=r.bytes();break;}case 13:{m.autoRenewAccountId=$root.proto.AccountID.decode(r,r.uint32());break;}case 14:{m.maxAutomaticTokenAssociations=r.int32();break;}case 15:{m.stakingInfo=$root.proto.StakingInfo.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};ContractInfo.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ContractGetInfoResponse.ContractInfo";};return ContractInfo;}();return ContractGetInfoResponse;}();proto.ContractGetBytecodeQuery=function(){function ContractGetBytecodeQuery(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ContractGetBytecodeQuery.prototype.header=null;ContractGetBytecodeQuery.prototype.contractID=null;ContractGetBytecodeQuery.create=function create(properties){return new ContractGetBytecodeQuery(properties);};ContractGetBytecodeQuery.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.header!=null&&Object.hasOwnProperty.call(m,"header"))$root.proto.QueryHeader.encode(m.header,w.uint32(10).fork()).ldelim();if(m.contractID!=null&&Object.hasOwnProperty.call(m,"contractID"))$root.proto.ContractID.encode(m.contractID,w.uint32(18).fork()).ldelim();return w;};ContractGetBytecodeQuery.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ContractGetBytecodeQuery();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.header=$root.proto.QueryHeader.decode(r,r.uint32());break;}case 2:{m.contractID=$root.proto.ContractID.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};ContractGetBytecodeQuery.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ContractGetBytecodeQuery";};return ContractGetBytecodeQuery;}();proto.ContractGetBytecodeResponse=function(){function ContractGetBytecodeResponse(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ContractGetBytecodeResponse.prototype.header=null;ContractGetBytecodeResponse.prototype.bytecode=$util.newBuffer([]);ContractGetBytecodeResponse.create=function create(properties){return new ContractGetBytecodeResponse(properties);};ContractGetBytecodeResponse.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.header!=null&&Object.hasOwnProperty.call(m,"header"))$root.proto.ResponseHeader.encode(m.header,w.uint32(10).fork()).ldelim();if(m.bytecode!=null&&Object.hasOwnProperty.call(m,"bytecode"))w.uint32(50).bytes(m.bytecode);return w;};ContractGetBytecodeResponse.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ContractGetBytecodeResponse();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.header=$root.proto.ResponseHeader.decode(r,r.uint32());break;}case 6:{m.bytecode=r.bytes();break;}default:r.skipType(t&7);break;}}return m;};ContractGetBytecodeResponse.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ContractGetBytecodeResponse";};return ContractGetBytecodeResponse;}();proto.ContractGetRecordsQuery=function(){function ContractGetRecordsQuery(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ContractGetRecordsQuery.prototype.header=null;ContractGetRecordsQuery.prototype.contractID=null;ContractGetRecordsQuery.create=function create(properties){return new ContractGetRecordsQuery(properties);};ContractGetRecordsQuery.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.header!=null&&Object.hasOwnProperty.call(m,"header"))$root.proto.QueryHeader.encode(m.header,w.uint32(10).fork()).ldelim();if(m.contractID!=null&&Object.hasOwnProperty.call(m,"contractID"))$root.proto.ContractID.encode(m.contractID,w.uint32(18).fork()).ldelim();return w;};ContractGetRecordsQuery.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ContractGetRecordsQuery();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.header=$root.proto.QueryHeader.decode(r,r.uint32());break;}case 2:{m.contractID=$root.proto.ContractID.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};ContractGetRecordsQuery.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ContractGetRecordsQuery";};return ContractGetRecordsQuery;}();proto.ContractGetRecordsResponse=function(){function ContractGetRecordsResponse(p){this.records=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ContractGetRecordsResponse.prototype.header=null;ContractGetRecordsResponse.prototype.contractID=null;ContractGetRecordsResponse.prototype.records=$util.emptyArray;ContractGetRecordsResponse.create=function create(properties){return new ContractGetRecordsResponse(properties);};ContractGetRecordsResponse.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.header!=null&&Object.hasOwnProperty.call(m,"header"))$root.proto.ResponseHeader.encode(m.header,w.uint32(10).fork()).ldelim();if(m.contractID!=null&&Object.hasOwnProperty.call(m,"contractID"))$root.proto.ContractID.encode(m.contractID,w.uint32(18).fork()).ldelim();if(m.records!=null&&m.records.length){for(var i=0;i<m.records.length;++i)$root.proto.TransactionRecord.encode(m.records[i],w.uint32(26).fork()).ldelim();}return w;};ContractGetRecordsResponse.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ContractGetRecordsResponse();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.header=$root.proto.ResponseHeader.decode(r,r.uint32());break;}case 2:{m.contractID=$root.proto.ContractID.decode(r,r.uint32());break;}case 3:{if(!(m.records&&m.records.length))m.records=[];m.records.push($root.proto.TransactionRecord.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};ContractGetRecordsResponse.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ContractGetRecordsResponse";};return ContractGetRecordsResponse;}();proto.TransactionRecord=function(){function TransactionRecord(p){this.tokenTransferLists=[];this.assessedCustomFees=[];this.automaticTokenAssociations=[];this.paidStakingRewards=[];this.newPendingAirdrops=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TransactionRecord.prototype.receipt=null;TransactionRecord.prototype.transactionHash=$util.newBuffer([]);TransactionRecord.prototype.consensusTimestamp=null;TransactionRecord.prototype.transactionID=null;TransactionRecord.prototype.memo="";TransactionRecord.prototype.transactionFee=$util.Long?$util.Long.fromBits(0,0,true):0;TransactionRecord.prototype.contractCallResult=null;TransactionRecord.prototype.contractCreateResult=null;TransactionRecord.prototype.transferList=null;TransactionRecord.prototype.tokenTransferLists=$util.emptyArray;TransactionRecord.prototype.scheduleRef=null;TransactionRecord.prototype.assessedCustomFees=$util.emptyArray;TransactionRecord.prototype.automaticTokenAssociations=$util.emptyArray;TransactionRecord.prototype.parentConsensusTimestamp=null;TransactionRecord.prototype.alias=$util.newBuffer([]);TransactionRecord.prototype.ethereumHash=$util.newBuffer([]);TransactionRecord.prototype.paidStakingRewards=$util.emptyArray;TransactionRecord.prototype.prngBytes=null;TransactionRecord.prototype.prngNumber=null;TransactionRecord.prototype.evmAddress=$util.newBuffer([]);TransactionRecord.prototype.newPendingAirdrops=$util.emptyArray;let $oneOfFields;Object.defineProperty(TransactionRecord.prototype,"body",{get:$util.oneOfGetter($oneOfFields=["contractCallResult","contractCreateResult"]),set:$util.oneOfSetter($oneOfFields)});Object.defineProperty(TransactionRecord.prototype,"entropy",{get:$util.oneOfGetter($oneOfFields=["prngBytes","prngNumber"]),set:$util.oneOfSetter($oneOfFields)});TransactionRecord.create=function create(properties){return new TransactionRecord(properties);};TransactionRecord.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.receipt!=null&&Object.hasOwnProperty.call(m,"receipt"))$root.proto.TransactionReceipt.encode(m.receipt,w.uint32(10).fork()).ldelim();if(m.transactionHash!=null&&Object.hasOwnProperty.call(m,"transactionHash"))w.uint32(18).bytes(m.transactionHash);if(m.consensusTimestamp!=null&&Object.hasOwnProperty.call(m,"consensusTimestamp"))$root.proto.Timestamp.encode(m.consensusTimestamp,w.uint32(26).fork()).ldelim();if(m.transactionID!=null&&Object.hasOwnProperty.call(m,"transactionID"))$root.proto.TransactionID.encode(m.transactionID,w.uint32(34).fork()).ldelim();if(m.memo!=null&&Object.hasOwnProperty.call(m,"memo"))w.uint32(42).string(m.memo);if(m.transactionFee!=null&&Object.hasOwnProperty.call(m,"transactionFee"))w.uint32(48).uint64(m.transactionFee);if(m.contractCallResult!=null&&Object.hasOwnProperty.call(m,"contractCallResult"))$root.proto.ContractFunctionResult.encode(m.contractCallResult,w.uint32(58).fork()).ldelim();if(m.contractCreateResult!=null&&Object.hasOwnProperty.call(m,"contractCreateResult"))$root.proto.ContractFunctionResult.encode(m.contractCreateResult,w.uint32(66).fork()).ldelim();if(m.transferList!=null&&Object.hasOwnProperty.call(m,"transferList"))$root.proto.TransferList.encode(m.transferList,w.uint32(82).fork()).ldelim();if(m.tokenTransferLists!=null&&m.tokenTransferLists.length){for(var i=0;i<m.tokenTransferLists.length;++i)$root.proto.TokenTransferList.encode(m.tokenTransferLists[i],w.uint32(90).fork()).ldelim();}if(m.scheduleRef!=null&&Object.hasOwnProperty.call(m,"scheduleRef"))$root.proto.ScheduleID.encode(m.scheduleRef,w.uint32(98).fork()).ldelim();if(m.assessedCustomFees!=null&&m.assessedCustomFees.length){for(var i=0;i<m.assessedCustomFees.length;++i)$root.proto.AssessedCustomFee.encode(m.assessedCustomFees[i],w.uint32(106).fork()).ldelim();}if(m.automaticTokenAssociations!=null&&m.automaticTokenAssociations.length){for(var i=0;i<m.automaticTokenAssociations.length;++i)$root.proto.TokenAssociation.encode(m.automaticTokenAssociations[i],w.uint32(114).fork()).ldelim();}if(m.parentConsensusTimestamp!=null&&Object.hasOwnProperty.call(m,"parentConsensusTimestamp"))$root.proto.Timestamp.encode(m.parentConsensusTimestamp,w.uint32(122).fork()).ldelim();if(m.alias!=null&&Object.hasOwnProperty.call(m,"alias"))w.uint32(130).bytes(m.alias);if(m.ethereumHash!=null&&Object.hasOwnProperty.call(m,"ethereumHash"))w.uint32(138).bytes(m.ethereumHash);if(m.paidStakingRewards!=null&&m.paidStakingRewards.length){for(var i=0;i<m.paidStakingRewards.length;++i)$root.proto.AccountAmount.encode(m.paidStakingRewards[i],w.uint32(146).fork()).ldelim();}if(m.prngBytes!=null&&Object.hasOwnProperty.call(m,"prngBytes"))w.uint32(154).bytes(m.prngBytes);if(m.prngNumber!=null&&Object.hasOwnProperty.call(m,"prngNumber"))w.uint32(160).int32(m.prngNumber);if(m.evmAddress!=null&&Object.hasOwnProperty.call(m,"evmAddress"))w.uint32(170).bytes(m.evmAddress);if(m.newPendingAirdrops!=null&&m.newPendingAirdrops.length){for(var i=0;i<m.newPendingAirdrops.length;++i)$root.proto.PendingAirdropRecord.encode(m.newPendingAirdrops[i],w.uint32(178).fork()).ldelim();}return w;};TransactionRecord.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TransactionRecord();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.receipt=$root.proto.TransactionReceipt.decode(r,r.uint32());break;}case 2:{m.transactionHash=r.bytes();break;}case 3:{m.consensusTimestamp=$root.proto.Timestamp.decode(r,r.uint32());break;}case 4:{m.transactionID=$root.proto.TransactionID.decode(r,r.uint32());break;}case 5:{m.memo=r.string();break;}case 6:{m.transactionFee=r.uint64();break;}case 7:{m.contractCallResult=$root.proto.ContractFunctionResult.decode(r,r.uint32());break;}case 8:{m.contractCreateResult=$root.proto.ContractFunctionResult.decode(r,r.uint32());break;}case 10:{m.transferList=$root.proto.TransferList.decode(r,r.uint32());break;}case 11:{if(!(m.tokenTransferLists&&m.tokenTransferLists.length))m.tokenTransferLists=[];m.tokenTransferLists.push($root.proto.TokenTransferList.decode(r,r.uint32()));break;}case 12:{m.scheduleRef=$root.proto.ScheduleID.decode(r,r.uint32());break;}case 13:{if(!(m.assessedCustomFees&&m.assessedCustomFees.length))m.assessedCustomFees=[];m.assessedCustomFees.push($root.proto.AssessedCustomFee.decode(r,r.uint32()));break;}case 14:{if(!(m.automaticTokenAssociations&&m.automaticTokenAssociations.length))m.automaticTokenAssociations=[];m.automaticTokenAssociations.push($root.proto.TokenAssociation.decode(r,r.uint32()));break;}case 15:{m.parentConsensusTimestamp=$root.proto.Timestamp.decode(r,r.uint32());break;}case 16:{m.alias=r.bytes();break;}case 17:{m.ethereumHash=r.bytes();break;}case 18:{if(!(m.paidStakingRewards&&m.paidStakingRewards.length))m.paidStakingRewards=[];m.paidStakingRewards.push($root.proto.AccountAmount.decode(r,r.uint32()));break;}case 19:{m.prngBytes=r.bytes();break;}case 20:{m.prngNumber=r.int32();break;}case 21:{m.evmAddress=r.bytes();break;}case 22:{if(!(m.newPendingAirdrops&&m.newPendingAirdrops.length))m.newPendingAirdrops=[];m.newPendingAirdrops.push($root.proto.PendingAirdropRecord.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};TransactionRecord.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TransactionRecord";};return TransactionRecord;}();proto.PendingAirdropRecord=function(){function PendingAirdropRecord(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}PendingAirdropRecord.prototype.pendingAirdropId=null;PendingAirdropRecord.prototype.pendingAirdropValue=null;PendingAirdropRecord.create=function create(properties){return new PendingAirdropRecord(properties);};PendingAirdropRecord.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.pendingAirdropId!=null&&Object.hasOwnProperty.call(m,"pendingAirdropId"))$root.proto.PendingAirdropId.encode(m.pendingAirdropId,w.uint32(10).fork()).ldelim();if(m.pendingAirdropValue!=null&&Object.hasOwnProperty.call(m,"pendingAirdropValue"))$root.proto.PendingAirdropValue.encode(m.pendingAirdropValue,w.uint32(18).fork()).ldelim();return w;};PendingAirdropRecord.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.PendingAirdropRecord();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.pendingAirdropId=$root.proto.PendingAirdropId.decode(r,r.uint32());break;}case 2:{m.pendingAirdropValue=$root.proto.PendingAirdropValue.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};PendingAirdropRecord.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.PendingAirdropRecord";};return PendingAirdropRecord;}();proto.TransactionReceipt=function(){function TransactionReceipt(p){this.serialNumbers=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TransactionReceipt.prototype.status=0;TransactionReceipt.prototype.accountID=null;TransactionReceipt.prototype.fileID=null;TransactionReceipt.prototype.contractID=null;TransactionReceipt.prototype.exchangeRate=null;TransactionReceipt.prototype.topicID=null;TransactionReceipt.prototype.topicSequenceNumber=$util.Long?$util.Long.fromBits(0,0,true):0;TransactionReceipt.prototype.topicRunningHash=$util.newBuffer([]);TransactionReceipt.prototype.topicRunningHashVersion=$util.Long?$util.Long.fromBits(0,0,true):0;TransactionReceipt.prototype.tokenID=null;TransactionReceipt.prototype.newTotalSupply=$util.Long?$util.Long.fromBits(0,0,true):0;TransactionReceipt.prototype.scheduleID=null;TransactionReceipt.prototype.scheduledTransactionID=null;TransactionReceipt.prototype.serialNumbers=$util.emptyArray;TransactionReceipt.prototype.nodeId=$util.Long?$util.Long.fromBits(0,0,true):0;TransactionReceipt.create=function create(properties){return new TransactionReceipt(properties);};TransactionReceipt.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.status!=null&&Object.hasOwnProperty.call(m,"status"))w.uint32(8).int32(m.status);if(m.accountID!=null&&Object.hasOwnProperty.call(m,"accountID"))$root.proto.AccountID.encode(m.accountID,w.uint32(18).fork()).ldelim();if(m.fileID!=null&&Object.hasOwnProperty.call(m,"fileID"))$root.proto.FileID.encode(m.fileID,w.uint32(26).fork()).ldelim();if(m.contractID!=null&&Object.hasOwnProperty.call(m,"contractID"))$root.proto.ContractID.encode(m.contractID,w.uint32(34).fork()).ldelim();if(m.exchangeRate!=null&&Object.hasOwnProperty.call(m,"exchangeRate"))$root.proto.ExchangeRateSet.encode(m.exchangeRate,w.uint32(42).fork()).ldelim();if(m.topicID!=null&&Object.hasOwnProperty.call(m,"topicID"))$root.proto.TopicID.encode(m.topicID,w.uint32(50).fork()).ldelim();if(m.topicSequenceNumber!=null&&Object.hasOwnProperty.call(m,"topicSequenceNumber"))w.uint32(56).uint64(m.topicSequenceNumber);if(m.topicRunningHash!=null&&Object.hasOwnProperty.call(m,"topicRunningHash"))w.uint32(66).bytes(m.topicRunningHash);if(m.topicRunningHashVersion!=null&&Object.hasOwnProperty.call(m,"topicRunningHashVersion"))w.uint32(72).uint64(m.topicRunningHashVersion);if(m.tokenID!=null&&Object.hasOwnProperty.call(m,"tokenID"))$root.proto.TokenID.encode(m.tokenID,w.uint32(82).fork()).ldelim();if(m.newTotalSupply!=null&&Object.hasOwnProperty.call(m,"newTotalSupply"))w.uint32(88).uint64(m.newTotalSupply);if(m.scheduleID!=null&&Object.hasOwnProperty.call(m,"scheduleID"))$root.proto.ScheduleID.encode(m.scheduleID,w.uint32(98).fork()).ldelim();if(m.scheduledTransactionID!=null&&Object.hasOwnProperty.call(m,"scheduledTransactionID"))$root.proto.TransactionID.encode(m.scheduledTransactionID,w.uint32(106).fork()).ldelim();if(m.serialNumbers!=null&&m.serialNumbers.length){w.uint32(114).fork();for(var i=0;i<m.serialNumbers.length;++i)w.int64(m.serialNumbers[i]);w.ldelim();}if(m.nodeId!=null&&Object.hasOwnProperty.call(m,"nodeId"))w.uint32(120).uint64(m.nodeId);return w;};TransactionReceipt.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TransactionReceipt();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.status=r.int32();break;}case 2:{m.accountID=$root.proto.AccountID.decode(r,r.uint32());break;}case 3:{m.fileID=$root.proto.FileID.decode(r,r.uint32());break;}case 4:{m.contractID=$root.proto.ContractID.decode(r,r.uint32());break;}case 5:{m.exchangeRate=$root.proto.ExchangeRateSet.decode(r,r.uint32());break;}case 6:{m.topicID=$root.proto.TopicID.decode(r,r.uint32());break;}case 7:{m.topicSequenceNumber=r.uint64();break;}case 8:{m.topicRunningHash=r.bytes();break;}case 9:{m.topicRunningHashVersion=r.uint64();break;}case 10:{m.tokenID=$root.proto.TokenID.decode(r,r.uint32());break;}case 11:{m.newTotalSupply=r.uint64();break;}case 12:{m.scheduleID=$root.proto.ScheduleID.decode(r,r.uint32());break;}case 13:{m.scheduledTransactionID=$root.proto.TransactionID.decode(r,r.uint32());break;}case 14:{if(!(m.serialNumbers&&m.serialNumbers.length))m.serialNumbers=[];if((t&7)===2){var c2=r.uint32()+r.pos;while(r.pos<c2)m.serialNumbers.push(r.int64());}else m.serialNumbers.push(r.int64());break;}case 15:{m.nodeId=r.uint64();break;}default:r.skipType(t&7);break;}}return m;};TransactionReceipt.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TransactionReceipt";};return TransactionReceipt;}();proto.ExchangeRate=function(){function ExchangeRate(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ExchangeRate.prototype.hbarEquiv=0;ExchangeRate.prototype.centEquiv=0;ExchangeRate.prototype.expirationTime=null;ExchangeRate.create=function create(properties){return new ExchangeRate(properties);};ExchangeRate.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.hbarEquiv!=null&&Object.hasOwnProperty.call(m,"hbarEquiv"))w.uint32(8).int32(m.hbarEquiv);if(m.centEquiv!=null&&Object.hasOwnProperty.call(m,"centEquiv"))w.uint32(16).int32(m.centEquiv);if(m.expirationTime!=null&&Object.hasOwnProperty.call(m,"expirationTime"))$root.proto.TimestampSeconds.encode(m.expirationTime,w.uint32(26).fork()).ldelim();return w;};ExchangeRate.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ExchangeRate();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.hbarEquiv=r.int32();break;}case 2:{m.centEquiv=r.int32();break;}case 3:{m.expirationTime=$root.proto.TimestampSeconds.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};ExchangeRate.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ExchangeRate";};return ExchangeRate;}();proto.ExchangeRateSet=function(){function ExchangeRateSet(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ExchangeRateSet.prototype.currentRate=null;ExchangeRateSet.prototype.nextRate=null;ExchangeRateSet.create=function create(properties){return new ExchangeRateSet(properties);};ExchangeRateSet.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.currentRate!=null&&Object.hasOwnProperty.call(m,"currentRate"))$root.proto.ExchangeRate.encode(m.currentRate,w.uint32(10).fork()).ldelim();if(m.nextRate!=null&&Object.hasOwnProperty.call(m,"nextRate"))$root.proto.ExchangeRate.encode(m.nextRate,w.uint32(18).fork()).ldelim();return w;};ExchangeRateSet.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ExchangeRateSet();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.currentRate=$root.proto.ExchangeRate.decode(r,r.uint32());break;}case 2:{m.nextRate=$root.proto.ExchangeRate.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};ExchangeRateSet.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ExchangeRateSet";};return ExchangeRateSet;}();proto.CryptoGetAccountBalanceQuery=function(){function CryptoGetAccountBalanceQuery(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}CryptoGetAccountBalanceQuery.prototype.header=null;CryptoGetAccountBalanceQuery.prototype.accountID=null;CryptoGetAccountBalanceQuery.prototype.contractID=null;let $oneOfFields;Object.defineProperty(CryptoGetAccountBalanceQuery.prototype,"balanceSource",{get:$util.oneOfGetter($oneOfFields=["accountID","contractID"]),set:$util.oneOfSetter($oneOfFields)});CryptoGetAccountBalanceQuery.create=function create(properties){return new CryptoGetAccountBalanceQuery(properties);};CryptoGetAccountBalanceQuery.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.header!=null&&Object.hasOwnProperty.call(m,"header"))$root.proto.QueryHeader.encode(m.header,w.uint32(10).fork()).ldelim();if(m.accountID!=null&&Object.hasOwnProperty.call(m,"accountID"))$root.proto.AccountID.encode(m.accountID,w.uint32(18).fork()).ldelim();if(m.contractID!=null&&Object.hasOwnProperty.call(m,"contractID"))$root.proto.ContractID.encode(m.contractID,w.uint32(26).fork()).ldelim();return w;};CryptoGetAccountBalanceQuery.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.CryptoGetAccountBalanceQuery();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.header=$root.proto.QueryHeader.decode(r,r.uint32());break;}case 2:{m.accountID=$root.proto.AccountID.decode(r,r.uint32());break;}case 3:{m.contractID=$root.proto.ContractID.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};CryptoGetAccountBalanceQuery.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.CryptoGetAccountBalanceQuery";};return CryptoGetAccountBalanceQuery;}();proto.CryptoGetAccountBalanceResponse=function(){function CryptoGetAccountBalanceResponse(p){this.tokenBalances=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}CryptoGetAccountBalanceResponse.prototype.header=null;CryptoGetAccountBalanceResponse.prototype.accountID=null;CryptoGetAccountBalanceResponse.prototype.balance=$util.Long?$util.Long.fromBits(0,0,true):0;CryptoGetAccountBalanceResponse.prototype.tokenBalances=$util.emptyArray;CryptoGetAccountBalanceResponse.create=function create(properties){return new CryptoGetAccountBalanceResponse(properties);};CryptoGetAccountBalanceResponse.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.header!=null&&Object.hasOwnProperty.call(m,"header"))$root.proto.ResponseHeader.encode(m.header,w.uint32(10).fork()).ldelim();if(m.accountID!=null&&Object.hasOwnProperty.call(m,"accountID"))$root.proto.AccountID.encode(m.accountID,w.uint32(18).fork()).ldelim();if(m.balance!=null&&Object.hasOwnProperty.call(m,"balance"))w.uint32(24).uint64(m.balance);if(m.tokenBalances!=null&&m.tokenBalances.length){for(var i=0;i<m.tokenBalances.length;++i)$root.proto.TokenBalance.encode(m.tokenBalances[i],w.uint32(34).fork()).ldelim();}return w;};CryptoGetAccountBalanceResponse.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.CryptoGetAccountBalanceResponse();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.header=$root.proto.ResponseHeader.decode(r,r.uint32());break;}case 2:{m.accountID=$root.proto.AccountID.decode(r,r.uint32());break;}case 3:{m.balance=r.uint64();break;}case 4:{if(!(m.tokenBalances&&m.tokenBalances.length))m.tokenBalances=[];m.tokenBalances.push($root.proto.TokenBalance.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};CryptoGetAccountBalanceResponse.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.CryptoGetAccountBalanceResponse";};return CryptoGetAccountBalanceResponse;}();proto.CryptoGetAccountRecordsQuery=function(){function CryptoGetAccountRecordsQuery(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}CryptoGetAccountRecordsQuery.prototype.header=null;CryptoGetAccountRecordsQuery.prototype.accountID=null;CryptoGetAccountRecordsQuery.create=function create(properties){return new CryptoGetAccountRecordsQuery(properties);};CryptoGetAccountRecordsQuery.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.header!=null&&Object.hasOwnProperty.call(m,"header"))$root.proto.QueryHeader.encode(m.header,w.uint32(10).fork()).ldelim();if(m.accountID!=null&&Object.hasOwnProperty.call(m,"accountID"))$root.proto.AccountID.encode(m.accountID,w.uint32(18).fork()).ldelim();return w;};CryptoGetAccountRecordsQuery.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.CryptoGetAccountRecordsQuery();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.header=$root.proto.QueryHeader.decode(r,r.uint32());break;}case 2:{m.accountID=$root.proto.AccountID.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};CryptoGetAccountRecordsQuery.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.CryptoGetAccountRecordsQuery";};return CryptoGetAccountRecordsQuery;}();proto.CryptoGetAccountRecordsResponse=function(){function CryptoGetAccountRecordsResponse(p){this.records=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}CryptoGetAccountRecordsResponse.prototype.header=null;CryptoGetAccountRecordsResponse.prototype.accountID=null;CryptoGetAccountRecordsResponse.prototype.records=$util.emptyArray;CryptoGetAccountRecordsResponse.create=function create(properties){return new CryptoGetAccountRecordsResponse(properties);};CryptoGetAccountRecordsResponse.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.header!=null&&Object.hasOwnProperty.call(m,"header"))$root.proto.ResponseHeader.encode(m.header,w.uint32(10).fork()).ldelim();if(m.accountID!=null&&Object.hasOwnProperty.call(m,"accountID"))$root.proto.AccountID.encode(m.accountID,w.uint32(18).fork()).ldelim();if(m.records!=null&&m.records.length){for(var i=0;i<m.records.length;++i)$root.proto.TransactionRecord.encode(m.records[i],w.uint32(26).fork()).ldelim();}return w;};CryptoGetAccountRecordsResponse.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.CryptoGetAccountRecordsResponse();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.header=$root.proto.ResponseHeader.decode(r,r.uint32());break;}case 2:{m.accountID=$root.proto.AccountID.decode(r,r.uint32());break;}case 3:{if(!(m.records&&m.records.length))m.records=[];m.records.push($root.proto.TransactionRecord.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};CryptoGetAccountRecordsResponse.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.CryptoGetAccountRecordsResponse";};return CryptoGetAccountRecordsResponse;}();proto.CryptoGetInfoQuery=function(){function CryptoGetInfoQuery(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}CryptoGetInfoQuery.prototype.header=null;CryptoGetInfoQuery.prototype.accountID=null;CryptoGetInfoQuery.create=function create(properties){return new CryptoGetInfoQuery(properties);};CryptoGetInfoQuery.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.header!=null&&Object.hasOwnProperty.call(m,"header"))$root.proto.QueryHeader.encode(m.header,w.uint32(10).fork()).ldelim();if(m.accountID!=null&&Object.hasOwnProperty.call(m,"accountID"))$root.proto.AccountID.encode(m.accountID,w.uint32(18).fork()).ldelim();return w;};CryptoGetInfoQuery.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.CryptoGetInfoQuery();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.header=$root.proto.QueryHeader.decode(r,r.uint32());break;}case 2:{m.accountID=$root.proto.AccountID.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};CryptoGetInfoQuery.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.CryptoGetInfoQuery";};return CryptoGetInfoQuery;}();proto.CryptoGetInfoResponse=function(){function CryptoGetInfoResponse(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}CryptoGetInfoResponse.prototype.header=null;CryptoGetInfoResponse.prototype.accountInfo=null;CryptoGetInfoResponse.create=function create(properties){return new CryptoGetInfoResponse(properties);};CryptoGetInfoResponse.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.header!=null&&Object.hasOwnProperty.call(m,"header"))$root.proto.ResponseHeader.encode(m.header,w.uint32(10).fork()).ldelim();if(m.accountInfo!=null&&Object.hasOwnProperty.call(m,"accountInfo"))$root.proto.CryptoGetInfoResponse.AccountInfo.encode(m.accountInfo,w.uint32(18).fork()).ldelim();return w;};CryptoGetInfoResponse.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.CryptoGetInfoResponse();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.header=$root.proto.ResponseHeader.decode(r,r.uint32());break;}case 2:{m.accountInfo=$root.proto.CryptoGetInfoResponse.AccountInfo.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};CryptoGetInfoResponse.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.CryptoGetInfoResponse";};CryptoGetInfoResponse.AccountInfo=function(){function AccountInfo(p){this.liveHashes=[];this.tokenRelationships=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}AccountInfo.prototype.accountID=null;AccountInfo.prototype.contractAccountID="";AccountInfo.prototype.deleted=false;AccountInfo.prototype.proxyAccountID=null;AccountInfo.prototype.proxyReceived=$util.Long?$util.Long.fromBits(0,0,false):0;AccountInfo.prototype.key=null;AccountInfo.prototype.balance=$util.Long?$util.Long.fromBits(0,0,true):0;AccountInfo.prototype.generateSendRecordThreshold=$util.Long?$util.Long.fromBits(0,0,true):0;AccountInfo.prototype.generateReceiveRecordThreshold=$util.Long?$util.Long.fromBits(0,0,true):0;AccountInfo.prototype.receiverSigRequired=false;AccountInfo.prototype.expirationTime=null;AccountInfo.prototype.autoRenewPeriod=null;AccountInfo.prototype.liveHashes=$util.emptyArray;AccountInfo.prototype.tokenRelationships=$util.emptyArray;AccountInfo.prototype.memo="";AccountInfo.prototype.ownedNfts=$util.Long?$util.Long.fromBits(0,0,false):0;AccountInfo.prototype.maxAutomaticTokenAssociations=0;AccountInfo.prototype.alias=$util.newBuffer([]);AccountInfo.prototype.ledgerId=$util.newBuffer([]);AccountInfo.prototype.ethereumNonce=$util.Long?$util.Long.fromBits(0,0,false):0;AccountInfo.prototype.stakingInfo=null;AccountInfo.create=function create(properties){return new AccountInfo(properties);};AccountInfo.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.accountID!=null&&Object.hasOwnProperty.call(m,"accountID"))$root.proto.AccountID.encode(m.accountID,w.uint32(10).fork()).ldelim();if(m.contractAccountID!=null&&Object.hasOwnProperty.call(m,"contractAccountID"))w.uint32(18).string(m.contractAccountID);if(m.deleted!=null&&Object.hasOwnProperty.call(m,"deleted"))w.uint32(24).bool(m.deleted);if(m.proxyAccountID!=null&&Object.hasOwnProperty.call(m,"proxyAccountID"))$root.proto.AccountID.encode(m.proxyAccountID,w.uint32(34).fork()).ldelim();if(m.proxyReceived!=null&&Object.hasOwnProperty.call(m,"proxyReceived"))w.uint32(48).int64(m.proxyReceived);if(m.key!=null&&Object.hasOwnProperty.call(m,"key"))$root.proto.Key.encode(m.key,w.uint32(58).fork()).ldelim();if(m.balance!=null&&Object.hasOwnProperty.call(m,"balance"))w.uint32(64).uint64(m.balance);if(m.generateSendRecordThreshold!=null&&Object.hasOwnProperty.call(m,"generateSendRecordThreshold"))w.uint32(72).uint64(m.generateSendRecordThreshold);if(m.generateReceiveRecordThreshold!=null&&Object.hasOwnProperty.call(m,"generateReceiveRecordThreshold"))w.uint32(80).uint64(m.generateReceiveRecordThreshold);if(m.receiverSigRequired!=null&&Object.hasOwnProperty.call(m,"receiverSigRequired"))w.uint32(88).bool(m.receiverSigRequired);if(m.expirationTime!=null&&Object.hasOwnProperty.call(m,"expirationTime"))$root.proto.Timestamp.encode(m.expirationTime,w.uint32(98).fork()).ldelim();if(m.autoRenewPeriod!=null&&Object.hasOwnProperty.call(m,"autoRenewPeriod"))$root.proto.Duration.encode(m.autoRenewPeriod,w.uint32(106).fork()).ldelim();if(m.liveHashes!=null&&m.liveHashes.length){for(var i=0;i<m.liveHashes.length;++i)$root.proto.LiveHash.encode(m.liveHashes[i],w.uint32(114).fork()).ldelim();}if(m.tokenRelationships!=null&&m.tokenRelationships.length){for(var i=0;i<m.tokenRelationships.length;++i)$root.proto.TokenRelationship.encode(m.tokenRelationships[i],w.uint32(122).fork()).ldelim();}if(m.memo!=null&&Object.hasOwnProperty.call(m,"memo"))w.uint32(130).string(m.memo);if(m.ownedNfts!=null&&Object.hasOwnProperty.call(m,"ownedNfts"))w.uint32(136).int64(m.ownedNfts);if(m.maxAutomaticTokenAssociations!=null&&Object.hasOwnProperty.call(m,"maxAutomaticTokenAssociations"))w.uint32(144).int32(m.maxAutomaticTokenAssociations);if(m.alias!=null&&Object.hasOwnProperty.call(m,"alias"))w.uint32(154).bytes(m.alias);if(m.ledgerId!=null&&Object.hasOwnProperty.call(m,"ledgerId"))w.uint32(162).bytes(m.ledgerId);if(m.ethereumNonce!=null&&Object.hasOwnProperty.call(m,"ethereumNonce"))w.uint32(168).int64(m.ethereumNonce);if(m.stakingInfo!=null&&Object.hasOwnProperty.call(m,"stakingInfo"))$root.proto.StakingInfo.encode(m.stakingInfo,w.uint32(178).fork()).ldelim();return w;};AccountInfo.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.CryptoGetInfoResponse.AccountInfo();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.accountID=$root.proto.AccountID.decode(r,r.uint32());break;}case 2:{m.contractAccountID=r.string();break;}case 3:{m.deleted=r.bool();break;}case 4:{m.proxyAccountID=$root.proto.AccountID.decode(r,r.uint32());break;}case 6:{m.proxyReceived=r.int64();break;}case 7:{m.key=$root.proto.Key.decode(r,r.uint32());break;}case 8:{m.balance=r.uint64();break;}case 9:{m.generateSendRecordThreshold=r.uint64();break;}case 10:{m.generateReceiveRecordThreshold=r.uint64();break;}case 11:{m.receiverSigRequired=r.bool();break;}case 12:{m.expirationTime=$root.proto.Timestamp.decode(r,r.uint32());break;}case 13:{m.autoRenewPeriod=$root.proto.Duration.decode(r,r.uint32());break;}case 14:{if(!(m.liveHashes&&m.liveHashes.length))m.liveHashes=[];m.liveHashes.push($root.proto.LiveHash.decode(r,r.uint32()));break;}case 15:{if(!(m.tokenRelationships&&m.tokenRelationships.length))m.tokenRelationships=[];m.tokenRelationships.push($root.proto.TokenRelationship.decode(r,r.uint32()));break;}case 16:{m.memo=r.string();break;}case 17:{m.ownedNfts=r.int64();break;}case 18:{m.maxAutomaticTokenAssociations=r.int32();break;}case 19:{m.alias=r.bytes();break;}case 20:{m.ledgerId=r.bytes();break;}case 21:{m.ethereumNonce=r.int64();break;}case 22:{m.stakingInfo=$root.proto.StakingInfo.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};AccountInfo.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.CryptoGetInfoResponse.AccountInfo";};return AccountInfo;}();return CryptoGetInfoResponse;}();proto.CryptoGetLiveHashQuery=function(){function CryptoGetLiveHashQuery(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}CryptoGetLiveHashQuery.prototype.header=null;CryptoGetLiveHashQuery.prototype.accountID=null;CryptoGetLiveHashQuery.prototype.hash=$util.newBuffer([]);CryptoGetLiveHashQuery.create=function create(properties){return new CryptoGetLiveHashQuery(properties);};CryptoGetLiveHashQuery.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.header!=null&&Object.hasOwnProperty.call(m,"header"))$root.proto.QueryHeader.encode(m.header,w.uint32(10).fork()).ldelim();if(m.accountID!=null&&Object.hasOwnProperty.call(m,"accountID"))$root.proto.AccountID.encode(m.accountID,w.uint32(18).fork()).ldelim();if(m.hash!=null&&Object.hasOwnProperty.call(m,"hash"))w.uint32(26).bytes(m.hash);return w;};CryptoGetLiveHashQuery.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.CryptoGetLiveHashQuery();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.header=$root.proto.QueryHeader.decode(r,r.uint32());break;}case 2:{m.accountID=$root.proto.AccountID.decode(r,r.uint32());break;}case 3:{m.hash=r.bytes();break;}default:r.skipType(t&7);break;}}return m;};CryptoGetLiveHashQuery.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.CryptoGetLiveHashQuery";};return CryptoGetLiveHashQuery;}();proto.CryptoGetLiveHashResponse=function(){function CryptoGetLiveHashResponse(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}CryptoGetLiveHashResponse.prototype.header=null;CryptoGetLiveHashResponse.prototype.liveHash=null;CryptoGetLiveHashResponse.create=function create(properties){return new CryptoGetLiveHashResponse(properties);};CryptoGetLiveHashResponse.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.header!=null&&Object.hasOwnProperty.call(m,"header"))$root.proto.ResponseHeader.encode(m.header,w.uint32(10).fork()).ldelim();if(m.liveHash!=null&&Object.hasOwnProperty.call(m,"liveHash"))$root.proto.LiveHash.encode(m.liveHash,w.uint32(18).fork()).ldelim();return w;};CryptoGetLiveHashResponse.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.CryptoGetLiveHashResponse();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.header=$root.proto.ResponseHeader.decode(r,r.uint32());break;}case 2:{m.liveHash=$root.proto.LiveHash.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};CryptoGetLiveHashResponse.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.CryptoGetLiveHashResponse";};return CryptoGetLiveHashResponse;}();proto.CryptoGetStakersQuery=function(){function CryptoGetStakersQuery(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}CryptoGetStakersQuery.prototype.header=null;CryptoGetStakersQuery.prototype.accountID=null;CryptoGetStakersQuery.create=function create(properties){return new CryptoGetStakersQuery(properties);};CryptoGetStakersQuery.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.header!=null&&Object.hasOwnProperty.call(m,"header"))$root.proto.QueryHeader.encode(m.header,w.uint32(10).fork()).ldelim();if(m.accountID!=null&&Object.hasOwnProperty.call(m,"accountID"))$root.proto.AccountID.encode(m.accountID,w.uint32(18).fork()).ldelim();return w;};CryptoGetStakersQuery.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.CryptoGetStakersQuery();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.header=$root.proto.QueryHeader.decode(r,r.uint32());break;}case 2:{m.accountID=$root.proto.AccountID.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};CryptoGetStakersQuery.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.CryptoGetStakersQuery";};return CryptoGetStakersQuery;}();proto.ProxyStaker=function(){function ProxyStaker(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ProxyStaker.prototype.accountID=null;ProxyStaker.prototype.amount=$util.Long?$util.Long.fromBits(0,0,false):0;ProxyStaker.create=function create(properties){return new ProxyStaker(properties);};ProxyStaker.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.accountID!=null&&Object.hasOwnProperty.call(m,"accountID"))$root.proto.AccountID.encode(m.accountID,w.uint32(10).fork()).ldelim();if(m.amount!=null&&Object.hasOwnProperty.call(m,"amount"))w.uint32(16).int64(m.amount);return w;};ProxyStaker.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ProxyStaker();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.accountID=$root.proto.AccountID.decode(r,r.uint32());break;}case 2:{m.amount=r.int64();break;}default:r.skipType(t&7);break;}}return m;};ProxyStaker.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ProxyStaker";};return ProxyStaker;}();proto.AllProxyStakers=function(){function AllProxyStakers(p){this.proxyStaker=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}AllProxyStakers.prototype.accountID=null;AllProxyStakers.prototype.proxyStaker=$util.emptyArray;AllProxyStakers.create=function create(properties){return new AllProxyStakers(properties);};AllProxyStakers.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.accountID!=null&&Object.hasOwnProperty.call(m,"accountID"))$root.proto.AccountID.encode(m.accountID,w.uint32(10).fork()).ldelim();if(m.proxyStaker!=null&&m.proxyStaker.length){for(var i=0;i<m.proxyStaker.length;++i)$root.proto.ProxyStaker.encode(m.proxyStaker[i],w.uint32(18).fork()).ldelim();}return w;};AllProxyStakers.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.AllProxyStakers();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.accountID=$root.proto.AccountID.decode(r,r.uint32());break;}case 2:{if(!(m.proxyStaker&&m.proxyStaker.length))m.proxyStaker=[];m.proxyStaker.push($root.proto.ProxyStaker.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};AllProxyStakers.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.AllProxyStakers";};return AllProxyStakers;}();proto.CryptoGetStakersResponse=function(){function CryptoGetStakersResponse(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}CryptoGetStakersResponse.prototype.header=null;CryptoGetStakersResponse.prototype.stakers=null;CryptoGetStakersResponse.create=function create(properties){return new CryptoGetStakersResponse(properties);};CryptoGetStakersResponse.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.header!=null&&Object.hasOwnProperty.call(m,"header"))$root.proto.ResponseHeader.encode(m.header,w.uint32(10).fork()).ldelim();if(m.stakers!=null&&Object.hasOwnProperty.call(m,"stakers"))$root.proto.AllProxyStakers.encode(m.stakers,w.uint32(26).fork()).ldelim();return w;};CryptoGetStakersResponse.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.CryptoGetStakersResponse();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.header=$root.proto.ResponseHeader.decode(r,r.uint32());break;}case 3:{m.stakers=$root.proto.AllProxyStakers.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};CryptoGetStakersResponse.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.CryptoGetStakersResponse";};return CryptoGetStakersResponse;}();proto.FileGetContentsQuery=function(){function FileGetContentsQuery(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}FileGetContentsQuery.prototype.header=null;FileGetContentsQuery.prototype.fileID=null;FileGetContentsQuery.create=function create(properties){return new FileGetContentsQuery(properties);};FileGetContentsQuery.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.header!=null&&Object.hasOwnProperty.call(m,"header"))$root.proto.QueryHeader.encode(m.header,w.uint32(10).fork()).ldelim();if(m.fileID!=null&&Object.hasOwnProperty.call(m,"fileID"))$root.proto.FileID.encode(m.fileID,w.uint32(18).fork()).ldelim();return w;};FileGetContentsQuery.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.FileGetContentsQuery();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.header=$root.proto.QueryHeader.decode(r,r.uint32());break;}case 2:{m.fileID=$root.proto.FileID.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};FileGetContentsQuery.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.FileGetContentsQuery";};return FileGetContentsQuery;}();proto.FileGetContentsResponse=function(){function FileGetContentsResponse(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}FileGetContentsResponse.prototype.header=null;FileGetContentsResponse.prototype.fileContents=null;FileGetContentsResponse.create=function create(properties){return new FileGetContentsResponse(properties);};FileGetContentsResponse.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.header!=null&&Object.hasOwnProperty.call(m,"header"))$root.proto.ResponseHeader.encode(m.header,w.uint32(10).fork()).ldelim();if(m.fileContents!=null&&Object.hasOwnProperty.call(m,"fileContents"))$root.proto.FileGetContentsResponse.FileContents.encode(m.fileContents,w.uint32(18).fork()).ldelim();return w;};FileGetContentsResponse.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.FileGetContentsResponse();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.header=$root.proto.ResponseHeader.decode(r,r.uint32());break;}case 2:{m.fileContents=$root.proto.FileGetContentsResponse.FileContents.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};FileGetContentsResponse.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.FileGetContentsResponse";};FileGetContentsResponse.FileContents=function(){function FileContents(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}FileContents.prototype.fileID=null;FileContents.prototype.contents=$util.newBuffer([]);FileContents.create=function create(properties){return new FileContents(properties);};FileContents.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.fileID!=null&&Object.hasOwnProperty.call(m,"fileID"))$root.proto.FileID.encode(m.fileID,w.uint32(10).fork()).ldelim();if(m.contents!=null&&Object.hasOwnProperty.call(m,"contents"))w.uint32(18).bytes(m.contents);return w;};FileContents.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.FileGetContentsResponse.FileContents();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.fileID=$root.proto.FileID.decode(r,r.uint32());break;}case 2:{m.contents=r.bytes();break;}default:r.skipType(t&7);break;}}return m;};FileContents.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.FileGetContentsResponse.FileContents";};return FileContents;}();return FileGetContentsResponse;}();proto.FileGetInfoQuery=function(){function FileGetInfoQuery(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}FileGetInfoQuery.prototype.header=null;FileGetInfoQuery.prototype.fileID=null;FileGetInfoQuery.create=function create(properties){return new FileGetInfoQuery(properties);};FileGetInfoQuery.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.header!=null&&Object.hasOwnProperty.call(m,"header"))$root.proto.QueryHeader.encode(m.header,w.uint32(10).fork()).ldelim();if(m.fileID!=null&&Object.hasOwnProperty.call(m,"fileID"))$root.proto.FileID.encode(m.fileID,w.uint32(18).fork()).ldelim();return w;};FileGetInfoQuery.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.FileGetInfoQuery();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.header=$root.proto.QueryHeader.decode(r,r.uint32());break;}case 2:{m.fileID=$root.proto.FileID.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};FileGetInfoQuery.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.FileGetInfoQuery";};return FileGetInfoQuery;}();proto.FileGetInfoResponse=function(){function FileGetInfoResponse(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}FileGetInfoResponse.prototype.header=null;FileGetInfoResponse.prototype.fileInfo=null;FileGetInfoResponse.create=function create(properties){return new FileGetInfoResponse(properties);};FileGetInfoResponse.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.header!=null&&Object.hasOwnProperty.call(m,"header"))$root.proto.ResponseHeader.encode(m.header,w.uint32(10).fork()).ldelim();if(m.fileInfo!=null&&Object.hasOwnProperty.call(m,"fileInfo"))$root.proto.FileGetInfoResponse.FileInfo.encode(m.fileInfo,w.uint32(18).fork()).ldelim();return w;};FileGetInfoResponse.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.FileGetInfoResponse();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.header=$root.proto.ResponseHeader.decode(r,r.uint32());break;}case 2:{m.fileInfo=$root.proto.FileGetInfoResponse.FileInfo.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};FileGetInfoResponse.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.FileGetInfoResponse";};FileGetInfoResponse.FileInfo=function(){function FileInfo(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}FileInfo.prototype.fileID=null;FileInfo.prototype.size=$util.Long?$util.Long.fromBits(0,0,false):0;FileInfo.prototype.expirationTime=null;FileInfo.prototype.deleted=false;FileInfo.prototype.keys=null;FileInfo.prototype.memo="";FileInfo.prototype.ledgerId=$util.newBuffer([]);FileInfo.create=function create(properties){return new FileInfo(properties);};FileInfo.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.fileID!=null&&Object.hasOwnProperty.call(m,"fileID"))$root.proto.FileID.encode(m.fileID,w.uint32(10).fork()).ldelim();if(m.size!=null&&Object.hasOwnProperty.call(m,"size"))w.uint32(16).int64(m.size);if(m.expirationTime!=null&&Object.hasOwnProperty.call(m,"expirationTime"))$root.proto.Timestamp.encode(m.expirationTime,w.uint32(26).fork()).ldelim();if(m.deleted!=null&&Object.hasOwnProperty.call(m,"deleted"))w.uint32(32).bool(m.deleted);if(m.keys!=null&&Object.hasOwnProperty.call(m,"keys"))$root.proto.KeyList.encode(m.keys,w.uint32(42).fork()).ldelim();if(m.memo!=null&&Object.hasOwnProperty.call(m,"memo"))w.uint32(50).string(m.memo);if(m.ledgerId!=null&&Object.hasOwnProperty.call(m,"ledgerId"))w.uint32(58).bytes(m.ledgerId);return w;};FileInfo.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.FileGetInfoResponse.FileInfo();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.fileID=$root.proto.FileID.decode(r,r.uint32());break;}case 2:{m.size=r.int64();break;}case 3:{m.expirationTime=$root.proto.Timestamp.decode(r,r.uint32());break;}case 4:{m.deleted=r.bool();break;}case 5:{m.keys=$root.proto.KeyList.decode(r,r.uint32());break;}case 6:{m.memo=r.string();break;}case 7:{m.ledgerId=r.bytes();break;}default:r.skipType(t&7);break;}}return m;};FileInfo.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.FileGetInfoResponse.FileInfo";};return FileInfo;}();return FileGetInfoResponse;}();proto.TransactionGetReceiptQuery=function(){function TransactionGetReceiptQuery(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TransactionGetReceiptQuery.prototype.header=null;TransactionGetReceiptQuery.prototype.transactionID=null;TransactionGetReceiptQuery.prototype.includeDuplicates=false;TransactionGetReceiptQuery.prototype.includeChildReceipts=false;TransactionGetReceiptQuery.create=function create(properties){return new TransactionGetReceiptQuery(properties);};TransactionGetReceiptQuery.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.header!=null&&Object.hasOwnProperty.call(m,"header"))$root.proto.QueryHeader.encode(m.header,w.uint32(10).fork()).ldelim();if(m.transactionID!=null&&Object.hasOwnProperty.call(m,"transactionID"))$root.proto.TransactionID.encode(m.transactionID,w.uint32(18).fork()).ldelim();if(m.includeDuplicates!=null&&Object.hasOwnProperty.call(m,"includeDuplicates"))w.uint32(24).bool(m.includeDuplicates);if(m.includeChildReceipts!=null&&Object.hasOwnProperty.call(m,"includeChildReceipts"))w.uint32(32).bool(m.includeChildReceipts);return w;};TransactionGetReceiptQuery.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TransactionGetReceiptQuery();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.header=$root.proto.QueryHeader.decode(r,r.uint32());break;}case 2:{m.transactionID=$root.proto.TransactionID.decode(r,r.uint32());break;}case 3:{m.includeDuplicates=r.bool();break;}case 4:{m.includeChildReceipts=r.bool();break;}default:r.skipType(t&7);break;}}return m;};TransactionGetReceiptQuery.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TransactionGetReceiptQuery";};return TransactionGetReceiptQuery;}();proto.TransactionGetReceiptResponse=function(){function TransactionGetReceiptResponse(p){this.duplicateTransactionReceipts=[];this.childTransactionReceipts=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TransactionGetReceiptResponse.prototype.header=null;TransactionGetReceiptResponse.prototype.receipt=null;TransactionGetReceiptResponse.prototype.duplicateTransactionReceipts=$util.emptyArray;TransactionGetReceiptResponse.prototype.childTransactionReceipts=$util.emptyArray;TransactionGetReceiptResponse.create=function create(properties){return new TransactionGetReceiptResponse(properties);};TransactionGetReceiptResponse.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.header!=null&&Object.hasOwnProperty.call(m,"header"))$root.proto.ResponseHeader.encode(m.header,w.uint32(10).fork()).ldelim();if(m.receipt!=null&&Object.hasOwnProperty.call(m,"receipt"))$root.proto.TransactionReceipt.encode(m.receipt,w.uint32(18).fork()).ldelim();if(m.duplicateTransactionReceipts!=null&&m.duplicateTransactionReceipts.length){for(var i=0;i<m.duplicateTransactionReceipts.length;++i)$root.proto.TransactionReceipt.encode(m.duplicateTransactionReceipts[i],w.uint32(34).fork()).ldelim();}if(m.childTransactionReceipts!=null&&m.childTransactionReceipts.length){for(var i=0;i<m.childTransactionReceipts.length;++i)$root.proto.TransactionReceipt.encode(m.childTransactionReceipts[i],w.uint32(42).fork()).ldelim();}return w;};TransactionGetReceiptResponse.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TransactionGetReceiptResponse();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.header=$root.proto.ResponseHeader.decode(r,r.uint32());break;}case 2:{m.receipt=$root.proto.TransactionReceipt.decode(r,r.uint32());break;}case 4:{if(!(m.duplicateTransactionReceipts&&m.duplicateTransactionReceipts.length))m.duplicateTransactionReceipts=[];m.duplicateTransactionReceipts.push($root.proto.TransactionReceipt.decode(r,r.uint32()));break;}case 5:{if(!(m.childTransactionReceipts&&m.childTransactionReceipts.length))m.childTransactionReceipts=[];m.childTransactionReceipts.push($root.proto.TransactionReceipt.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};TransactionGetReceiptResponse.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TransactionGetReceiptResponse";};return TransactionGetReceiptResponse;}();proto.TransactionGetRecordQuery=function(){function TransactionGetRecordQuery(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TransactionGetRecordQuery.prototype.header=null;TransactionGetRecordQuery.prototype.transactionID=null;TransactionGetRecordQuery.prototype.includeDuplicates=false;TransactionGetRecordQuery.prototype.includeChildRecords=false;TransactionGetRecordQuery.create=function create(properties){return new TransactionGetRecordQuery(properties);};TransactionGetRecordQuery.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.header!=null&&Object.hasOwnProperty.call(m,"header"))$root.proto.QueryHeader.encode(m.header,w.uint32(10).fork()).ldelim();if(m.transactionID!=null&&Object.hasOwnProperty.call(m,"transactionID"))$root.proto.TransactionID.encode(m.transactionID,w.uint32(18).fork()).ldelim();if(m.includeDuplicates!=null&&Object.hasOwnProperty.call(m,"includeDuplicates"))w.uint32(24).bool(m.includeDuplicates);if(m.includeChildRecords!=null&&Object.hasOwnProperty.call(m,"includeChildRecords"))w.uint32(32).bool(m.includeChildRecords);return w;};TransactionGetRecordQuery.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TransactionGetRecordQuery();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.header=$root.proto.QueryHeader.decode(r,r.uint32());break;}case 2:{m.transactionID=$root.proto.TransactionID.decode(r,r.uint32());break;}case 3:{m.includeDuplicates=r.bool();break;}case 4:{m.includeChildRecords=r.bool();break;}default:r.skipType(t&7);break;}}return m;};TransactionGetRecordQuery.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TransactionGetRecordQuery";};return TransactionGetRecordQuery;}();proto.TransactionGetRecordResponse=function(){function TransactionGetRecordResponse(p){this.duplicateTransactionRecords=[];this.childTransactionRecords=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TransactionGetRecordResponse.prototype.header=null;TransactionGetRecordResponse.prototype.transactionRecord=null;TransactionGetRecordResponse.prototype.duplicateTransactionRecords=$util.emptyArray;TransactionGetRecordResponse.prototype.childTransactionRecords=$util.emptyArray;TransactionGetRecordResponse.create=function create(properties){return new TransactionGetRecordResponse(properties);};TransactionGetRecordResponse.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.header!=null&&Object.hasOwnProperty.call(m,"header"))$root.proto.ResponseHeader.encode(m.header,w.uint32(10).fork()).ldelim();if(m.transactionRecord!=null&&Object.hasOwnProperty.call(m,"transactionRecord"))$root.proto.TransactionRecord.encode(m.transactionRecord,w.uint32(26).fork()).ldelim();if(m.duplicateTransactionRecords!=null&&m.duplicateTransactionRecords.length){for(var i=0;i<m.duplicateTransactionRecords.length;++i)$root.proto.TransactionRecord.encode(m.duplicateTransactionRecords[i],w.uint32(34).fork()).ldelim();}if(m.childTransactionRecords!=null&&m.childTransactionRecords.length){for(var i=0;i<m.childTransactionRecords.length;++i)$root.proto.TransactionRecord.encode(m.childTransactionRecords[i],w.uint32(42).fork()).ldelim();}return w;};TransactionGetRecordResponse.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TransactionGetRecordResponse();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.header=$root.proto.ResponseHeader.decode(r,r.uint32());break;}case 3:{m.transactionRecord=$root.proto.TransactionRecord.decode(r,r.uint32());break;}case 4:{if(!(m.duplicateTransactionRecords&&m.duplicateTransactionRecords.length))m.duplicateTransactionRecords=[];m.duplicateTransactionRecords.push($root.proto.TransactionRecord.decode(r,r.uint32()));break;}case 5:{if(!(m.childTransactionRecords&&m.childTransactionRecords.length))m.childTransactionRecords=[];m.childTransactionRecords.push($root.proto.TransactionRecord.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};TransactionGetRecordResponse.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TransactionGetRecordResponse";};return TransactionGetRecordResponse;}();proto.TransactionGetFastRecordQuery=function(){function TransactionGetFastRecordQuery(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TransactionGetFastRecordQuery.prototype.header=null;TransactionGetFastRecordQuery.prototype.transactionID=null;TransactionGetFastRecordQuery.create=function create(properties){return new TransactionGetFastRecordQuery(properties);};TransactionGetFastRecordQuery.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.header!=null&&Object.hasOwnProperty.call(m,"header"))$root.proto.QueryHeader.encode(m.header,w.uint32(10).fork()).ldelim();if(m.transactionID!=null&&Object.hasOwnProperty.call(m,"transactionID"))$root.proto.TransactionID.encode(m.transactionID,w.uint32(18).fork()).ldelim();return w;};TransactionGetFastRecordQuery.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TransactionGetFastRecordQuery();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.header=$root.proto.QueryHeader.decode(r,r.uint32());break;}case 2:{m.transactionID=$root.proto.TransactionID.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};TransactionGetFastRecordQuery.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TransactionGetFastRecordQuery";};return TransactionGetFastRecordQuery;}();proto.TransactionGetFastRecordResponse=function(){function TransactionGetFastRecordResponse(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TransactionGetFastRecordResponse.prototype.header=null;TransactionGetFastRecordResponse.prototype.transactionRecord=null;TransactionGetFastRecordResponse.create=function create(properties){return new TransactionGetFastRecordResponse(properties);};TransactionGetFastRecordResponse.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.header!=null&&Object.hasOwnProperty.call(m,"header"))$root.proto.ResponseHeader.encode(m.header,w.uint32(10).fork()).ldelim();if(m.transactionRecord!=null&&Object.hasOwnProperty.call(m,"transactionRecord"))$root.proto.TransactionRecord.encode(m.transactionRecord,w.uint32(18).fork()).ldelim();return w;};TransactionGetFastRecordResponse.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TransactionGetFastRecordResponse();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.header=$root.proto.ResponseHeader.decode(r,r.uint32());break;}case 2:{m.transactionRecord=$root.proto.TransactionRecord.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};TransactionGetFastRecordResponse.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TransactionGetFastRecordResponse";};return TransactionGetFastRecordResponse;}();proto.NetworkGetVersionInfoQuery=function(){function NetworkGetVersionInfoQuery(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}NetworkGetVersionInfoQuery.prototype.header=null;NetworkGetVersionInfoQuery.create=function create(properties){return new NetworkGetVersionInfoQuery(properties);};NetworkGetVersionInfoQuery.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.header!=null&&Object.hasOwnProperty.call(m,"header"))$root.proto.QueryHeader.encode(m.header,w.uint32(10).fork()).ldelim();return w;};NetworkGetVersionInfoQuery.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.NetworkGetVersionInfoQuery();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.header=$root.proto.QueryHeader.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};NetworkGetVersionInfoQuery.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.NetworkGetVersionInfoQuery";};return NetworkGetVersionInfoQuery;}();proto.NetworkGetVersionInfoResponse=function(){function NetworkGetVersionInfoResponse(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}NetworkGetVersionInfoResponse.prototype.header=null;NetworkGetVersionInfoResponse.prototype.hapiProtoVersion=null;NetworkGetVersionInfoResponse.prototype.hederaServicesVersion=null;NetworkGetVersionInfoResponse.create=function create(properties){return new NetworkGetVersionInfoResponse(properties);};NetworkGetVersionInfoResponse.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.header!=null&&Object.hasOwnProperty.call(m,"header"))$root.proto.ResponseHeader.encode(m.header,w.uint32(10).fork()).ldelim();if(m.hapiProtoVersion!=null&&Object.hasOwnProperty.call(m,"hapiProtoVersion"))$root.proto.SemanticVersion.encode(m.hapiProtoVersion,w.uint32(18).fork()).ldelim();if(m.hederaServicesVersion!=null&&Object.hasOwnProperty.call(m,"hederaServicesVersion"))$root.proto.SemanticVersion.encode(m.hederaServicesVersion,w.uint32(26).fork()).ldelim();return w;};NetworkGetVersionInfoResponse.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.NetworkGetVersionInfoResponse();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.header=$root.proto.ResponseHeader.decode(r,r.uint32());break;}case 2:{m.hapiProtoVersion=$root.proto.SemanticVersion.decode(r,r.uint32());break;}case 3:{m.hederaServicesVersion=$root.proto.SemanticVersion.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};NetworkGetVersionInfoResponse.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.NetworkGetVersionInfoResponse";};return NetworkGetVersionInfoResponse;}();proto.NetworkGetExecutionTimeQuery=function(){function NetworkGetExecutionTimeQuery(p){this.transactionIds=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}NetworkGetExecutionTimeQuery.prototype.header=null;NetworkGetExecutionTimeQuery.prototype.transactionIds=$util.emptyArray;NetworkGetExecutionTimeQuery.create=function create(properties){return new NetworkGetExecutionTimeQuery(properties);};NetworkGetExecutionTimeQuery.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.header!=null&&Object.hasOwnProperty.call(m,"header"))$root.proto.QueryHeader.encode(m.header,w.uint32(10).fork()).ldelim();if(m.transactionIds!=null&&m.transactionIds.length){for(var i=0;i<m.transactionIds.length;++i)$root.proto.TransactionID.encode(m.transactionIds[i],w.uint32(18).fork()).ldelim();}return w;};NetworkGetExecutionTimeQuery.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.NetworkGetExecutionTimeQuery();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.header=$root.proto.QueryHeader.decode(r,r.uint32());break;}case 2:{if(!(m.transactionIds&&m.transactionIds.length))m.transactionIds=[];m.transactionIds.push($root.proto.TransactionID.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};NetworkGetExecutionTimeQuery.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.NetworkGetExecutionTimeQuery";};return NetworkGetExecutionTimeQuery;}();proto.NetworkGetExecutionTimeResponse=function(){function NetworkGetExecutionTimeResponse(p){this.executionTimes=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}NetworkGetExecutionTimeResponse.prototype.header=null;NetworkGetExecutionTimeResponse.prototype.executionTimes=$util.emptyArray;NetworkGetExecutionTimeResponse.create=function create(properties){return new NetworkGetExecutionTimeResponse(properties);};NetworkGetExecutionTimeResponse.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.header!=null&&Object.hasOwnProperty.call(m,"header"))$root.proto.ResponseHeader.encode(m.header,w.uint32(10).fork()).ldelim();if(m.executionTimes!=null&&m.executionTimes.length){w.uint32(18).fork();for(var i=0;i<m.executionTimes.length;++i)w.uint64(m.executionTimes[i]);w.ldelim();}return w;};NetworkGetExecutionTimeResponse.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.NetworkGetExecutionTimeResponse();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.header=$root.proto.ResponseHeader.decode(r,r.uint32());break;}case 2:{if(!(m.executionTimes&&m.executionTimes.length))m.executionTimes=[];if((t&7)===2){var c2=r.uint32()+r.pos;while(r.pos<c2)m.executionTimes.push(r.uint64());}else m.executionTimes.push(r.uint64());break;}default:r.skipType(t&7);break;}}return m;};NetworkGetExecutionTimeResponse.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.NetworkGetExecutionTimeResponse";};return NetworkGetExecutionTimeResponse;}();proto.TokenGetInfoQuery=function(){function TokenGetInfoQuery(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TokenGetInfoQuery.prototype.header=null;TokenGetInfoQuery.prototype.token=null;TokenGetInfoQuery.create=function create(properties){return new TokenGetInfoQuery(properties);};TokenGetInfoQuery.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.header!=null&&Object.hasOwnProperty.call(m,"header"))$root.proto.QueryHeader.encode(m.header,w.uint32(10).fork()).ldelim();if(m.token!=null&&Object.hasOwnProperty.call(m,"token"))$root.proto.TokenID.encode(m.token,w.uint32(18).fork()).ldelim();return w;};TokenGetInfoQuery.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TokenGetInfoQuery();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.header=$root.proto.QueryHeader.decode(r,r.uint32());break;}case 2:{m.token=$root.proto.TokenID.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};TokenGetInfoQuery.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TokenGetInfoQuery";};return TokenGetInfoQuery;}();proto.TokenInfo=function(){function TokenInfo(p){this.customFees=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TokenInfo.prototype.tokenId=null;TokenInfo.prototype.name="";TokenInfo.prototype.symbol="";TokenInfo.prototype.decimals=0;TokenInfo.prototype.totalSupply=$util.Long?$util.Long.fromBits(0,0,true):0;TokenInfo.prototype.treasury=null;TokenInfo.prototype.adminKey=null;TokenInfo.prototype.kycKey=null;TokenInfo.prototype.freezeKey=null;TokenInfo.prototype.wipeKey=null;TokenInfo.prototype.supplyKey=null;TokenInfo.prototype.defaultFreezeStatus=0;TokenInfo.prototype.defaultKycStatus=0;TokenInfo.prototype.deleted=false;TokenInfo.prototype.autoRenewAccount=null;TokenInfo.prototype.autoRenewPeriod=null;TokenInfo.prototype.expiry=null;TokenInfo.prototype.memo="";TokenInfo.prototype.tokenType=0;TokenInfo.prototype.supplyType=0;TokenInfo.prototype.maxSupply=$util.Long?$util.Long.fromBits(0,0,false):0;TokenInfo.prototype.feeScheduleKey=null;TokenInfo.prototype.customFees=$util.emptyArray;TokenInfo.prototype.pauseKey=null;TokenInfo.prototype.pauseStatus=0;TokenInfo.prototype.ledgerId=$util.newBuffer([]);TokenInfo.prototype.metadata=$util.newBuffer([]);TokenInfo.prototype.metadataKey=null;TokenInfo.create=function create(properties){return new TokenInfo(properties);};TokenInfo.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.tokenId!=null&&Object.hasOwnProperty.call(m,"tokenId"))$root.proto.TokenID.encode(m.tokenId,w.uint32(10).fork()).ldelim();if(m.name!=null&&Object.hasOwnProperty.call(m,"name"))w.uint32(18).string(m.name);if(m.symbol!=null&&Object.hasOwnProperty.call(m,"symbol"))w.uint32(26).string(m.symbol);if(m.decimals!=null&&Object.hasOwnProperty.call(m,"decimals"))w.uint32(32).uint32(m.decimals);if(m.totalSupply!=null&&Object.hasOwnProperty.call(m,"totalSupply"))w.uint32(40).uint64(m.totalSupply);if(m.treasury!=null&&Object.hasOwnProperty.call(m,"treasury"))$root.proto.AccountID.encode(m.treasury,w.uint32(50).fork()).ldelim();if(m.adminKey!=null&&Object.hasOwnProperty.call(m,"adminKey"))$root.proto.Key.encode(m.adminKey,w.uint32(58).fork()).ldelim();if(m.kycKey!=null&&Object.hasOwnProperty.call(m,"kycKey"))$root.proto.Key.encode(m.kycKey,w.uint32(66).fork()).ldelim();if(m.freezeKey!=null&&Object.hasOwnProperty.call(m,"freezeKey"))$root.proto.Key.encode(m.freezeKey,w.uint32(74).fork()).ldelim();if(m.wipeKey!=null&&Object.hasOwnProperty.call(m,"wipeKey"))$root.proto.Key.encode(m.wipeKey,w.uint32(82).fork()).ldelim();if(m.supplyKey!=null&&Object.hasOwnProperty.call(m,"supplyKey"))$root.proto.Key.encode(m.supplyKey,w.uint32(90).fork()).ldelim();if(m.defaultFreezeStatus!=null&&Object.hasOwnProperty.call(m,"defaultFreezeStatus"))w.uint32(96).int32(m.defaultFreezeStatus);if(m.defaultKycStatus!=null&&Object.hasOwnProperty.call(m,"defaultKycStatus"))w.uint32(104).int32(m.defaultKycStatus);if(m.deleted!=null&&Object.hasOwnProperty.call(m,"deleted"))w.uint32(112).bool(m.deleted);if(m.autoRenewAccount!=null&&Object.hasOwnProperty.call(m,"autoRenewAccount"))$root.proto.AccountID.encode(m.autoRenewAccount,w.uint32(122).fork()).ldelim();if(m.autoRenewPeriod!=null&&Object.hasOwnProperty.call(m,"autoRenewPeriod"))$root.proto.Duration.encode(m.autoRenewPeriod,w.uint32(130).fork()).ldelim();if(m.expiry!=null&&Object.hasOwnProperty.call(m,"expiry"))$root.proto.Timestamp.encode(m.expiry,w.uint32(138).fork()).ldelim();if(m.memo!=null&&Object.hasOwnProperty.call(m,"memo"))w.uint32(146).string(m.memo);if(m.tokenType!=null&&Object.hasOwnProperty.call(m,"tokenType"))w.uint32(152).int32(m.tokenType);if(m.supplyType!=null&&Object.hasOwnProperty.call(m,"supplyType"))w.uint32(160).int32(m.supplyType);if(m.maxSupply!=null&&Object.hasOwnProperty.call(m,"maxSupply"))w.uint32(168).int64(m.maxSupply);if(m.feeScheduleKey!=null&&Object.hasOwnProperty.call(m,"feeScheduleKey"))$root.proto.Key.encode(m.feeScheduleKey,w.uint32(178).fork()).ldelim();if(m.customFees!=null&&m.customFees.length){for(var i=0;i<m.customFees.length;++i)$root.proto.CustomFee.encode(m.customFees[i],w.uint32(186).fork()).ldelim();}if(m.pauseKey!=null&&Object.hasOwnProperty.call(m,"pauseKey"))$root.proto.Key.encode(m.pauseKey,w.uint32(194).fork()).ldelim();if(m.pauseStatus!=null&&Object.hasOwnProperty.call(m,"pauseStatus"))w.uint32(200).int32(m.pauseStatus);if(m.ledgerId!=null&&Object.hasOwnProperty.call(m,"ledgerId"))w.uint32(210).bytes(m.ledgerId);if(m.metadata!=null&&Object.hasOwnProperty.call(m,"metadata"))w.uint32(218).bytes(m.metadata);if(m.metadataKey!=null&&Object.hasOwnProperty.call(m,"metadataKey"))$root.proto.Key.encode(m.metadataKey,w.uint32(226).fork()).ldelim();return w;};TokenInfo.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TokenInfo();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.tokenId=$root.proto.TokenID.decode(r,r.uint32());break;}case 2:{m.name=r.string();break;}case 3:{m.symbol=r.string();break;}case 4:{m.decimals=r.uint32();break;}case 5:{m.totalSupply=r.uint64();break;}case 6:{m.treasury=$root.proto.AccountID.decode(r,r.uint32());break;}case 7:{m.adminKey=$root.proto.Key.decode(r,r.uint32());break;}case 8:{m.kycKey=$root.proto.Key.decode(r,r.uint32());break;}case 9:{m.freezeKey=$root.proto.Key.decode(r,r.uint32());break;}case 10:{m.wipeKey=$root.proto.Key.decode(r,r.uint32());break;}case 11:{m.supplyKey=$root.proto.Key.decode(r,r.uint32());break;}case 12:{m.defaultFreezeStatus=r.int32();break;}case 13:{m.defaultKycStatus=r.int32();break;}case 14:{m.deleted=r.bool();break;}case 15:{m.autoRenewAccount=$root.proto.AccountID.decode(r,r.uint32());break;}case 16:{m.autoRenewPeriod=$root.proto.Duration.decode(r,r.uint32());break;}case 17:{m.expiry=$root.proto.Timestamp.decode(r,r.uint32());break;}case 18:{m.memo=r.string();break;}case 19:{m.tokenType=r.int32();break;}case 20:{m.supplyType=r.int32();break;}case 21:{m.maxSupply=r.int64();break;}case 22:{m.feeScheduleKey=$root.proto.Key.decode(r,r.uint32());break;}case 23:{if(!(m.customFees&&m.customFees.length))m.customFees=[];m.customFees.push($root.proto.CustomFee.decode(r,r.uint32()));break;}case 24:{m.pauseKey=$root.proto.Key.decode(r,r.uint32());break;}case 25:{m.pauseStatus=r.int32();break;}case 26:{m.ledgerId=r.bytes();break;}case 27:{m.metadata=r.bytes();break;}case 28:{m.metadataKey=$root.proto.Key.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};TokenInfo.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TokenInfo";};return TokenInfo;}();proto.TokenGetInfoResponse=function(){function TokenGetInfoResponse(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TokenGetInfoResponse.prototype.header=null;TokenGetInfoResponse.prototype.tokenInfo=null;TokenGetInfoResponse.create=function create(properties){return new TokenGetInfoResponse(properties);};TokenGetInfoResponse.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.header!=null&&Object.hasOwnProperty.call(m,"header"))$root.proto.ResponseHeader.encode(m.header,w.uint32(10).fork()).ldelim();if(m.tokenInfo!=null&&Object.hasOwnProperty.call(m,"tokenInfo"))$root.proto.TokenInfo.encode(m.tokenInfo,w.uint32(18).fork()).ldelim();return w;};TokenGetInfoResponse.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TokenGetInfoResponse();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.header=$root.proto.ResponseHeader.decode(r,r.uint32());break;}case 2:{m.tokenInfo=$root.proto.TokenInfo.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};TokenGetInfoResponse.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TokenGetInfoResponse";};return TokenGetInfoResponse;}();proto.ScheduleGetInfoQuery=function(){function ScheduleGetInfoQuery(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ScheduleGetInfoQuery.prototype.header=null;ScheduleGetInfoQuery.prototype.scheduleID=null;ScheduleGetInfoQuery.create=function create(properties){return new ScheduleGetInfoQuery(properties);};ScheduleGetInfoQuery.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.header!=null&&Object.hasOwnProperty.call(m,"header"))$root.proto.QueryHeader.encode(m.header,w.uint32(10).fork()).ldelim();if(m.scheduleID!=null&&Object.hasOwnProperty.call(m,"scheduleID"))$root.proto.ScheduleID.encode(m.scheduleID,w.uint32(18).fork()).ldelim();return w;};ScheduleGetInfoQuery.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ScheduleGetInfoQuery();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.header=$root.proto.QueryHeader.decode(r,r.uint32());break;}case 2:{m.scheduleID=$root.proto.ScheduleID.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};ScheduleGetInfoQuery.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ScheduleGetInfoQuery";};return ScheduleGetInfoQuery;}();proto.ScheduleInfo=function(){function ScheduleInfo(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ScheduleInfo.prototype.scheduleID=null;ScheduleInfo.prototype.deletionTime=null;ScheduleInfo.prototype.executionTime=null;ScheduleInfo.prototype.expirationTime=null;ScheduleInfo.prototype.scheduledTransactionBody=null;ScheduleInfo.prototype.memo="";ScheduleInfo.prototype.adminKey=null;ScheduleInfo.prototype.signers=null;ScheduleInfo.prototype.creatorAccountID=null;ScheduleInfo.prototype.payerAccountID=null;ScheduleInfo.prototype.scheduledTransactionID=null;ScheduleInfo.prototype.ledgerId=$util.newBuffer([]);ScheduleInfo.prototype.waitForExpiry=false;let $oneOfFields;Object.defineProperty(ScheduleInfo.prototype,"data",{get:$util.oneOfGetter($oneOfFields=["deletionTime","executionTime"]),set:$util.oneOfSetter($oneOfFields)});ScheduleInfo.create=function create(properties){return new ScheduleInfo(properties);};ScheduleInfo.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.scheduleID!=null&&Object.hasOwnProperty.call(m,"scheduleID"))$root.proto.ScheduleID.encode(m.scheduleID,w.uint32(10).fork()).ldelim();if(m.deletionTime!=null&&Object.hasOwnProperty.call(m,"deletionTime"))$root.proto.Timestamp.encode(m.deletionTime,w.uint32(18).fork()).ldelim();if(m.executionTime!=null&&Object.hasOwnProperty.call(m,"executionTime"))$root.proto.Timestamp.encode(m.executionTime,w.uint32(26).fork()).ldelim();if(m.expirationTime!=null&&Object.hasOwnProperty.call(m,"expirationTime"))$root.proto.Timestamp.encode(m.expirationTime,w.uint32(34).fork()).ldelim();if(m.scheduledTransactionBody!=null&&Object.hasOwnProperty.call(m,"scheduledTransactionBody"))$root.proto.SchedulableTransactionBody.encode(m.scheduledTransactionBody,w.uint32(42).fork()).ldelim();if(m.memo!=null&&Object.hasOwnProperty.call(m,"memo"))w.uint32(50).string(m.memo);if(m.adminKey!=null&&Object.hasOwnProperty.call(m,"adminKey"))$root.proto.Key.encode(m.adminKey,w.uint32(58).fork()).ldelim();if(m.signers!=null&&Object.hasOwnProperty.call(m,"signers"))$root.proto.KeyList.encode(m.signers,w.uint32(66).fork()).ldelim();if(m.creatorAccountID!=null&&Object.hasOwnProperty.call(m,"creatorAccountID"))$root.proto.AccountID.encode(m.creatorAccountID,w.uint32(74).fork()).ldelim();if(m.payerAccountID!=null&&Object.hasOwnProperty.call(m,"payerAccountID"))$root.proto.AccountID.encode(m.payerAccountID,w.uint32(82).fork()).ldelim();if(m.scheduledTransactionID!=null&&Object.hasOwnProperty.call(m,"scheduledTransactionID"))$root.proto.TransactionID.encode(m.scheduledTransactionID,w.uint32(90).fork()).ldelim();if(m.ledgerId!=null&&Object.hasOwnProperty.call(m,"ledgerId"))w.uint32(98).bytes(m.ledgerId);if(m.waitForExpiry!=null&&Object.hasOwnProperty.call(m,"waitForExpiry"))w.uint32(104).bool(m.waitForExpiry);return w;};ScheduleInfo.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ScheduleInfo();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.scheduleID=$root.proto.ScheduleID.decode(r,r.uint32());break;}case 2:{m.deletionTime=$root.proto.Timestamp.decode(r,r.uint32());break;}case 3:{m.executionTime=$root.proto.Timestamp.decode(r,r.uint32());break;}case 4:{m.expirationTime=$root.proto.Timestamp.decode(r,r.uint32());break;}case 5:{m.scheduledTransactionBody=$root.proto.SchedulableTransactionBody.decode(r,r.uint32());break;}case 6:{m.memo=r.string();break;}case 7:{m.adminKey=$root.proto.Key.decode(r,r.uint32());break;}case 8:{m.signers=$root.proto.KeyList.decode(r,r.uint32());break;}case 9:{m.creatorAccountID=$root.proto.AccountID.decode(r,r.uint32());break;}case 10:{m.payerAccountID=$root.proto.AccountID.decode(r,r.uint32());break;}case 11:{m.scheduledTransactionID=$root.proto.TransactionID.decode(r,r.uint32());break;}case 12:{m.ledgerId=r.bytes();break;}case 13:{m.waitForExpiry=r.bool();break;}default:r.skipType(t&7);break;}}return m;};ScheduleInfo.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ScheduleInfo";};return ScheduleInfo;}();proto.ScheduleGetInfoResponse=function(){function ScheduleGetInfoResponse(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ScheduleGetInfoResponse.prototype.header=null;ScheduleGetInfoResponse.prototype.scheduleInfo=null;ScheduleGetInfoResponse.create=function create(properties){return new ScheduleGetInfoResponse(properties);};ScheduleGetInfoResponse.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.header!=null&&Object.hasOwnProperty.call(m,"header"))$root.proto.ResponseHeader.encode(m.header,w.uint32(10).fork()).ldelim();if(m.scheduleInfo!=null&&Object.hasOwnProperty.call(m,"scheduleInfo"))$root.proto.ScheduleInfo.encode(m.scheduleInfo,w.uint32(18).fork()).ldelim();return w;};ScheduleGetInfoResponse.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ScheduleGetInfoResponse();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.header=$root.proto.ResponseHeader.decode(r,r.uint32());break;}case 2:{m.scheduleInfo=$root.proto.ScheduleInfo.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};ScheduleGetInfoResponse.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ScheduleGetInfoResponse";};return ScheduleGetInfoResponse;}();proto.SchedulableTransactionBody=function(){function SchedulableTransactionBody(p){this.maxCustomFees=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}SchedulableTransactionBody.prototype.transactionFee=$util.Long?$util.Long.fromBits(0,0,true):0;SchedulableTransactionBody.prototype.memo="";SchedulableTransactionBody.prototype.contractCall=null;SchedulableTransactionBody.prototype.contractCreateInstance=null;SchedulableTransactionBody.prototype.contractUpdateInstance=null;SchedulableTransactionBody.prototype.contractDeleteInstance=null;SchedulableTransactionBody.prototype.cryptoCreateAccount=null;SchedulableTransactionBody.prototype.cryptoDelete=null;SchedulableTransactionBody.prototype.cryptoTransfer=null;SchedulableTransactionBody.prototype.cryptoUpdateAccount=null;SchedulableTransactionBody.prototype.fileAppend=null;SchedulableTransactionBody.prototype.fileCreate=null;SchedulableTransactionBody.prototype.fileDelete=null;SchedulableTransactionBody.prototype.fileUpdate=null;SchedulableTransactionBody.prototype.systemDelete=null;SchedulableTransactionBody.prototype.systemUndelete=null;SchedulableTransactionBody.prototype.freeze=null;SchedulableTransactionBody.prototype.consensusCreateTopic=null;SchedulableTransactionBody.prototype.consensusUpdateTopic=null;SchedulableTransactionBody.prototype.consensusDeleteTopic=null;SchedulableTransactionBody.prototype.consensusSubmitMessage=null;SchedulableTransactionBody.prototype.tokenCreation=null;SchedulableTransactionBody.prototype.tokenFreeze=null;SchedulableTransactionBody.prototype.tokenUnfreeze=null;SchedulableTransactionBody.prototype.tokenGrantKyc=null;SchedulableTransactionBody.prototype.tokenRevokeKyc=null;SchedulableTransactionBody.prototype.tokenDeletion=null;SchedulableTransactionBody.prototype.tokenUpdate=null;SchedulableTransactionBody.prototype.tokenMint=null;SchedulableTransactionBody.prototype.tokenBurn=null;SchedulableTransactionBody.prototype.tokenWipe=null;SchedulableTransactionBody.prototype.tokenAssociate=null;SchedulableTransactionBody.prototype.tokenDissociate=null;SchedulableTransactionBody.prototype.scheduleDelete=null;SchedulableTransactionBody.prototype.tokenPause=null;SchedulableTransactionBody.prototype.tokenUnpause=null;SchedulableTransactionBody.prototype.cryptoApproveAllowance=null;SchedulableTransactionBody.prototype.cryptoDeleteAllowance=null;SchedulableTransactionBody.prototype.tokenFeeScheduleUpdate=null;SchedulableTransactionBody.prototype.utilPrng=null;SchedulableTransactionBody.prototype.tokenUpdateNfts=null;SchedulableTransactionBody.prototype.nodeCreate=null;SchedulableTransactionBody.prototype.nodeUpdate=null;SchedulableTransactionBody.prototype.nodeDelete=null;SchedulableTransactionBody.prototype.tokenReject=null;SchedulableTransactionBody.prototype.tokenCancelAirdrop=null;SchedulableTransactionBody.prototype.tokenClaimAirdrop=null;SchedulableTransactionBody.prototype.tokenAirdrop=null;SchedulableTransactionBody.prototype.maxCustomFees=$util.emptyArray;let $oneOfFields;Object.defineProperty(SchedulableTransactionBody.prototype,"data",{get:$util.oneOfGetter($oneOfFields=["contractCall","contractCreateInstance","contractUpdateInstance","contractDeleteInstance","cryptoCreateAccount","cryptoDelete","cryptoTransfer","cryptoUpdateAccount","fileAppend","fileCreate","fileDelete","fileUpdate","systemDelete","systemUndelete","freeze","consensusCreateTopic","consensusUpdateTopic","consensusDeleteTopic","consensusSubmitMessage","tokenCreation","tokenFreeze","tokenUnfreeze","tokenGrantKyc","tokenRevokeKyc","tokenDeletion","tokenUpdate","tokenMint","tokenBurn","tokenWipe","tokenAssociate","tokenDissociate","scheduleDelete","tokenPause","tokenUnpause","cryptoApproveAllowance","cryptoDeleteAllowance","tokenFeeScheduleUpdate","utilPrng","tokenUpdateNfts","nodeCreate","nodeUpdate","nodeDelete","tokenReject","tokenCancelAirdrop","tokenClaimAirdrop","tokenAirdrop"]),set:$util.oneOfSetter($oneOfFields)});SchedulableTransactionBody.create=function create(properties){return new SchedulableTransactionBody(properties);};SchedulableTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.transactionFee!=null&&Object.hasOwnProperty.call(m,"transactionFee"))w.uint32(8).uint64(m.transactionFee);if(m.memo!=null&&Object.hasOwnProperty.call(m,"memo"))w.uint32(18).string(m.memo);if(m.contractCall!=null&&Object.hasOwnProperty.call(m,"contractCall"))$root.proto.ContractCallTransactionBody.encode(m.contractCall,w.uint32(26).fork()).ldelim();if(m.contractCreateInstance!=null&&Object.hasOwnProperty.call(m,"contractCreateInstance"))$root.proto.ContractCreateTransactionBody.encode(m.contractCreateInstance,w.uint32(34).fork()).ldelim();if(m.contractUpdateInstance!=null&&Object.hasOwnProperty.call(m,"contractUpdateInstance"))$root.proto.ContractUpdateTransactionBody.encode(m.contractUpdateInstance,w.uint32(42).fork()).ldelim();if(m.contractDeleteInstance!=null&&Object.hasOwnProperty.call(m,"contractDeleteInstance"))$root.proto.ContractDeleteTransactionBody.encode(m.contractDeleteInstance,w.uint32(50).fork()).ldelim();if(m.cryptoCreateAccount!=null&&Object.hasOwnProperty.call(m,"cryptoCreateAccount"))$root.proto.CryptoCreateTransactionBody.encode(m.cryptoCreateAccount,w.uint32(58).fork()).ldelim();if(m.cryptoDelete!=null&&Object.hasOwnProperty.call(m,"cryptoDelete"))$root.proto.CryptoDeleteTransactionBody.encode(m.cryptoDelete,w.uint32(66).fork()).ldelim();if(m.cryptoTransfer!=null&&Object.hasOwnProperty.call(m,"cryptoTransfer"))$root.proto.CryptoTransferTransactionBody.encode(m.cryptoTransfer,w.uint32(74).fork()).ldelim();if(m.cryptoUpdateAccount!=null&&Object.hasOwnProperty.call(m,"cryptoUpdateAccount"))$root.proto.CryptoUpdateTransactionBody.encode(m.cryptoUpdateAccount,w.uint32(82).fork()).ldelim();if(m.fileAppend!=null&&Object.hasOwnProperty.call(m,"fileAppend"))$root.proto.FileAppendTransactionBody.encode(m.fileAppend,w.uint32(90).fork()).ldelim();if(m.fileCreate!=null&&Object.hasOwnProperty.call(m,"fileCreate"))$root.proto.FileCreateTransactionBody.encode(m.fileCreate,w.uint32(98).fork()).ldelim();if(m.fileDelete!=null&&Object.hasOwnProperty.call(m,"fileDelete"))$root.proto.FileDeleteTransactionBody.encode(m.fileDelete,w.uint32(106).fork()).ldelim();if(m.fileUpdate!=null&&Object.hasOwnProperty.call(m,"fileUpdate"))$root.proto.FileUpdateTransactionBody.encode(m.fileUpdate,w.uint32(114).fork()).ldelim();if(m.systemDelete!=null&&Object.hasOwnProperty.call(m,"systemDelete"))$root.proto.SystemDeleteTransactionBody.encode(m.systemDelete,w.uint32(122).fork()).ldelim();if(m.systemUndelete!=null&&Object.hasOwnProperty.call(m,"systemUndelete"))$root.proto.SystemUndeleteTransactionBody.encode(m.systemUndelete,w.uint32(130).fork()).ldelim();if(m.freeze!=null&&Object.hasOwnProperty.call(m,"freeze"))$root.proto.FreezeTransactionBody.encode(m.freeze,w.uint32(138).fork()).ldelim();if(m.consensusCreateTopic!=null&&Object.hasOwnProperty.call(m,"consensusCreateTopic"))$root.proto.ConsensusCreateTopicTransactionBody.encode(m.consensusCreateTopic,w.uint32(146).fork()).ldelim();if(m.consensusUpdateTopic!=null&&Object.hasOwnProperty.call(m,"consensusUpdateTopic"))$root.proto.ConsensusUpdateTopicTransactionBody.encode(m.consensusUpdateTopic,w.uint32(154).fork()).ldelim();if(m.consensusDeleteTopic!=null&&Object.hasOwnProperty.call(m,"consensusDeleteTopic"))$root.proto.ConsensusDeleteTopicTransactionBody.encode(m.consensusDeleteTopic,w.uint32(162).fork()).ldelim();if(m.consensusSubmitMessage!=null&&Object.hasOwnProperty.call(m,"consensusSubmitMessage"))$root.proto.ConsensusSubmitMessageTransactionBody.encode(m.consensusSubmitMessage,w.uint32(170).fork()).ldelim();if(m.tokenCreation!=null&&Object.hasOwnProperty.call(m,"tokenCreation"))$root.proto.TokenCreateTransactionBody.encode(m.tokenCreation,w.uint32(178).fork()).ldelim();if(m.tokenFreeze!=null&&Object.hasOwnProperty.call(m,"tokenFreeze"))$root.proto.TokenFreezeAccountTransactionBody.encode(m.tokenFreeze,w.uint32(186).fork()).ldelim();if(m.tokenUnfreeze!=null&&Object.hasOwnProperty.call(m,"tokenUnfreeze"))$root.proto.TokenUnfreezeAccountTransactionBody.encode(m.tokenUnfreeze,w.uint32(194).fork()).ldelim();if(m.tokenGrantKyc!=null&&Object.hasOwnProperty.call(m,"tokenGrantKyc"))$root.proto.TokenGrantKycTransactionBody.encode(m.tokenGrantKyc,w.uint32(202).fork()).ldelim();if(m.tokenRevokeKyc!=null&&Object.hasOwnProperty.call(m,"tokenRevokeKyc"))$root.proto.TokenRevokeKycTransactionBody.encode(m.tokenRevokeKyc,w.uint32(210).fork()).ldelim();if(m.tokenDeletion!=null&&Object.hasOwnProperty.call(m,"tokenDeletion"))$root.proto.TokenDeleteTransactionBody.encode(m.tokenDeletion,w.uint32(218).fork()).ldelim();if(m.tokenUpdate!=null&&Object.hasOwnProperty.call(m,"tokenUpdate"))$root.proto.TokenUpdateTransactionBody.encode(m.tokenUpdate,w.uint32(226).fork()).ldelim();if(m.tokenMint!=null&&Object.hasOwnProperty.call(m,"tokenMint"))$root.proto.TokenMintTransactionBody.encode(m.tokenMint,w.uint32(234).fork()).ldelim();if(m.tokenBurn!=null&&Object.hasOwnProperty.call(m,"tokenBurn"))$root.proto.TokenBurnTransactionBody.encode(m.tokenBurn,w.uint32(242).fork()).ldelim();if(m.tokenWipe!=null&&Object.hasOwnProperty.call(m,"tokenWipe"))$root.proto.TokenWipeAccountTransactionBody.encode(m.tokenWipe,w.uint32(250).fork()).ldelim();if(m.tokenAssociate!=null&&Object.hasOwnProperty.call(m,"tokenAssociate"))$root.proto.TokenAssociateTransactionBody.encode(m.tokenAssociate,w.uint32(258).fork()).ldelim();if(m.tokenDissociate!=null&&Object.hasOwnProperty.call(m,"tokenDissociate"))$root.proto.TokenDissociateTransactionBody.encode(m.tokenDissociate,w.uint32(266).fork()).ldelim();if(m.scheduleDelete!=null&&Object.hasOwnProperty.call(m,"scheduleDelete"))$root.proto.ScheduleDeleteTransactionBody.encode(m.scheduleDelete,w.uint32(274).fork()).ldelim();if(m.tokenPause!=null&&Object.hasOwnProperty.call(m,"tokenPause"))$root.proto.TokenPauseTransactionBody.encode(m.tokenPause,w.uint32(282).fork()).ldelim();if(m.tokenUnpause!=null&&Object.hasOwnProperty.call(m,"tokenUnpause"))$root.proto.TokenUnpauseTransactionBody.encode(m.tokenUnpause,w.uint32(290).fork()).ldelim();if(m.cryptoApproveAllowance!=null&&Object.hasOwnProperty.call(m,"cryptoApproveAllowance"))$root.proto.CryptoApproveAllowanceTransactionBody.encode(m.cryptoApproveAllowance,w.uint32(298).fork()).ldelim();if(m.cryptoDeleteAllowance!=null&&Object.hasOwnProperty.call(m,"cryptoDeleteAllowance"))$root.proto.CryptoDeleteAllowanceTransactionBody.encode(m.cryptoDeleteAllowance,w.uint32(306).fork()).ldelim();if(m.tokenFeeScheduleUpdate!=null&&Object.hasOwnProperty.call(m,"tokenFeeScheduleUpdate"))$root.proto.TokenFeeScheduleUpdateTransactionBody.encode(m.tokenFeeScheduleUpdate,w.uint32(314).fork()).ldelim();if(m.utilPrng!=null&&Object.hasOwnProperty.call(m,"utilPrng"))$root.proto.UtilPrngTransactionBody.encode(m.utilPrng,w.uint32(322).fork()).ldelim();if(m.tokenUpdateNfts!=null&&Object.hasOwnProperty.call(m,"tokenUpdateNfts"))$root.proto.TokenUpdateNftsTransactionBody.encode(m.tokenUpdateNfts,w.uint32(330).fork()).ldelim();if(m.nodeCreate!=null&&Object.hasOwnProperty.call(m,"nodeCreate"))$root.com.hedera.hapi.node.addressbook.NodeCreateTransactionBody.encode(m.nodeCreate,w.uint32(338).fork()).ldelim();if(m.nodeUpdate!=null&&Object.hasOwnProperty.call(m,"nodeUpdate"))$root.com.hedera.hapi.node.addressbook.NodeUpdateTransactionBody.encode(m.nodeUpdate,w.uint32(346).fork()).ldelim();if(m.nodeDelete!=null&&Object.hasOwnProperty.call(m,"nodeDelete"))$root.com.hedera.hapi.node.addressbook.NodeDeleteTransactionBody.encode(m.nodeDelete,w.uint32(354).fork()).ldelim();if(m.tokenReject!=null&&Object.hasOwnProperty.call(m,"tokenReject"))$root.proto.TokenRejectTransactionBody.encode(m.tokenReject,w.uint32(362).fork()).ldelim();if(m.tokenCancelAirdrop!=null&&Object.hasOwnProperty.call(m,"tokenCancelAirdrop"))$root.proto.TokenCancelAirdropTransactionBody.encode(m.tokenCancelAirdrop,w.uint32(370).fork()).ldelim();if(m.tokenClaimAirdrop!=null&&Object.hasOwnProperty.call(m,"tokenClaimAirdrop"))$root.proto.TokenClaimAirdropTransactionBody.encode(m.tokenClaimAirdrop,w.uint32(378).fork()).ldelim();if(m.tokenAirdrop!=null&&Object.hasOwnProperty.call(m,"tokenAirdrop"))$root.proto.TokenAirdropTransactionBody.encode(m.tokenAirdrop,w.uint32(386).fork()).ldelim();if(m.maxCustomFees!=null&&m.maxCustomFees.length){for(var i=0;i<m.maxCustomFees.length;++i)$root.proto.CustomFeeLimit.encode(m.maxCustomFees[i],w.uint32(8010).fork()).ldelim();}return w;};SchedulableTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.SchedulableTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.transactionFee=r.uint64();break;}case 2:{m.memo=r.string();break;}case 3:{m.contractCall=$root.proto.ContractCallTransactionBody.decode(r,r.uint32());break;}case 4:{m.contractCreateInstance=$root.proto.ContractCreateTransactionBody.decode(r,r.uint32());break;}case 5:{m.contractUpdateInstance=$root.proto.ContractUpdateTransactionBody.decode(r,r.uint32());break;}case 6:{m.contractDeleteInstance=$root.proto.ContractDeleteTransactionBody.decode(r,r.uint32());break;}case 7:{m.cryptoCreateAccount=$root.proto.CryptoCreateTransactionBody.decode(r,r.uint32());break;}case 8:{m.cryptoDelete=$root.proto.CryptoDeleteTransactionBody.decode(r,r.uint32());break;}case 9:{m.cryptoTransfer=$root.proto.CryptoTransferTransactionBody.decode(r,r.uint32());break;}case 10:{m.cryptoUpdateAccount=$root.proto.CryptoUpdateTransactionBody.decode(r,r.uint32());break;}case 11:{m.fileAppend=$root.proto.FileAppendTransactionBody.decode(r,r.uint32());break;}case 12:{m.fileCreate=$root.proto.FileCreateTransactionBody.decode(r,r.uint32());break;}case 13:{m.fileDelete=$root.proto.FileDeleteTransactionBody.decode(r,r.uint32());break;}case 14:{m.fileUpdate=$root.proto.FileUpdateTransactionBody.decode(r,r.uint32());break;}case 15:{m.systemDelete=$root.proto.SystemDeleteTransactionBody.decode(r,r.uint32());break;}case 16:{m.systemUndelete=$root.proto.SystemUndeleteTransactionBody.decode(r,r.uint32());break;}case 17:{m.freeze=$root.proto.FreezeTransactionBody.decode(r,r.uint32());break;}case 18:{m.consensusCreateTopic=$root.proto.ConsensusCreateTopicTransactionBody.decode(r,r.uint32());break;}case 19:{m.consensusUpdateTopic=$root.proto.ConsensusUpdateTopicTransactionBody.decode(r,r.uint32());break;}case 20:{m.consensusDeleteTopic=$root.proto.ConsensusDeleteTopicTransactionBody.decode(r,r.uint32());break;}case 21:{m.consensusSubmitMessage=$root.proto.ConsensusSubmitMessageTransactionBody.decode(r,r.uint32());break;}case 22:{m.tokenCreation=$root.proto.TokenCreateTransactionBody.decode(r,r.uint32());break;}case 23:{m.tokenFreeze=$root.proto.TokenFreezeAccountTransactionBody.decode(r,r.uint32());break;}case 24:{m.tokenUnfreeze=$root.proto.TokenUnfreezeAccountTransactionBody.decode(r,r.uint32());break;}case 25:{m.tokenGrantKyc=$root.proto.TokenGrantKycTransactionBody.decode(r,r.uint32());break;}case 26:{m.tokenRevokeKyc=$root.proto.TokenRevokeKycTransactionBody.decode(r,r.uint32());break;}case 27:{m.tokenDeletion=$root.proto.TokenDeleteTransactionBody.decode(r,r.uint32());break;}case 28:{m.tokenUpdate=$root.proto.TokenUpdateTransactionBody.decode(r,r.uint32());break;}case 29:{m.tokenMint=$root.proto.TokenMintTransactionBody.decode(r,r.uint32());break;}case 30:{m.tokenBurn=$root.proto.TokenBurnTransactionBody.decode(r,r.uint32());break;}case 31:{m.tokenWipe=$root.proto.TokenWipeAccountTransactionBody.decode(r,r.uint32());break;}case 32:{m.tokenAssociate=$root.proto.TokenAssociateTransactionBody.decode(r,r.uint32());break;}case 33:{m.tokenDissociate=$root.proto.TokenDissociateTransactionBody.decode(r,r.uint32());break;}case 34:{m.scheduleDelete=$root.proto.ScheduleDeleteTransactionBody.decode(r,r.uint32());break;}case 35:{m.tokenPause=$root.proto.TokenPauseTransactionBody.decode(r,r.uint32());break;}case 36:{m.tokenUnpause=$root.proto.TokenUnpauseTransactionBody.decode(r,r.uint32());break;}case 37:{m.cryptoApproveAllowance=$root.proto.CryptoApproveAllowanceTransactionBody.decode(r,r.uint32());break;}case 38:{m.cryptoDeleteAllowance=$root.proto.CryptoDeleteAllowanceTransactionBody.decode(r,r.uint32());break;}case 39:{m.tokenFeeScheduleUpdate=$root.proto.TokenFeeScheduleUpdateTransactionBody.decode(r,r.uint32());break;}case 40:{m.utilPrng=$root.proto.UtilPrngTransactionBody.decode(r,r.uint32());break;}case 41:{m.tokenUpdateNfts=$root.proto.TokenUpdateNftsTransactionBody.decode(r,r.uint32());break;}case 42:{m.nodeCreate=$root.com.hedera.hapi.node.addressbook.NodeCreateTransactionBody.decode(r,r.uint32());break;}case 43:{m.nodeUpdate=$root.com.hedera.hapi.node.addressbook.NodeUpdateTransactionBody.decode(r,r.uint32());break;}case 44:{m.nodeDelete=$root.com.hedera.hapi.node.addressbook.NodeDeleteTransactionBody.decode(r,r.uint32());break;}case 45:{m.tokenReject=$root.proto.TokenRejectTransactionBody.decode(r,r.uint32());break;}case 46:{m.tokenCancelAirdrop=$root.proto.TokenCancelAirdropTransactionBody.decode(r,r.uint32());break;}case 47:{m.tokenClaimAirdrop=$root.proto.TokenClaimAirdropTransactionBody.decode(r,r.uint32());break;}case 48:{m.tokenAirdrop=$root.proto.TokenAirdropTransactionBody.decode(r,r.uint32());break;}case 1001:{if(!(m.maxCustomFees&&m.maxCustomFees.length))m.maxCustomFees=[];m.maxCustomFees.push($root.proto.CustomFeeLimit.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};SchedulableTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.SchedulableTransactionBody";};return SchedulableTransactionBody;}();proto.SystemDeleteTransactionBody=function(){function SystemDeleteTransactionBody(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}SystemDeleteTransactionBody.prototype.fileID=null;SystemDeleteTransactionBody.prototype.contractID=null;SystemDeleteTransactionBody.prototype.expirationTime=null;let $oneOfFields;Object.defineProperty(SystemDeleteTransactionBody.prototype,"id",{get:$util.oneOfGetter($oneOfFields=["fileID","contractID"]),set:$util.oneOfSetter($oneOfFields)});SystemDeleteTransactionBody.create=function create(properties){return new SystemDeleteTransactionBody(properties);};SystemDeleteTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.fileID!=null&&Object.hasOwnProperty.call(m,"fileID"))$root.proto.FileID.encode(m.fileID,w.uint32(10).fork()).ldelim();if(m.contractID!=null&&Object.hasOwnProperty.call(m,"contractID"))$root.proto.ContractID.encode(m.contractID,w.uint32(18).fork()).ldelim();if(m.expirationTime!=null&&Object.hasOwnProperty.call(m,"expirationTime"))$root.proto.TimestampSeconds.encode(m.expirationTime,w.uint32(26).fork()).ldelim();return w;};SystemDeleteTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.SystemDeleteTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.fileID=$root.proto.FileID.decode(r,r.uint32());break;}case 2:{m.contractID=$root.proto.ContractID.decode(r,r.uint32());break;}case 3:{m.expirationTime=$root.proto.TimestampSeconds.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};SystemDeleteTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.SystemDeleteTransactionBody";};return SystemDeleteTransactionBody;}();proto.SystemUndeleteTransactionBody=function(){function SystemUndeleteTransactionBody(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}SystemUndeleteTransactionBody.prototype.fileID=null;SystemUndeleteTransactionBody.prototype.contractID=null;let $oneOfFields;Object.defineProperty(SystemUndeleteTransactionBody.prototype,"id",{get:$util.oneOfGetter($oneOfFields=["fileID","contractID"]),set:$util.oneOfSetter($oneOfFields)});SystemUndeleteTransactionBody.create=function create(properties){return new SystemUndeleteTransactionBody(properties);};SystemUndeleteTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.fileID!=null&&Object.hasOwnProperty.call(m,"fileID"))$root.proto.FileID.encode(m.fileID,w.uint32(10).fork()).ldelim();if(m.contractID!=null&&Object.hasOwnProperty.call(m,"contractID"))$root.proto.ContractID.encode(m.contractID,w.uint32(18).fork()).ldelim();return w;};SystemUndeleteTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.SystemUndeleteTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.fileID=$root.proto.FileID.decode(r,r.uint32());break;}case 2:{m.contractID=$root.proto.ContractID.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};SystemUndeleteTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.SystemUndeleteTransactionBody";};return SystemUndeleteTransactionBody;}();proto.FreezeTransactionBody=function(){function FreezeTransactionBody(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}FreezeTransactionBody.prototype.startHour=0;FreezeTransactionBody.prototype.startMin=0;FreezeTransactionBody.prototype.endHour=0;FreezeTransactionBody.prototype.endMin=0;FreezeTransactionBody.prototype.updateFile=null;FreezeTransactionBody.prototype.fileHash=$util.newBuffer([]);FreezeTransactionBody.prototype.startTime=null;FreezeTransactionBody.prototype.freezeType=0;FreezeTransactionBody.create=function create(properties){return new FreezeTransactionBody(properties);};FreezeTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.startHour!=null&&Object.hasOwnProperty.call(m,"startHour"))w.uint32(8).int32(m.startHour);if(m.startMin!=null&&Object.hasOwnProperty.call(m,"startMin"))w.uint32(16).int32(m.startMin);if(m.endHour!=null&&Object.hasOwnProperty.call(m,"endHour"))w.uint32(24).int32(m.endHour);if(m.endMin!=null&&Object.hasOwnProperty.call(m,"endMin"))w.uint32(32).int32(m.endMin);if(m.updateFile!=null&&Object.hasOwnProperty.call(m,"updateFile"))$root.proto.FileID.encode(m.updateFile,w.uint32(42).fork()).ldelim();if(m.fileHash!=null&&Object.hasOwnProperty.call(m,"fileHash"))w.uint32(50).bytes(m.fileHash);if(m.startTime!=null&&Object.hasOwnProperty.call(m,"startTime"))$root.proto.Timestamp.encode(m.startTime,w.uint32(58).fork()).ldelim();if(m.freezeType!=null&&Object.hasOwnProperty.call(m,"freezeType"))w.uint32(64).int32(m.freezeType);return w;};FreezeTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.FreezeTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.startHour=r.int32();break;}case 2:{m.startMin=r.int32();break;}case 3:{m.endHour=r.int32();break;}case 4:{m.endMin=r.int32();break;}case 5:{m.updateFile=$root.proto.FileID.decode(r,r.uint32());break;}case 6:{m.fileHash=r.bytes();break;}case 7:{m.startTime=$root.proto.Timestamp.decode(r,r.uint32());break;}case 8:{m.freezeType=r.int32();break;}default:r.skipType(t&7);break;}}return m;};FreezeTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.FreezeTransactionBody";};return FreezeTransactionBody;}();proto.FreezeType=function(){const valuesById={},values=Object.create(valuesById);values[valuesById[0]="UNKNOWN_FREEZE_TYPE"]=0;values[valuesById[1]="FREEZE_ONLY"]=1;values[valuesById[2]="PREPARE_UPGRADE"]=2;values[valuesById[3]="FREEZE_UPGRADE"]=3;values[valuesById[4]="FREEZE_ABORT"]=4;values[valuesById[5]="TELEMETRY_UPGRADE"]=5;return values;}();proto.ContractCallTransactionBody=function(){function ContractCallTransactionBody(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ContractCallTransactionBody.prototype.contractID=null;ContractCallTransactionBody.prototype.gas=$util.Long?$util.Long.fromBits(0,0,false):0;ContractCallTransactionBody.prototype.amount=$util.Long?$util.Long.fromBits(0,0,false):0;ContractCallTransactionBody.prototype.functionParameters=$util.newBuffer([]);ContractCallTransactionBody.create=function create(properties){return new ContractCallTransactionBody(properties);};ContractCallTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.contractID!=null&&Object.hasOwnProperty.call(m,"contractID"))$root.proto.ContractID.encode(m.contractID,w.uint32(10).fork()).ldelim();if(m.gas!=null&&Object.hasOwnProperty.call(m,"gas"))w.uint32(16).int64(m.gas);if(m.amount!=null&&Object.hasOwnProperty.call(m,"amount"))w.uint32(24).int64(m.amount);if(m.functionParameters!=null&&Object.hasOwnProperty.call(m,"functionParameters"))w.uint32(34).bytes(m.functionParameters);return w;};ContractCallTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ContractCallTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.contractID=$root.proto.ContractID.decode(r,r.uint32());break;}case 2:{m.gas=r.int64();break;}case 3:{m.amount=r.int64();break;}case 4:{m.functionParameters=r.bytes();break;}default:r.skipType(t&7);break;}}return m;};ContractCallTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ContractCallTransactionBody";};return ContractCallTransactionBody;}();proto.ContractCreateTransactionBody=function(){function ContractCreateTransactionBody(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ContractCreateTransactionBody.prototype.fileID=null;ContractCreateTransactionBody.prototype.initcode=null;ContractCreateTransactionBody.prototype.adminKey=null;ContractCreateTransactionBody.prototype.gas=$util.Long?$util.Long.fromBits(0,0,false):0;ContractCreateTransactionBody.prototype.initialBalance=$util.Long?$util.Long.fromBits(0,0,false):0;ContractCreateTransactionBody.prototype.proxyAccountID=null;ContractCreateTransactionBody.prototype.autoRenewPeriod=null;ContractCreateTransactionBody.prototype.constructorParameters=$util.newBuffer([]);ContractCreateTransactionBody.prototype.shardID=null;ContractCreateTransactionBody.prototype.realmID=null;ContractCreateTransactionBody.prototype.newRealmAdminKey=null;ContractCreateTransactionBody.prototype.memo="";ContractCreateTransactionBody.prototype.maxAutomaticTokenAssociations=0;ContractCreateTransactionBody.prototype.autoRenewAccountId=null;ContractCreateTransactionBody.prototype.stakedAccountId=null;ContractCreateTransactionBody.prototype.stakedNodeId=null;ContractCreateTransactionBody.prototype.declineReward=false;let $oneOfFields;Object.defineProperty(ContractCreateTransactionBody.prototype,"initcodeSource",{get:$util.oneOfGetter($oneOfFields=["fileID","initcode"]),set:$util.oneOfSetter($oneOfFields)});Object.defineProperty(ContractCreateTransactionBody.prototype,"stakedId",{get:$util.oneOfGetter($oneOfFields=["stakedAccountId","stakedNodeId"]),set:$util.oneOfSetter($oneOfFields)});ContractCreateTransactionBody.create=function create(properties){return new ContractCreateTransactionBody(properties);};ContractCreateTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.fileID!=null&&Object.hasOwnProperty.call(m,"fileID"))$root.proto.FileID.encode(m.fileID,w.uint32(10).fork()).ldelim();if(m.adminKey!=null&&Object.hasOwnProperty.call(m,"adminKey"))$root.proto.Key.encode(m.adminKey,w.uint32(26).fork()).ldelim();if(m.gas!=null&&Object.hasOwnProperty.call(m,"gas"))w.uint32(32).int64(m.gas);if(m.initialBalance!=null&&Object.hasOwnProperty.call(m,"initialBalance"))w.uint32(40).int64(m.initialBalance);if(m.proxyAccountID!=null&&Object.hasOwnProperty.call(m,"proxyAccountID"))$root.proto.AccountID.encode(m.proxyAccountID,w.uint32(50).fork()).ldelim();if(m.autoRenewPeriod!=null&&Object.hasOwnProperty.call(m,"autoRenewPeriod"))$root.proto.Duration.encode(m.autoRenewPeriod,w.uint32(66).fork()).ldelim();if(m.constructorParameters!=null&&Object.hasOwnProperty.call(m,"constructorParameters"))w.uint32(74).bytes(m.constructorParameters);if(m.shardID!=null&&Object.hasOwnProperty.call(m,"shardID"))$root.proto.ShardID.encode(m.shardID,w.uint32(82).fork()).ldelim();if(m.realmID!=null&&Object.hasOwnProperty.call(m,"realmID"))$root.proto.RealmID.encode(m.realmID,w.uint32(90).fork()).ldelim();if(m.newRealmAdminKey!=null&&Object.hasOwnProperty.call(m,"newRealmAdminKey"))$root.proto.Key.encode(m.newRealmAdminKey,w.uint32(98).fork()).ldelim();if(m.memo!=null&&Object.hasOwnProperty.call(m,"memo"))w.uint32(106).string(m.memo);if(m.maxAutomaticTokenAssociations!=null&&Object.hasOwnProperty.call(m,"maxAutomaticTokenAssociations"))w.uint32(112).int32(m.maxAutomaticTokenAssociations);if(m.autoRenewAccountId!=null&&Object.hasOwnProperty.call(m,"autoRenewAccountId"))$root.proto.AccountID.encode(m.autoRenewAccountId,w.uint32(122).fork()).ldelim();if(m.initcode!=null&&Object.hasOwnProperty.call(m,"initcode"))w.uint32(130).bytes(m.initcode);if(m.stakedAccountId!=null&&Object.hasOwnProperty.call(m,"stakedAccountId"))$root.proto.AccountID.encode(m.stakedAccountId,w.uint32(138).fork()).ldelim();if(m.stakedNodeId!=null&&Object.hasOwnProperty.call(m,"stakedNodeId"))w.uint32(144).int64(m.stakedNodeId);if(m.declineReward!=null&&Object.hasOwnProperty.call(m,"declineReward"))w.uint32(152).bool(m.declineReward);return w;};ContractCreateTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ContractCreateTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.fileID=$root.proto.FileID.decode(r,r.uint32());break;}case 16:{m.initcode=r.bytes();break;}case 3:{m.adminKey=$root.proto.Key.decode(r,r.uint32());break;}case 4:{m.gas=r.int64();break;}case 5:{m.initialBalance=r.int64();break;}case 6:{m.proxyAccountID=$root.proto.AccountID.decode(r,r.uint32());break;}case 8:{m.autoRenewPeriod=$root.proto.Duration.decode(r,r.uint32());break;}case 9:{m.constructorParameters=r.bytes();break;}case 10:{m.shardID=$root.proto.ShardID.decode(r,r.uint32());break;}case 11:{m.realmID=$root.proto.RealmID.decode(r,r.uint32());break;}case 12:{m.newRealmAdminKey=$root.proto.Key.decode(r,r.uint32());break;}case 13:{m.memo=r.string();break;}case 14:{m.maxAutomaticTokenAssociations=r.int32();break;}case 15:{m.autoRenewAccountId=$root.proto.AccountID.decode(r,r.uint32());break;}case 17:{m.stakedAccountId=$root.proto.AccountID.decode(r,r.uint32());break;}case 18:{m.stakedNodeId=r.int64();break;}case 19:{m.declineReward=r.bool();break;}default:r.skipType(t&7);break;}}return m;};ContractCreateTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ContractCreateTransactionBody";};return ContractCreateTransactionBody;}();proto.ContractUpdateTransactionBody=function(){function ContractUpdateTransactionBody(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ContractUpdateTransactionBody.prototype.contractID=null;ContractUpdateTransactionBody.prototype.expirationTime=null;ContractUpdateTransactionBody.prototype.adminKey=null;ContractUpdateTransactionBody.prototype.proxyAccountID=null;ContractUpdateTransactionBody.prototype.autoRenewPeriod=null;ContractUpdateTransactionBody.prototype.fileID=null;ContractUpdateTransactionBody.prototype.memo=null;ContractUpdateTransactionBody.prototype.memoWrapper=null;ContractUpdateTransactionBody.prototype.maxAutomaticTokenAssociations=null;ContractUpdateTransactionBody.prototype.autoRenewAccountId=null;ContractUpdateTransactionBody.prototype.stakedAccountId=null;ContractUpdateTransactionBody.prototype.stakedNodeId=null;ContractUpdateTransactionBody.prototype.declineReward=null;let $oneOfFields;Object.defineProperty(ContractUpdateTransactionBody.prototype,"memoField",{get:$util.oneOfGetter($oneOfFields=["memo","memoWrapper"]),set:$util.oneOfSetter($oneOfFields)});Object.defineProperty(ContractUpdateTransactionBody.prototype,"stakedId",{get:$util.oneOfGetter($oneOfFields=["stakedAccountId","stakedNodeId"]),set:$util.oneOfSetter($oneOfFields)});ContractUpdateTransactionBody.create=function create(properties){return new ContractUpdateTransactionBody(properties);};ContractUpdateTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.contractID!=null&&Object.hasOwnProperty.call(m,"contractID"))$root.proto.ContractID.encode(m.contractID,w.uint32(10).fork()).ldelim();if(m.expirationTime!=null&&Object.hasOwnProperty.call(m,"expirationTime"))$root.proto.Timestamp.encode(m.expirationTime,w.uint32(18).fork()).ldelim();if(m.adminKey!=null&&Object.hasOwnProperty.call(m,"adminKey"))$root.proto.Key.encode(m.adminKey,w.uint32(26).fork()).ldelim();if(m.proxyAccountID!=null&&Object.hasOwnProperty.call(m,"proxyAccountID"))$root.proto.AccountID.encode(m.proxyAccountID,w.uint32(50).fork()).ldelim();if(m.autoRenewPeriod!=null&&Object.hasOwnProperty.call(m,"autoRenewPeriod"))$root.proto.Duration.encode(m.autoRenewPeriod,w.uint32(58).fork()).ldelim();if(m.fileID!=null&&Object.hasOwnProperty.call(m,"fileID"))$root.proto.FileID.encode(m.fileID,w.uint32(66).fork()).ldelim();if(m.memo!=null&&Object.hasOwnProperty.call(m,"memo"))w.uint32(74).string(m.memo);if(m.memoWrapper!=null&&Object.hasOwnProperty.call(m,"memoWrapper"))$root.google.protobuf.StringValue.encode(m.memoWrapper,w.uint32(82).fork()).ldelim();if(m.maxAutomaticTokenAssociations!=null&&Object.hasOwnProperty.call(m,"maxAutomaticTokenAssociations"))$root.google.protobuf.Int32Value.encode(m.maxAutomaticTokenAssociations,w.uint32(90).fork()).ldelim();if(m.autoRenewAccountId!=null&&Object.hasOwnProperty.call(m,"autoRenewAccountId"))$root.proto.AccountID.encode(m.autoRenewAccountId,w.uint32(98).fork()).ldelim();if(m.stakedAccountId!=null&&Object.hasOwnProperty.call(m,"stakedAccountId"))$root.proto.AccountID.encode(m.stakedAccountId,w.uint32(106).fork()).ldelim();if(m.stakedNodeId!=null&&Object.hasOwnProperty.call(m,"stakedNodeId"))w.uint32(112).int64(m.stakedNodeId);if(m.declineReward!=null&&Object.hasOwnProperty.call(m,"declineReward"))$root.google.protobuf.BoolValue.encode(m.declineReward,w.uint32(122).fork()).ldelim();return w;};ContractUpdateTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ContractUpdateTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.contractID=$root.proto.ContractID.decode(r,r.uint32());break;}case 2:{m.expirationTime=$root.proto.Timestamp.decode(r,r.uint32());break;}case 3:{m.adminKey=$root.proto.Key.decode(r,r.uint32());break;}case 6:{m.proxyAccountID=$root.proto.AccountID.decode(r,r.uint32());break;}case 7:{m.autoRenewPeriod=$root.proto.Duration.decode(r,r.uint32());break;}case 8:{m.fileID=$root.proto.FileID.decode(r,r.uint32());break;}case 9:{m.memo=r.string();break;}case 10:{m.memoWrapper=$root.google.protobuf.StringValue.decode(r,r.uint32());break;}case 11:{m.maxAutomaticTokenAssociations=$root.google.protobuf.Int32Value.decode(r,r.uint32());break;}case 12:{m.autoRenewAccountId=$root.proto.AccountID.decode(r,r.uint32());break;}case 13:{m.stakedAccountId=$root.proto.AccountID.decode(r,r.uint32());break;}case 14:{m.stakedNodeId=r.int64();break;}case 15:{m.declineReward=$root.google.protobuf.BoolValue.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};ContractUpdateTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ContractUpdateTransactionBody";};return ContractUpdateTransactionBody;}();proto.CryptoCreateTransactionBody=function(){function CryptoCreateTransactionBody(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}CryptoCreateTransactionBody.prototype.key=null;CryptoCreateTransactionBody.prototype.initialBalance=$util.Long?$util.Long.fromBits(0,0,true):0;CryptoCreateTransactionBody.prototype.proxyAccountID=null;CryptoCreateTransactionBody.prototype.sendRecordThreshold=$util.Long?$util.Long.fromBits(0,0,true):0;CryptoCreateTransactionBody.prototype.receiveRecordThreshold=$util.Long?$util.Long.fromBits(0,0,true):0;CryptoCreateTransactionBody.prototype.receiverSigRequired=false;CryptoCreateTransactionBody.prototype.autoRenewPeriod=null;CryptoCreateTransactionBody.prototype.shardID=null;CryptoCreateTransactionBody.prototype.realmID=null;CryptoCreateTransactionBody.prototype.newRealmAdminKey=null;CryptoCreateTransactionBody.prototype.memo="";CryptoCreateTransactionBody.prototype.maxAutomaticTokenAssociations=0;CryptoCreateTransactionBody.prototype.stakedAccountId=null;CryptoCreateTransactionBody.prototype.stakedNodeId=null;CryptoCreateTransactionBody.prototype.declineReward=false;CryptoCreateTransactionBody.prototype.alias=$util.newBuffer([]);let $oneOfFields;Object.defineProperty(CryptoCreateTransactionBody.prototype,"stakedId",{get:$util.oneOfGetter($oneOfFields=["stakedAccountId","stakedNodeId"]),set:$util.oneOfSetter($oneOfFields)});CryptoCreateTransactionBody.create=function create(properties){return new CryptoCreateTransactionBody(properties);};CryptoCreateTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.key!=null&&Object.hasOwnProperty.call(m,"key"))$root.proto.Key.encode(m.key,w.uint32(10).fork()).ldelim();if(m.initialBalance!=null&&Object.hasOwnProperty.call(m,"initialBalance"))w.uint32(16).uint64(m.initialBalance);if(m.proxyAccountID!=null&&Object.hasOwnProperty.call(m,"proxyAccountID"))$root.proto.AccountID.encode(m.proxyAccountID,w.uint32(26).fork()).ldelim();if(m.sendRecordThreshold!=null&&Object.hasOwnProperty.call(m,"sendRecordThreshold"))w.uint32(48).uint64(m.sendRecordThreshold);if(m.receiveRecordThreshold!=null&&Object.hasOwnProperty.call(m,"receiveRecordThreshold"))w.uint32(56).uint64(m.receiveRecordThreshold);if(m.receiverSigRequired!=null&&Object.hasOwnProperty.call(m,"receiverSigRequired"))w.uint32(64).bool(m.receiverSigRequired);if(m.autoRenewPeriod!=null&&Object.hasOwnProperty.call(m,"autoRenewPeriod"))$root.proto.Duration.encode(m.autoRenewPeriod,w.uint32(74).fork()).ldelim();if(m.shardID!=null&&Object.hasOwnProperty.call(m,"shardID"))$root.proto.ShardID.encode(m.shardID,w.uint32(82).fork()).ldelim();if(m.realmID!=null&&Object.hasOwnProperty.call(m,"realmID"))$root.proto.RealmID.encode(m.realmID,w.uint32(90).fork()).ldelim();if(m.newRealmAdminKey!=null&&Object.hasOwnProperty.call(m,"newRealmAdminKey"))$root.proto.Key.encode(m.newRealmAdminKey,w.uint32(98).fork()).ldelim();if(m.memo!=null&&Object.hasOwnProperty.call(m,"memo"))w.uint32(106).string(m.memo);if(m.maxAutomaticTokenAssociations!=null&&Object.hasOwnProperty.call(m,"maxAutomaticTokenAssociations"))w.uint32(112).int32(m.maxAutomaticTokenAssociations);if(m.stakedAccountId!=null&&Object.hasOwnProperty.call(m,"stakedAccountId"))$root.proto.AccountID.encode(m.stakedAccountId,w.uint32(122).fork()).ldelim();if(m.stakedNodeId!=null&&Object.hasOwnProperty.call(m,"stakedNodeId"))w.uint32(128).int64(m.stakedNodeId);if(m.declineReward!=null&&Object.hasOwnProperty.call(m,"declineReward"))w.uint32(136).bool(m.declineReward);if(m.alias!=null&&Object.hasOwnProperty.call(m,"alias"))w.uint32(146).bytes(m.alias);return w;};CryptoCreateTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.CryptoCreateTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.key=$root.proto.Key.decode(r,r.uint32());break;}case 2:{m.initialBalance=r.uint64();break;}case 3:{m.proxyAccountID=$root.proto.AccountID.decode(r,r.uint32());break;}case 6:{m.sendRecordThreshold=r.uint64();break;}case 7:{m.receiveRecordThreshold=r.uint64();break;}case 8:{m.receiverSigRequired=r.bool();break;}case 9:{m.autoRenewPeriod=$root.proto.Duration.decode(r,r.uint32());break;}case 10:{m.shardID=$root.proto.ShardID.decode(r,r.uint32());break;}case 11:{m.realmID=$root.proto.RealmID.decode(r,r.uint32());break;}case 12:{m.newRealmAdminKey=$root.proto.Key.decode(r,r.uint32());break;}case 13:{m.memo=r.string();break;}case 14:{m.maxAutomaticTokenAssociations=r.int32();break;}case 15:{m.stakedAccountId=$root.proto.AccountID.decode(r,r.uint32());break;}case 16:{m.stakedNodeId=r.int64();break;}case 17:{m.declineReward=r.bool();break;}case 18:{m.alias=r.bytes();break;}default:r.skipType(t&7);break;}}return m;};CryptoCreateTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.CryptoCreateTransactionBody";};return CryptoCreateTransactionBody;}();proto.CryptoDeleteTransactionBody=function(){function CryptoDeleteTransactionBody(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}CryptoDeleteTransactionBody.prototype.transferAccountID=null;CryptoDeleteTransactionBody.prototype.deleteAccountID=null;CryptoDeleteTransactionBody.create=function create(properties){return new CryptoDeleteTransactionBody(properties);};CryptoDeleteTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.transferAccountID!=null&&Object.hasOwnProperty.call(m,"transferAccountID"))$root.proto.AccountID.encode(m.transferAccountID,w.uint32(10).fork()).ldelim();if(m.deleteAccountID!=null&&Object.hasOwnProperty.call(m,"deleteAccountID"))$root.proto.AccountID.encode(m.deleteAccountID,w.uint32(18).fork()).ldelim();return w;};CryptoDeleteTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.CryptoDeleteTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.transferAccountID=$root.proto.AccountID.decode(r,r.uint32());break;}case 2:{m.deleteAccountID=$root.proto.AccountID.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};CryptoDeleteTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.CryptoDeleteTransactionBody";};return CryptoDeleteTransactionBody;}();proto.CryptoTransferTransactionBody=function(){function CryptoTransferTransactionBody(p){this.tokenTransfers=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}CryptoTransferTransactionBody.prototype.transfers=null;CryptoTransferTransactionBody.prototype.tokenTransfers=$util.emptyArray;CryptoTransferTransactionBody.create=function create(properties){return new CryptoTransferTransactionBody(properties);};CryptoTransferTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.transfers!=null&&Object.hasOwnProperty.call(m,"transfers"))$root.proto.TransferList.encode(m.transfers,w.uint32(10).fork()).ldelim();if(m.tokenTransfers!=null&&m.tokenTransfers.length){for(var i=0;i<m.tokenTransfers.length;++i)$root.proto.TokenTransferList.encode(m.tokenTransfers[i],w.uint32(18).fork()).ldelim();}return w;};CryptoTransferTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.CryptoTransferTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.transfers=$root.proto.TransferList.decode(r,r.uint32());break;}case 2:{if(!(m.tokenTransfers&&m.tokenTransfers.length))m.tokenTransfers=[];m.tokenTransfers.push($root.proto.TokenTransferList.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};CryptoTransferTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.CryptoTransferTransactionBody";};return CryptoTransferTransactionBody;}();proto.CryptoUpdateTransactionBody=function(){function CryptoUpdateTransactionBody(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}CryptoUpdateTransactionBody.prototype.accountIDToUpdate=null;CryptoUpdateTransactionBody.prototype.key=null;CryptoUpdateTransactionBody.prototype.proxyAccountID=null;CryptoUpdateTransactionBody.prototype.proxyFraction=0;CryptoUpdateTransactionBody.prototype.sendRecordThreshold=null;CryptoUpdateTransactionBody.prototype.sendRecordThresholdWrapper=null;CryptoUpdateTransactionBody.prototype.receiveRecordThreshold=null;CryptoUpdateTransactionBody.prototype.receiveRecordThresholdWrapper=null;CryptoUpdateTransactionBody.prototype.autoRenewPeriod=null;CryptoUpdateTransactionBody.prototype.expirationTime=null;CryptoUpdateTransactionBody.prototype.receiverSigRequired=null;CryptoUpdateTransactionBody.prototype.receiverSigRequiredWrapper=null;CryptoUpdateTransactionBody.prototype.memo=null;CryptoUpdateTransactionBody.prototype.maxAutomaticTokenAssociations=null;CryptoUpdateTransactionBody.prototype.stakedAccountId=null;CryptoUpdateTransactionBody.prototype.stakedNodeId=null;CryptoUpdateTransactionBody.prototype.declineReward=null;let $oneOfFields;Object.defineProperty(CryptoUpdateTransactionBody.prototype,"sendRecordThresholdField",{get:$util.oneOfGetter($oneOfFields=["sendRecordThreshold","sendRecordThresholdWrapper"]),set:$util.oneOfSetter($oneOfFields)});Object.defineProperty(CryptoUpdateTransactionBody.prototype,"receiveRecordThresholdField",{get:$util.oneOfGetter($oneOfFields=["receiveRecordThreshold","receiveRecordThresholdWrapper"]),set:$util.oneOfSetter($oneOfFields)});Object.defineProperty(CryptoUpdateTransactionBody.prototype,"receiverSigRequiredField",{get:$util.oneOfGetter($oneOfFields=["receiverSigRequired","receiverSigRequiredWrapper"]),set:$util.oneOfSetter($oneOfFields)});Object.defineProperty(CryptoUpdateTransactionBody.prototype,"stakedId",{get:$util.oneOfGetter($oneOfFields=["stakedAccountId","stakedNodeId"]),set:$util.oneOfSetter($oneOfFields)});CryptoUpdateTransactionBody.create=function create(properties){return new CryptoUpdateTransactionBody(properties);};CryptoUpdateTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.accountIDToUpdate!=null&&Object.hasOwnProperty.call(m,"accountIDToUpdate"))$root.proto.AccountID.encode(m.accountIDToUpdate,w.uint32(18).fork()).ldelim();if(m.key!=null&&Object.hasOwnProperty.call(m,"key"))$root.proto.Key.encode(m.key,w.uint32(26).fork()).ldelim();if(m.proxyAccountID!=null&&Object.hasOwnProperty.call(m,"proxyAccountID"))$root.proto.AccountID.encode(m.proxyAccountID,w.uint32(34).fork()).ldelim();if(m.proxyFraction!=null&&Object.hasOwnProperty.call(m,"proxyFraction"))w.uint32(40).int32(m.proxyFraction);if(m.sendRecordThreshold!=null&&Object.hasOwnProperty.call(m,"sendRecordThreshold"))w.uint32(48).uint64(m.sendRecordThreshold);if(m.receiveRecordThreshold!=null&&Object.hasOwnProperty.call(m,"receiveRecordThreshold"))w.uint32(56).uint64(m.receiveRecordThreshold);if(m.autoRenewPeriod!=null&&Object.hasOwnProperty.call(m,"autoRenewPeriod"))$root.proto.Duration.encode(m.autoRenewPeriod,w.uint32(66).fork()).ldelim();if(m.expirationTime!=null&&Object.hasOwnProperty.call(m,"expirationTime"))$root.proto.Timestamp.encode(m.expirationTime,w.uint32(74).fork()).ldelim();if(m.receiverSigRequired!=null&&Object.hasOwnProperty.call(m,"receiverSigRequired"))w.uint32(80).bool(m.receiverSigRequired);if(m.sendRecordThresholdWrapper!=null&&Object.hasOwnProperty.call(m,"sendRecordThresholdWrapper"))$root.google.protobuf.UInt64Value.encode(m.sendRecordThresholdWrapper,w.uint32(90).fork()).ldelim();if(m.receiveRecordThresholdWrapper!=null&&Object.hasOwnProperty.call(m,"receiveRecordThresholdWrapper"))$root.google.protobuf.UInt64Value.encode(m.receiveRecordThresholdWrapper,w.uint32(98).fork()).ldelim();if(m.receiverSigRequiredWrapper!=null&&Object.hasOwnProperty.call(m,"receiverSigRequiredWrapper"))$root.google.protobuf.BoolValue.encode(m.receiverSigRequiredWrapper,w.uint32(106).fork()).ldelim();if(m.memo!=null&&Object.hasOwnProperty.call(m,"memo"))$root.google.protobuf.StringValue.encode(m.memo,w.uint32(114).fork()).ldelim();if(m.maxAutomaticTokenAssociations!=null&&Object.hasOwnProperty.call(m,"maxAutomaticTokenAssociations"))$root.google.protobuf.Int32Value.encode(m.maxAutomaticTokenAssociations,w.uint32(122).fork()).ldelim();if(m.stakedAccountId!=null&&Object.hasOwnProperty.call(m,"stakedAccountId"))$root.proto.AccountID.encode(m.stakedAccountId,w.uint32(130).fork()).ldelim();if(m.stakedNodeId!=null&&Object.hasOwnProperty.call(m,"stakedNodeId"))w.uint32(136).int64(m.stakedNodeId);if(m.declineReward!=null&&Object.hasOwnProperty.call(m,"declineReward"))$root.google.protobuf.BoolValue.encode(m.declineReward,w.uint32(146).fork()).ldelim();return w;};CryptoUpdateTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.CryptoUpdateTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 2:{m.accountIDToUpdate=$root.proto.AccountID.decode(r,r.uint32());break;}case 3:{m.key=$root.proto.Key.decode(r,r.uint32());break;}case 4:{m.proxyAccountID=$root.proto.AccountID.decode(r,r.uint32());break;}case 5:{m.proxyFraction=r.int32();break;}case 6:{m.sendRecordThreshold=r.uint64();break;}case 11:{m.sendRecordThresholdWrapper=$root.google.protobuf.UInt64Value.decode(r,r.uint32());break;}case 7:{m.receiveRecordThreshold=r.uint64();break;}case 12:{m.receiveRecordThresholdWrapper=$root.google.protobuf.UInt64Value.decode(r,r.uint32());break;}case 8:{m.autoRenewPeriod=$root.proto.Duration.decode(r,r.uint32());break;}case 9:{m.expirationTime=$root.proto.Timestamp.decode(r,r.uint32());break;}case 10:{m.receiverSigRequired=r.bool();break;}case 13:{m.receiverSigRequiredWrapper=$root.google.protobuf.BoolValue.decode(r,r.uint32());break;}case 14:{m.memo=$root.google.protobuf.StringValue.decode(r,r.uint32());break;}case 15:{m.maxAutomaticTokenAssociations=$root.google.protobuf.Int32Value.decode(r,r.uint32());break;}case 16:{m.stakedAccountId=$root.proto.AccountID.decode(r,r.uint32());break;}case 17:{m.stakedNodeId=r.int64();break;}case 18:{m.declineReward=$root.google.protobuf.BoolValue.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};CryptoUpdateTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.CryptoUpdateTransactionBody";};return CryptoUpdateTransactionBody;}();proto.CryptoApproveAllowanceTransactionBody=function(){function CryptoApproveAllowanceTransactionBody(p){this.cryptoAllowances=[];this.nftAllowances=[];this.tokenAllowances=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}CryptoApproveAllowanceTransactionBody.prototype.cryptoAllowances=$util.emptyArray;CryptoApproveAllowanceTransactionBody.prototype.nftAllowances=$util.emptyArray;CryptoApproveAllowanceTransactionBody.prototype.tokenAllowances=$util.emptyArray;CryptoApproveAllowanceTransactionBody.create=function create(properties){return new CryptoApproveAllowanceTransactionBody(properties);};CryptoApproveAllowanceTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.cryptoAllowances!=null&&m.cryptoAllowances.length){for(var i=0;i<m.cryptoAllowances.length;++i)$root.proto.CryptoAllowance.encode(m.cryptoAllowances[i],w.uint32(10).fork()).ldelim();}if(m.nftAllowances!=null&&m.nftAllowances.length){for(var i=0;i<m.nftAllowances.length;++i)$root.proto.NftAllowance.encode(m.nftAllowances[i],w.uint32(18).fork()).ldelim();}if(m.tokenAllowances!=null&&m.tokenAllowances.length){for(var i=0;i<m.tokenAllowances.length;++i)$root.proto.TokenAllowance.encode(m.tokenAllowances[i],w.uint32(26).fork()).ldelim();}return w;};CryptoApproveAllowanceTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.CryptoApproveAllowanceTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{if(!(m.cryptoAllowances&&m.cryptoAllowances.length))m.cryptoAllowances=[];m.cryptoAllowances.push($root.proto.CryptoAllowance.decode(r,r.uint32()));break;}case 2:{if(!(m.nftAllowances&&m.nftAllowances.length))m.nftAllowances=[];m.nftAllowances.push($root.proto.NftAllowance.decode(r,r.uint32()));break;}case 3:{if(!(m.tokenAllowances&&m.tokenAllowances.length))m.tokenAllowances=[];m.tokenAllowances.push($root.proto.TokenAllowance.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};CryptoApproveAllowanceTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.CryptoApproveAllowanceTransactionBody";};return CryptoApproveAllowanceTransactionBody;}();proto.CryptoAllowance=function(){function CryptoAllowance(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}CryptoAllowance.prototype.owner=null;CryptoAllowance.prototype.spender=null;CryptoAllowance.prototype.amount=$util.Long?$util.Long.fromBits(0,0,false):0;CryptoAllowance.create=function create(properties){return new CryptoAllowance(properties);};CryptoAllowance.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.owner!=null&&Object.hasOwnProperty.call(m,"owner"))$root.proto.AccountID.encode(m.owner,w.uint32(10).fork()).ldelim();if(m.spender!=null&&Object.hasOwnProperty.call(m,"spender"))$root.proto.AccountID.encode(m.spender,w.uint32(18).fork()).ldelim();if(m.amount!=null&&Object.hasOwnProperty.call(m,"amount"))w.uint32(24).int64(m.amount);return w;};CryptoAllowance.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.CryptoAllowance();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.owner=$root.proto.AccountID.decode(r,r.uint32());break;}case 2:{m.spender=$root.proto.AccountID.decode(r,r.uint32());break;}case 3:{m.amount=r.int64();break;}default:r.skipType(t&7);break;}}return m;};CryptoAllowance.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.CryptoAllowance";};return CryptoAllowance;}();proto.NftAllowance=function(){function NftAllowance(p){this.serialNumbers=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}NftAllowance.prototype.tokenId=null;NftAllowance.prototype.owner=null;NftAllowance.prototype.spender=null;NftAllowance.prototype.serialNumbers=$util.emptyArray;NftAllowance.prototype.approvedForAll=null;NftAllowance.prototype.delegatingSpender=null;NftAllowance.create=function create(properties){return new NftAllowance(properties);};NftAllowance.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.tokenId!=null&&Object.hasOwnProperty.call(m,"tokenId"))$root.proto.TokenID.encode(m.tokenId,w.uint32(10).fork()).ldelim();if(m.owner!=null&&Object.hasOwnProperty.call(m,"owner"))$root.proto.AccountID.encode(m.owner,w.uint32(18).fork()).ldelim();if(m.spender!=null&&Object.hasOwnProperty.call(m,"spender"))$root.proto.AccountID.encode(m.spender,w.uint32(26).fork()).ldelim();if(m.serialNumbers!=null&&m.serialNumbers.length){w.uint32(34).fork();for(var i=0;i<m.serialNumbers.length;++i)w.int64(m.serialNumbers[i]);w.ldelim();}if(m.approvedForAll!=null&&Object.hasOwnProperty.call(m,"approvedForAll"))$root.google.protobuf.BoolValue.encode(m.approvedForAll,w.uint32(42).fork()).ldelim();if(m.delegatingSpender!=null&&Object.hasOwnProperty.call(m,"delegatingSpender"))$root.proto.AccountID.encode(m.delegatingSpender,w.uint32(50).fork()).ldelim();return w;};NftAllowance.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.NftAllowance();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.tokenId=$root.proto.TokenID.decode(r,r.uint32());break;}case 2:{m.owner=$root.proto.AccountID.decode(r,r.uint32());break;}case 3:{m.spender=$root.proto.AccountID.decode(r,r.uint32());break;}case 4:{if(!(m.serialNumbers&&m.serialNumbers.length))m.serialNumbers=[];if((t&7)===2){var c2=r.uint32()+r.pos;while(r.pos<c2)m.serialNumbers.push(r.int64());}else m.serialNumbers.push(r.int64());break;}case 5:{m.approvedForAll=$root.google.protobuf.BoolValue.decode(r,r.uint32());break;}case 6:{m.delegatingSpender=$root.proto.AccountID.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};NftAllowance.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.NftAllowance";};return NftAllowance;}();proto.TokenAllowance=function(){function TokenAllowance(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TokenAllowance.prototype.tokenId=null;TokenAllowance.prototype.owner=null;TokenAllowance.prototype.spender=null;TokenAllowance.prototype.amount=$util.Long?$util.Long.fromBits(0,0,false):0;TokenAllowance.create=function create(properties){return new TokenAllowance(properties);};TokenAllowance.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.tokenId!=null&&Object.hasOwnProperty.call(m,"tokenId"))$root.proto.TokenID.encode(m.tokenId,w.uint32(10).fork()).ldelim();if(m.owner!=null&&Object.hasOwnProperty.call(m,"owner"))$root.proto.AccountID.encode(m.owner,w.uint32(18).fork()).ldelim();if(m.spender!=null&&Object.hasOwnProperty.call(m,"spender"))$root.proto.AccountID.encode(m.spender,w.uint32(26).fork()).ldelim();if(m.amount!=null&&Object.hasOwnProperty.call(m,"amount"))w.uint32(32).int64(m.amount);return w;};TokenAllowance.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TokenAllowance();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.tokenId=$root.proto.TokenID.decode(r,r.uint32());break;}case 2:{m.owner=$root.proto.AccountID.decode(r,r.uint32());break;}case 3:{m.spender=$root.proto.AccountID.decode(r,r.uint32());break;}case 4:{m.amount=r.int64();break;}default:r.skipType(t&7);break;}}return m;};TokenAllowance.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TokenAllowance";};return TokenAllowance;}();proto.CryptoDeleteAllowanceTransactionBody=function(){function CryptoDeleteAllowanceTransactionBody(p){this.nftAllowances=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}CryptoDeleteAllowanceTransactionBody.prototype.nftAllowances=$util.emptyArray;CryptoDeleteAllowanceTransactionBody.create=function create(properties){return new CryptoDeleteAllowanceTransactionBody(properties);};CryptoDeleteAllowanceTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.nftAllowances!=null&&m.nftAllowances.length){for(var i=0;i<m.nftAllowances.length;++i)$root.proto.NftRemoveAllowance.encode(m.nftAllowances[i],w.uint32(18).fork()).ldelim();}return w;};CryptoDeleteAllowanceTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.CryptoDeleteAllowanceTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 2:{if(!(m.nftAllowances&&m.nftAllowances.length))m.nftAllowances=[];m.nftAllowances.push($root.proto.NftRemoveAllowance.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};CryptoDeleteAllowanceTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.CryptoDeleteAllowanceTransactionBody";};return CryptoDeleteAllowanceTransactionBody;}();proto.NftRemoveAllowance=function(){function NftRemoveAllowance(p){this.serialNumbers=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}NftRemoveAllowance.prototype.tokenId=null;NftRemoveAllowance.prototype.owner=null;NftRemoveAllowance.prototype.serialNumbers=$util.emptyArray;NftRemoveAllowance.create=function create(properties){return new NftRemoveAllowance(properties);};NftRemoveAllowance.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.tokenId!=null&&Object.hasOwnProperty.call(m,"tokenId"))$root.proto.TokenID.encode(m.tokenId,w.uint32(10).fork()).ldelim();if(m.owner!=null&&Object.hasOwnProperty.call(m,"owner"))$root.proto.AccountID.encode(m.owner,w.uint32(18).fork()).ldelim();if(m.serialNumbers!=null&&m.serialNumbers.length){w.uint32(26).fork();for(var i=0;i<m.serialNumbers.length;++i)w.int64(m.serialNumbers[i]);w.ldelim();}return w;};NftRemoveAllowance.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.NftRemoveAllowance();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.tokenId=$root.proto.TokenID.decode(r,r.uint32());break;}case 2:{m.owner=$root.proto.AccountID.decode(r,r.uint32());break;}case 3:{if(!(m.serialNumbers&&m.serialNumbers.length))m.serialNumbers=[];if((t&7)===2){var c2=r.uint32()+r.pos;while(r.pos<c2)m.serialNumbers.push(r.int64());}else m.serialNumbers.push(r.int64());break;}default:r.skipType(t&7);break;}}return m;};NftRemoveAllowance.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.NftRemoveAllowance";};return NftRemoveAllowance;}();proto.FileAppendTransactionBody=function(){function FileAppendTransactionBody(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}FileAppendTransactionBody.prototype.fileID=null;FileAppendTransactionBody.prototype.contents=$util.newBuffer([]);FileAppendTransactionBody.create=function create(properties){return new FileAppendTransactionBody(properties);};FileAppendTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.fileID!=null&&Object.hasOwnProperty.call(m,"fileID"))$root.proto.FileID.encode(m.fileID,w.uint32(18).fork()).ldelim();if(m.contents!=null&&Object.hasOwnProperty.call(m,"contents"))w.uint32(34).bytes(m.contents);return w;};FileAppendTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.FileAppendTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 2:{m.fileID=$root.proto.FileID.decode(r,r.uint32());break;}case 4:{m.contents=r.bytes();break;}default:r.skipType(t&7);break;}}return m;};FileAppendTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.FileAppendTransactionBody";};return FileAppendTransactionBody;}();proto.FileCreateTransactionBody=function(){function FileCreateTransactionBody(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}FileCreateTransactionBody.prototype.expirationTime=null;FileCreateTransactionBody.prototype.keys=null;FileCreateTransactionBody.prototype.contents=$util.newBuffer([]);FileCreateTransactionBody.prototype.shardID=null;FileCreateTransactionBody.prototype.realmID=null;FileCreateTransactionBody.prototype.newRealmAdminKey=null;FileCreateTransactionBody.prototype.memo="";FileCreateTransactionBody.create=function create(properties){return new FileCreateTransactionBody(properties);};FileCreateTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.expirationTime!=null&&Object.hasOwnProperty.call(m,"expirationTime"))$root.proto.Timestamp.encode(m.expirationTime,w.uint32(18).fork()).ldelim();if(m.keys!=null&&Object.hasOwnProperty.call(m,"keys"))$root.proto.KeyList.encode(m.keys,w.uint32(26).fork()).ldelim();if(m.contents!=null&&Object.hasOwnProperty.call(m,"contents"))w.uint32(34).bytes(m.contents);if(m.shardID!=null&&Object.hasOwnProperty.call(m,"shardID"))$root.proto.ShardID.encode(m.shardID,w.uint32(42).fork()).ldelim();if(m.realmID!=null&&Object.hasOwnProperty.call(m,"realmID"))$root.proto.RealmID.encode(m.realmID,w.uint32(50).fork()).ldelim();if(m.newRealmAdminKey!=null&&Object.hasOwnProperty.call(m,"newRealmAdminKey"))$root.proto.Key.encode(m.newRealmAdminKey,w.uint32(58).fork()).ldelim();if(m.memo!=null&&Object.hasOwnProperty.call(m,"memo"))w.uint32(66).string(m.memo);return w;};FileCreateTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.FileCreateTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 2:{m.expirationTime=$root.proto.Timestamp.decode(r,r.uint32());break;}case 3:{m.keys=$root.proto.KeyList.decode(r,r.uint32());break;}case 4:{m.contents=r.bytes();break;}case 5:{m.shardID=$root.proto.ShardID.decode(r,r.uint32());break;}case 6:{m.realmID=$root.proto.RealmID.decode(r,r.uint32());break;}case 7:{m.newRealmAdminKey=$root.proto.Key.decode(r,r.uint32());break;}case 8:{m.memo=r.string();break;}default:r.skipType(t&7);break;}}return m;};FileCreateTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.FileCreateTransactionBody";};return FileCreateTransactionBody;}();proto.FileDeleteTransactionBody=function(){function FileDeleteTransactionBody(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}FileDeleteTransactionBody.prototype.fileID=null;FileDeleteTransactionBody.create=function create(properties){return new FileDeleteTransactionBody(properties);};FileDeleteTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.fileID!=null&&Object.hasOwnProperty.call(m,"fileID"))$root.proto.FileID.encode(m.fileID,w.uint32(18).fork()).ldelim();return w;};FileDeleteTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.FileDeleteTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 2:{m.fileID=$root.proto.FileID.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};FileDeleteTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.FileDeleteTransactionBody";};return FileDeleteTransactionBody;}();proto.FileUpdateTransactionBody=function(){function FileUpdateTransactionBody(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}FileUpdateTransactionBody.prototype.fileID=null;FileUpdateTransactionBody.prototype.expirationTime=null;FileUpdateTransactionBody.prototype.keys=null;FileUpdateTransactionBody.prototype.contents=$util.newBuffer([]);FileUpdateTransactionBody.prototype.memo=null;FileUpdateTransactionBody.create=function create(properties){return new FileUpdateTransactionBody(properties);};FileUpdateTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.fileID!=null&&Object.hasOwnProperty.call(m,"fileID"))$root.proto.FileID.encode(m.fileID,w.uint32(10).fork()).ldelim();if(m.expirationTime!=null&&Object.hasOwnProperty.call(m,"expirationTime"))$root.proto.Timestamp.encode(m.expirationTime,w.uint32(18).fork()).ldelim();if(m.keys!=null&&Object.hasOwnProperty.call(m,"keys"))$root.proto.KeyList.encode(m.keys,w.uint32(26).fork()).ldelim();if(m.contents!=null&&Object.hasOwnProperty.call(m,"contents"))w.uint32(34).bytes(m.contents);if(m.memo!=null&&Object.hasOwnProperty.call(m,"memo"))$root.google.protobuf.StringValue.encode(m.memo,w.uint32(42).fork()).ldelim();return w;};FileUpdateTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.FileUpdateTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.fileID=$root.proto.FileID.decode(r,r.uint32());break;}case 2:{m.expirationTime=$root.proto.Timestamp.decode(r,r.uint32());break;}case 3:{m.keys=$root.proto.KeyList.decode(r,r.uint32());break;}case 4:{m.contents=r.bytes();break;}case 5:{m.memo=$root.google.protobuf.StringValue.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};FileUpdateTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.FileUpdateTransactionBody";};return FileUpdateTransactionBody;}();proto.ContractDeleteTransactionBody=function(){function ContractDeleteTransactionBody(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ContractDeleteTransactionBody.prototype.contractID=null;ContractDeleteTransactionBody.prototype.transferAccountID=null;ContractDeleteTransactionBody.prototype.transferContractID=null;ContractDeleteTransactionBody.prototype.permanentRemoval=false;let $oneOfFields;Object.defineProperty(ContractDeleteTransactionBody.prototype,"obtainers",{get:$util.oneOfGetter($oneOfFields=["transferAccountID","transferContractID"]),set:$util.oneOfSetter($oneOfFields)});ContractDeleteTransactionBody.create=function create(properties){return new ContractDeleteTransactionBody(properties);};ContractDeleteTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.contractID!=null&&Object.hasOwnProperty.call(m,"contractID"))$root.proto.ContractID.encode(m.contractID,w.uint32(10).fork()).ldelim();if(m.transferAccountID!=null&&Object.hasOwnProperty.call(m,"transferAccountID"))$root.proto.AccountID.encode(m.transferAccountID,w.uint32(18).fork()).ldelim();if(m.transferContractID!=null&&Object.hasOwnProperty.call(m,"transferContractID"))$root.proto.ContractID.encode(m.transferContractID,w.uint32(26).fork()).ldelim();if(m.permanentRemoval!=null&&Object.hasOwnProperty.call(m,"permanentRemoval"))w.uint32(32).bool(m.permanentRemoval);return w;};ContractDeleteTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ContractDeleteTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.contractID=$root.proto.ContractID.decode(r,r.uint32());break;}case 2:{m.transferAccountID=$root.proto.AccountID.decode(r,r.uint32());break;}case 3:{m.transferContractID=$root.proto.ContractID.decode(r,r.uint32());break;}case 4:{m.permanentRemoval=r.bool();break;}default:r.skipType(t&7);break;}}return m;};ContractDeleteTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ContractDeleteTransactionBody";};return ContractDeleteTransactionBody;}();proto.ConsensusUpdateTopicTransactionBody=function(){function ConsensusUpdateTopicTransactionBody(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ConsensusUpdateTopicTransactionBody.prototype.topicID=null;ConsensusUpdateTopicTransactionBody.prototype.memo=null;ConsensusUpdateTopicTransactionBody.prototype.expirationTime=null;ConsensusUpdateTopicTransactionBody.prototype.adminKey=null;ConsensusUpdateTopicTransactionBody.prototype.submitKey=null;ConsensusUpdateTopicTransactionBody.prototype.autoRenewPeriod=null;ConsensusUpdateTopicTransactionBody.prototype.autoRenewAccount=null;ConsensusUpdateTopicTransactionBody.prototype.feeScheduleKey=null;ConsensusUpdateTopicTransactionBody.prototype.feeExemptKeyList=null;ConsensusUpdateTopicTransactionBody.prototype.customFees=null;ConsensusUpdateTopicTransactionBody.create=function create(properties){return new ConsensusUpdateTopicTransactionBody(properties);};ConsensusUpdateTopicTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.topicID!=null&&Object.hasOwnProperty.call(m,"topicID"))$root.proto.TopicID.encode(m.topicID,w.uint32(10).fork()).ldelim();if(m.memo!=null&&Object.hasOwnProperty.call(m,"memo"))$root.google.protobuf.StringValue.encode(m.memo,w.uint32(18).fork()).ldelim();if(m.expirationTime!=null&&Object.hasOwnProperty.call(m,"expirationTime"))$root.proto.Timestamp.encode(m.expirationTime,w.uint32(34).fork()).ldelim();if(m.adminKey!=null&&Object.hasOwnProperty.call(m,"adminKey"))$root.proto.Key.encode(m.adminKey,w.uint32(50).fork()).ldelim();if(m.submitKey!=null&&Object.hasOwnProperty.call(m,"submitKey"))$root.proto.Key.encode(m.submitKey,w.uint32(58).fork()).ldelim();if(m.autoRenewPeriod!=null&&Object.hasOwnProperty.call(m,"autoRenewPeriod"))$root.proto.Duration.encode(m.autoRenewPeriod,w.uint32(66).fork()).ldelim();if(m.autoRenewAccount!=null&&Object.hasOwnProperty.call(m,"autoRenewAccount"))$root.proto.AccountID.encode(m.autoRenewAccount,w.uint32(74).fork()).ldelim();if(m.feeScheduleKey!=null&&Object.hasOwnProperty.call(m,"feeScheduleKey"))$root.proto.Key.encode(m.feeScheduleKey,w.uint32(82).fork()).ldelim();if(m.feeExemptKeyList!=null&&Object.hasOwnProperty.call(m,"feeExemptKeyList"))$root.proto.FeeExemptKeyList.encode(m.feeExemptKeyList,w.uint32(90).fork()).ldelim();if(m.customFees!=null&&Object.hasOwnProperty.call(m,"customFees"))$root.proto.FixedCustomFeeList.encode(m.customFees,w.uint32(98).fork()).ldelim();return w;};ConsensusUpdateTopicTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ConsensusUpdateTopicTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.topicID=$root.proto.TopicID.decode(r,r.uint32());break;}case 2:{m.memo=$root.google.protobuf.StringValue.decode(r,r.uint32());break;}case 4:{m.expirationTime=$root.proto.Timestamp.decode(r,r.uint32());break;}case 6:{m.adminKey=$root.proto.Key.decode(r,r.uint32());break;}case 7:{m.submitKey=$root.proto.Key.decode(r,r.uint32());break;}case 8:{m.autoRenewPeriod=$root.proto.Duration.decode(r,r.uint32());break;}case 9:{m.autoRenewAccount=$root.proto.AccountID.decode(r,r.uint32());break;}case 10:{m.feeScheduleKey=$root.proto.Key.decode(r,r.uint32());break;}case 11:{m.feeExemptKeyList=$root.proto.FeeExemptKeyList.decode(r,r.uint32());break;}case 12:{m.customFees=$root.proto.FixedCustomFeeList.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};ConsensusUpdateTopicTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ConsensusUpdateTopicTransactionBody";};return ConsensusUpdateTopicTransactionBody;}();proto.TokenCreateTransactionBody=function(){function TokenCreateTransactionBody(p){this.customFees=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TokenCreateTransactionBody.prototype.name="";TokenCreateTransactionBody.prototype.symbol="";TokenCreateTransactionBody.prototype.decimals=0;TokenCreateTransactionBody.prototype.initialSupply=$util.Long?$util.Long.fromBits(0,0,true):0;TokenCreateTransactionBody.prototype.treasury=null;TokenCreateTransactionBody.prototype.adminKey=null;TokenCreateTransactionBody.prototype.kycKey=null;TokenCreateTransactionBody.prototype.freezeKey=null;TokenCreateTransactionBody.prototype.wipeKey=null;TokenCreateTransactionBody.prototype.supplyKey=null;TokenCreateTransactionBody.prototype.freezeDefault=false;TokenCreateTransactionBody.prototype.expiry=null;TokenCreateTransactionBody.prototype.autoRenewAccount=null;TokenCreateTransactionBody.prototype.autoRenewPeriod=null;TokenCreateTransactionBody.prototype.memo="";TokenCreateTransactionBody.prototype.tokenType=0;TokenCreateTransactionBody.prototype.supplyType=0;TokenCreateTransactionBody.prototype.maxSupply=$util.Long?$util.Long.fromBits(0,0,false):0;TokenCreateTransactionBody.prototype.feeScheduleKey=null;TokenCreateTransactionBody.prototype.customFees=$util.emptyArray;TokenCreateTransactionBody.prototype.pauseKey=null;TokenCreateTransactionBody.prototype.metadata=$util.newBuffer([]);TokenCreateTransactionBody.prototype.metadataKey=null;TokenCreateTransactionBody.create=function create(properties){return new TokenCreateTransactionBody(properties);};TokenCreateTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.name!=null&&Object.hasOwnProperty.call(m,"name"))w.uint32(10).string(m.name);if(m.symbol!=null&&Object.hasOwnProperty.call(m,"symbol"))w.uint32(18).string(m.symbol);if(m.decimals!=null&&Object.hasOwnProperty.call(m,"decimals"))w.uint32(24).uint32(m.decimals);if(m.initialSupply!=null&&Object.hasOwnProperty.call(m,"initialSupply"))w.uint32(32).uint64(m.initialSupply);if(m.treasury!=null&&Object.hasOwnProperty.call(m,"treasury"))$root.proto.AccountID.encode(m.treasury,w.uint32(42).fork()).ldelim();if(m.adminKey!=null&&Object.hasOwnProperty.call(m,"adminKey"))$root.proto.Key.encode(m.adminKey,w.uint32(50).fork()).ldelim();if(m.kycKey!=null&&Object.hasOwnProperty.call(m,"kycKey"))$root.proto.Key.encode(m.kycKey,w.uint32(58).fork()).ldelim();if(m.freezeKey!=null&&Object.hasOwnProperty.call(m,"freezeKey"))$root.proto.Key.encode(m.freezeKey,w.uint32(66).fork()).ldelim();if(m.wipeKey!=null&&Object.hasOwnProperty.call(m,"wipeKey"))$root.proto.Key.encode(m.wipeKey,w.uint32(74).fork()).ldelim();if(m.supplyKey!=null&&Object.hasOwnProperty.call(m,"supplyKey"))$root.proto.Key.encode(m.supplyKey,w.uint32(82).fork()).ldelim();if(m.freezeDefault!=null&&Object.hasOwnProperty.call(m,"freezeDefault"))w.uint32(88).bool(m.freezeDefault);if(m.expiry!=null&&Object.hasOwnProperty.call(m,"expiry"))$root.proto.Timestamp.encode(m.expiry,w.uint32(106).fork()).ldelim();if(m.autoRenewAccount!=null&&Object.hasOwnProperty.call(m,"autoRenewAccount"))$root.proto.AccountID.encode(m.autoRenewAccount,w.uint32(114).fork()).ldelim();if(m.autoRenewPeriod!=null&&Object.hasOwnProperty.call(m,"autoRenewPeriod"))$root.proto.Duration.encode(m.autoRenewPeriod,w.uint32(122).fork()).ldelim();if(m.memo!=null&&Object.hasOwnProperty.call(m,"memo"))w.uint32(130).string(m.memo);if(m.tokenType!=null&&Object.hasOwnProperty.call(m,"tokenType"))w.uint32(136).int32(m.tokenType);if(m.supplyType!=null&&Object.hasOwnProperty.call(m,"supplyType"))w.uint32(144).int32(m.supplyType);if(m.maxSupply!=null&&Object.hasOwnProperty.call(m,"maxSupply"))w.uint32(152).int64(m.maxSupply);if(m.feeScheduleKey!=null&&Object.hasOwnProperty.call(m,"feeScheduleKey"))$root.proto.Key.encode(m.feeScheduleKey,w.uint32(162).fork()).ldelim();if(m.customFees!=null&&m.customFees.length){for(var i=0;i<m.customFees.length;++i)$root.proto.CustomFee.encode(m.customFees[i],w.uint32(170).fork()).ldelim();}if(m.pauseKey!=null&&Object.hasOwnProperty.call(m,"pauseKey"))$root.proto.Key.encode(m.pauseKey,w.uint32(178).fork()).ldelim();if(m.metadata!=null&&Object.hasOwnProperty.call(m,"metadata"))w.uint32(186).bytes(m.metadata);if(m.metadataKey!=null&&Object.hasOwnProperty.call(m,"metadataKey"))$root.proto.Key.encode(m.metadataKey,w.uint32(194).fork()).ldelim();return w;};TokenCreateTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TokenCreateTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.name=r.string();break;}case 2:{m.symbol=r.string();break;}case 3:{m.decimals=r.uint32();break;}case 4:{m.initialSupply=r.uint64();break;}case 5:{m.treasury=$root.proto.AccountID.decode(r,r.uint32());break;}case 6:{m.adminKey=$root.proto.Key.decode(r,r.uint32());break;}case 7:{m.kycKey=$root.proto.Key.decode(r,r.uint32());break;}case 8:{m.freezeKey=$root.proto.Key.decode(r,r.uint32());break;}case 9:{m.wipeKey=$root.proto.Key.decode(r,r.uint32());break;}case 10:{m.supplyKey=$root.proto.Key.decode(r,r.uint32());break;}case 11:{m.freezeDefault=r.bool();break;}case 13:{m.expiry=$root.proto.Timestamp.decode(r,r.uint32());break;}case 14:{m.autoRenewAccount=$root.proto.AccountID.decode(r,r.uint32());break;}case 15:{m.autoRenewPeriod=$root.proto.Duration.decode(r,r.uint32());break;}case 16:{m.memo=r.string();break;}case 17:{m.tokenType=r.int32();break;}case 18:{m.supplyType=r.int32();break;}case 19:{m.maxSupply=r.int64();break;}case 20:{m.feeScheduleKey=$root.proto.Key.decode(r,r.uint32());break;}case 21:{if(!(m.customFees&&m.customFees.length))m.customFees=[];m.customFees.push($root.proto.CustomFee.decode(r,r.uint32()));break;}case 22:{m.pauseKey=$root.proto.Key.decode(r,r.uint32());break;}case 23:{m.metadata=r.bytes();break;}case 24:{m.metadataKey=$root.proto.Key.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};TokenCreateTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TokenCreateTransactionBody";};return TokenCreateTransactionBody;}();proto.TokenFreezeAccountTransactionBody=function(){function TokenFreezeAccountTransactionBody(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TokenFreezeAccountTransactionBody.prototype.token=null;TokenFreezeAccountTransactionBody.prototype.account=null;TokenFreezeAccountTransactionBody.create=function create(properties){return new TokenFreezeAccountTransactionBody(properties);};TokenFreezeAccountTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.token!=null&&Object.hasOwnProperty.call(m,"token"))$root.proto.TokenID.encode(m.token,w.uint32(10).fork()).ldelim();if(m.account!=null&&Object.hasOwnProperty.call(m,"account"))$root.proto.AccountID.encode(m.account,w.uint32(18).fork()).ldelim();return w;};TokenFreezeAccountTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TokenFreezeAccountTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.token=$root.proto.TokenID.decode(r,r.uint32());break;}case 2:{m.account=$root.proto.AccountID.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};TokenFreezeAccountTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TokenFreezeAccountTransactionBody";};return TokenFreezeAccountTransactionBody;}();proto.TokenUnfreezeAccountTransactionBody=function(){function TokenUnfreezeAccountTransactionBody(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TokenUnfreezeAccountTransactionBody.prototype.token=null;TokenUnfreezeAccountTransactionBody.prototype.account=null;TokenUnfreezeAccountTransactionBody.create=function create(properties){return new TokenUnfreezeAccountTransactionBody(properties);};TokenUnfreezeAccountTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.token!=null&&Object.hasOwnProperty.call(m,"token"))$root.proto.TokenID.encode(m.token,w.uint32(10).fork()).ldelim();if(m.account!=null&&Object.hasOwnProperty.call(m,"account"))$root.proto.AccountID.encode(m.account,w.uint32(18).fork()).ldelim();return w;};TokenUnfreezeAccountTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TokenUnfreezeAccountTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.token=$root.proto.TokenID.decode(r,r.uint32());break;}case 2:{m.account=$root.proto.AccountID.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};TokenUnfreezeAccountTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TokenUnfreezeAccountTransactionBody";};return TokenUnfreezeAccountTransactionBody;}();proto.TokenGrantKycTransactionBody=function(){function TokenGrantKycTransactionBody(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TokenGrantKycTransactionBody.prototype.token=null;TokenGrantKycTransactionBody.prototype.account=null;TokenGrantKycTransactionBody.create=function create(properties){return new TokenGrantKycTransactionBody(properties);};TokenGrantKycTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.token!=null&&Object.hasOwnProperty.call(m,"token"))$root.proto.TokenID.encode(m.token,w.uint32(10).fork()).ldelim();if(m.account!=null&&Object.hasOwnProperty.call(m,"account"))$root.proto.AccountID.encode(m.account,w.uint32(18).fork()).ldelim();return w;};TokenGrantKycTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TokenGrantKycTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.token=$root.proto.TokenID.decode(r,r.uint32());break;}case 2:{m.account=$root.proto.AccountID.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};TokenGrantKycTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TokenGrantKycTransactionBody";};return TokenGrantKycTransactionBody;}();proto.TokenRevokeKycTransactionBody=function(){function TokenRevokeKycTransactionBody(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TokenRevokeKycTransactionBody.prototype.token=null;TokenRevokeKycTransactionBody.prototype.account=null;TokenRevokeKycTransactionBody.create=function create(properties){return new TokenRevokeKycTransactionBody(properties);};TokenRevokeKycTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.token!=null&&Object.hasOwnProperty.call(m,"token"))$root.proto.TokenID.encode(m.token,w.uint32(10).fork()).ldelim();if(m.account!=null&&Object.hasOwnProperty.call(m,"account"))$root.proto.AccountID.encode(m.account,w.uint32(18).fork()).ldelim();return w;};TokenRevokeKycTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TokenRevokeKycTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.token=$root.proto.TokenID.decode(r,r.uint32());break;}case 2:{m.account=$root.proto.AccountID.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};TokenRevokeKycTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TokenRevokeKycTransactionBody";};return TokenRevokeKycTransactionBody;}();proto.TokenDeleteTransactionBody=function(){function TokenDeleteTransactionBody(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TokenDeleteTransactionBody.prototype.token=null;TokenDeleteTransactionBody.create=function create(properties){return new TokenDeleteTransactionBody(properties);};TokenDeleteTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.token!=null&&Object.hasOwnProperty.call(m,"token"))$root.proto.TokenID.encode(m.token,w.uint32(10).fork()).ldelim();return w;};TokenDeleteTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TokenDeleteTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.token=$root.proto.TokenID.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};TokenDeleteTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TokenDeleteTransactionBody";};return TokenDeleteTransactionBody;}();proto.TokenUpdateTransactionBody=function(){function TokenUpdateTransactionBody(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TokenUpdateTransactionBody.prototype.token=null;TokenUpdateTransactionBody.prototype.symbol="";TokenUpdateTransactionBody.prototype.name="";TokenUpdateTransactionBody.prototype.treasury=null;TokenUpdateTransactionBody.prototype.adminKey=null;TokenUpdateTransactionBody.prototype.kycKey=null;TokenUpdateTransactionBody.prototype.freezeKey=null;TokenUpdateTransactionBody.prototype.wipeKey=null;TokenUpdateTransactionBody.prototype.supplyKey=null;TokenUpdateTransactionBody.prototype.autoRenewAccount=null;TokenUpdateTransactionBody.prototype.autoRenewPeriod=null;TokenUpdateTransactionBody.prototype.expiry=null;TokenUpdateTransactionBody.prototype.memo=null;TokenUpdateTransactionBody.prototype.feeScheduleKey=null;TokenUpdateTransactionBody.prototype.pauseKey=null;TokenUpdateTransactionBody.prototype.metadata=null;TokenUpdateTransactionBody.prototype.metadataKey=null;TokenUpdateTransactionBody.prototype.keyVerificationMode=0;TokenUpdateTransactionBody.create=function create(properties){return new TokenUpdateTransactionBody(properties);};TokenUpdateTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.token!=null&&Object.hasOwnProperty.call(m,"token"))$root.proto.TokenID.encode(m.token,w.uint32(10).fork()).ldelim();if(m.symbol!=null&&Object.hasOwnProperty.call(m,"symbol"))w.uint32(18).string(m.symbol);if(m.name!=null&&Object.hasOwnProperty.call(m,"name"))w.uint32(26).string(m.name);if(m.treasury!=null&&Object.hasOwnProperty.call(m,"treasury"))$root.proto.AccountID.encode(m.treasury,w.uint32(34).fork()).ldelim();if(m.adminKey!=null&&Object.hasOwnProperty.call(m,"adminKey"))$root.proto.Key.encode(m.adminKey,w.uint32(42).fork()).ldelim();if(m.kycKey!=null&&Object.hasOwnProperty.call(m,"kycKey"))$root.proto.Key.encode(m.kycKey,w.uint32(50).fork()).ldelim();if(m.freezeKey!=null&&Object.hasOwnProperty.call(m,"freezeKey"))$root.proto.Key.encode(m.freezeKey,w.uint32(58).fork()).ldelim();if(m.wipeKey!=null&&Object.hasOwnProperty.call(m,"wipeKey"))$root.proto.Key.encode(m.wipeKey,w.uint32(66).fork()).ldelim();if(m.supplyKey!=null&&Object.hasOwnProperty.call(m,"supplyKey"))$root.proto.Key.encode(m.supplyKey,w.uint32(74).fork()).ldelim();if(m.autoRenewAccount!=null&&Object.hasOwnProperty.call(m,"autoRenewAccount"))$root.proto.AccountID.encode(m.autoRenewAccount,w.uint32(82).fork()).ldelim();if(m.autoRenewPeriod!=null&&Object.hasOwnProperty.call(m,"autoRenewPeriod"))$root.proto.Duration.encode(m.autoRenewPeriod,w.uint32(90).fork()).ldelim();if(m.expiry!=null&&Object.hasOwnProperty.call(m,"expiry"))$root.proto.Timestamp.encode(m.expiry,w.uint32(98).fork()).ldelim();if(m.memo!=null&&Object.hasOwnProperty.call(m,"memo"))$root.google.protobuf.StringValue.encode(m.memo,w.uint32(106).fork()).ldelim();if(m.feeScheduleKey!=null&&Object.hasOwnProperty.call(m,"feeScheduleKey"))$root.proto.Key.encode(m.feeScheduleKey,w.uint32(114).fork()).ldelim();if(m.pauseKey!=null&&Object.hasOwnProperty.call(m,"pauseKey"))$root.proto.Key.encode(m.pauseKey,w.uint32(122).fork()).ldelim();if(m.metadata!=null&&Object.hasOwnProperty.call(m,"metadata"))$root.google.protobuf.BytesValue.encode(m.metadata,w.uint32(130).fork()).ldelim();if(m.metadataKey!=null&&Object.hasOwnProperty.call(m,"metadataKey"))$root.proto.Key.encode(m.metadataKey,w.uint32(138).fork()).ldelim();if(m.keyVerificationMode!=null&&Object.hasOwnProperty.call(m,"keyVerificationMode"))w.uint32(144).int32(m.keyVerificationMode);return w;};TokenUpdateTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TokenUpdateTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.token=$root.proto.TokenID.decode(r,r.uint32());break;}case 2:{m.symbol=r.string();break;}case 3:{m.name=r.string();break;}case 4:{m.treasury=$root.proto.AccountID.decode(r,r.uint32());break;}case 5:{m.adminKey=$root.proto.Key.decode(r,r.uint32());break;}case 6:{m.kycKey=$root.proto.Key.decode(r,r.uint32());break;}case 7:{m.freezeKey=$root.proto.Key.decode(r,r.uint32());break;}case 8:{m.wipeKey=$root.proto.Key.decode(r,r.uint32());break;}case 9:{m.supplyKey=$root.proto.Key.decode(r,r.uint32());break;}case 10:{m.autoRenewAccount=$root.proto.AccountID.decode(r,r.uint32());break;}case 11:{m.autoRenewPeriod=$root.proto.Duration.decode(r,r.uint32());break;}case 12:{m.expiry=$root.proto.Timestamp.decode(r,r.uint32());break;}case 13:{m.memo=$root.google.protobuf.StringValue.decode(r,r.uint32());break;}case 14:{m.feeScheduleKey=$root.proto.Key.decode(r,r.uint32());break;}case 15:{m.pauseKey=$root.proto.Key.decode(r,r.uint32());break;}case 16:{m.metadata=$root.google.protobuf.BytesValue.decode(r,r.uint32());break;}case 17:{m.metadataKey=$root.proto.Key.decode(r,r.uint32());break;}case 18:{m.keyVerificationMode=r.int32();break;}default:r.skipType(t&7);break;}}return m;};TokenUpdateTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TokenUpdateTransactionBody";};return TokenUpdateTransactionBody;}();proto.TokenMintTransactionBody=function(){function TokenMintTransactionBody(p){this.metadata=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TokenMintTransactionBody.prototype.token=null;TokenMintTransactionBody.prototype.amount=$util.Long?$util.Long.fromBits(0,0,true):0;TokenMintTransactionBody.prototype.metadata=$util.emptyArray;TokenMintTransactionBody.create=function create(properties){return new TokenMintTransactionBody(properties);};TokenMintTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.token!=null&&Object.hasOwnProperty.call(m,"token"))$root.proto.TokenID.encode(m.token,w.uint32(10).fork()).ldelim();if(m.amount!=null&&Object.hasOwnProperty.call(m,"amount"))w.uint32(16).uint64(m.amount);if(m.metadata!=null&&m.metadata.length){for(var i=0;i<m.metadata.length;++i)w.uint32(26).bytes(m.metadata[i]);}return w;};TokenMintTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TokenMintTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.token=$root.proto.TokenID.decode(r,r.uint32());break;}case 2:{m.amount=r.uint64();break;}case 3:{if(!(m.metadata&&m.metadata.length))m.metadata=[];m.metadata.push(r.bytes());break;}default:r.skipType(t&7);break;}}return m;};TokenMintTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TokenMintTransactionBody";};return TokenMintTransactionBody;}();proto.TokenBurnTransactionBody=function(){function TokenBurnTransactionBody(p){this.serialNumbers=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TokenBurnTransactionBody.prototype.token=null;TokenBurnTransactionBody.prototype.amount=$util.Long?$util.Long.fromBits(0,0,true):0;TokenBurnTransactionBody.prototype.serialNumbers=$util.emptyArray;TokenBurnTransactionBody.create=function create(properties){return new TokenBurnTransactionBody(properties);};TokenBurnTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.token!=null&&Object.hasOwnProperty.call(m,"token"))$root.proto.TokenID.encode(m.token,w.uint32(10).fork()).ldelim();if(m.amount!=null&&Object.hasOwnProperty.call(m,"amount"))w.uint32(16).uint64(m.amount);if(m.serialNumbers!=null&&m.serialNumbers.length){w.uint32(26).fork();for(var i=0;i<m.serialNumbers.length;++i)w.int64(m.serialNumbers[i]);w.ldelim();}return w;};TokenBurnTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TokenBurnTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.token=$root.proto.TokenID.decode(r,r.uint32());break;}case 2:{m.amount=r.uint64();break;}case 3:{if(!(m.serialNumbers&&m.serialNumbers.length))m.serialNumbers=[];if((t&7)===2){var c2=r.uint32()+r.pos;while(r.pos<c2)m.serialNumbers.push(r.int64());}else m.serialNumbers.push(r.int64());break;}default:r.skipType(t&7);break;}}return m;};TokenBurnTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TokenBurnTransactionBody";};return TokenBurnTransactionBody;}();proto.TokenWipeAccountTransactionBody=function(){function TokenWipeAccountTransactionBody(p){this.serialNumbers=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TokenWipeAccountTransactionBody.prototype.token=null;TokenWipeAccountTransactionBody.prototype.account=null;TokenWipeAccountTransactionBody.prototype.amount=$util.Long?$util.Long.fromBits(0,0,true):0;TokenWipeAccountTransactionBody.prototype.serialNumbers=$util.emptyArray;TokenWipeAccountTransactionBody.create=function create(properties){return new TokenWipeAccountTransactionBody(properties);};TokenWipeAccountTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.token!=null&&Object.hasOwnProperty.call(m,"token"))$root.proto.TokenID.encode(m.token,w.uint32(10).fork()).ldelim();if(m.account!=null&&Object.hasOwnProperty.call(m,"account"))$root.proto.AccountID.encode(m.account,w.uint32(18).fork()).ldelim();if(m.amount!=null&&Object.hasOwnProperty.call(m,"amount"))w.uint32(24).uint64(m.amount);if(m.serialNumbers!=null&&m.serialNumbers.length){w.uint32(34).fork();for(var i=0;i<m.serialNumbers.length;++i)w.int64(m.serialNumbers[i]);w.ldelim();}return w;};TokenWipeAccountTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TokenWipeAccountTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.token=$root.proto.TokenID.decode(r,r.uint32());break;}case 2:{m.account=$root.proto.AccountID.decode(r,r.uint32());break;}case 3:{m.amount=r.uint64();break;}case 4:{if(!(m.serialNumbers&&m.serialNumbers.length))m.serialNumbers=[];if((t&7)===2){var c2=r.uint32()+r.pos;while(r.pos<c2)m.serialNumbers.push(r.int64());}else m.serialNumbers.push(r.int64());break;}default:r.skipType(t&7);break;}}return m;};TokenWipeAccountTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TokenWipeAccountTransactionBody";};return TokenWipeAccountTransactionBody;}();proto.TokenAssociateTransactionBody=function(){function TokenAssociateTransactionBody(p){this.tokens=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TokenAssociateTransactionBody.prototype.account=null;TokenAssociateTransactionBody.prototype.tokens=$util.emptyArray;TokenAssociateTransactionBody.create=function create(properties){return new TokenAssociateTransactionBody(properties);};TokenAssociateTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.account!=null&&Object.hasOwnProperty.call(m,"account"))$root.proto.AccountID.encode(m.account,w.uint32(10).fork()).ldelim();if(m.tokens!=null&&m.tokens.length){for(var i=0;i<m.tokens.length;++i)$root.proto.TokenID.encode(m.tokens[i],w.uint32(18).fork()).ldelim();}return w;};TokenAssociateTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TokenAssociateTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.account=$root.proto.AccountID.decode(r,r.uint32());break;}case 2:{if(!(m.tokens&&m.tokens.length))m.tokens=[];m.tokens.push($root.proto.TokenID.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};TokenAssociateTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TokenAssociateTransactionBody";};return TokenAssociateTransactionBody;}();proto.TokenDissociateTransactionBody=function(){function TokenDissociateTransactionBody(p){this.tokens=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TokenDissociateTransactionBody.prototype.account=null;TokenDissociateTransactionBody.prototype.tokens=$util.emptyArray;TokenDissociateTransactionBody.create=function create(properties){return new TokenDissociateTransactionBody(properties);};TokenDissociateTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.account!=null&&Object.hasOwnProperty.call(m,"account"))$root.proto.AccountID.encode(m.account,w.uint32(10).fork()).ldelim();if(m.tokens!=null&&m.tokens.length){for(var i=0;i<m.tokens.length;++i)$root.proto.TokenID.encode(m.tokens[i],w.uint32(18).fork()).ldelim();}return w;};TokenDissociateTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TokenDissociateTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.account=$root.proto.AccountID.decode(r,r.uint32());break;}case 2:{if(!(m.tokens&&m.tokens.length))m.tokens=[];m.tokens.push($root.proto.TokenID.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};TokenDissociateTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TokenDissociateTransactionBody";};return TokenDissociateTransactionBody;}();proto.TokenFeeScheduleUpdateTransactionBody=function(){function TokenFeeScheduleUpdateTransactionBody(p){this.customFees=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TokenFeeScheduleUpdateTransactionBody.prototype.tokenId=null;TokenFeeScheduleUpdateTransactionBody.prototype.customFees=$util.emptyArray;TokenFeeScheduleUpdateTransactionBody.create=function create(properties){return new TokenFeeScheduleUpdateTransactionBody(properties);};TokenFeeScheduleUpdateTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.tokenId!=null&&Object.hasOwnProperty.call(m,"tokenId"))$root.proto.TokenID.encode(m.tokenId,w.uint32(10).fork()).ldelim();if(m.customFees!=null&&m.customFees.length){for(var i=0;i<m.customFees.length;++i)$root.proto.CustomFee.encode(m.customFees[i],w.uint32(18).fork()).ldelim();}return w;};TokenFeeScheduleUpdateTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TokenFeeScheduleUpdateTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.tokenId=$root.proto.TokenID.decode(r,r.uint32());break;}case 2:{if(!(m.customFees&&m.customFees.length))m.customFees=[];m.customFees.push($root.proto.CustomFee.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};TokenFeeScheduleUpdateTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TokenFeeScheduleUpdateTransactionBody";};return TokenFeeScheduleUpdateTransactionBody;}();proto.TokenPauseTransactionBody=function(){function TokenPauseTransactionBody(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TokenPauseTransactionBody.prototype.token=null;TokenPauseTransactionBody.create=function create(properties){return new TokenPauseTransactionBody(properties);};TokenPauseTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.token!=null&&Object.hasOwnProperty.call(m,"token"))$root.proto.TokenID.encode(m.token,w.uint32(10).fork()).ldelim();return w;};TokenPauseTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TokenPauseTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.token=$root.proto.TokenID.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};TokenPauseTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TokenPauseTransactionBody";};return TokenPauseTransactionBody;}();proto.TokenUnpauseTransactionBody=function(){function TokenUnpauseTransactionBody(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TokenUnpauseTransactionBody.prototype.token=null;TokenUnpauseTransactionBody.create=function create(properties){return new TokenUnpauseTransactionBody(properties);};TokenUnpauseTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.token!=null&&Object.hasOwnProperty.call(m,"token"))$root.proto.TokenID.encode(m.token,w.uint32(10).fork()).ldelim();return w;};TokenUnpauseTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TokenUnpauseTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.token=$root.proto.TokenID.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};TokenUnpauseTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TokenUnpauseTransactionBody";};return TokenUnpauseTransactionBody;}();proto.TokenUpdateNftsTransactionBody=function(){function TokenUpdateNftsTransactionBody(p){this.serialNumbers=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TokenUpdateNftsTransactionBody.prototype.token=null;TokenUpdateNftsTransactionBody.prototype.serialNumbers=$util.emptyArray;TokenUpdateNftsTransactionBody.prototype.metadata=null;TokenUpdateNftsTransactionBody.create=function create(properties){return new TokenUpdateNftsTransactionBody(properties);};TokenUpdateNftsTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.token!=null&&Object.hasOwnProperty.call(m,"token"))$root.proto.TokenID.encode(m.token,w.uint32(10).fork()).ldelim();if(m.serialNumbers!=null&&m.serialNumbers.length){w.uint32(18).fork();for(var i=0;i<m.serialNumbers.length;++i)w.int64(m.serialNumbers[i]);w.ldelim();}if(m.metadata!=null&&Object.hasOwnProperty.call(m,"metadata"))$root.google.protobuf.BytesValue.encode(m.metadata,w.uint32(26).fork()).ldelim();return w;};TokenUpdateNftsTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TokenUpdateNftsTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.token=$root.proto.TokenID.decode(r,r.uint32());break;}case 2:{if(!(m.serialNumbers&&m.serialNumbers.length))m.serialNumbers=[];if((t&7)===2){var c2=r.uint32()+r.pos;while(r.pos<c2)m.serialNumbers.push(r.int64());}else m.serialNumbers.push(r.int64());break;}case 3:{m.metadata=$root.google.protobuf.BytesValue.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};TokenUpdateNftsTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TokenUpdateNftsTransactionBody";};return TokenUpdateNftsTransactionBody;}();proto.TokenRejectTransactionBody=function(){function TokenRejectTransactionBody(p){this.rejections=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TokenRejectTransactionBody.prototype.owner=null;TokenRejectTransactionBody.prototype.rejections=$util.emptyArray;TokenRejectTransactionBody.create=function create(properties){return new TokenRejectTransactionBody(properties);};TokenRejectTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.owner!=null&&Object.hasOwnProperty.call(m,"owner"))$root.proto.AccountID.encode(m.owner,w.uint32(10).fork()).ldelim();if(m.rejections!=null&&m.rejections.length){for(var i=0;i<m.rejections.length;++i)$root.proto.TokenReference.encode(m.rejections[i],w.uint32(18).fork()).ldelim();}return w;};TokenRejectTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TokenRejectTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.owner=$root.proto.AccountID.decode(r,r.uint32());break;}case 2:{if(!(m.rejections&&m.rejections.length))m.rejections=[];m.rejections.push($root.proto.TokenReference.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};TokenRejectTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TokenRejectTransactionBody";};return TokenRejectTransactionBody;}();proto.TokenReference=function(){function TokenReference(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TokenReference.prototype.fungibleToken=null;TokenReference.prototype.nft=null;let $oneOfFields;Object.defineProperty(TokenReference.prototype,"tokenIdentifier",{get:$util.oneOfGetter($oneOfFields=["fungibleToken","nft"]),set:$util.oneOfSetter($oneOfFields)});TokenReference.create=function create(properties){return new TokenReference(properties);};TokenReference.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.fungibleToken!=null&&Object.hasOwnProperty.call(m,"fungibleToken"))$root.proto.TokenID.encode(m.fungibleToken,w.uint32(10).fork()).ldelim();if(m.nft!=null&&Object.hasOwnProperty.call(m,"nft"))$root.proto.NftID.encode(m.nft,w.uint32(18).fork()).ldelim();return w;};TokenReference.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TokenReference();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.fungibleToken=$root.proto.TokenID.decode(r,r.uint32());break;}case 2:{m.nft=$root.proto.NftID.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};TokenReference.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TokenReference";};return TokenReference;}();proto.TokenCancelAirdropTransactionBody=function(){function TokenCancelAirdropTransactionBody(p){this.pendingAirdrops=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TokenCancelAirdropTransactionBody.prototype.pendingAirdrops=$util.emptyArray;TokenCancelAirdropTransactionBody.create=function create(properties){return new TokenCancelAirdropTransactionBody(properties);};TokenCancelAirdropTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.pendingAirdrops!=null&&m.pendingAirdrops.length){for(var i=0;i<m.pendingAirdrops.length;++i)$root.proto.PendingAirdropId.encode(m.pendingAirdrops[i],w.uint32(10).fork()).ldelim();}return w;};TokenCancelAirdropTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TokenCancelAirdropTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{if(!(m.pendingAirdrops&&m.pendingAirdrops.length))m.pendingAirdrops=[];m.pendingAirdrops.push($root.proto.PendingAirdropId.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};TokenCancelAirdropTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TokenCancelAirdropTransactionBody";};return TokenCancelAirdropTransactionBody;}();proto.TokenClaimAirdropTransactionBody=function(){function TokenClaimAirdropTransactionBody(p){this.pendingAirdrops=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TokenClaimAirdropTransactionBody.prototype.pendingAirdrops=$util.emptyArray;TokenClaimAirdropTransactionBody.create=function create(properties){return new TokenClaimAirdropTransactionBody(properties);};TokenClaimAirdropTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.pendingAirdrops!=null&&m.pendingAirdrops.length){for(var i=0;i<m.pendingAirdrops.length;++i)$root.proto.PendingAirdropId.encode(m.pendingAirdrops[i],w.uint32(10).fork()).ldelim();}return w;};TokenClaimAirdropTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TokenClaimAirdropTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{if(!(m.pendingAirdrops&&m.pendingAirdrops.length))m.pendingAirdrops=[];m.pendingAirdrops.push($root.proto.PendingAirdropId.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};TokenClaimAirdropTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TokenClaimAirdropTransactionBody";};return TokenClaimAirdropTransactionBody;}();proto.TokenAirdropTransactionBody=function(){function TokenAirdropTransactionBody(p){this.tokenTransfers=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TokenAirdropTransactionBody.prototype.tokenTransfers=$util.emptyArray;TokenAirdropTransactionBody.create=function create(properties){return new TokenAirdropTransactionBody(properties);};TokenAirdropTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.tokenTransfers!=null&&m.tokenTransfers.length){for(var i=0;i<m.tokenTransfers.length;++i)$root.proto.TokenTransferList.encode(m.tokenTransfers[i],w.uint32(10).fork()).ldelim();}return w;};TokenAirdropTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TokenAirdropTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{if(!(m.tokenTransfers&&m.tokenTransfers.length))m.tokenTransfers=[];m.tokenTransfers.push($root.proto.TokenTransferList.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};TokenAirdropTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TokenAirdropTransactionBody";};return TokenAirdropTransactionBody;}();proto.ScheduleDeleteTransactionBody=function(){function ScheduleDeleteTransactionBody(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ScheduleDeleteTransactionBody.prototype.scheduleID=null;ScheduleDeleteTransactionBody.create=function create(properties){return new ScheduleDeleteTransactionBody(properties);};ScheduleDeleteTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.scheduleID!=null&&Object.hasOwnProperty.call(m,"scheduleID"))$root.proto.ScheduleID.encode(m.scheduleID,w.uint32(10).fork()).ldelim();return w;};ScheduleDeleteTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ScheduleDeleteTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.scheduleID=$root.proto.ScheduleID.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};ScheduleDeleteTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ScheduleDeleteTransactionBody";};return ScheduleDeleteTransactionBody;}();proto.UtilPrngTransactionBody=function(){function UtilPrngTransactionBody(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}UtilPrngTransactionBody.prototype.range=0;UtilPrngTransactionBody.create=function create(properties){return new UtilPrngTransactionBody(properties);};UtilPrngTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.range!=null&&Object.hasOwnProperty.call(m,"range"))w.uint32(8).int32(m.range);return w;};UtilPrngTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.UtilPrngTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.range=r.int32();break;}default:r.skipType(t&7);break;}}return m;};UtilPrngTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.UtilPrngTransactionBody";};return UtilPrngTransactionBody;}();proto.TokenGetAccountNftInfosQuery=function(){function TokenGetAccountNftInfosQuery(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TokenGetAccountNftInfosQuery.prototype.header=null;TokenGetAccountNftInfosQuery.prototype.accountID=null;TokenGetAccountNftInfosQuery.prototype.start=$util.Long?$util.Long.fromBits(0,0,false):0;TokenGetAccountNftInfosQuery.prototype.end=$util.Long?$util.Long.fromBits(0,0,false):0;TokenGetAccountNftInfosQuery.create=function create(properties){return new TokenGetAccountNftInfosQuery(properties);};TokenGetAccountNftInfosQuery.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.header!=null&&Object.hasOwnProperty.call(m,"header"))$root.proto.QueryHeader.encode(m.header,w.uint32(10).fork()).ldelim();if(m.accountID!=null&&Object.hasOwnProperty.call(m,"accountID"))$root.proto.AccountID.encode(m.accountID,w.uint32(18).fork()).ldelim();if(m.start!=null&&Object.hasOwnProperty.call(m,"start"))w.uint32(24).int64(m.start);if(m.end!=null&&Object.hasOwnProperty.call(m,"end"))w.uint32(32).int64(m.end);return w;};TokenGetAccountNftInfosQuery.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TokenGetAccountNftInfosQuery();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.header=$root.proto.QueryHeader.decode(r,r.uint32());break;}case 2:{m.accountID=$root.proto.AccountID.decode(r,r.uint32());break;}case 3:{m.start=r.int64();break;}case 4:{m.end=r.int64();break;}default:r.skipType(t&7);break;}}return m;};TokenGetAccountNftInfosQuery.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TokenGetAccountNftInfosQuery";};return TokenGetAccountNftInfosQuery;}();proto.TokenGetAccountNftInfosResponse=function(){function TokenGetAccountNftInfosResponse(p){this.nfts=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TokenGetAccountNftInfosResponse.prototype.header=null;TokenGetAccountNftInfosResponse.prototype.nfts=$util.emptyArray;TokenGetAccountNftInfosResponse.create=function create(properties){return new TokenGetAccountNftInfosResponse(properties);};TokenGetAccountNftInfosResponse.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.header!=null&&Object.hasOwnProperty.call(m,"header"))$root.proto.ResponseHeader.encode(m.header,w.uint32(10).fork()).ldelim();if(m.nfts!=null&&m.nfts.length){for(var i=0;i<m.nfts.length;++i)$root.proto.TokenNftInfo.encode(m.nfts[i],w.uint32(18).fork()).ldelim();}return w;};TokenGetAccountNftInfosResponse.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TokenGetAccountNftInfosResponse();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.header=$root.proto.ResponseHeader.decode(r,r.uint32());break;}case 2:{if(!(m.nfts&&m.nfts.length))m.nfts=[];m.nfts.push($root.proto.TokenNftInfo.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};TokenGetAccountNftInfosResponse.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TokenGetAccountNftInfosResponse";};return TokenGetAccountNftInfosResponse;}();proto.TokenGetNftInfoQuery=function(){function TokenGetNftInfoQuery(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TokenGetNftInfoQuery.prototype.header=null;TokenGetNftInfoQuery.prototype.nftID=null;TokenGetNftInfoQuery.create=function create(properties){return new TokenGetNftInfoQuery(properties);};TokenGetNftInfoQuery.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.header!=null&&Object.hasOwnProperty.call(m,"header"))$root.proto.QueryHeader.encode(m.header,w.uint32(10).fork()).ldelim();if(m.nftID!=null&&Object.hasOwnProperty.call(m,"nftID"))$root.proto.NftID.encode(m.nftID,w.uint32(18).fork()).ldelim();return w;};TokenGetNftInfoQuery.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TokenGetNftInfoQuery();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.header=$root.proto.QueryHeader.decode(r,r.uint32());break;}case 2:{m.nftID=$root.proto.NftID.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};TokenGetNftInfoQuery.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TokenGetNftInfoQuery";};return TokenGetNftInfoQuery;}();proto.TokenNftInfo=function(){function TokenNftInfo(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TokenNftInfo.prototype.nftID=null;TokenNftInfo.prototype.accountID=null;TokenNftInfo.prototype.creationTime=null;TokenNftInfo.prototype.metadata=$util.newBuffer([]);TokenNftInfo.prototype.ledgerId=$util.newBuffer([]);TokenNftInfo.prototype.spenderId=null;TokenNftInfo.create=function create(properties){return new TokenNftInfo(properties);};TokenNftInfo.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.nftID!=null&&Object.hasOwnProperty.call(m,"nftID"))$root.proto.NftID.encode(m.nftID,w.uint32(10).fork()).ldelim();if(m.accountID!=null&&Object.hasOwnProperty.call(m,"accountID"))$root.proto.AccountID.encode(m.accountID,w.uint32(18).fork()).ldelim();if(m.creationTime!=null&&Object.hasOwnProperty.call(m,"creationTime"))$root.proto.Timestamp.encode(m.creationTime,w.uint32(26).fork()).ldelim();if(m.metadata!=null&&Object.hasOwnProperty.call(m,"metadata"))w.uint32(34).bytes(m.metadata);if(m.ledgerId!=null&&Object.hasOwnProperty.call(m,"ledgerId"))w.uint32(42).bytes(m.ledgerId);if(m.spenderId!=null&&Object.hasOwnProperty.call(m,"spenderId"))$root.proto.AccountID.encode(m.spenderId,w.uint32(50).fork()).ldelim();return w;};TokenNftInfo.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TokenNftInfo();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.nftID=$root.proto.NftID.decode(r,r.uint32());break;}case 2:{m.accountID=$root.proto.AccountID.decode(r,r.uint32());break;}case 3:{m.creationTime=$root.proto.Timestamp.decode(r,r.uint32());break;}case 4:{m.metadata=r.bytes();break;}case 5:{m.ledgerId=r.bytes();break;}case 6:{m.spenderId=$root.proto.AccountID.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};TokenNftInfo.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TokenNftInfo";};return TokenNftInfo;}();proto.TokenGetNftInfoResponse=function(){function TokenGetNftInfoResponse(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TokenGetNftInfoResponse.prototype.header=null;TokenGetNftInfoResponse.prototype.nft=null;TokenGetNftInfoResponse.create=function create(properties){return new TokenGetNftInfoResponse(properties);};TokenGetNftInfoResponse.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.header!=null&&Object.hasOwnProperty.call(m,"header"))$root.proto.ResponseHeader.encode(m.header,w.uint32(10).fork()).ldelim();if(m.nft!=null&&Object.hasOwnProperty.call(m,"nft"))$root.proto.TokenNftInfo.encode(m.nft,w.uint32(18).fork()).ldelim();return w;};TokenGetNftInfoResponse.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TokenGetNftInfoResponse();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.header=$root.proto.ResponseHeader.decode(r,r.uint32());break;}case 2:{m.nft=$root.proto.TokenNftInfo.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};TokenGetNftInfoResponse.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TokenGetNftInfoResponse";};return TokenGetNftInfoResponse;}();proto.TokenGetNftInfosQuery=function(){function TokenGetNftInfosQuery(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TokenGetNftInfosQuery.prototype.header=null;TokenGetNftInfosQuery.prototype.tokenID=null;TokenGetNftInfosQuery.prototype.start=$util.Long?$util.Long.fromBits(0,0,false):0;TokenGetNftInfosQuery.prototype.end=$util.Long?$util.Long.fromBits(0,0,false):0;TokenGetNftInfosQuery.create=function create(properties){return new TokenGetNftInfosQuery(properties);};TokenGetNftInfosQuery.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.header!=null&&Object.hasOwnProperty.call(m,"header"))$root.proto.QueryHeader.encode(m.header,w.uint32(10).fork()).ldelim();if(m.tokenID!=null&&Object.hasOwnProperty.call(m,"tokenID"))$root.proto.TokenID.encode(m.tokenID,w.uint32(18).fork()).ldelim();if(m.start!=null&&Object.hasOwnProperty.call(m,"start"))w.uint32(24).int64(m.start);if(m.end!=null&&Object.hasOwnProperty.call(m,"end"))w.uint32(32).int64(m.end);return w;};TokenGetNftInfosQuery.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TokenGetNftInfosQuery();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.header=$root.proto.QueryHeader.decode(r,r.uint32());break;}case 2:{m.tokenID=$root.proto.TokenID.decode(r,r.uint32());break;}case 3:{m.start=r.int64();break;}case 4:{m.end=r.int64();break;}default:r.skipType(t&7);break;}}return m;};TokenGetNftInfosQuery.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TokenGetNftInfosQuery";};return TokenGetNftInfosQuery;}();proto.TokenGetNftInfosResponse=function(){function TokenGetNftInfosResponse(p){this.nfts=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TokenGetNftInfosResponse.prototype.header=null;TokenGetNftInfosResponse.prototype.tokenID=null;TokenGetNftInfosResponse.prototype.nfts=$util.emptyArray;TokenGetNftInfosResponse.create=function create(properties){return new TokenGetNftInfosResponse(properties);};TokenGetNftInfosResponse.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.header!=null&&Object.hasOwnProperty.call(m,"header"))$root.proto.ResponseHeader.encode(m.header,w.uint32(10).fork()).ldelim();if(m.tokenID!=null&&Object.hasOwnProperty.call(m,"tokenID"))$root.proto.TokenID.encode(m.tokenID,w.uint32(18).fork()).ldelim();if(m.nfts!=null&&m.nfts.length){for(var i=0;i<m.nfts.length;++i)$root.proto.TokenNftInfo.encode(m.nfts[i],w.uint32(26).fork()).ldelim();}return w;};TokenGetNftInfosResponse.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TokenGetNftInfosResponse();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.header=$root.proto.ResponseHeader.decode(r,r.uint32());break;}case 2:{m.tokenID=$root.proto.TokenID.decode(r,r.uint32());break;}case 3:{if(!(m.nfts&&m.nfts.length))m.nfts=[];m.nfts.push($root.proto.TokenNftInfo.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};TokenGetNftInfosResponse.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TokenGetNftInfosResponse";};return TokenGetNftInfosResponse;}();proto.GetAccountDetailsQuery=function(){function GetAccountDetailsQuery(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}GetAccountDetailsQuery.prototype.header=null;GetAccountDetailsQuery.prototype.accountId=null;GetAccountDetailsQuery.create=function create(properties){return new GetAccountDetailsQuery(properties);};GetAccountDetailsQuery.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.header!=null&&Object.hasOwnProperty.call(m,"header"))$root.proto.QueryHeader.encode(m.header,w.uint32(10).fork()).ldelim();if(m.accountId!=null&&Object.hasOwnProperty.call(m,"accountId"))$root.proto.AccountID.encode(m.accountId,w.uint32(18).fork()).ldelim();return w;};GetAccountDetailsQuery.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.GetAccountDetailsQuery();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.header=$root.proto.QueryHeader.decode(r,r.uint32());break;}case 2:{m.accountId=$root.proto.AccountID.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};GetAccountDetailsQuery.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.GetAccountDetailsQuery";};return GetAccountDetailsQuery;}();proto.GetAccountDetailsResponse=function(){function GetAccountDetailsResponse(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}GetAccountDetailsResponse.prototype.header=null;GetAccountDetailsResponse.prototype.accountDetails=null;GetAccountDetailsResponse.create=function create(properties){return new GetAccountDetailsResponse(properties);};GetAccountDetailsResponse.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.header!=null&&Object.hasOwnProperty.call(m,"header"))$root.proto.ResponseHeader.encode(m.header,w.uint32(10).fork()).ldelim();if(m.accountDetails!=null&&Object.hasOwnProperty.call(m,"accountDetails"))$root.proto.GetAccountDetailsResponse.AccountDetails.encode(m.accountDetails,w.uint32(18).fork()).ldelim();return w;};GetAccountDetailsResponse.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.GetAccountDetailsResponse();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.header=$root.proto.ResponseHeader.decode(r,r.uint32());break;}case 2:{m.accountDetails=$root.proto.GetAccountDetailsResponse.AccountDetails.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};GetAccountDetailsResponse.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.GetAccountDetailsResponse";};GetAccountDetailsResponse.AccountDetails=function(){function AccountDetails(p){this.tokenRelationships=[];this.grantedCryptoAllowances=[];this.grantedNftAllowances=[];this.grantedTokenAllowances=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}AccountDetails.prototype.accountId=null;AccountDetails.prototype.contractAccountId="";AccountDetails.prototype.deleted=false;AccountDetails.prototype.proxyAccountId=null;AccountDetails.prototype.proxyReceived=$util.Long?$util.Long.fromBits(0,0,false):0;AccountDetails.prototype.key=null;AccountDetails.prototype.balance=$util.Long?$util.Long.fromBits(0,0,true):0;AccountDetails.prototype.receiverSigRequired=false;AccountDetails.prototype.expirationTime=null;AccountDetails.prototype.autoRenewPeriod=null;AccountDetails.prototype.tokenRelationships=$util.emptyArray;AccountDetails.prototype.memo="";AccountDetails.prototype.ownedNfts=$util.Long?$util.Long.fromBits(0,0,false):0;AccountDetails.prototype.maxAutomaticTokenAssociations=0;AccountDetails.prototype.alias=$util.newBuffer([]);AccountDetails.prototype.ledgerId=$util.newBuffer([]);AccountDetails.prototype.grantedCryptoAllowances=$util.emptyArray;AccountDetails.prototype.grantedNftAllowances=$util.emptyArray;AccountDetails.prototype.grantedTokenAllowances=$util.emptyArray;AccountDetails.create=function create(properties){return new AccountDetails(properties);};AccountDetails.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.accountId!=null&&Object.hasOwnProperty.call(m,"accountId"))$root.proto.AccountID.encode(m.accountId,w.uint32(10).fork()).ldelim();if(m.contractAccountId!=null&&Object.hasOwnProperty.call(m,"contractAccountId"))w.uint32(18).string(m.contractAccountId);if(m.deleted!=null&&Object.hasOwnProperty.call(m,"deleted"))w.uint32(24).bool(m.deleted);if(m.proxyAccountId!=null&&Object.hasOwnProperty.call(m,"proxyAccountId"))$root.proto.AccountID.encode(m.proxyAccountId,w.uint32(34).fork()).ldelim();if(m.proxyReceived!=null&&Object.hasOwnProperty.call(m,"proxyReceived"))w.uint32(40).int64(m.proxyReceived);if(m.key!=null&&Object.hasOwnProperty.call(m,"key"))$root.proto.Key.encode(m.key,w.uint32(50).fork()).ldelim();if(m.balance!=null&&Object.hasOwnProperty.call(m,"balance"))w.uint32(56).uint64(m.balance);if(m.receiverSigRequired!=null&&Object.hasOwnProperty.call(m,"receiverSigRequired"))w.uint32(64).bool(m.receiverSigRequired);if(m.expirationTime!=null&&Object.hasOwnProperty.call(m,"expirationTime"))$root.proto.Timestamp.encode(m.expirationTime,w.uint32(74).fork()).ldelim();if(m.autoRenewPeriod!=null&&Object.hasOwnProperty.call(m,"autoRenewPeriod"))$root.proto.Duration.encode(m.autoRenewPeriod,w.uint32(82).fork()).ldelim();if(m.tokenRelationships!=null&&m.tokenRelationships.length){for(var i=0;i<m.tokenRelationships.length;++i)$root.proto.TokenRelationship.encode(m.tokenRelationships[i],w.uint32(90).fork()).ldelim();}if(m.memo!=null&&Object.hasOwnProperty.call(m,"memo"))w.uint32(98).string(m.memo);if(m.ownedNfts!=null&&Object.hasOwnProperty.call(m,"ownedNfts"))w.uint32(104).int64(m.ownedNfts);if(m.maxAutomaticTokenAssociations!=null&&Object.hasOwnProperty.call(m,"maxAutomaticTokenAssociations"))w.uint32(112).int32(m.maxAutomaticTokenAssociations);if(m.alias!=null&&Object.hasOwnProperty.call(m,"alias"))w.uint32(122).bytes(m.alias);if(m.ledgerId!=null&&Object.hasOwnProperty.call(m,"ledgerId"))w.uint32(130).bytes(m.ledgerId);if(m.grantedCryptoAllowances!=null&&m.grantedCryptoAllowances.length){for(var i=0;i<m.grantedCryptoAllowances.length;++i)$root.proto.GrantedCryptoAllowance.encode(m.grantedCryptoAllowances[i],w.uint32(138).fork()).ldelim();}if(m.grantedNftAllowances!=null&&m.grantedNftAllowances.length){for(var i=0;i<m.grantedNftAllowances.length;++i)$root.proto.GrantedNftAllowance.encode(m.grantedNftAllowances[i],w.uint32(146).fork()).ldelim();}if(m.grantedTokenAllowances!=null&&m.grantedTokenAllowances.length){for(var i=0;i<m.grantedTokenAllowances.length;++i)$root.proto.GrantedTokenAllowance.encode(m.grantedTokenAllowances[i],w.uint32(154).fork()).ldelim();}return w;};AccountDetails.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.GetAccountDetailsResponse.AccountDetails();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.accountId=$root.proto.AccountID.decode(r,r.uint32());break;}case 2:{m.contractAccountId=r.string();break;}case 3:{m.deleted=r.bool();break;}case 4:{m.proxyAccountId=$root.proto.AccountID.decode(r,r.uint32());break;}case 5:{m.proxyReceived=r.int64();break;}case 6:{m.key=$root.proto.Key.decode(r,r.uint32());break;}case 7:{m.balance=r.uint64();break;}case 8:{m.receiverSigRequired=r.bool();break;}case 9:{m.expirationTime=$root.proto.Timestamp.decode(r,r.uint32());break;}case 10:{m.autoRenewPeriod=$root.proto.Duration.decode(r,r.uint32());break;}case 11:{if(!(m.tokenRelationships&&m.tokenRelationships.length))m.tokenRelationships=[];m.tokenRelationships.push($root.proto.TokenRelationship.decode(r,r.uint32()));break;}case 12:{m.memo=r.string();break;}case 13:{m.ownedNfts=r.int64();break;}case 14:{m.maxAutomaticTokenAssociations=r.int32();break;}case 15:{m.alias=r.bytes();break;}case 16:{m.ledgerId=r.bytes();break;}case 17:{if(!(m.grantedCryptoAllowances&&m.grantedCryptoAllowances.length))m.grantedCryptoAllowances=[];m.grantedCryptoAllowances.push($root.proto.GrantedCryptoAllowance.decode(r,r.uint32()));break;}case 18:{if(!(m.grantedNftAllowances&&m.grantedNftAllowances.length))m.grantedNftAllowances=[];m.grantedNftAllowances.push($root.proto.GrantedNftAllowance.decode(r,r.uint32()));break;}case 19:{if(!(m.grantedTokenAllowances&&m.grantedTokenAllowances.length))m.grantedTokenAllowances=[];m.grantedTokenAllowances.push($root.proto.GrantedTokenAllowance.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};AccountDetails.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.GetAccountDetailsResponse.AccountDetails";};return AccountDetails;}();return GetAccountDetailsResponse;}();proto.GrantedCryptoAllowance=function(){function GrantedCryptoAllowance(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}GrantedCryptoAllowance.prototype.spender=null;GrantedCryptoAllowance.prototype.amount=$util.Long?$util.Long.fromBits(0,0,false):0;GrantedCryptoAllowance.create=function create(properties){return new GrantedCryptoAllowance(properties);};GrantedCryptoAllowance.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.spender!=null&&Object.hasOwnProperty.call(m,"spender"))$root.proto.AccountID.encode(m.spender,w.uint32(10).fork()).ldelim();if(m.amount!=null&&Object.hasOwnProperty.call(m,"amount"))w.uint32(16).int64(m.amount);return w;};GrantedCryptoAllowance.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.GrantedCryptoAllowance();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.spender=$root.proto.AccountID.decode(r,r.uint32());break;}case 2:{m.amount=r.int64();break;}default:r.skipType(t&7);break;}}return m;};GrantedCryptoAllowance.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.GrantedCryptoAllowance";};return GrantedCryptoAllowance;}();proto.GrantedNftAllowance=function(){function GrantedNftAllowance(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}GrantedNftAllowance.prototype.tokenId=null;GrantedNftAllowance.prototype.spender=null;GrantedNftAllowance.create=function create(properties){return new GrantedNftAllowance(properties);};GrantedNftAllowance.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.tokenId!=null&&Object.hasOwnProperty.call(m,"tokenId"))$root.proto.TokenID.encode(m.tokenId,w.uint32(10).fork()).ldelim();if(m.spender!=null&&Object.hasOwnProperty.call(m,"spender"))$root.proto.AccountID.encode(m.spender,w.uint32(18).fork()).ldelim();return w;};GrantedNftAllowance.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.GrantedNftAllowance();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.tokenId=$root.proto.TokenID.decode(r,r.uint32());break;}case 2:{m.spender=$root.proto.AccountID.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};GrantedNftAllowance.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.GrantedNftAllowance";};return GrantedNftAllowance;}();proto.GrantedTokenAllowance=function(){function GrantedTokenAllowance(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}GrantedTokenAllowance.prototype.tokenId=null;GrantedTokenAllowance.prototype.spender=null;GrantedTokenAllowance.prototype.amount=$util.Long?$util.Long.fromBits(0,0,false):0;GrantedTokenAllowance.create=function create(properties){return new GrantedTokenAllowance(properties);};GrantedTokenAllowance.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.tokenId!=null&&Object.hasOwnProperty.call(m,"tokenId"))$root.proto.TokenID.encode(m.tokenId,w.uint32(10).fork()).ldelim();if(m.spender!=null&&Object.hasOwnProperty.call(m,"spender"))$root.proto.AccountID.encode(m.spender,w.uint32(18).fork()).ldelim();if(m.amount!=null&&Object.hasOwnProperty.call(m,"amount"))w.uint32(24).int64(m.amount);return w;};GrantedTokenAllowance.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.GrantedTokenAllowance();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.tokenId=$root.proto.TokenID.decode(r,r.uint32());break;}case 2:{m.spender=$root.proto.AccountID.decode(r,r.uint32());break;}case 3:{m.amount=r.int64();break;}default:r.skipType(t&7);break;}}return m;};GrantedTokenAllowance.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.GrantedTokenAllowance";};return GrantedTokenAllowance;}();proto.Response=function(){function Response(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}Response.prototype.getByKey=null;Response.prototype.getBySolidityID=null;Response.prototype.contractCallLocal=null;Response.prototype.contractGetBytecodeResponse=null;Response.prototype.contractGetInfo=null;Response.prototype.contractGetRecordsResponse=null;Response.prototype.cryptogetAccountBalance=null;Response.prototype.cryptoGetAccountRecords=null;Response.prototype.cryptoGetInfo=null;Response.prototype.cryptoGetLiveHash=null;Response.prototype.cryptoGetProxyStakers=null;Response.prototype.fileGetContents=null;Response.prototype.fileGetInfo=null;Response.prototype.transactionGetReceipt=null;Response.prototype.transactionGetRecord=null;Response.prototype.transactionGetFastRecord=null;Response.prototype.consensusGetTopicInfo=null;Response.prototype.networkGetVersionInfo=null;Response.prototype.tokenGetInfo=null;Response.prototype.scheduleGetInfo=null;Response.prototype.tokenGetAccountNftInfos=null;Response.prototype.tokenGetNftInfo=null;Response.prototype.tokenGetNftInfos=null;Response.prototype.networkGetExecutionTime=null;Response.prototype.accountDetails=null;let $oneOfFields;Object.defineProperty(Response.prototype,"response",{get:$util.oneOfGetter($oneOfFields=["getByKey","getBySolidityID","contractCallLocal","contractGetBytecodeResponse","contractGetInfo","contractGetRecordsResponse","cryptogetAccountBalance","cryptoGetAccountRecords","cryptoGetInfo","cryptoGetLiveHash","cryptoGetProxyStakers","fileGetContents","fileGetInfo","transactionGetReceipt","transactionGetRecord","transactionGetFastRecord","consensusGetTopicInfo","networkGetVersionInfo","tokenGetInfo","scheduleGetInfo","tokenGetAccountNftInfos","tokenGetNftInfo","tokenGetNftInfos","networkGetExecutionTime","accountDetails"]),set:$util.oneOfSetter($oneOfFields)});Response.create=function create(properties){return new Response(properties);};Response.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.getByKey!=null&&Object.hasOwnProperty.call(m,"getByKey"))$root.proto.GetByKeyResponse.encode(m.getByKey,w.uint32(10).fork()).ldelim();if(m.getBySolidityID!=null&&Object.hasOwnProperty.call(m,"getBySolidityID"))$root.proto.GetBySolidityIDResponse.encode(m.getBySolidityID,w.uint32(18).fork()).ldelim();if(m.contractCallLocal!=null&&Object.hasOwnProperty.call(m,"contractCallLocal"))$root.proto.ContractCallLocalResponse.encode(m.contractCallLocal,w.uint32(26).fork()).ldelim();if(m.contractGetInfo!=null&&Object.hasOwnProperty.call(m,"contractGetInfo"))$root.proto.ContractGetInfoResponse.encode(m.contractGetInfo,w.uint32(34).fork()).ldelim();if(m.contractGetBytecodeResponse!=null&&Object.hasOwnProperty.call(m,"contractGetBytecodeResponse"))$root.proto.ContractGetBytecodeResponse.encode(m.contractGetBytecodeResponse,w.uint32(42).fork()).ldelim();if(m.contractGetRecordsResponse!=null&&Object.hasOwnProperty.call(m,"contractGetRecordsResponse"))$root.proto.ContractGetRecordsResponse.encode(m.contractGetRecordsResponse,w.uint32(50).fork()).ldelim();if(m.cryptogetAccountBalance!=null&&Object.hasOwnProperty.call(m,"cryptogetAccountBalance"))$root.proto.CryptoGetAccountBalanceResponse.encode(m.cryptogetAccountBalance,w.uint32(58).fork()).ldelim();if(m.cryptoGetAccountRecords!=null&&Object.hasOwnProperty.call(m,"cryptoGetAccountRecords"))$root.proto.CryptoGetAccountRecordsResponse.encode(m.cryptoGetAccountRecords,w.uint32(66).fork()).ldelim();if(m.cryptoGetInfo!=null&&Object.hasOwnProperty.call(m,"cryptoGetInfo"))$root.proto.CryptoGetInfoResponse.encode(m.cryptoGetInfo,w.uint32(74).fork()).ldelim();if(m.cryptoGetLiveHash!=null&&Object.hasOwnProperty.call(m,"cryptoGetLiveHash"))$root.proto.CryptoGetLiveHashResponse.encode(m.cryptoGetLiveHash,w.uint32(82).fork()).ldelim();if(m.cryptoGetProxyStakers!=null&&Object.hasOwnProperty.call(m,"cryptoGetProxyStakers"))$root.proto.CryptoGetStakersResponse.encode(m.cryptoGetProxyStakers,w.uint32(90).fork()).ldelim();if(m.fileGetContents!=null&&Object.hasOwnProperty.call(m,"fileGetContents"))$root.proto.FileGetContentsResponse.encode(m.fileGetContents,w.uint32(98).fork()).ldelim();if(m.fileGetInfo!=null&&Object.hasOwnProperty.call(m,"fileGetInfo"))$root.proto.FileGetInfoResponse.encode(m.fileGetInfo,w.uint32(106).fork()).ldelim();if(m.transactionGetReceipt!=null&&Object.hasOwnProperty.call(m,"transactionGetReceipt"))$root.proto.TransactionGetReceiptResponse.encode(m.transactionGetReceipt,w.uint32(114).fork()).ldelim();if(m.transactionGetRecord!=null&&Object.hasOwnProperty.call(m,"transactionGetRecord"))$root.proto.TransactionGetRecordResponse.encode(m.transactionGetRecord,w.uint32(122).fork()).ldelim();if(m.transactionGetFastRecord!=null&&Object.hasOwnProperty.call(m,"transactionGetFastRecord"))$root.proto.TransactionGetFastRecordResponse.encode(m.transactionGetFastRecord,w.uint32(130).fork()).ldelim();if(m.consensusGetTopicInfo!=null&&Object.hasOwnProperty.call(m,"consensusGetTopicInfo"))$root.proto.ConsensusGetTopicInfoResponse.encode(m.consensusGetTopicInfo,w.uint32(1202).fork()).ldelim();if(m.networkGetVersionInfo!=null&&Object.hasOwnProperty.call(m,"networkGetVersionInfo"))$root.proto.NetworkGetVersionInfoResponse.encode(m.networkGetVersionInfo,w.uint32(1210).fork()).ldelim();if(m.tokenGetInfo!=null&&Object.hasOwnProperty.call(m,"tokenGetInfo"))$root.proto.TokenGetInfoResponse.encode(m.tokenGetInfo,w.uint32(1218).fork()).ldelim();if(m.scheduleGetInfo!=null&&Object.hasOwnProperty.call(m,"scheduleGetInfo"))$root.proto.ScheduleGetInfoResponse.encode(m.scheduleGetInfo,w.uint32(1226).fork()).ldelim();if(m.tokenGetAccountNftInfos!=null&&Object.hasOwnProperty.call(m,"tokenGetAccountNftInfos"))$root.proto.TokenGetAccountNftInfosResponse.encode(m.tokenGetAccountNftInfos,w.uint32(1234).fork()).ldelim();if(m.tokenGetNftInfo!=null&&Object.hasOwnProperty.call(m,"tokenGetNftInfo"))$root.proto.TokenGetNftInfoResponse.encode(m.tokenGetNftInfo,w.uint32(1242).fork()).ldelim();if(m.tokenGetNftInfos!=null&&Object.hasOwnProperty.call(m,"tokenGetNftInfos"))$root.proto.TokenGetNftInfosResponse.encode(m.tokenGetNftInfos,w.uint32(1250).fork()).ldelim();if(m.networkGetExecutionTime!=null&&Object.hasOwnProperty.call(m,"networkGetExecutionTime"))$root.proto.NetworkGetExecutionTimeResponse.encode(m.networkGetExecutionTime,w.uint32(1258).fork()).ldelim();if(m.accountDetails!=null&&Object.hasOwnProperty.call(m,"accountDetails"))$root.proto.GetAccountDetailsResponse.encode(m.accountDetails,w.uint32(1266).fork()).ldelim();return w;};Response.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.Response();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.getByKey=$root.proto.GetByKeyResponse.decode(r,r.uint32());break;}case 2:{m.getBySolidityID=$root.proto.GetBySolidityIDResponse.decode(r,r.uint32());break;}case 3:{m.contractCallLocal=$root.proto.ContractCallLocalResponse.decode(r,r.uint32());break;}case 5:{m.contractGetBytecodeResponse=$root.proto.ContractGetBytecodeResponse.decode(r,r.uint32());break;}case 4:{m.contractGetInfo=$root.proto.ContractGetInfoResponse.decode(r,r.uint32());break;}case 6:{m.contractGetRecordsResponse=$root.proto.ContractGetRecordsResponse.decode(r,r.uint32());break;}case 7:{m.cryptogetAccountBalance=$root.proto.CryptoGetAccountBalanceResponse.decode(r,r.uint32());break;}case 8:{m.cryptoGetAccountRecords=$root.proto.CryptoGetAccountRecordsResponse.decode(r,r.uint32());break;}case 9:{m.cryptoGetInfo=$root.proto.CryptoGetInfoResponse.decode(r,r.uint32());break;}case 10:{m.cryptoGetLiveHash=$root.proto.CryptoGetLiveHashResponse.decode(r,r.uint32());break;}case 11:{m.cryptoGetProxyStakers=$root.proto.CryptoGetStakersResponse.decode(r,r.uint32());break;}case 12:{m.fileGetContents=$root.proto.FileGetContentsResponse.decode(r,r.uint32());break;}case 13:{m.fileGetInfo=$root.proto.FileGetInfoResponse.decode(r,r.uint32());break;}case 14:{m.transactionGetReceipt=$root.proto.TransactionGetReceiptResponse.decode(r,r.uint32());break;}case 15:{m.transactionGetRecord=$root.proto.TransactionGetRecordResponse.decode(r,r.uint32());break;}case 16:{m.transactionGetFastRecord=$root.proto.TransactionGetFastRecordResponse.decode(r,r.uint32());break;}case 150:{m.consensusGetTopicInfo=$root.proto.ConsensusGetTopicInfoResponse.decode(r,r.uint32());break;}case 151:{m.networkGetVersionInfo=$root.proto.NetworkGetVersionInfoResponse.decode(r,r.uint32());break;}case 152:{m.tokenGetInfo=$root.proto.TokenGetInfoResponse.decode(r,r.uint32());break;}case 153:{m.scheduleGetInfo=$root.proto.ScheduleGetInfoResponse.decode(r,r.uint32());break;}case 154:{m.tokenGetAccountNftInfos=$root.proto.TokenGetAccountNftInfosResponse.decode(r,r.uint32());break;}case 155:{m.tokenGetNftInfo=$root.proto.TokenGetNftInfoResponse.decode(r,r.uint32());break;}case 156:{m.tokenGetNftInfos=$root.proto.TokenGetNftInfosResponse.decode(r,r.uint32());break;}case 157:{m.networkGetExecutionTime=$root.proto.NetworkGetExecutionTimeResponse.decode(r,r.uint32());break;}case 158:{m.accountDetails=$root.proto.GetAccountDetailsResponse.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};Response.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.Response";};return Response;}();proto.CryptoDeleteLiveHashTransactionBody=function(){function CryptoDeleteLiveHashTransactionBody(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}CryptoDeleteLiveHashTransactionBody.prototype.accountOfLiveHash=null;CryptoDeleteLiveHashTransactionBody.prototype.liveHashToDelete=$util.newBuffer([]);CryptoDeleteLiveHashTransactionBody.create=function create(properties){return new CryptoDeleteLiveHashTransactionBody(properties);};CryptoDeleteLiveHashTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.accountOfLiveHash!=null&&Object.hasOwnProperty.call(m,"accountOfLiveHash"))$root.proto.AccountID.encode(m.accountOfLiveHash,w.uint32(10).fork()).ldelim();if(m.liveHashToDelete!=null&&Object.hasOwnProperty.call(m,"liveHashToDelete"))w.uint32(18).bytes(m.liveHashToDelete);return w;};CryptoDeleteLiveHashTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.CryptoDeleteLiveHashTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.accountOfLiveHash=$root.proto.AccountID.decode(r,r.uint32());break;}case 2:{m.liveHashToDelete=r.bytes();break;}default:r.skipType(t&7);break;}}return m;};CryptoDeleteLiveHashTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.CryptoDeleteLiveHashTransactionBody";};return CryptoDeleteLiveHashTransactionBody;}();proto.CryptoService=function(){function CryptoService(rpcImpl,requestDelimited,responseDelimited){$protobuf.rpc.Service.call(this,rpcImpl,requestDelimited,responseDelimited);}(CryptoService.prototype=Object.create($protobuf.rpc.Service.prototype)).constructor=CryptoService;CryptoService.create=function create(rpcImpl,requestDelimited,responseDelimited){return new this(rpcImpl,requestDelimited,responseDelimited);};Object.defineProperty(CryptoService.prototype.createAccount=function createAccount(request,callback){return this.rpcCall(createAccount,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"createAccount"});Object.defineProperty(CryptoService.prototype.updateAccount=function updateAccount(request,callback){return this.rpcCall(updateAccount,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"updateAccount"});Object.defineProperty(CryptoService.prototype.cryptoTransfer=function cryptoTransfer(request,callback){return this.rpcCall(cryptoTransfer,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"cryptoTransfer"});Object.defineProperty(CryptoService.prototype.cryptoDelete=function cryptoDelete(request,callback){return this.rpcCall(cryptoDelete,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"cryptoDelete"});Object.defineProperty(CryptoService.prototype.approveAllowances=function approveAllowances(request,callback){return this.rpcCall(approveAllowances,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"approveAllowances"});Object.defineProperty(CryptoService.prototype.deleteAllowances=function deleteAllowances(request,callback){return this.rpcCall(deleteAllowances,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"deleteAllowances"});Object.defineProperty(CryptoService.prototype.addLiveHash=function addLiveHash(request,callback){return this.rpcCall(addLiveHash,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"addLiveHash"});Object.defineProperty(CryptoService.prototype.deleteLiveHash=function deleteLiveHash(request,callback){return this.rpcCall(deleteLiveHash,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"deleteLiveHash"});Object.defineProperty(CryptoService.prototype.getLiveHash=function getLiveHash(request,callback){return this.rpcCall(getLiveHash,$root.proto.Query,$root.proto.Response,request,callback);},"name",{value:"getLiveHash"});Object.defineProperty(CryptoService.prototype.getAccountRecords=function getAccountRecords(request,callback){return this.rpcCall(getAccountRecords,$root.proto.Query,$root.proto.Response,request,callback);},"name",{value:"getAccountRecords"});Object.defineProperty(CryptoService.prototype.cryptoGetBalance=function cryptoGetBalance(request,callback){return this.rpcCall(cryptoGetBalance,$root.proto.Query,$root.proto.Response,request,callback);},"name",{value:"cryptoGetBalance"});Object.defineProperty(CryptoService.prototype.getAccountInfo=function getAccountInfo(request,callback){return this.rpcCall(getAccountInfo,$root.proto.Query,$root.proto.Response,request,callback);},"name",{value:"getAccountInfo"});Object.defineProperty(CryptoService.prototype.getTransactionReceipts=function getTransactionReceipts(request,callback){return this.rpcCall(getTransactionReceipts,$root.proto.Query,$root.proto.Response,request,callback);},"name",{value:"getTransactionReceipts"});Object.defineProperty(CryptoService.prototype.getTxRecordByTxID=function getTxRecordByTxID(request,callback){return this.rpcCall(getTxRecordByTxID,$root.proto.Query,$root.proto.Response,request,callback);},"name",{value:"getTxRecordByTxID"});return CryptoService;}();proto.FileService=function(){function FileService(rpcImpl,requestDelimited,responseDelimited){$protobuf.rpc.Service.call(this,rpcImpl,requestDelimited,responseDelimited);}(FileService.prototype=Object.create($protobuf.rpc.Service.prototype)).constructor=FileService;FileService.create=function create(rpcImpl,requestDelimited,responseDelimited){return new this(rpcImpl,requestDelimited,responseDelimited);};Object.defineProperty(FileService.prototype.createFile=function createFile(request,callback){return this.rpcCall(createFile,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"createFile"});Object.defineProperty(FileService.prototype.updateFile=function updateFile(request,callback){return this.rpcCall(updateFile,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"updateFile"});Object.defineProperty(FileService.prototype.deleteFile=function deleteFile(request,callback){return this.rpcCall(deleteFile,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"deleteFile"});Object.defineProperty(FileService.prototype.appendContent=function appendContent(request,callback){return this.rpcCall(appendContent,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"appendContent"});Object.defineProperty(FileService.prototype.getFileContent=function getFileContent(request,callback){return this.rpcCall(getFileContent,$root.proto.Query,$root.proto.Response,request,callback);},"name",{value:"getFileContent"});Object.defineProperty(FileService.prototype.getFileInfo=function getFileInfo(request,callback){return this.rpcCall(getFileInfo,$root.proto.Query,$root.proto.Response,request,callback);},"name",{value:"getFileInfo"});Object.defineProperty(FileService.prototype.systemDelete=function systemDelete(request,callback){return this.rpcCall(systemDelete,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"systemDelete"});Object.defineProperty(FileService.prototype.systemUndelete=function systemUndelete(request,callback){return this.rpcCall(systemUndelete,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"systemUndelete"});return FileService;}();proto.FreezeService=function(){function FreezeService(rpcImpl,requestDelimited,responseDelimited){$protobuf.rpc.Service.call(this,rpcImpl,requestDelimited,responseDelimited);}(FreezeService.prototype=Object.create($protobuf.rpc.Service.prototype)).constructor=FreezeService;FreezeService.create=function create(rpcImpl,requestDelimited,responseDelimited){return new this(rpcImpl,requestDelimited,responseDelimited);};Object.defineProperty(FreezeService.prototype.freeze=function freeze(request,callback){return this.rpcCall(freeze,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"freeze"});return FreezeService;}();proto.NetworkService=function(){function NetworkService(rpcImpl,requestDelimited,responseDelimited){$protobuf.rpc.Service.call(this,rpcImpl,requestDelimited,responseDelimited);}(NetworkService.prototype=Object.create($protobuf.rpc.Service.prototype)).constructor=NetworkService;NetworkService.create=function create(rpcImpl,requestDelimited,responseDelimited){return new this(rpcImpl,requestDelimited,responseDelimited);};Object.defineProperty(NetworkService.prototype.getVersionInfo=function getVersionInfo(request,callback){return this.rpcCall(getVersionInfo,$root.proto.Query,$root.proto.Response,request,callback);},"name",{value:"getVersionInfo"});Object.defineProperty(NetworkService.prototype.getAccountDetails=function getAccountDetails(request,callback){return this.rpcCall(getAccountDetails,$root.proto.Query,$root.proto.Response,request,callback);},"name",{value:"getAccountDetails"});Object.defineProperty(NetworkService.prototype.getExecutionTime=function getExecutionTime(request,callback){return this.rpcCall(getExecutionTime,$root.proto.Query,$root.proto.Response,request,callback);},"name",{value:"getExecutionTime"});Object.defineProperty(NetworkService.prototype.uncheckedSubmit=function uncheckedSubmit(request,callback){return this.rpcCall(uncheckedSubmit,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"uncheckedSubmit"});return NetworkService;}();proto.NodeStakeUpdateTransactionBody=function(){function NodeStakeUpdateTransactionBody(p){this.nodeStake=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}NodeStakeUpdateTransactionBody.prototype.endOfStakingPeriod=null;NodeStakeUpdateTransactionBody.prototype.nodeStake=$util.emptyArray;NodeStakeUpdateTransactionBody.prototype.maxStakingRewardRatePerHbar=$util.Long?$util.Long.fromBits(0,0,false):0;NodeStakeUpdateTransactionBody.prototype.nodeRewardFeeFraction=null;NodeStakeUpdateTransactionBody.prototype.stakingPeriodsStored=$util.Long?$util.Long.fromBits(0,0,false):0;NodeStakeUpdateTransactionBody.prototype.stakingPeriod=$util.Long?$util.Long.fromBits(0,0,false):0;NodeStakeUpdateTransactionBody.prototype.stakingRewardFeeFraction=null;NodeStakeUpdateTransactionBody.prototype.stakingStartThreshold=$util.Long?$util.Long.fromBits(0,0,false):0;NodeStakeUpdateTransactionBody.prototype.stakingRewardRate=$util.Long?$util.Long.fromBits(0,0,false):0;NodeStakeUpdateTransactionBody.prototype.reservedStakingRewards=$util.Long?$util.Long.fromBits(0,0,false):0;NodeStakeUpdateTransactionBody.prototype.unreservedStakingRewardBalance=$util.Long?$util.Long.fromBits(0,0,false):0;NodeStakeUpdateTransactionBody.prototype.rewardBalanceThreshold=$util.Long?$util.Long.fromBits(0,0,false):0;NodeStakeUpdateTransactionBody.prototype.maxStakeRewarded=$util.Long?$util.Long.fromBits(0,0,false):0;NodeStakeUpdateTransactionBody.prototype.maxTotalReward=$util.Long?$util.Long.fromBits(0,0,false):0;NodeStakeUpdateTransactionBody.create=function create(properties){return new NodeStakeUpdateTransactionBody(properties);};NodeStakeUpdateTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.endOfStakingPeriod!=null&&Object.hasOwnProperty.call(m,"endOfStakingPeriod"))$root.proto.Timestamp.encode(m.endOfStakingPeriod,w.uint32(10).fork()).ldelim();if(m.nodeStake!=null&&m.nodeStake.length){for(var i=0;i<m.nodeStake.length;++i)$root.proto.NodeStake.encode(m.nodeStake[i],w.uint32(18).fork()).ldelim();}if(m.maxStakingRewardRatePerHbar!=null&&Object.hasOwnProperty.call(m,"maxStakingRewardRatePerHbar"))w.uint32(24).int64(m.maxStakingRewardRatePerHbar);if(m.nodeRewardFeeFraction!=null&&Object.hasOwnProperty.call(m,"nodeRewardFeeFraction"))$root.proto.Fraction.encode(m.nodeRewardFeeFraction,w.uint32(34).fork()).ldelim();if(m.stakingPeriodsStored!=null&&Object.hasOwnProperty.call(m,"stakingPeriodsStored"))w.uint32(40).int64(m.stakingPeriodsStored);if(m.stakingPeriod!=null&&Object.hasOwnProperty.call(m,"stakingPeriod"))w.uint32(48).int64(m.stakingPeriod);if(m.stakingRewardFeeFraction!=null&&Object.hasOwnProperty.call(m,"stakingRewardFeeFraction"))$root.proto.Fraction.encode(m.stakingRewardFeeFraction,w.uint32(58).fork()).ldelim();if(m.stakingStartThreshold!=null&&Object.hasOwnProperty.call(m,"stakingStartThreshold"))w.uint32(64).int64(m.stakingStartThreshold);if(m.stakingRewardRate!=null&&Object.hasOwnProperty.call(m,"stakingRewardRate"))w.uint32(72).int64(m.stakingRewardRate);if(m.reservedStakingRewards!=null&&Object.hasOwnProperty.call(m,"reservedStakingRewards"))w.uint32(80).int64(m.reservedStakingRewards);if(m.unreservedStakingRewardBalance!=null&&Object.hasOwnProperty.call(m,"unreservedStakingRewardBalance"))w.uint32(88).int64(m.unreservedStakingRewardBalance);if(m.rewardBalanceThreshold!=null&&Object.hasOwnProperty.call(m,"rewardBalanceThreshold"))w.uint32(96).int64(m.rewardBalanceThreshold);if(m.maxStakeRewarded!=null&&Object.hasOwnProperty.call(m,"maxStakeRewarded"))w.uint32(104).int64(m.maxStakeRewarded);if(m.maxTotalReward!=null&&Object.hasOwnProperty.call(m,"maxTotalReward"))w.uint32(112).int64(m.maxTotalReward);return w;};NodeStakeUpdateTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.NodeStakeUpdateTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.endOfStakingPeriod=$root.proto.Timestamp.decode(r,r.uint32());break;}case 2:{if(!(m.nodeStake&&m.nodeStake.length))m.nodeStake=[];m.nodeStake.push($root.proto.NodeStake.decode(r,r.uint32()));break;}case 3:{m.maxStakingRewardRatePerHbar=r.int64();break;}case 4:{m.nodeRewardFeeFraction=$root.proto.Fraction.decode(r,r.uint32());break;}case 5:{m.stakingPeriodsStored=r.int64();break;}case 6:{m.stakingPeriod=r.int64();break;}case 7:{m.stakingRewardFeeFraction=$root.proto.Fraction.decode(r,r.uint32());break;}case 8:{m.stakingStartThreshold=r.int64();break;}case 9:{m.stakingRewardRate=r.int64();break;}case 10:{m.reservedStakingRewards=r.int64();break;}case 11:{m.unreservedStakingRewardBalance=r.int64();break;}case 12:{m.rewardBalanceThreshold=r.int64();break;}case 13:{m.maxStakeRewarded=r.int64();break;}case 14:{m.maxTotalReward=r.int64();break;}default:r.skipType(t&7);break;}}return m;};NodeStakeUpdateTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.NodeStakeUpdateTransactionBody";};return NodeStakeUpdateTransactionBody;}();proto.NodeStake=function(){function NodeStake(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}NodeStake.prototype.maxStake=$util.Long?$util.Long.fromBits(0,0,false):0;NodeStake.prototype.minStake=$util.Long?$util.Long.fromBits(0,0,false):0;NodeStake.prototype.nodeId=$util.Long?$util.Long.fromBits(0,0,false):0;NodeStake.prototype.rewardRate=$util.Long?$util.Long.fromBits(0,0,false):0;NodeStake.prototype.stake=$util.Long?$util.Long.fromBits(0,0,false):0;NodeStake.prototype.stakeNotRewarded=$util.Long?$util.Long.fromBits(0,0,false):0;NodeStake.prototype.stakeRewarded=$util.Long?$util.Long.fromBits(0,0,false):0;NodeStake.create=function create(properties){return new NodeStake(properties);};NodeStake.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.maxStake!=null&&Object.hasOwnProperty.call(m,"maxStake"))w.uint32(8).int64(m.maxStake);if(m.minStake!=null&&Object.hasOwnProperty.call(m,"minStake"))w.uint32(16).int64(m.minStake);if(m.nodeId!=null&&Object.hasOwnProperty.call(m,"nodeId"))w.uint32(24).int64(m.nodeId);if(m.rewardRate!=null&&Object.hasOwnProperty.call(m,"rewardRate"))w.uint32(32).int64(m.rewardRate);if(m.stake!=null&&Object.hasOwnProperty.call(m,"stake"))w.uint32(40).int64(m.stake);if(m.stakeNotRewarded!=null&&Object.hasOwnProperty.call(m,"stakeNotRewarded"))w.uint32(48).int64(m.stakeNotRewarded);if(m.stakeRewarded!=null&&Object.hasOwnProperty.call(m,"stakeRewarded"))w.uint32(56).int64(m.stakeRewarded);return w;};NodeStake.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.NodeStake();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.maxStake=r.int64();break;}case 2:{m.minStake=r.int64();break;}case 3:{m.nodeId=r.int64();break;}case 4:{m.rewardRate=r.int64();break;}case 5:{m.stake=r.int64();break;}case 6:{m.stakeNotRewarded=r.int64();break;}case 7:{m.stakeRewarded=r.int64();break;}default:r.skipType(t&7);break;}}return m;};NodeStake.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.NodeStake";};return NodeStake;}();proto.ScheduleCreateTransactionBody=function(){function ScheduleCreateTransactionBody(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ScheduleCreateTransactionBody.prototype.scheduledTransactionBody=null;ScheduleCreateTransactionBody.prototype.memo="";ScheduleCreateTransactionBody.prototype.adminKey=null;ScheduleCreateTransactionBody.prototype.payerAccountID=null;ScheduleCreateTransactionBody.prototype.expirationTime=null;ScheduleCreateTransactionBody.prototype.waitForExpiry=false;ScheduleCreateTransactionBody.create=function create(properties){return new ScheduleCreateTransactionBody(properties);};ScheduleCreateTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.scheduledTransactionBody!=null&&Object.hasOwnProperty.call(m,"scheduledTransactionBody"))$root.proto.SchedulableTransactionBody.encode(m.scheduledTransactionBody,w.uint32(10).fork()).ldelim();if(m.memo!=null&&Object.hasOwnProperty.call(m,"memo"))w.uint32(18).string(m.memo);if(m.adminKey!=null&&Object.hasOwnProperty.call(m,"adminKey"))$root.proto.Key.encode(m.adminKey,w.uint32(26).fork()).ldelim();if(m.payerAccountID!=null&&Object.hasOwnProperty.call(m,"payerAccountID"))$root.proto.AccountID.encode(m.payerAccountID,w.uint32(34).fork()).ldelim();if(m.expirationTime!=null&&Object.hasOwnProperty.call(m,"expirationTime"))$root.proto.Timestamp.encode(m.expirationTime,w.uint32(42).fork()).ldelim();if(m.waitForExpiry!=null&&Object.hasOwnProperty.call(m,"waitForExpiry"))w.uint32(104).bool(m.waitForExpiry);return w;};ScheduleCreateTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ScheduleCreateTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.scheduledTransactionBody=$root.proto.SchedulableTransactionBody.decode(r,r.uint32());break;}case 2:{m.memo=r.string();break;}case 3:{m.adminKey=$root.proto.Key.decode(r,r.uint32());break;}case 4:{m.payerAccountID=$root.proto.AccountID.decode(r,r.uint32());break;}case 5:{m.expirationTime=$root.proto.Timestamp.decode(r,r.uint32());break;}case 13:{m.waitForExpiry=r.bool();break;}default:r.skipType(t&7);break;}}return m;};ScheduleCreateTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ScheduleCreateTransactionBody";};return ScheduleCreateTransactionBody;}();proto.ScheduleService=function(){function ScheduleService(rpcImpl,requestDelimited,responseDelimited){$protobuf.rpc.Service.call(this,rpcImpl,requestDelimited,responseDelimited);}(ScheduleService.prototype=Object.create($protobuf.rpc.Service.prototype)).constructor=ScheduleService;ScheduleService.create=function create(rpcImpl,requestDelimited,responseDelimited){return new this(rpcImpl,requestDelimited,responseDelimited);};Object.defineProperty(ScheduleService.prototype.createSchedule=function createSchedule(request,callback){return this.rpcCall(createSchedule,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"createSchedule"});Object.defineProperty(ScheduleService.prototype.signSchedule=function signSchedule(request,callback){return this.rpcCall(signSchedule,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"signSchedule"});Object.defineProperty(ScheduleService.prototype.deleteSchedule=function deleteSchedule(request,callback){return this.rpcCall(deleteSchedule,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"deleteSchedule"});Object.defineProperty(ScheduleService.prototype.getScheduleInfo=function getScheduleInfo(request,callback){return this.rpcCall(getScheduleInfo,$root.proto.Query,$root.proto.Response,request,callback);},"name",{value:"getScheduleInfo"});return ScheduleService;}();proto.ScheduleSignTransactionBody=function(){function ScheduleSignTransactionBody(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ScheduleSignTransactionBody.prototype.scheduleID=null;ScheduleSignTransactionBody.create=function create(properties){return new ScheduleSignTransactionBody(properties);};ScheduleSignTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.scheduleID!=null&&Object.hasOwnProperty.call(m,"scheduleID"))$root.proto.ScheduleID.encode(m.scheduleID,w.uint32(10).fork()).ldelim();return w;};ScheduleSignTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ScheduleSignTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.scheduleID=$root.proto.ScheduleID.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};ScheduleSignTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ScheduleSignTransactionBody";};return ScheduleSignTransactionBody;}();proto.SmartContractService=function(){function SmartContractService(rpcImpl,requestDelimited,responseDelimited){$protobuf.rpc.Service.call(this,rpcImpl,requestDelimited,responseDelimited);}(SmartContractService.prototype=Object.create($protobuf.rpc.Service.prototype)).constructor=SmartContractService;SmartContractService.create=function create(rpcImpl,requestDelimited,responseDelimited){return new this(rpcImpl,requestDelimited,responseDelimited);};Object.defineProperty(SmartContractService.prototype.createContract=function createContract(request,callback){return this.rpcCall(createContract,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"createContract"});Object.defineProperty(SmartContractService.prototype.updateContract=function updateContract(request,callback){return this.rpcCall(updateContract,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"updateContract"});Object.defineProperty(SmartContractService.prototype.contractCallMethod=function contractCallMethod(request,callback){return this.rpcCall(contractCallMethod,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"contractCallMethod"});Object.defineProperty(SmartContractService.prototype.contractCallLocalMethod=function contractCallLocalMethod(request,callback){return this.rpcCall(contractCallLocalMethod,$root.proto.Query,$root.proto.Response,request,callback);},"name",{value:"contractCallLocalMethod"});Object.defineProperty(SmartContractService.prototype.getContractInfo=function getContractInfo(request,callback){return this.rpcCall(getContractInfo,$root.proto.Query,$root.proto.Response,request,callback);},"name",{value:"getContractInfo"});Object.defineProperty(SmartContractService.prototype.contractGetBytecode=function contractGetBytecode(request,callback){return this.rpcCall(contractGetBytecode,$root.proto.Query,$root.proto.Response,request,callback);},"name",{value:"ContractGetBytecode"});Object.defineProperty(SmartContractService.prototype.getBySolidityID=function getBySolidityID(request,callback){return this.rpcCall(getBySolidityID,$root.proto.Query,$root.proto.Response,request,callback);},"name",{value:"getBySolidityID"});Object.defineProperty(SmartContractService.prototype.getTxRecordByContractID=function getTxRecordByContractID(request,callback){return this.rpcCall(getTxRecordByContractID,$root.proto.Query,$root.proto.Response,request,callback);},"name",{value:"getTxRecordByContractID"});Object.defineProperty(SmartContractService.prototype.deleteContract=function deleteContract(request,callback){return this.rpcCall(deleteContract,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"deleteContract"});Object.defineProperty(SmartContractService.prototype.systemDelete=function systemDelete(request,callback){return this.rpcCall(systemDelete,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"systemDelete"});Object.defineProperty(SmartContractService.prototype.systemUndelete=function systemUndelete(request,callback){return this.rpcCall(systemUndelete,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"systemUndelete"});Object.defineProperty(SmartContractService.prototype.callEthereum=function callEthereum(request,callback){return this.rpcCall(callEthereum,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"callEthereum"});return SmartContractService;}();proto.BlockInfo=function(){function BlockInfo(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}BlockInfo.prototype.lastBlockNumber=$util.Long?$util.Long.fromBits(0,0,false):0;BlockInfo.prototype.firstConsTimeOfLastBlock=null;BlockInfo.prototype.blockHashes=$util.newBuffer([]);BlockInfo.prototype.consTimeOfLastHandledTxn=null;BlockInfo.prototype.migrationRecordsStreamed=false;BlockInfo.prototype.firstConsTimeOfCurrentBlock=null;BlockInfo.create=function create(properties){return new BlockInfo(properties);};BlockInfo.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.lastBlockNumber!=null&&Object.hasOwnProperty.call(m,"lastBlockNumber"))w.uint32(8).int64(m.lastBlockNumber);if(m.firstConsTimeOfLastBlock!=null&&Object.hasOwnProperty.call(m,"firstConsTimeOfLastBlock"))$root.proto.Timestamp.encode(m.firstConsTimeOfLastBlock,w.uint32(18).fork()).ldelim();if(m.blockHashes!=null&&Object.hasOwnProperty.call(m,"blockHashes"))w.uint32(26).bytes(m.blockHashes);if(m.consTimeOfLastHandledTxn!=null&&Object.hasOwnProperty.call(m,"consTimeOfLastHandledTxn"))$root.proto.Timestamp.encode(m.consTimeOfLastHandledTxn,w.uint32(34).fork()).ldelim();if(m.migrationRecordsStreamed!=null&&Object.hasOwnProperty.call(m,"migrationRecordsStreamed"))w.uint32(40).bool(m.migrationRecordsStreamed);if(m.firstConsTimeOfCurrentBlock!=null&&Object.hasOwnProperty.call(m,"firstConsTimeOfCurrentBlock"))$root.proto.Timestamp.encode(m.firstConsTimeOfCurrentBlock,w.uint32(50).fork()).ldelim();return w;};BlockInfo.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.BlockInfo();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.lastBlockNumber=r.int64();break;}case 2:{m.firstConsTimeOfLastBlock=$root.proto.Timestamp.decode(r,r.uint32());break;}case 3:{m.blockHashes=r.bytes();break;}case 4:{m.consTimeOfLastHandledTxn=$root.proto.Timestamp.decode(r,r.uint32());break;}case 5:{m.migrationRecordsStreamed=r.bool();break;}case 6:{m.firstConsTimeOfCurrentBlock=$root.proto.Timestamp.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};BlockInfo.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.BlockInfo";};return BlockInfo;}();proto.RunningHashes=function(){function RunningHashes(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}RunningHashes.prototype.runningHash=$util.newBuffer([]);RunningHashes.prototype.nMinus_1RunningHash=$util.newBuffer([]);RunningHashes.prototype.nMinus_2RunningHash=$util.newBuffer([]);RunningHashes.prototype.nMinus_3RunningHash=$util.newBuffer([]);RunningHashes.create=function create(properties){return new RunningHashes(properties);};RunningHashes.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.runningHash!=null&&Object.hasOwnProperty.call(m,"runningHash"))w.uint32(10).bytes(m.runningHash);if(m.nMinus_1RunningHash!=null&&Object.hasOwnProperty.call(m,"nMinus_1RunningHash"))w.uint32(18).bytes(m.nMinus_1RunningHash);if(m.nMinus_2RunningHash!=null&&Object.hasOwnProperty.call(m,"nMinus_2RunningHash"))w.uint32(26).bytes(m.nMinus_2RunningHash);if(m.nMinus_3RunningHash!=null&&Object.hasOwnProperty.call(m,"nMinus_3RunningHash"))w.uint32(34).bytes(m.nMinus_3RunningHash);return w;};RunningHashes.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.RunningHashes();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.runningHash=r.bytes();break;}case 2:{m.nMinus_1RunningHash=r.bytes();break;}case 3:{m.nMinus_2RunningHash=r.bytes();break;}case 4:{m.nMinus_3RunningHash=r.bytes();break;}default:r.skipType(t&7);break;}}return m;};RunningHashes.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.RunningHashes";};return RunningHashes;}();proto.EntityNumber=function(){function EntityNumber(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}EntityNumber.prototype.number=$util.Long?$util.Long.fromBits(0,0,false):0;EntityNumber.create=function create(properties){return new EntityNumber(properties);};EntityNumber.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.number!=null&&Object.hasOwnProperty.call(m,"number"))w.uint32(8).int64(m.number);return w;};EntityNumber.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.EntityNumber();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.number=r.int64();break;}default:r.skipType(t&7);break;}}return m;};EntityNumber.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.EntityNumber";};return EntityNumber;}();proto.EntityIDPair=function(){function EntityIDPair(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}EntityIDPair.prototype.accountId=null;EntityIDPair.prototype.tokenId=null;EntityIDPair.create=function create(properties){return new EntityIDPair(properties);};EntityIDPair.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.accountId!=null&&Object.hasOwnProperty.call(m,"accountId"))$root.proto.AccountID.encode(m.accountId,w.uint32(10).fork()).ldelim();if(m.tokenId!=null&&Object.hasOwnProperty.call(m,"tokenId"))$root.proto.TokenID.encode(m.tokenId,w.uint32(18).fork()).ldelim();return w;};EntityIDPair.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.EntityIDPair();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.accountId=$root.proto.AccountID.decode(r,r.uint32());break;}case 2:{m.tokenId=$root.proto.TokenID.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};EntityIDPair.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.EntityIDPair";};return EntityIDPair;}();proto.CongestionLevelStarts=function(){function CongestionLevelStarts(p){this.genericLevelStarts=[];this.gasLevelStarts=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}CongestionLevelStarts.prototype.genericLevelStarts=$util.emptyArray;CongestionLevelStarts.prototype.gasLevelStarts=$util.emptyArray;CongestionLevelStarts.create=function create(properties){return new CongestionLevelStarts(properties);};CongestionLevelStarts.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.genericLevelStarts!=null&&m.genericLevelStarts.length){for(var i=0;i<m.genericLevelStarts.length;++i)$root.proto.Timestamp.encode(m.genericLevelStarts[i],w.uint32(10).fork()).ldelim();}if(m.gasLevelStarts!=null&&m.gasLevelStarts.length){for(var i=0;i<m.gasLevelStarts.length;++i)$root.proto.Timestamp.encode(m.gasLevelStarts[i],w.uint32(18).fork()).ldelim();}return w;};CongestionLevelStarts.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.CongestionLevelStarts();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{if(!(m.genericLevelStarts&&m.genericLevelStarts.length))m.genericLevelStarts=[];m.genericLevelStarts.push($root.proto.Timestamp.decode(r,r.uint32()));break;}case 2:{if(!(m.gasLevelStarts&&m.gasLevelStarts.length))m.gasLevelStarts=[];m.gasLevelStarts.push($root.proto.Timestamp.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};CongestionLevelStarts.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.CongestionLevelStarts";};return CongestionLevelStarts;}();proto.Topic=function(){function Topic(p){this.feeExemptKeyList=[];this.customFees=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}Topic.prototype.topicId=null;Topic.prototype.sequenceNumber=$util.Long?$util.Long.fromBits(0,0,false):0;Topic.prototype.expirationSecond=$util.Long?$util.Long.fromBits(0,0,false):0;Topic.prototype.autoRenewPeriod=$util.Long?$util.Long.fromBits(0,0,false):0;Topic.prototype.autoRenewAccountId=null;Topic.prototype.deleted=false;Topic.prototype.runningHash=$util.newBuffer([]);Topic.prototype.memo="";Topic.prototype.adminKey=null;Topic.prototype.submitKey=null;Topic.prototype.feeScheduleKey=null;Topic.prototype.feeExemptKeyList=$util.emptyArray;Topic.prototype.customFees=$util.emptyArray;Topic.create=function create(properties){return new Topic(properties);};Topic.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.topicId!=null&&Object.hasOwnProperty.call(m,"topicId"))$root.proto.TopicID.encode(m.topicId,w.uint32(10).fork()).ldelim();if(m.sequenceNumber!=null&&Object.hasOwnProperty.call(m,"sequenceNumber"))w.uint32(16).int64(m.sequenceNumber);if(m.expirationSecond!=null&&Object.hasOwnProperty.call(m,"expirationSecond"))w.uint32(24).int64(m.expirationSecond);if(m.autoRenewPeriod!=null&&Object.hasOwnProperty.call(m,"autoRenewPeriod"))w.uint32(32).int64(m.autoRenewPeriod);if(m.autoRenewAccountId!=null&&Object.hasOwnProperty.call(m,"autoRenewAccountId"))$root.proto.AccountID.encode(m.autoRenewAccountId,w.uint32(42).fork()).ldelim();if(m.deleted!=null&&Object.hasOwnProperty.call(m,"deleted"))w.uint32(48).bool(m.deleted);if(m.runningHash!=null&&Object.hasOwnProperty.call(m,"runningHash"))w.uint32(58).bytes(m.runningHash);if(m.memo!=null&&Object.hasOwnProperty.call(m,"memo"))w.uint32(66).string(m.memo);if(m.adminKey!=null&&Object.hasOwnProperty.call(m,"adminKey"))$root.proto.Key.encode(m.adminKey,w.uint32(74).fork()).ldelim();if(m.submitKey!=null&&Object.hasOwnProperty.call(m,"submitKey"))$root.proto.Key.encode(m.submitKey,w.uint32(82).fork()).ldelim();if(m.feeScheduleKey!=null&&Object.hasOwnProperty.call(m,"feeScheduleKey"))$root.proto.Key.encode(m.feeScheduleKey,w.uint32(90).fork()).ldelim();if(m.feeExemptKeyList!=null&&m.feeExemptKeyList.length){for(var i=0;i<m.feeExemptKeyList.length;++i)$root.proto.Key.encode(m.feeExemptKeyList[i],w.uint32(98).fork()).ldelim();}if(m.customFees!=null&&m.customFees.length){for(var i=0;i<m.customFees.length;++i)$root.proto.FixedCustomFee.encode(m.customFees[i],w.uint32(106).fork()).ldelim();}return w;};Topic.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.Topic();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.topicId=$root.proto.TopicID.decode(r,r.uint32());break;}case 2:{m.sequenceNumber=r.int64();break;}case 3:{m.expirationSecond=r.int64();break;}case 4:{m.autoRenewPeriod=r.int64();break;}case 5:{m.autoRenewAccountId=$root.proto.AccountID.decode(r,r.uint32());break;}case 6:{m.deleted=r.bool();break;}case 7:{m.runningHash=r.bytes();break;}case 8:{m.memo=r.string();break;}case 9:{m.adminKey=$root.proto.Key.decode(r,r.uint32());break;}case 10:{m.submitKey=$root.proto.Key.decode(r,r.uint32());break;}case 11:{m.feeScheduleKey=$root.proto.Key.decode(r,r.uint32());break;}case 12:{if(!(m.feeExemptKeyList&&m.feeExemptKeyList.length))m.feeExemptKeyList=[];m.feeExemptKeyList.push($root.proto.Key.decode(r,r.uint32()));break;}case 13:{if(!(m.customFees&&m.customFees.length))m.customFees=[];m.customFees.push($root.proto.FixedCustomFee.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};Topic.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.Topic";};return Topic;}();proto.Bytecode=function(){function Bytecode(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}Bytecode.prototype.code=$util.newBuffer([]);Bytecode.create=function create(properties){return new Bytecode(properties);};Bytecode.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.code!=null&&Object.hasOwnProperty.call(m,"code"))w.uint32(10).bytes(m.code);return w;};Bytecode.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.Bytecode();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.code=r.bytes();break;}default:r.skipType(t&7);break;}}return m;};Bytecode.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.Bytecode";};return Bytecode;}();proto.SlotKey=function(){function SlotKey(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}SlotKey.prototype.contractID=null;SlotKey.prototype.key=$util.newBuffer([]);SlotKey.create=function create(properties){return new SlotKey(properties);};SlotKey.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.contractID!=null&&Object.hasOwnProperty.call(m,"contractID"))$root.proto.ContractID.encode(m.contractID,w.uint32(10).fork()).ldelim();if(m.key!=null&&Object.hasOwnProperty.call(m,"key"))w.uint32(18).bytes(m.key);return w;};SlotKey.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.SlotKey();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.contractID=$root.proto.ContractID.decode(r,r.uint32());break;}case 2:{m.key=r.bytes();break;}default:r.skipType(t&7);break;}}return m;};SlotKey.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.SlotKey";};return SlotKey;}();proto.SlotValue=function(){function SlotValue(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}SlotValue.prototype.value=$util.newBuffer([]);SlotValue.prototype.previousKey=$util.newBuffer([]);SlotValue.prototype.nextKey=$util.newBuffer([]);SlotValue.create=function create(properties){return new SlotValue(properties);};SlotValue.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.value!=null&&Object.hasOwnProperty.call(m,"value"))w.uint32(10).bytes(m.value);if(m.previousKey!=null&&Object.hasOwnProperty.call(m,"previousKey"))w.uint32(18).bytes(m.previousKey);if(m.nextKey!=null&&Object.hasOwnProperty.call(m,"nextKey"))w.uint32(26).bytes(m.nextKey);return w;};SlotValue.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.SlotValue();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.value=r.bytes();break;}case 2:{m.previousKey=r.bytes();break;}case 3:{m.nextKey=r.bytes();break;}default:r.skipType(t&7);break;}}return m;};SlotValue.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.SlotValue";};return SlotValue;}();proto.File=function(){function File(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}File.prototype.fileId=null;File.prototype.expirationSecond=$util.Long?$util.Long.fromBits(0,0,false):0;File.prototype.keys=null;File.prototype.contents=$util.newBuffer([]);File.prototype.memo="";File.prototype.deleted=false;File.prototype.preSystemDeleteExpirationSecond=$util.Long?$util.Long.fromBits(0,0,false):0;File.create=function create(properties){return new File(properties);};File.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.fileId!=null&&Object.hasOwnProperty.call(m,"fileId"))$root.proto.FileID.encode(m.fileId,w.uint32(10).fork()).ldelim();if(m.expirationSecond!=null&&Object.hasOwnProperty.call(m,"expirationSecond"))w.uint32(16).int64(m.expirationSecond);if(m.keys!=null&&Object.hasOwnProperty.call(m,"keys"))$root.proto.KeyList.encode(m.keys,w.uint32(26).fork()).ldelim();if(m.contents!=null&&Object.hasOwnProperty.call(m,"contents"))w.uint32(34).bytes(m.contents);if(m.memo!=null&&Object.hasOwnProperty.call(m,"memo"))w.uint32(42).string(m.memo);if(m.deleted!=null&&Object.hasOwnProperty.call(m,"deleted"))w.uint32(48).bool(m.deleted);if(m.preSystemDeleteExpirationSecond!=null&&Object.hasOwnProperty.call(m,"preSystemDeleteExpirationSecond"))w.uint32(56).int64(m.preSystemDeleteExpirationSecond);return w;};File.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.File();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.fileId=$root.proto.FileID.decode(r,r.uint32());break;}case 2:{m.expirationSecond=r.int64();break;}case 3:{m.keys=$root.proto.KeyList.decode(r,r.uint32());break;}case 4:{m.contents=r.bytes();break;}case 5:{m.memo=r.string();break;}case 6:{m.deleted=r.bool();break;}case 7:{m.preSystemDeleteExpirationSecond=r.int64();break;}default:r.skipType(t&7);break;}}return m;};File.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.File";};return File;}();proto.ProtoLong=function(){function ProtoLong(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ProtoLong.prototype.value=$util.Long?$util.Long.fromBits(0,0,false):0;ProtoLong.create=function create(properties){return new ProtoLong(properties);};ProtoLong.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.value!=null&&Object.hasOwnProperty.call(m,"value"))w.uint32(8).int64(m.value);return w;};ProtoLong.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ProtoLong();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.value=r.int64();break;}default:r.skipType(t&7);break;}}return m;};ProtoLong.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ProtoLong";};return ProtoLong;}();proto.ProtoInteger=function(){function ProtoInteger(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ProtoInteger.prototype.value=0;ProtoInteger.create=function create(properties){return new ProtoInteger(properties);};ProtoInteger.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.value!=null&&Object.hasOwnProperty.call(m,"value"))w.uint32(8).int32(m.value);return w;};ProtoInteger.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ProtoInteger();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.value=r.int32();break;}default:r.skipType(t&7);break;}}return m;};ProtoInteger.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ProtoInteger";};return ProtoInteger;}();proto.ProtoBoolean=function(){function ProtoBoolean(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ProtoBoolean.prototype.value=false;ProtoBoolean.create=function create(properties){return new ProtoBoolean(properties);};ProtoBoolean.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.value!=null&&Object.hasOwnProperty.call(m,"value"))w.uint32(8).bool(m.value);return w;};ProtoBoolean.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ProtoBoolean();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.value=r.bool();break;}default:r.skipType(t&7);break;}}return m;};ProtoBoolean.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ProtoBoolean";};return ProtoBoolean;}();proto.ProtoString=function(){function ProtoString(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ProtoString.prototype.value="";ProtoString.create=function create(properties){return new ProtoString(properties);};ProtoString.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.value!=null&&Object.hasOwnProperty.call(m,"value"))w.uint32(10).string(m.value);return w;};ProtoString.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ProtoString();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.value=r.string();break;}default:r.skipType(t&7);break;}}return m;};ProtoString.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ProtoString";};return ProtoString;}();proto.ProtoBytes=function(){function ProtoBytes(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ProtoBytes.prototype.value=$util.newBuffer([]);ProtoBytes.create=function create(properties){return new ProtoBytes(properties);};ProtoBytes.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.value!=null&&Object.hasOwnProperty.call(m,"value"))w.uint32(10).bytes(m.value);return w;};ProtoBytes.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ProtoBytes();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.value=r.bytes();break;}default:r.skipType(t&7);break;}}return m;};ProtoBytes.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ProtoBytes";};return ProtoBytes;}();proto.TransactionRecordEntry=function(){function TransactionRecordEntry(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TransactionRecordEntry.prototype.nodeId=$util.Long?$util.Long.fromBits(0,0,false):0;TransactionRecordEntry.prototype.payerAccountId=null;TransactionRecordEntry.prototype.transactionRecord=null;TransactionRecordEntry.create=function create(properties){return new TransactionRecordEntry(properties);};TransactionRecordEntry.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.nodeId!=null&&Object.hasOwnProperty.call(m,"nodeId"))w.uint32(8).int64(m.nodeId);if(m.payerAccountId!=null&&Object.hasOwnProperty.call(m,"payerAccountId"))$root.proto.AccountID.encode(m.payerAccountId,w.uint32(18).fork()).ldelim();if(m.transactionRecord!=null&&Object.hasOwnProperty.call(m,"transactionRecord"))$root.proto.TransactionRecord.encode(m.transactionRecord,w.uint32(26).fork()).ldelim();return w;};TransactionRecordEntry.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TransactionRecordEntry();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.nodeId=r.int64();break;}case 2:{m.payerAccountId=$root.proto.AccountID.decode(r,r.uint32());break;}case 3:{m.transactionRecord=$root.proto.TransactionRecord.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};TransactionRecordEntry.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TransactionRecordEntry";};return TransactionRecordEntry;}();proto.TransactionReceiptEntry=function(){function TransactionReceiptEntry(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TransactionReceiptEntry.prototype.nodeId=$util.Long?$util.Long.fromBits(0,0,true):0;TransactionReceiptEntry.prototype.transactionId=null;TransactionReceiptEntry.prototype.status=0;TransactionReceiptEntry.create=function create(properties){return new TransactionReceiptEntry(properties);};TransactionReceiptEntry.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.nodeId!=null&&Object.hasOwnProperty.call(m,"nodeId"))w.uint32(8).uint64(m.nodeId);if(m.transactionId!=null&&Object.hasOwnProperty.call(m,"transactionId"))$root.proto.TransactionID.encode(m.transactionId,w.uint32(18).fork()).ldelim();if(m.status!=null&&Object.hasOwnProperty.call(m,"status"))w.uint32(24).int32(m.status);return w;};TransactionReceiptEntry.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TransactionReceiptEntry();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.nodeId=r.uint64();break;}case 2:{m.transactionId=$root.proto.TransactionID.decode(r,r.uint32());break;}case 3:{m.status=r.int32();break;}default:r.skipType(t&7);break;}}return m;};TransactionReceiptEntry.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TransactionReceiptEntry";};return TransactionReceiptEntry;}();proto.TransactionReceiptEntries=function(){function TransactionReceiptEntries(p){this.entries=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TransactionReceiptEntries.prototype.entries=$util.emptyArray;TransactionReceiptEntries.create=function create(properties){return new TransactionReceiptEntries(properties);};TransactionReceiptEntries.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.entries!=null&&m.entries.length){for(var i=0;i<m.entries.length;++i)$root.proto.TransactionReceiptEntry.encode(m.entries[i],w.uint32(10).fork()).ldelim();}return w;};TransactionReceiptEntries.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TransactionReceiptEntries();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{if(!(m.entries&&m.entries.length))m.entries=[];m.entries.push($root.proto.TransactionReceiptEntry.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};TransactionReceiptEntries.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TransactionReceiptEntries";};return TransactionReceiptEntries;}();proto.Schedule=function(){function Schedule(p){this.signatories=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}Schedule.prototype.scheduleId=null;Schedule.prototype.deleted=false;Schedule.prototype.executed=false;Schedule.prototype.waitForExpiry=false;Schedule.prototype.memo="";Schedule.prototype.schedulerAccountId=null;Schedule.prototype.payerAccountId=null;Schedule.prototype.adminKey=null;Schedule.prototype.scheduleValidStart=null;Schedule.prototype.providedExpirationSecond=$util.Long?$util.Long.fromBits(0,0,false):0;Schedule.prototype.calculatedExpirationSecond=$util.Long?$util.Long.fromBits(0,0,false):0;Schedule.prototype.resolutionTime=null;Schedule.prototype.scheduledTransaction=null;Schedule.prototype.originalCreateTransaction=null;Schedule.prototype.signatories=$util.emptyArray;Schedule.create=function create(properties){return new Schedule(properties);};Schedule.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.scheduleId!=null&&Object.hasOwnProperty.call(m,"scheduleId"))$root.proto.ScheduleID.encode(m.scheduleId,w.uint32(10).fork()).ldelim();if(m.deleted!=null&&Object.hasOwnProperty.call(m,"deleted"))w.uint32(16).bool(m.deleted);if(m.executed!=null&&Object.hasOwnProperty.call(m,"executed"))w.uint32(24).bool(m.executed);if(m.waitForExpiry!=null&&Object.hasOwnProperty.call(m,"waitForExpiry"))w.uint32(32).bool(m.waitForExpiry);if(m.memo!=null&&Object.hasOwnProperty.call(m,"memo"))w.uint32(42).string(m.memo);if(m.schedulerAccountId!=null&&Object.hasOwnProperty.call(m,"schedulerAccountId"))$root.proto.AccountID.encode(m.schedulerAccountId,w.uint32(50).fork()).ldelim();if(m.payerAccountId!=null&&Object.hasOwnProperty.call(m,"payerAccountId"))$root.proto.AccountID.encode(m.payerAccountId,w.uint32(58).fork()).ldelim();if(m.adminKey!=null&&Object.hasOwnProperty.call(m,"adminKey"))$root.proto.Key.encode(m.adminKey,w.uint32(66).fork()).ldelim();if(m.scheduleValidStart!=null&&Object.hasOwnProperty.call(m,"scheduleValidStart"))$root.proto.Timestamp.encode(m.scheduleValidStart,w.uint32(74).fork()).ldelim();if(m.providedExpirationSecond!=null&&Object.hasOwnProperty.call(m,"providedExpirationSecond"))w.uint32(80).int64(m.providedExpirationSecond);if(m.calculatedExpirationSecond!=null&&Object.hasOwnProperty.call(m,"calculatedExpirationSecond"))w.uint32(88).int64(m.calculatedExpirationSecond);if(m.resolutionTime!=null&&Object.hasOwnProperty.call(m,"resolutionTime"))$root.proto.Timestamp.encode(m.resolutionTime,w.uint32(98).fork()).ldelim();if(m.scheduledTransaction!=null&&Object.hasOwnProperty.call(m,"scheduledTransaction"))$root.proto.SchedulableTransactionBody.encode(m.scheduledTransaction,w.uint32(106).fork()).ldelim();if(m.originalCreateTransaction!=null&&Object.hasOwnProperty.call(m,"originalCreateTransaction"))$root.proto.TransactionBody.encode(m.originalCreateTransaction,w.uint32(114).fork()).ldelim();if(m.signatories!=null&&m.signatories.length){for(var i=0;i<m.signatories.length;++i)$root.proto.Key.encode(m.signatories[i],w.uint32(122).fork()).ldelim();}return w;};Schedule.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.Schedule();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.scheduleId=$root.proto.ScheduleID.decode(r,r.uint32());break;}case 2:{m.deleted=r.bool();break;}case 3:{m.executed=r.bool();break;}case 4:{m.waitForExpiry=r.bool();break;}case 5:{m.memo=r.string();break;}case 6:{m.schedulerAccountId=$root.proto.AccountID.decode(r,r.uint32());break;}case 7:{m.payerAccountId=$root.proto.AccountID.decode(r,r.uint32());break;}case 8:{m.adminKey=$root.proto.Key.decode(r,r.uint32());break;}case 9:{m.scheduleValidStart=$root.proto.Timestamp.decode(r,r.uint32());break;}case 10:{m.providedExpirationSecond=r.int64();break;}case 11:{m.calculatedExpirationSecond=r.int64();break;}case 12:{m.resolutionTime=$root.proto.Timestamp.decode(r,r.uint32());break;}case 13:{m.scheduledTransaction=$root.proto.SchedulableTransactionBody.decode(r,r.uint32());break;}case 14:{m.originalCreateTransaction=$root.proto.TransactionBody.decode(r,r.uint32());break;}case 15:{if(!(m.signatories&&m.signatories.length))m.signatories=[];m.signatories.push($root.proto.Key.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};Schedule.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.Schedule";};return Schedule;}();proto.ScheduleList=function(){function ScheduleList(p){this.schedules=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ScheduleList.prototype.schedules=$util.emptyArray;ScheduleList.create=function create(properties){return new ScheduleList(properties);};ScheduleList.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.schedules!=null&&m.schedules.length){for(var i=0;i<m.schedules.length;++i)$root.proto.Schedule.encode(m.schedules[i],w.uint32(10).fork()).ldelim();}return w;};ScheduleList.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ScheduleList();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{if(!(m.schedules&&m.schedules.length))m.schedules=[];m.schedules.push($root.proto.Schedule.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};ScheduleList.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ScheduleList";};return ScheduleList;}();proto.ScheduleIdList=function(){function ScheduleIdList(p){this.scheduleIds=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ScheduleIdList.prototype.scheduleIds=$util.emptyArray;ScheduleIdList.create=function create(properties){return new ScheduleIdList(properties);};ScheduleIdList.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.scheduleIds!=null&&m.scheduleIds.length){for(var i=0;i<m.scheduleIds.length;++i)$root.proto.ScheduleID.encode(m.scheduleIds[i],w.uint32(10).fork()).ldelim();}return w;};ScheduleIdList.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ScheduleIdList();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{if(!(m.scheduleIds&&m.scheduleIds.length))m.scheduleIds=[];m.scheduleIds.push($root.proto.ScheduleID.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};ScheduleIdList.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ScheduleIdList";};return ScheduleIdList;}();proto.ScheduledCounts=function(){function ScheduledCounts(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ScheduledCounts.prototype.numberScheduled=0;ScheduledCounts.prototype.numberProcessed=0;ScheduledCounts.create=function create(properties){return new ScheduledCounts(properties);};ScheduledCounts.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.numberScheduled!=null&&Object.hasOwnProperty.call(m,"numberScheduled"))w.uint32(8).uint32(m.numberScheduled);if(m.numberProcessed!=null&&Object.hasOwnProperty.call(m,"numberProcessed"))w.uint32(16).uint32(m.numberProcessed);return w;};ScheduledCounts.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ScheduledCounts();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.numberScheduled=r.uint32();break;}case 2:{m.numberProcessed=r.uint32();break;}default:r.skipType(t&7);break;}}return m;};ScheduledCounts.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ScheduledCounts";};return ScheduledCounts;}();proto.ScheduledOrder=function(){function ScheduledOrder(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ScheduledOrder.prototype.expirySecond=$util.Long?$util.Long.fromBits(0,0,true):0;ScheduledOrder.prototype.orderNumber=0;ScheduledOrder.create=function create(properties){return new ScheduledOrder(properties);};ScheduledOrder.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.expirySecond!=null&&Object.hasOwnProperty.call(m,"expirySecond"))w.uint32(8).uint64(m.expirySecond);if(m.orderNumber!=null&&Object.hasOwnProperty.call(m,"orderNumber"))w.uint32(16).uint32(m.orderNumber);return w;};ScheduledOrder.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ScheduledOrder();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.expirySecond=r.uint64();break;}case 2:{m.orderNumber=r.uint32();break;}default:r.skipType(t&7);break;}}return m;};ScheduledOrder.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ScheduledOrder";};return ScheduledOrder;}();proto.ThrottleUsageSnapshots=function(){function ThrottleUsageSnapshots(p){this.tpsThrottles=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ThrottleUsageSnapshots.prototype.tpsThrottles=$util.emptyArray;ThrottleUsageSnapshots.prototype.gasThrottle=null;ThrottleUsageSnapshots.prototype.evmOpsDurationThrottle=null;ThrottleUsageSnapshots.create=function create(properties){return new ThrottleUsageSnapshots(properties);};ThrottleUsageSnapshots.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.tpsThrottles!=null&&m.tpsThrottles.length){for(var i=0;i<m.tpsThrottles.length;++i)$root.proto.ThrottleUsageSnapshot.encode(m.tpsThrottles[i],w.uint32(10).fork()).ldelim();}if(m.gasThrottle!=null&&Object.hasOwnProperty.call(m,"gasThrottle"))$root.proto.ThrottleUsageSnapshot.encode(m.gasThrottle,w.uint32(18).fork()).ldelim();if(m.evmOpsDurationThrottle!=null&&Object.hasOwnProperty.call(m,"evmOpsDurationThrottle"))$root.proto.ThrottleUsageSnapshot.encode(m.evmOpsDurationThrottle,w.uint32(26).fork()).ldelim();return w;};ThrottleUsageSnapshots.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ThrottleUsageSnapshots();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{if(!(m.tpsThrottles&&m.tpsThrottles.length))m.tpsThrottles=[];m.tpsThrottles.push($root.proto.ThrottleUsageSnapshot.decode(r,r.uint32()));break;}case 2:{m.gasThrottle=$root.proto.ThrottleUsageSnapshot.decode(r,r.uint32());break;}case 3:{m.evmOpsDurationThrottle=$root.proto.ThrottleUsageSnapshot.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};ThrottleUsageSnapshots.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ThrottleUsageSnapshots";};return ThrottleUsageSnapshots;}();proto.ThrottleUsageSnapshot=function(){function ThrottleUsageSnapshot(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ThrottleUsageSnapshot.prototype.used=$util.Long?$util.Long.fromBits(0,0,false):0;ThrottleUsageSnapshot.prototype.lastDecisionTime=null;ThrottleUsageSnapshot.create=function create(properties){return new ThrottleUsageSnapshot(properties);};ThrottleUsageSnapshot.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.used!=null&&Object.hasOwnProperty.call(m,"used"))w.uint32(8).int64(m.used);if(m.lastDecisionTime!=null&&Object.hasOwnProperty.call(m,"lastDecisionTime"))$root.proto.Timestamp.encode(m.lastDecisionTime,w.uint32(18).fork()).ldelim();return w;};ThrottleUsageSnapshot.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ThrottleUsageSnapshot();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.used=r.int64();break;}case 2:{m.lastDecisionTime=$root.proto.Timestamp.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};ThrottleUsageSnapshot.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ThrottleUsageSnapshot";};return ThrottleUsageSnapshot;}();proto.AccountPendingAirdrop=function(){function AccountPendingAirdrop(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}AccountPendingAirdrop.prototype.pendingAirdropValue=null;AccountPendingAirdrop.prototype.previousAirdrop=null;AccountPendingAirdrop.prototype.nextAirdrop=null;AccountPendingAirdrop.create=function create(properties){return new AccountPendingAirdrop(properties);};AccountPendingAirdrop.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.pendingAirdropValue!=null&&Object.hasOwnProperty.call(m,"pendingAirdropValue"))$root.proto.PendingAirdropValue.encode(m.pendingAirdropValue,w.uint32(10).fork()).ldelim();if(m.previousAirdrop!=null&&Object.hasOwnProperty.call(m,"previousAirdrop"))$root.proto.PendingAirdropId.encode(m.previousAirdrop,w.uint32(18).fork()).ldelim();if(m.nextAirdrop!=null&&Object.hasOwnProperty.call(m,"nextAirdrop"))$root.proto.PendingAirdropId.encode(m.nextAirdrop,w.uint32(26).fork()).ldelim();return w;};AccountPendingAirdrop.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.AccountPendingAirdrop();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.pendingAirdropValue=$root.proto.PendingAirdropValue.decode(r,r.uint32());break;}case 2:{m.previousAirdrop=$root.proto.PendingAirdropId.decode(r,r.uint32());break;}case 3:{m.nextAirdrop=$root.proto.PendingAirdropId.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};AccountPendingAirdrop.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.AccountPendingAirdrop";};return AccountPendingAirdrop;}();proto.Account=function(){function Account(p){this.cryptoAllowances=[];this.approveForAllNftAllowances=[];this.tokenAllowances=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}Account.prototype.accountId=null;Account.prototype.alias=$util.newBuffer([]);Account.prototype.key=null;Account.prototype.expirationSecond=$util.Long?$util.Long.fromBits(0,0,false):0;Account.prototype.tinybarBalance=$util.Long?$util.Long.fromBits(0,0,false):0;Account.prototype.memo="";Account.prototype.deleted=false;Account.prototype.stakedToMe=$util.Long?$util.Long.fromBits(0,0,false):0;Account.prototype.stakePeriodStart=$util.Long?$util.Long.fromBits(0,0,false):0;Account.prototype.stakedAccountId=null;Account.prototype.stakedNodeId=null;Account.prototype.declineReward=false;Account.prototype.receiverSigRequired=false;Account.prototype.headTokenId=null;Account.prototype.headNftId=null;Account.prototype.headNftSerialNumber=$util.Long?$util.Long.fromBits(0,0,false):0;Account.prototype.numberOwnedNfts=$util.Long?$util.Long.fromBits(0,0,false):0;Account.prototype.maxAutoAssociations=0;Account.prototype.usedAutoAssociations=0;Account.prototype.numberAssociations=0;Account.prototype.smartContract=false;Account.prototype.numberPositiveBalances=0;Account.prototype.ethereumNonce=$util.Long?$util.Long.fromBits(0,0,false):0;Account.prototype.stakeAtStartOfLastRewardedPeriod=$util.Long?$util.Long.fromBits(0,0,false):0;Account.prototype.autoRenewAccountId=null;Account.prototype.autoRenewSeconds=$util.Long?$util.Long.fromBits(0,0,false):0;Account.prototype.contractKvPairsNumber=0;Account.prototype.cryptoAllowances=$util.emptyArray;Account.prototype.approveForAllNftAllowances=$util.emptyArray;Account.prototype.tokenAllowances=$util.emptyArray;Account.prototype.numberTreasuryTitles=0;Account.prototype.expiredAndPendingRemoval=false;Account.prototype.firstContractStorageKey=$util.newBuffer([]);Account.prototype.headPendingAirdropId=null;Account.prototype.numberPendingAirdrops=$util.Long?$util.Long.fromBits(0,0,true):0;let $oneOfFields;Object.defineProperty(Account.prototype,"stakedId",{get:$util.oneOfGetter($oneOfFields=["stakedAccountId","stakedNodeId"]),set:$util.oneOfSetter($oneOfFields)});Account.create=function create(properties){return new Account(properties);};Account.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.accountId!=null&&Object.hasOwnProperty.call(m,"accountId"))$root.proto.AccountID.encode(m.accountId,w.uint32(10).fork()).ldelim();if(m.alias!=null&&Object.hasOwnProperty.call(m,"alias"))w.uint32(18).bytes(m.alias);if(m.key!=null&&Object.hasOwnProperty.call(m,"key"))$root.proto.Key.encode(m.key,w.uint32(26).fork()).ldelim();if(m.expirationSecond!=null&&Object.hasOwnProperty.call(m,"expirationSecond"))w.uint32(32).int64(m.expirationSecond);if(m.tinybarBalance!=null&&Object.hasOwnProperty.call(m,"tinybarBalance"))w.uint32(40).int64(m.tinybarBalance);if(m.memo!=null&&Object.hasOwnProperty.call(m,"memo"))w.uint32(50).string(m.memo);if(m.deleted!=null&&Object.hasOwnProperty.call(m,"deleted"))w.uint32(56).bool(m.deleted);if(m.stakedToMe!=null&&Object.hasOwnProperty.call(m,"stakedToMe"))w.uint32(64).int64(m.stakedToMe);if(m.stakePeriodStart!=null&&Object.hasOwnProperty.call(m,"stakePeriodStart"))w.uint32(72).int64(m.stakePeriodStart);if(m.stakedAccountId!=null&&Object.hasOwnProperty.call(m,"stakedAccountId"))$root.proto.AccountID.encode(m.stakedAccountId,w.uint32(82).fork()).ldelim();if(m.stakedNodeId!=null&&Object.hasOwnProperty.call(m,"stakedNodeId"))w.uint32(88).int64(m.stakedNodeId);if(m.declineReward!=null&&Object.hasOwnProperty.call(m,"declineReward"))w.uint32(96).bool(m.declineReward);if(m.receiverSigRequired!=null&&Object.hasOwnProperty.call(m,"receiverSigRequired"))w.uint32(104).bool(m.receiverSigRequired);if(m.headTokenId!=null&&Object.hasOwnProperty.call(m,"headTokenId"))$root.proto.TokenID.encode(m.headTokenId,w.uint32(114).fork()).ldelim();if(m.headNftId!=null&&Object.hasOwnProperty.call(m,"headNftId"))$root.proto.NftID.encode(m.headNftId,w.uint32(122).fork()).ldelim();if(m.headNftSerialNumber!=null&&Object.hasOwnProperty.call(m,"headNftSerialNumber"))w.uint32(128).int64(m.headNftSerialNumber);if(m.numberOwnedNfts!=null&&Object.hasOwnProperty.call(m,"numberOwnedNfts"))w.uint32(136).int64(m.numberOwnedNfts);if(m.maxAutoAssociations!=null&&Object.hasOwnProperty.call(m,"maxAutoAssociations"))w.uint32(144).int32(m.maxAutoAssociations);if(m.usedAutoAssociations!=null&&Object.hasOwnProperty.call(m,"usedAutoAssociations"))w.uint32(152).int32(m.usedAutoAssociations);if(m.numberAssociations!=null&&Object.hasOwnProperty.call(m,"numberAssociations"))w.uint32(160).int32(m.numberAssociations);if(m.smartContract!=null&&Object.hasOwnProperty.call(m,"smartContract"))w.uint32(168).bool(m.smartContract);if(m.numberPositiveBalances!=null&&Object.hasOwnProperty.call(m,"numberPositiveBalances"))w.uint32(176).int32(m.numberPositiveBalances);if(m.ethereumNonce!=null&&Object.hasOwnProperty.call(m,"ethereumNonce"))w.uint32(184).int64(m.ethereumNonce);if(m.stakeAtStartOfLastRewardedPeriod!=null&&Object.hasOwnProperty.call(m,"stakeAtStartOfLastRewardedPeriod"))w.uint32(192).int64(m.stakeAtStartOfLastRewardedPeriod);if(m.autoRenewAccountId!=null&&Object.hasOwnProperty.call(m,"autoRenewAccountId"))$root.proto.AccountID.encode(m.autoRenewAccountId,w.uint32(202).fork()).ldelim();if(m.autoRenewSeconds!=null&&Object.hasOwnProperty.call(m,"autoRenewSeconds"))w.uint32(208).int64(m.autoRenewSeconds);if(m.contractKvPairsNumber!=null&&Object.hasOwnProperty.call(m,"contractKvPairsNumber"))w.uint32(216).int32(m.contractKvPairsNumber);if(m.cryptoAllowances!=null&&m.cryptoAllowances.length){for(var i=0;i<m.cryptoAllowances.length;++i)$root.proto.AccountCryptoAllowance.encode(m.cryptoAllowances[i],w.uint32(226).fork()).ldelim();}if(m.approveForAllNftAllowances!=null&&m.approveForAllNftAllowances.length){for(var i=0;i<m.approveForAllNftAllowances.length;++i)$root.proto.AccountApprovalForAllAllowance.encode(m.approveForAllNftAllowances[i],w.uint32(234).fork()).ldelim();}if(m.tokenAllowances!=null&&m.tokenAllowances.length){for(var i=0;i<m.tokenAllowances.length;++i)$root.proto.AccountFungibleTokenAllowance.encode(m.tokenAllowances[i],w.uint32(242).fork()).ldelim();}if(m.numberTreasuryTitles!=null&&Object.hasOwnProperty.call(m,"numberTreasuryTitles"))w.uint32(248).uint32(m.numberTreasuryTitles);if(m.expiredAndPendingRemoval!=null&&Object.hasOwnProperty.call(m,"expiredAndPendingRemoval"))w.uint32(256).bool(m.expiredAndPendingRemoval);if(m.firstContractStorageKey!=null&&Object.hasOwnProperty.call(m,"firstContractStorageKey"))w.uint32(266).bytes(m.firstContractStorageKey);if(m.headPendingAirdropId!=null&&Object.hasOwnProperty.call(m,"headPendingAirdropId"))$root.proto.PendingAirdropId.encode(m.headPendingAirdropId,w.uint32(274).fork()).ldelim();if(m.numberPendingAirdrops!=null&&Object.hasOwnProperty.call(m,"numberPendingAirdrops"))w.uint32(280).uint64(m.numberPendingAirdrops);return w;};Account.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.Account();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.accountId=$root.proto.AccountID.decode(r,r.uint32());break;}case 2:{m.alias=r.bytes();break;}case 3:{m.key=$root.proto.Key.decode(r,r.uint32());break;}case 4:{m.expirationSecond=r.int64();break;}case 5:{m.tinybarBalance=r.int64();break;}case 6:{m.memo=r.string();break;}case 7:{m.deleted=r.bool();break;}case 8:{m.stakedToMe=r.int64();break;}case 9:{m.stakePeriodStart=r.int64();break;}case 10:{m.stakedAccountId=$root.proto.AccountID.decode(r,r.uint32());break;}case 11:{m.stakedNodeId=r.int64();break;}case 12:{m.declineReward=r.bool();break;}case 13:{m.receiverSigRequired=r.bool();break;}case 14:{m.headTokenId=$root.proto.TokenID.decode(r,r.uint32());break;}case 15:{m.headNftId=$root.proto.NftID.decode(r,r.uint32());break;}case 16:{m.headNftSerialNumber=r.int64();break;}case 17:{m.numberOwnedNfts=r.int64();break;}case 18:{m.maxAutoAssociations=r.int32();break;}case 19:{m.usedAutoAssociations=r.int32();break;}case 20:{m.numberAssociations=r.int32();break;}case 21:{m.smartContract=r.bool();break;}case 22:{m.numberPositiveBalances=r.int32();break;}case 23:{m.ethereumNonce=r.int64();break;}case 24:{m.stakeAtStartOfLastRewardedPeriod=r.int64();break;}case 25:{m.autoRenewAccountId=$root.proto.AccountID.decode(r,r.uint32());break;}case 26:{m.autoRenewSeconds=r.int64();break;}case 27:{m.contractKvPairsNumber=r.int32();break;}case 28:{if(!(m.cryptoAllowances&&m.cryptoAllowances.length))m.cryptoAllowances=[];m.cryptoAllowances.push($root.proto.AccountCryptoAllowance.decode(r,r.uint32()));break;}case 29:{if(!(m.approveForAllNftAllowances&&m.approveForAllNftAllowances.length))m.approveForAllNftAllowances=[];m.approveForAllNftAllowances.push($root.proto.AccountApprovalForAllAllowance.decode(r,r.uint32()));break;}case 30:{if(!(m.tokenAllowances&&m.tokenAllowances.length))m.tokenAllowances=[];m.tokenAllowances.push($root.proto.AccountFungibleTokenAllowance.decode(r,r.uint32()));break;}case 31:{m.numberTreasuryTitles=r.uint32();break;}case 32:{m.expiredAndPendingRemoval=r.bool();break;}case 33:{m.firstContractStorageKey=r.bytes();break;}case 34:{m.headPendingAirdropId=$root.proto.PendingAirdropId.decode(r,r.uint32());break;}case 35:{m.numberPendingAirdrops=r.uint64();break;}default:r.skipType(t&7);break;}}return m;};Account.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.Account";};return Account;}();proto.AccountApprovalForAllAllowance=function(){function AccountApprovalForAllAllowance(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}AccountApprovalForAllAllowance.prototype.tokenId=null;AccountApprovalForAllAllowance.prototype.spenderId=null;AccountApprovalForAllAllowance.create=function create(properties){return new AccountApprovalForAllAllowance(properties);};AccountApprovalForAllAllowance.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.tokenId!=null&&Object.hasOwnProperty.call(m,"tokenId"))$root.proto.TokenID.encode(m.tokenId,w.uint32(10).fork()).ldelim();if(m.spenderId!=null&&Object.hasOwnProperty.call(m,"spenderId"))$root.proto.AccountID.encode(m.spenderId,w.uint32(18).fork()).ldelim();return w;};AccountApprovalForAllAllowance.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.AccountApprovalForAllAllowance();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.tokenId=$root.proto.TokenID.decode(r,r.uint32());break;}case 2:{m.spenderId=$root.proto.AccountID.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};AccountApprovalForAllAllowance.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.AccountApprovalForAllAllowance";};return AccountApprovalForAllAllowance;}();proto.AccountFungibleTokenAllowance=function(){function AccountFungibleTokenAllowance(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}AccountFungibleTokenAllowance.prototype.tokenId=null;AccountFungibleTokenAllowance.prototype.spenderId=null;AccountFungibleTokenAllowance.prototype.amount=$util.Long?$util.Long.fromBits(0,0,false):0;AccountFungibleTokenAllowance.create=function create(properties){return new AccountFungibleTokenAllowance(properties);};AccountFungibleTokenAllowance.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.tokenId!=null&&Object.hasOwnProperty.call(m,"tokenId"))$root.proto.TokenID.encode(m.tokenId,w.uint32(10).fork()).ldelim();if(m.spenderId!=null&&Object.hasOwnProperty.call(m,"spenderId"))$root.proto.AccountID.encode(m.spenderId,w.uint32(18).fork()).ldelim();if(m.amount!=null&&Object.hasOwnProperty.call(m,"amount"))w.uint32(24).int64(m.amount);return w;};AccountFungibleTokenAllowance.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.AccountFungibleTokenAllowance();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.tokenId=$root.proto.TokenID.decode(r,r.uint32());break;}case 2:{m.spenderId=$root.proto.AccountID.decode(r,r.uint32());break;}case 3:{m.amount=r.int64();break;}default:r.skipType(t&7);break;}}return m;};AccountFungibleTokenAllowance.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.AccountFungibleTokenAllowance";};return AccountFungibleTokenAllowance;}();proto.AccountCryptoAllowance=function(){function AccountCryptoAllowance(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}AccountCryptoAllowance.prototype.spenderId=null;AccountCryptoAllowance.prototype.amount=$util.Long?$util.Long.fromBits(0,0,false):0;AccountCryptoAllowance.create=function create(properties){return new AccountCryptoAllowance(properties);};AccountCryptoAllowance.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.spenderId!=null&&Object.hasOwnProperty.call(m,"spenderId"))$root.proto.AccountID.encode(m.spenderId,w.uint32(10).fork()).ldelim();if(m.amount!=null&&Object.hasOwnProperty.call(m,"amount"))w.uint32(16).int64(m.amount);return w;};AccountCryptoAllowance.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.AccountCryptoAllowance();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.spenderId=$root.proto.AccountID.decode(r,r.uint32());break;}case 2:{m.amount=r.int64();break;}default:r.skipType(t&7);break;}}return m;};AccountCryptoAllowance.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.AccountCryptoAllowance";};return AccountCryptoAllowance;}();proto.NetworkStakingRewards=function(){function NetworkStakingRewards(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}NetworkStakingRewards.prototype.stakingRewardsActivated=false;NetworkStakingRewards.prototype.totalStakedRewardStart=$util.Long?$util.Long.fromBits(0,0,false):0;NetworkStakingRewards.prototype.totalStakedStart=$util.Long?$util.Long.fromBits(0,0,false):0;NetworkStakingRewards.prototype.pendingRewards=$util.Long?$util.Long.fromBits(0,0,false):0;NetworkStakingRewards.prototype.lastNodeRewardPaymentsTime=null;NetworkStakingRewards.create=function create(properties){return new NetworkStakingRewards(properties);};NetworkStakingRewards.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.stakingRewardsActivated!=null&&Object.hasOwnProperty.call(m,"stakingRewardsActivated"))w.uint32(8).bool(m.stakingRewardsActivated);if(m.totalStakedRewardStart!=null&&Object.hasOwnProperty.call(m,"totalStakedRewardStart"))w.uint32(16).int64(m.totalStakedRewardStart);if(m.totalStakedStart!=null&&Object.hasOwnProperty.call(m,"totalStakedStart"))w.uint32(24).int64(m.totalStakedStart);if(m.pendingRewards!=null&&Object.hasOwnProperty.call(m,"pendingRewards"))w.uint32(32).int64(m.pendingRewards);if(m.lastNodeRewardPaymentsTime!=null&&Object.hasOwnProperty.call(m,"lastNodeRewardPaymentsTime"))$root.proto.Timestamp.encode(m.lastNodeRewardPaymentsTime,w.uint32(42).fork()).ldelim();return w;};NetworkStakingRewards.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.NetworkStakingRewards();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.stakingRewardsActivated=r.bool();break;}case 2:{m.totalStakedRewardStart=r.int64();break;}case 3:{m.totalStakedStart=r.int64();break;}case 4:{m.pendingRewards=r.int64();break;}case 5:{m.lastNodeRewardPaymentsTime=$root.proto.Timestamp.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};NetworkStakingRewards.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.NetworkStakingRewards";};return NetworkStakingRewards;}();proto.Nft=function(){function Nft(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}Nft.prototype.nftId=null;Nft.prototype.ownerId=null;Nft.prototype.spenderId=null;Nft.prototype.mintTime=null;Nft.prototype.metadata=$util.newBuffer([]);Nft.prototype.ownerPreviousNftId=null;Nft.prototype.ownerNextNftId=null;Nft.create=function create(properties){return new Nft(properties);};Nft.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.nftId!=null&&Object.hasOwnProperty.call(m,"nftId"))$root.proto.NftID.encode(m.nftId,w.uint32(10).fork()).ldelim();if(m.ownerId!=null&&Object.hasOwnProperty.call(m,"ownerId"))$root.proto.AccountID.encode(m.ownerId,w.uint32(18).fork()).ldelim();if(m.spenderId!=null&&Object.hasOwnProperty.call(m,"spenderId"))$root.proto.AccountID.encode(m.spenderId,w.uint32(26).fork()).ldelim();if(m.mintTime!=null&&Object.hasOwnProperty.call(m,"mintTime"))$root.proto.Timestamp.encode(m.mintTime,w.uint32(34).fork()).ldelim();if(m.metadata!=null&&Object.hasOwnProperty.call(m,"metadata"))w.uint32(42).bytes(m.metadata);if(m.ownerPreviousNftId!=null&&Object.hasOwnProperty.call(m,"ownerPreviousNftId"))$root.proto.NftID.encode(m.ownerPreviousNftId,w.uint32(50).fork()).ldelim();if(m.ownerNextNftId!=null&&Object.hasOwnProperty.call(m,"ownerNextNftId"))$root.proto.NftID.encode(m.ownerNextNftId,w.uint32(58).fork()).ldelim();return w;};Nft.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.Nft();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.nftId=$root.proto.NftID.decode(r,r.uint32());break;}case 2:{m.ownerId=$root.proto.AccountID.decode(r,r.uint32());break;}case 3:{m.spenderId=$root.proto.AccountID.decode(r,r.uint32());break;}case 4:{m.mintTime=$root.proto.Timestamp.decode(r,r.uint32());break;}case 5:{m.metadata=r.bytes();break;}case 6:{m.ownerPreviousNftId=$root.proto.NftID.decode(r,r.uint32());break;}case 7:{m.ownerNextNftId=$root.proto.NftID.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};Nft.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.Nft";};return Nft;}();proto.NodeRewards=function(){function NodeRewards(p){this.nodeActivities=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}NodeRewards.prototype.numRoundsInStakingPeriod=$util.Long?$util.Long.fromBits(0,0,true):0;NodeRewards.prototype.nodeFeesCollected=$util.Long?$util.Long.fromBits(0,0,true):0;NodeRewards.prototype.nodeActivities=$util.emptyArray;NodeRewards.create=function create(properties){return new NodeRewards(properties);};NodeRewards.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.numRoundsInStakingPeriod!=null&&Object.hasOwnProperty.call(m,"numRoundsInStakingPeriod"))w.uint32(8).uint64(m.numRoundsInStakingPeriod);if(m.nodeFeesCollected!=null&&Object.hasOwnProperty.call(m,"nodeFeesCollected"))w.uint32(16).uint64(m.nodeFeesCollected);if(m.nodeActivities!=null&&m.nodeActivities.length){for(var i=0;i<m.nodeActivities.length;++i)$root.proto.NodeActivity.encode(m.nodeActivities[i],w.uint32(26).fork()).ldelim();}return w;};NodeRewards.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.NodeRewards();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.numRoundsInStakingPeriod=r.uint64();break;}case 2:{m.nodeFeesCollected=r.uint64();break;}case 3:{if(!(m.nodeActivities&&m.nodeActivities.length))m.nodeActivities=[];m.nodeActivities.push($root.proto.NodeActivity.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};NodeRewards.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.NodeRewards";};return NodeRewards;}();proto.NodeActivity=function(){function NodeActivity(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}NodeActivity.prototype.nodeId=$util.Long?$util.Long.fromBits(0,0,true):0;NodeActivity.prototype.numMissedJudgeRounds=$util.Long?$util.Long.fromBits(0,0,true):0;NodeActivity.create=function create(properties){return new NodeActivity(properties);};NodeActivity.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.nodeId!=null&&Object.hasOwnProperty.call(m,"nodeId"))w.uint32(8).uint64(m.nodeId);if(m.numMissedJudgeRounds!=null&&Object.hasOwnProperty.call(m,"numMissedJudgeRounds"))w.uint32(16).uint64(m.numMissedJudgeRounds);return w;};NodeActivity.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.NodeActivity();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.nodeId=r.uint64();break;}case 2:{m.numMissedJudgeRounds=r.uint64();break;}default:r.skipType(t&7);break;}}return m;};NodeActivity.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.NodeActivity";};return NodeActivity;}();proto.StakingNodeInfo=function(){function StakingNodeInfo(p){this.rewardSumHistory=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}StakingNodeInfo.prototype.nodeNumber=$util.Long?$util.Long.fromBits(0,0,false):0;StakingNodeInfo.prototype.minStake=$util.Long?$util.Long.fromBits(0,0,false):0;StakingNodeInfo.prototype.maxStake=$util.Long?$util.Long.fromBits(0,0,false):0;StakingNodeInfo.prototype.stakeToReward=$util.Long?$util.Long.fromBits(0,0,false):0;StakingNodeInfo.prototype.stakeToNotReward=$util.Long?$util.Long.fromBits(0,0,false):0;StakingNodeInfo.prototype.stakeRewardStart=$util.Long?$util.Long.fromBits(0,0,false):0;StakingNodeInfo.prototype.unclaimedStakeRewardStart=$util.Long?$util.Long.fromBits(0,0,false):0;StakingNodeInfo.prototype.stake=$util.Long?$util.Long.fromBits(0,0,false):0;StakingNodeInfo.prototype.rewardSumHistory=$util.emptyArray;StakingNodeInfo.prototype.weight=0;StakingNodeInfo.prototype.pendingRewards=$util.Long?$util.Long.fromBits(0,0,false):0;StakingNodeInfo.prototype.deleted=false;StakingNodeInfo.create=function create(properties){return new StakingNodeInfo(properties);};StakingNodeInfo.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.nodeNumber!=null&&Object.hasOwnProperty.call(m,"nodeNumber"))w.uint32(8).int64(m.nodeNumber);if(m.minStake!=null&&Object.hasOwnProperty.call(m,"minStake"))w.uint32(16).int64(m.minStake);if(m.maxStake!=null&&Object.hasOwnProperty.call(m,"maxStake"))w.uint32(24).int64(m.maxStake);if(m.stakeToReward!=null&&Object.hasOwnProperty.call(m,"stakeToReward"))w.uint32(32).int64(m.stakeToReward);if(m.stakeToNotReward!=null&&Object.hasOwnProperty.call(m,"stakeToNotReward"))w.uint32(40).int64(m.stakeToNotReward);if(m.stakeRewardStart!=null&&Object.hasOwnProperty.call(m,"stakeRewardStart"))w.uint32(48).int64(m.stakeRewardStart);if(m.unclaimedStakeRewardStart!=null&&Object.hasOwnProperty.call(m,"unclaimedStakeRewardStart"))w.uint32(56).int64(m.unclaimedStakeRewardStart);if(m.stake!=null&&Object.hasOwnProperty.call(m,"stake"))w.uint32(64).int64(m.stake);if(m.rewardSumHistory!=null&&m.rewardSumHistory.length){w.uint32(74).fork();for(var i=0;i<m.rewardSumHistory.length;++i)w.int64(m.rewardSumHistory[i]);w.ldelim();}if(m.weight!=null&&Object.hasOwnProperty.call(m,"weight"))w.uint32(80).int32(m.weight);if(m.pendingRewards!=null&&Object.hasOwnProperty.call(m,"pendingRewards"))w.uint32(88).int64(m.pendingRewards);if(m.deleted!=null&&Object.hasOwnProperty.call(m,"deleted"))w.uint32(96).bool(m.deleted);return w;};StakingNodeInfo.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.StakingNodeInfo();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.nodeNumber=r.int64();break;}case 2:{m.minStake=r.int64();break;}case 3:{m.maxStake=r.int64();break;}case 4:{m.stakeToReward=r.int64();break;}case 5:{m.stakeToNotReward=r.int64();break;}case 6:{m.stakeRewardStart=r.int64();break;}case 7:{m.unclaimedStakeRewardStart=r.int64();break;}case 8:{m.stake=r.int64();break;}case 9:{if(!(m.rewardSumHistory&&m.rewardSumHistory.length))m.rewardSumHistory=[];if((t&7)===2){var c2=r.uint32()+r.pos;while(r.pos<c2)m.rewardSumHistory.push(r.int64());}else m.rewardSumHistory.push(r.int64());break;}case 10:{m.weight=r.int32();break;}case 11:{m.pendingRewards=r.int64();break;}case 12:{m.deleted=r.bool();break;}default:r.skipType(t&7);break;}}return m;};StakingNodeInfo.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.StakingNodeInfo";};return StakingNodeInfo;}();proto.TokenRelation=function(){function TokenRelation(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TokenRelation.prototype.tokenId=null;TokenRelation.prototype.accountId=null;TokenRelation.prototype.balance=$util.Long?$util.Long.fromBits(0,0,false):0;TokenRelation.prototype.frozen=false;TokenRelation.prototype.kycGranted=false;TokenRelation.prototype.automaticAssociation=false;TokenRelation.prototype.previousToken=null;TokenRelation.prototype.nextToken=null;TokenRelation.create=function create(properties){return new TokenRelation(properties);};TokenRelation.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.tokenId!=null&&Object.hasOwnProperty.call(m,"tokenId"))$root.proto.TokenID.encode(m.tokenId,w.uint32(10).fork()).ldelim();if(m.accountId!=null&&Object.hasOwnProperty.call(m,"accountId"))$root.proto.AccountID.encode(m.accountId,w.uint32(18).fork()).ldelim();if(m.balance!=null&&Object.hasOwnProperty.call(m,"balance"))w.uint32(24).int64(m.balance);if(m.frozen!=null&&Object.hasOwnProperty.call(m,"frozen"))w.uint32(32).bool(m.frozen);if(m.kycGranted!=null&&Object.hasOwnProperty.call(m,"kycGranted"))w.uint32(40).bool(m.kycGranted);if(m.automaticAssociation!=null&&Object.hasOwnProperty.call(m,"automaticAssociation"))w.uint32(48).bool(m.automaticAssociation);if(m.previousToken!=null&&Object.hasOwnProperty.call(m,"previousToken"))$root.proto.TokenID.encode(m.previousToken,w.uint32(58).fork()).ldelim();if(m.nextToken!=null&&Object.hasOwnProperty.call(m,"nextToken"))$root.proto.TokenID.encode(m.nextToken,w.uint32(66).fork()).ldelim();return w;};TokenRelation.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TokenRelation();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.tokenId=$root.proto.TokenID.decode(r,r.uint32());break;}case 2:{m.accountId=$root.proto.AccountID.decode(r,r.uint32());break;}case 3:{m.balance=r.int64();break;}case 4:{m.frozen=r.bool();break;}case 5:{m.kycGranted=r.bool();break;}case 6:{m.automaticAssociation=r.bool();break;}case 7:{m.previousToken=$root.proto.TokenID.decode(r,r.uint32());break;}case 8:{m.nextToken=$root.proto.TokenID.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};TokenRelation.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TokenRelation";};return TokenRelation;}();proto.Token=function(){function Token(p){this.customFees=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}Token.prototype.tokenId=null;Token.prototype.name="";Token.prototype.symbol="";Token.prototype.decimals=0;Token.prototype.totalSupply=$util.Long?$util.Long.fromBits(0,0,false):0;Token.prototype.treasuryAccountId=null;Token.prototype.adminKey=null;Token.prototype.kycKey=null;Token.prototype.freezeKey=null;Token.prototype.wipeKey=null;Token.prototype.supplyKey=null;Token.prototype.feeScheduleKey=null;Token.prototype.pauseKey=null;Token.prototype.lastUsedSerialNumber=$util.Long?$util.Long.fromBits(0,0,false):0;Token.prototype.deleted=false;Token.prototype.tokenType=0;Token.prototype.supplyType=0;Token.prototype.autoRenewAccountId=null;Token.prototype.autoRenewSeconds=$util.Long?$util.Long.fromBits(0,0,false):0;Token.prototype.expirationSecond=$util.Long?$util.Long.fromBits(0,0,false):0;Token.prototype.memo="";Token.prototype.maxSupply=$util.Long?$util.Long.fromBits(0,0,false):0;Token.prototype.paused=false;Token.prototype.accountsFrozenByDefault=false;Token.prototype.accountsKycGrantedByDefault=false;Token.prototype.customFees=$util.emptyArray;Token.prototype.metadata=$util.newBuffer([]);Token.prototype.metadataKey=null;Token.create=function create(properties){return new Token(properties);};Token.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.tokenId!=null&&Object.hasOwnProperty.call(m,"tokenId"))$root.proto.TokenID.encode(m.tokenId,w.uint32(10).fork()).ldelim();if(m.name!=null&&Object.hasOwnProperty.call(m,"name"))w.uint32(18).string(m.name);if(m.symbol!=null&&Object.hasOwnProperty.call(m,"symbol"))w.uint32(26).string(m.symbol);if(m.decimals!=null&&Object.hasOwnProperty.call(m,"decimals"))w.uint32(32).int32(m.decimals);if(m.totalSupply!=null&&Object.hasOwnProperty.call(m,"totalSupply"))w.uint32(40).int64(m.totalSupply);if(m.treasuryAccountId!=null&&Object.hasOwnProperty.call(m,"treasuryAccountId"))$root.proto.AccountID.encode(m.treasuryAccountId,w.uint32(50).fork()).ldelim();if(m.adminKey!=null&&Object.hasOwnProperty.call(m,"adminKey"))$root.proto.Key.encode(m.adminKey,w.uint32(58).fork()).ldelim();if(m.kycKey!=null&&Object.hasOwnProperty.call(m,"kycKey"))$root.proto.Key.encode(m.kycKey,w.uint32(66).fork()).ldelim();if(m.freezeKey!=null&&Object.hasOwnProperty.call(m,"freezeKey"))$root.proto.Key.encode(m.freezeKey,w.uint32(74).fork()).ldelim();if(m.wipeKey!=null&&Object.hasOwnProperty.call(m,"wipeKey"))$root.proto.Key.encode(m.wipeKey,w.uint32(82).fork()).ldelim();if(m.supplyKey!=null&&Object.hasOwnProperty.call(m,"supplyKey"))$root.proto.Key.encode(m.supplyKey,w.uint32(90).fork()).ldelim();if(m.feeScheduleKey!=null&&Object.hasOwnProperty.call(m,"feeScheduleKey"))$root.proto.Key.encode(m.feeScheduleKey,w.uint32(98).fork()).ldelim();if(m.pauseKey!=null&&Object.hasOwnProperty.call(m,"pauseKey"))$root.proto.Key.encode(m.pauseKey,w.uint32(106).fork()).ldelim();if(m.lastUsedSerialNumber!=null&&Object.hasOwnProperty.call(m,"lastUsedSerialNumber"))w.uint32(112).int64(m.lastUsedSerialNumber);if(m.deleted!=null&&Object.hasOwnProperty.call(m,"deleted"))w.uint32(120).bool(m.deleted);if(m.tokenType!=null&&Object.hasOwnProperty.call(m,"tokenType"))w.uint32(128).int32(m.tokenType);if(m.supplyType!=null&&Object.hasOwnProperty.call(m,"supplyType"))w.uint32(136).int32(m.supplyType);if(m.autoRenewAccountId!=null&&Object.hasOwnProperty.call(m,"autoRenewAccountId"))$root.proto.AccountID.encode(m.autoRenewAccountId,w.uint32(146).fork()).ldelim();if(m.autoRenewSeconds!=null&&Object.hasOwnProperty.call(m,"autoRenewSeconds"))w.uint32(152).int64(m.autoRenewSeconds);if(m.expirationSecond!=null&&Object.hasOwnProperty.call(m,"expirationSecond"))w.uint32(160).int64(m.expirationSecond);if(m.memo!=null&&Object.hasOwnProperty.call(m,"memo"))w.uint32(170).string(m.memo);if(m.maxSupply!=null&&Object.hasOwnProperty.call(m,"maxSupply"))w.uint32(176).int64(m.maxSupply);if(m.paused!=null&&Object.hasOwnProperty.call(m,"paused"))w.uint32(184).bool(m.paused);if(m.accountsFrozenByDefault!=null&&Object.hasOwnProperty.call(m,"accountsFrozenByDefault"))w.uint32(192).bool(m.accountsFrozenByDefault);if(m.accountsKycGrantedByDefault!=null&&Object.hasOwnProperty.call(m,"accountsKycGrantedByDefault"))w.uint32(200).bool(m.accountsKycGrantedByDefault);if(m.customFees!=null&&m.customFees.length){for(var i=0;i<m.customFees.length;++i)$root.proto.CustomFee.encode(m.customFees[i],w.uint32(210).fork()).ldelim();}if(m.metadata!=null&&Object.hasOwnProperty.call(m,"metadata"))w.uint32(218).bytes(m.metadata);if(m.metadataKey!=null&&Object.hasOwnProperty.call(m,"metadataKey"))$root.proto.Key.encode(m.metadataKey,w.uint32(226).fork()).ldelim();return w;};Token.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.Token();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.tokenId=$root.proto.TokenID.decode(r,r.uint32());break;}case 2:{m.name=r.string();break;}case 3:{m.symbol=r.string();break;}case 4:{m.decimals=r.int32();break;}case 5:{m.totalSupply=r.int64();break;}case 6:{m.treasuryAccountId=$root.proto.AccountID.decode(r,r.uint32());break;}case 7:{m.adminKey=$root.proto.Key.decode(r,r.uint32());break;}case 8:{m.kycKey=$root.proto.Key.decode(r,r.uint32());break;}case 9:{m.freezeKey=$root.proto.Key.decode(r,r.uint32());break;}case 10:{m.wipeKey=$root.proto.Key.decode(r,r.uint32());break;}case 11:{m.supplyKey=$root.proto.Key.decode(r,r.uint32());break;}case 12:{m.feeScheduleKey=$root.proto.Key.decode(r,r.uint32());break;}case 13:{m.pauseKey=$root.proto.Key.decode(r,r.uint32());break;}case 14:{m.lastUsedSerialNumber=r.int64();break;}case 15:{m.deleted=r.bool();break;}case 16:{m.tokenType=r.int32();break;}case 17:{m.supplyType=r.int32();break;}case 18:{m.autoRenewAccountId=$root.proto.AccountID.decode(r,r.uint32());break;}case 19:{m.autoRenewSeconds=r.int64();break;}case 20:{m.expirationSecond=r.int64();break;}case 21:{m.memo=r.string();break;}case 22:{m.maxSupply=r.int64();break;}case 23:{m.paused=r.bool();break;}case 24:{m.accountsFrozenByDefault=r.bool();break;}case 25:{m.accountsKycGrantedByDefault=r.bool();break;}case 26:{if(!(m.customFees&&m.customFees.length))m.customFees=[];m.customFees.push($root.proto.CustomFee.decode(r,r.uint32()));break;}case 27:{m.metadata=r.bytes();break;}case 28:{m.metadataKey=$root.proto.Key.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};Token.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.Token";};return Token;}();proto.ThrottleGroup=function(){function ThrottleGroup(p){this.operations=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ThrottleGroup.prototype.operations=$util.emptyArray;ThrottleGroup.prototype.milliOpsPerSec=$util.Long?$util.Long.fromBits(0,0,true):0;ThrottleGroup.create=function create(properties){return new ThrottleGroup(properties);};ThrottleGroup.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.operations!=null&&m.operations.length){w.uint32(10).fork();for(var i=0;i<m.operations.length;++i)w.int32(m.operations[i]);w.ldelim();}if(m.milliOpsPerSec!=null&&Object.hasOwnProperty.call(m,"milliOpsPerSec"))w.uint32(16).uint64(m.milliOpsPerSec);return w;};ThrottleGroup.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ThrottleGroup();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{if(!(m.operations&&m.operations.length))m.operations=[];if((t&7)===2){var c2=r.uint32()+r.pos;while(r.pos<c2)m.operations.push(r.int32());}else m.operations.push(r.int32());break;}case 2:{m.milliOpsPerSec=r.uint64();break;}default:r.skipType(t&7);break;}}return m;};ThrottleGroup.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ThrottleGroup";};return ThrottleGroup;}();proto.ThrottleBucket=function(){function ThrottleBucket(p){this.throttleGroups=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ThrottleBucket.prototype.name="";ThrottleBucket.prototype.burstPeriodMs=$util.Long?$util.Long.fromBits(0,0,true):0;ThrottleBucket.prototype.throttleGroups=$util.emptyArray;ThrottleBucket.create=function create(properties){return new ThrottleBucket(properties);};ThrottleBucket.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.name!=null&&Object.hasOwnProperty.call(m,"name"))w.uint32(10).string(m.name);if(m.burstPeriodMs!=null&&Object.hasOwnProperty.call(m,"burstPeriodMs"))w.uint32(16).uint64(m.burstPeriodMs);if(m.throttleGroups!=null&&m.throttleGroups.length){for(var i=0;i<m.throttleGroups.length;++i)$root.proto.ThrottleGroup.encode(m.throttleGroups[i],w.uint32(26).fork()).ldelim();}return w;};ThrottleBucket.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ThrottleBucket();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.name=r.string();break;}case 2:{m.burstPeriodMs=r.uint64();break;}case 3:{if(!(m.throttleGroups&&m.throttleGroups.length))m.throttleGroups=[];m.throttleGroups.push($root.proto.ThrottleGroup.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};ThrottleBucket.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ThrottleBucket";};return ThrottleBucket;}();proto.ThrottleDefinitions=function(){function ThrottleDefinitions(p){this.throttleBuckets=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ThrottleDefinitions.prototype.throttleBuckets=$util.emptyArray;ThrottleDefinitions.create=function create(properties){return new ThrottleDefinitions(properties);};ThrottleDefinitions.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.throttleBuckets!=null&&m.throttleBuckets.length){for(var i=0;i<m.throttleBuckets.length;++i)$root.proto.ThrottleBucket.encode(m.throttleBuckets[i],w.uint32(10).fork()).ldelim();}return w;};ThrottleDefinitions.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ThrottleDefinitions();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{if(!(m.throttleBuckets&&m.throttleBuckets.length))m.throttleBuckets=[];m.throttleBuckets.push($root.proto.ThrottleBucket.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};ThrottleDefinitions.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ThrottleDefinitions";};return ThrottleDefinitions;}();proto.TokenService=function(){function TokenService(rpcImpl,requestDelimited,responseDelimited){$protobuf.rpc.Service.call(this,rpcImpl,requestDelimited,responseDelimited);}(TokenService.prototype=Object.create($protobuf.rpc.Service.prototype)).constructor=TokenService;TokenService.create=function create(rpcImpl,requestDelimited,responseDelimited){return new this(rpcImpl,requestDelimited,responseDelimited);};Object.defineProperty(TokenService.prototype.createToken=function createToken(request,callback){return this.rpcCall(createToken,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"createToken"});Object.defineProperty(TokenService.prototype.updateToken=function updateToken(request,callback){return this.rpcCall(updateToken,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"updateToken"});Object.defineProperty(TokenService.prototype.mintToken=function mintToken(request,callback){return this.rpcCall(mintToken,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"mintToken"});Object.defineProperty(TokenService.prototype.burnToken=function burnToken(request,callback){return this.rpcCall(burnToken,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"burnToken"});Object.defineProperty(TokenService.prototype.deleteToken=function deleteToken(request,callback){return this.rpcCall(deleteToken,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"deleteToken"});Object.defineProperty(TokenService.prototype.wipeTokenAccount=function wipeTokenAccount(request,callback){return this.rpcCall(wipeTokenAccount,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"wipeTokenAccount"});Object.defineProperty(TokenService.prototype.freezeTokenAccount=function freezeTokenAccount(request,callback){return this.rpcCall(freezeTokenAccount,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"freezeTokenAccount"});Object.defineProperty(TokenService.prototype.unfreezeTokenAccount=function unfreezeTokenAccount(request,callback){return this.rpcCall(unfreezeTokenAccount,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"unfreezeTokenAccount"});Object.defineProperty(TokenService.prototype.grantKycToTokenAccount=function grantKycToTokenAccount(request,callback){return this.rpcCall(grantKycToTokenAccount,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"grantKycToTokenAccount"});Object.defineProperty(TokenService.prototype.revokeKycFromTokenAccount=function revokeKycFromTokenAccount(request,callback){return this.rpcCall(revokeKycFromTokenAccount,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"revokeKycFromTokenAccount"});Object.defineProperty(TokenService.prototype.associateTokens=function associateTokens(request,callback){return this.rpcCall(associateTokens,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"associateTokens"});Object.defineProperty(TokenService.prototype.dissociateTokens=function dissociateTokens(request,callback){return this.rpcCall(dissociateTokens,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"dissociateTokens"});Object.defineProperty(TokenService.prototype.updateTokenFeeSchedule=function updateTokenFeeSchedule(request,callback){return this.rpcCall(updateTokenFeeSchedule,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"updateTokenFeeSchedule"});Object.defineProperty(TokenService.prototype.getTokenInfo=function getTokenInfo(request,callback){return this.rpcCall(getTokenInfo,$root.proto.Query,$root.proto.Response,request,callback);},"name",{value:"getTokenInfo"});Object.defineProperty(TokenService.prototype.getTokenNftInfo=function getTokenNftInfo(request,callback){return this.rpcCall(getTokenNftInfo,$root.proto.Query,$root.proto.Response,request,callback);},"name",{value:"getTokenNftInfo"});Object.defineProperty(TokenService.prototype.pauseToken=function pauseToken(request,callback){return this.rpcCall(pauseToken,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"pauseToken"});Object.defineProperty(TokenService.prototype.unpauseToken=function unpauseToken(request,callback){return this.rpcCall(unpauseToken,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"unpauseToken"});Object.defineProperty(TokenService.prototype.updateNfts=function updateNfts(request,callback){return this.rpcCall(updateNfts,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"updateNfts"});Object.defineProperty(TokenService.prototype.rejectToken=function rejectToken(request,callback){return this.rpcCall(rejectToken,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"rejectToken"});Object.defineProperty(TokenService.prototype.airdropTokens=function airdropTokens(request,callback){return this.rpcCall(airdropTokens,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"airdropTokens"});Object.defineProperty(TokenService.prototype.cancelAirdrop=function cancelAirdrop(request,callback){return this.rpcCall(cancelAirdrop,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"cancelAirdrop"});Object.defineProperty(TokenService.prototype.claimAirdrop=function claimAirdrop(request,callback){return this.rpcCall(claimAirdrop,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"claimAirdrop"});return TokenService;}();proto.SignedTransaction=function(){function SignedTransaction(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}SignedTransaction.prototype.bodyBytes=$util.newBuffer([]);SignedTransaction.prototype.sigMap=null;SignedTransaction.create=function create(properties){return new SignedTransaction(properties);};SignedTransaction.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.bodyBytes!=null&&Object.hasOwnProperty.call(m,"bodyBytes"))w.uint32(10).bytes(m.bodyBytes);if(m.sigMap!=null&&Object.hasOwnProperty.call(m,"sigMap"))$root.proto.SignatureMap.encode(m.sigMap,w.uint32(18).fork()).ldelim();return w;};SignedTransaction.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.SignedTransaction();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.bodyBytes=r.bytes();break;}case 2:{m.sigMap=$root.proto.SignatureMap.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};SignedTransaction.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.SignedTransaction";};return SignedTransaction;}();proto.Transaction=function(){function Transaction(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}Transaction.prototype.body=null;Transaction.prototype.sigs=null;Transaction.prototype.sigMap=null;Transaction.prototype.bodyBytes=$util.newBuffer([]);Transaction.prototype.signedTransactionBytes=$util.newBuffer([]);Transaction.create=function create(properties){return new Transaction(properties);};Transaction.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.body!=null&&Object.hasOwnProperty.call(m,"body"))$root.proto.TransactionBody.encode(m.body,w.uint32(10).fork()).ldelim();if(m.sigs!=null&&Object.hasOwnProperty.call(m,"sigs"))$root.proto.SignatureList.encode(m.sigs,w.uint32(18).fork()).ldelim();if(m.sigMap!=null&&Object.hasOwnProperty.call(m,"sigMap"))$root.proto.SignatureMap.encode(m.sigMap,w.uint32(26).fork()).ldelim();if(m.bodyBytes!=null&&Object.hasOwnProperty.call(m,"bodyBytes"))w.uint32(34).bytes(m.bodyBytes);if(m.signedTransactionBytes!=null&&Object.hasOwnProperty.call(m,"signedTransactionBytes"))w.uint32(42).bytes(m.signedTransactionBytes);return w;};Transaction.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.Transaction();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.body=$root.proto.TransactionBody.decode(r,r.uint32());break;}case 2:{m.sigs=$root.proto.SignatureList.decode(r,r.uint32());break;}case 3:{m.sigMap=$root.proto.SignatureMap.decode(r,r.uint32());break;}case 4:{m.bodyBytes=r.bytes();break;}case 5:{m.signedTransactionBytes=r.bytes();break;}default:r.skipType(t&7);break;}}return m;};Transaction.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.Transaction";};return Transaction;}();proto.TransactionBody=function(){function TransactionBody(p){this.maxCustomFees=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TransactionBody.prototype.transactionID=null;TransactionBody.prototype.nodeAccountID=null;TransactionBody.prototype.transactionFee=$util.Long?$util.Long.fromBits(0,0,true):0;TransactionBody.prototype.transactionValidDuration=null;TransactionBody.prototype.generateRecord=false;TransactionBody.prototype.memo="";TransactionBody.prototype.batchKey=null;TransactionBody.prototype.contractCall=null;TransactionBody.prototype.contractCreateInstance=null;TransactionBody.prototype.contractUpdateInstance=null;TransactionBody.prototype.cryptoAddLiveHash=null;TransactionBody.prototype.cryptoCreateAccount=null;TransactionBody.prototype.cryptoDelete=null;TransactionBody.prototype.cryptoDeleteLiveHash=null;TransactionBody.prototype.cryptoTransfer=null;TransactionBody.prototype.cryptoUpdateAccount=null;TransactionBody.prototype.fileAppend=null;TransactionBody.prototype.fileCreate=null;TransactionBody.prototype.fileDelete=null;TransactionBody.prototype.fileUpdate=null;TransactionBody.prototype.systemDelete=null;TransactionBody.prototype.systemUndelete=null;TransactionBody.prototype.contractDeleteInstance=null;TransactionBody.prototype.freeze=null;TransactionBody.prototype.consensusCreateTopic=null;TransactionBody.prototype.consensusUpdateTopic=null;TransactionBody.prototype.consensusDeleteTopic=null;TransactionBody.prototype.consensusSubmitMessage=null;TransactionBody.prototype.uncheckedSubmit=null;TransactionBody.prototype.tokenCreation=null;TransactionBody.prototype.tokenFreeze=null;TransactionBody.prototype.tokenUnfreeze=null;TransactionBody.prototype.tokenGrantKyc=null;TransactionBody.prototype.tokenRevokeKyc=null;TransactionBody.prototype.tokenDeletion=null;TransactionBody.prototype.tokenUpdate=null;TransactionBody.prototype.tokenMint=null;TransactionBody.prototype.tokenBurn=null;TransactionBody.prototype.tokenWipe=null;TransactionBody.prototype.tokenAssociate=null;TransactionBody.prototype.tokenDissociate=null;TransactionBody.prototype.scheduleCreate=null;TransactionBody.prototype.scheduleDelete=null;TransactionBody.prototype.scheduleSign=null;TransactionBody.prototype.tokenFeeScheduleUpdate=null;TransactionBody.prototype.tokenPause=null;TransactionBody.prototype.tokenUnpause=null;TransactionBody.prototype.cryptoApproveAllowance=null;TransactionBody.prototype.cryptoDeleteAllowance=null;TransactionBody.prototype.ethereumTransaction=null;TransactionBody.prototype.nodeStakeUpdate=null;TransactionBody.prototype.utilPrng=null;TransactionBody.prototype.tokenUpdateNfts=null;TransactionBody.prototype.nodeCreate=null;TransactionBody.prototype.nodeUpdate=null;TransactionBody.prototype.nodeDelete=null;TransactionBody.prototype.tokenReject=null;TransactionBody.prototype.tokenAirdrop=null;TransactionBody.prototype.tokenCancelAirdrop=null;TransactionBody.prototype.tokenClaimAirdrop=null;TransactionBody.prototype.stateSignatureTransaction=null;TransactionBody.prototype.hintsPreprocessingVote=null;TransactionBody.prototype.hintsKeyPublication=null;TransactionBody.prototype.hintsPartialSignature=null;TransactionBody.prototype.historyProofSignature=null;TransactionBody.prototype.historyProofKeyPublication=null;TransactionBody.prototype.historyProofVote=null;TransactionBody.prototype.crsPublication=null;TransactionBody.prototype.atomicBatch=null;TransactionBody.prototype.maxCustomFees=$util.emptyArray;let $oneOfFields;Object.defineProperty(TransactionBody.prototype,"data",{get:$util.oneOfGetter($oneOfFields=["contractCall","contractCreateInstance","contractUpdateInstance","cryptoAddLiveHash","cryptoCreateAccount","cryptoDelete","cryptoDeleteLiveHash","cryptoTransfer","cryptoUpdateAccount","fileAppend","fileCreate","fileDelete","fileUpdate","systemDelete","systemUndelete","contractDeleteInstance","freeze","consensusCreateTopic","consensusUpdateTopic","consensusDeleteTopic","consensusSubmitMessage","uncheckedSubmit","tokenCreation","tokenFreeze","tokenUnfreeze","tokenGrantKyc","tokenRevokeKyc","tokenDeletion","tokenUpdate","tokenMint","tokenBurn","tokenWipe","tokenAssociate","tokenDissociate","scheduleCreate","scheduleDelete","scheduleSign","tokenFeeScheduleUpdate","tokenPause","tokenUnpause","cryptoApproveAllowance","cryptoDeleteAllowance","ethereumTransaction","nodeStakeUpdate","utilPrng","tokenUpdateNfts","nodeCreate","nodeUpdate","nodeDelete","tokenReject","tokenAirdrop","tokenCancelAirdrop","tokenClaimAirdrop","stateSignatureTransaction","hintsPreprocessingVote","hintsKeyPublication","hintsPartialSignature","historyProofSignature","historyProofKeyPublication","historyProofVote","crsPublication","atomicBatch"]),set:$util.oneOfSetter($oneOfFields)});TransactionBody.create=function create(properties){return new TransactionBody(properties);};TransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.transactionID!=null&&Object.hasOwnProperty.call(m,"transactionID"))$root.proto.TransactionID.encode(m.transactionID,w.uint32(10).fork()).ldelim();if(m.nodeAccountID!=null&&Object.hasOwnProperty.call(m,"nodeAccountID"))$root.proto.AccountID.encode(m.nodeAccountID,w.uint32(18).fork()).ldelim();if(m.transactionFee!=null&&Object.hasOwnProperty.call(m,"transactionFee"))w.uint32(24).uint64(m.transactionFee);if(m.transactionValidDuration!=null&&Object.hasOwnProperty.call(m,"transactionValidDuration"))$root.proto.Duration.encode(m.transactionValidDuration,w.uint32(34).fork()).ldelim();if(m.generateRecord!=null&&Object.hasOwnProperty.call(m,"generateRecord"))w.uint32(40).bool(m.generateRecord);if(m.memo!=null&&Object.hasOwnProperty.call(m,"memo"))w.uint32(50).string(m.memo);if(m.contractCall!=null&&Object.hasOwnProperty.call(m,"contractCall"))$root.proto.ContractCallTransactionBody.encode(m.contractCall,w.uint32(58).fork()).ldelim();if(m.contractCreateInstance!=null&&Object.hasOwnProperty.call(m,"contractCreateInstance"))$root.proto.ContractCreateTransactionBody.encode(m.contractCreateInstance,w.uint32(66).fork()).ldelim();if(m.contractUpdateInstance!=null&&Object.hasOwnProperty.call(m,"contractUpdateInstance"))$root.proto.ContractUpdateTransactionBody.encode(m.contractUpdateInstance,w.uint32(74).fork()).ldelim();if(m.cryptoAddLiveHash!=null&&Object.hasOwnProperty.call(m,"cryptoAddLiveHash"))$root.proto.CryptoAddLiveHashTransactionBody.encode(m.cryptoAddLiveHash,w.uint32(82).fork()).ldelim();if(m.cryptoCreateAccount!=null&&Object.hasOwnProperty.call(m,"cryptoCreateAccount"))$root.proto.CryptoCreateTransactionBody.encode(m.cryptoCreateAccount,w.uint32(90).fork()).ldelim();if(m.cryptoDelete!=null&&Object.hasOwnProperty.call(m,"cryptoDelete"))$root.proto.CryptoDeleteTransactionBody.encode(m.cryptoDelete,w.uint32(98).fork()).ldelim();if(m.cryptoDeleteLiveHash!=null&&Object.hasOwnProperty.call(m,"cryptoDeleteLiveHash"))$root.proto.CryptoDeleteLiveHashTransactionBody.encode(m.cryptoDeleteLiveHash,w.uint32(106).fork()).ldelim();if(m.cryptoTransfer!=null&&Object.hasOwnProperty.call(m,"cryptoTransfer"))$root.proto.CryptoTransferTransactionBody.encode(m.cryptoTransfer,w.uint32(114).fork()).ldelim();if(m.cryptoUpdateAccount!=null&&Object.hasOwnProperty.call(m,"cryptoUpdateAccount"))$root.proto.CryptoUpdateTransactionBody.encode(m.cryptoUpdateAccount,w.uint32(122).fork()).ldelim();if(m.fileAppend!=null&&Object.hasOwnProperty.call(m,"fileAppend"))$root.proto.FileAppendTransactionBody.encode(m.fileAppend,w.uint32(130).fork()).ldelim();if(m.fileCreate!=null&&Object.hasOwnProperty.call(m,"fileCreate"))$root.proto.FileCreateTransactionBody.encode(m.fileCreate,w.uint32(138).fork()).ldelim();if(m.fileDelete!=null&&Object.hasOwnProperty.call(m,"fileDelete"))$root.proto.FileDeleteTransactionBody.encode(m.fileDelete,w.uint32(146).fork()).ldelim();if(m.fileUpdate!=null&&Object.hasOwnProperty.call(m,"fileUpdate"))$root.proto.FileUpdateTransactionBody.encode(m.fileUpdate,w.uint32(154).fork()).ldelim();if(m.systemDelete!=null&&Object.hasOwnProperty.call(m,"systemDelete"))$root.proto.SystemDeleteTransactionBody.encode(m.systemDelete,w.uint32(162).fork()).ldelim();if(m.systemUndelete!=null&&Object.hasOwnProperty.call(m,"systemUndelete"))$root.proto.SystemUndeleteTransactionBody.encode(m.systemUndelete,w.uint32(170).fork()).ldelim();if(m.contractDeleteInstance!=null&&Object.hasOwnProperty.call(m,"contractDeleteInstance"))$root.proto.ContractDeleteTransactionBody.encode(m.contractDeleteInstance,w.uint32(178).fork()).ldelim();if(m.freeze!=null&&Object.hasOwnProperty.call(m,"freeze"))$root.proto.FreezeTransactionBody.encode(m.freeze,w.uint32(186).fork()).ldelim();if(m.consensusCreateTopic!=null&&Object.hasOwnProperty.call(m,"consensusCreateTopic"))$root.proto.ConsensusCreateTopicTransactionBody.encode(m.consensusCreateTopic,w.uint32(194).fork()).ldelim();if(m.consensusUpdateTopic!=null&&Object.hasOwnProperty.call(m,"consensusUpdateTopic"))$root.proto.ConsensusUpdateTopicTransactionBody.encode(m.consensusUpdateTopic,w.uint32(202).fork()).ldelim();if(m.consensusDeleteTopic!=null&&Object.hasOwnProperty.call(m,"consensusDeleteTopic"))$root.proto.ConsensusDeleteTopicTransactionBody.encode(m.consensusDeleteTopic,w.uint32(210).fork()).ldelim();if(m.consensusSubmitMessage!=null&&Object.hasOwnProperty.call(m,"consensusSubmitMessage"))$root.proto.ConsensusSubmitMessageTransactionBody.encode(m.consensusSubmitMessage,w.uint32(218).fork()).ldelim();if(m.uncheckedSubmit!=null&&Object.hasOwnProperty.call(m,"uncheckedSubmit"))$root.proto.UncheckedSubmitBody.encode(m.uncheckedSubmit,w.uint32(226).fork()).ldelim();if(m.tokenCreation!=null&&Object.hasOwnProperty.call(m,"tokenCreation"))$root.proto.TokenCreateTransactionBody.encode(m.tokenCreation,w.uint32(234).fork()).ldelim();if(m.tokenFreeze!=null&&Object.hasOwnProperty.call(m,"tokenFreeze"))$root.proto.TokenFreezeAccountTransactionBody.encode(m.tokenFreeze,w.uint32(250).fork()).ldelim();if(m.tokenUnfreeze!=null&&Object.hasOwnProperty.call(m,"tokenUnfreeze"))$root.proto.TokenUnfreezeAccountTransactionBody.encode(m.tokenUnfreeze,w.uint32(258).fork()).ldelim();if(m.tokenGrantKyc!=null&&Object.hasOwnProperty.call(m,"tokenGrantKyc"))$root.proto.TokenGrantKycTransactionBody.encode(m.tokenGrantKyc,w.uint32(266).fork()).ldelim();if(m.tokenRevokeKyc!=null&&Object.hasOwnProperty.call(m,"tokenRevokeKyc"))$root.proto.TokenRevokeKycTransactionBody.encode(m.tokenRevokeKyc,w.uint32(274).fork()).ldelim();if(m.tokenDeletion!=null&&Object.hasOwnProperty.call(m,"tokenDeletion"))$root.proto.TokenDeleteTransactionBody.encode(m.tokenDeletion,w.uint32(282).fork()).ldelim();if(m.tokenUpdate!=null&&Object.hasOwnProperty.call(m,"tokenUpdate"))$root.proto.TokenUpdateTransactionBody.encode(m.tokenUpdate,w.uint32(290).fork()).ldelim();if(m.tokenMint!=null&&Object.hasOwnProperty.call(m,"tokenMint"))$root.proto.TokenMintTransactionBody.encode(m.tokenMint,w.uint32(298).fork()).ldelim();if(m.tokenBurn!=null&&Object.hasOwnProperty.call(m,"tokenBurn"))$root.proto.TokenBurnTransactionBody.encode(m.tokenBurn,w.uint32(306).fork()).ldelim();if(m.tokenWipe!=null&&Object.hasOwnProperty.call(m,"tokenWipe"))$root.proto.TokenWipeAccountTransactionBody.encode(m.tokenWipe,w.uint32(314).fork()).ldelim();if(m.tokenAssociate!=null&&Object.hasOwnProperty.call(m,"tokenAssociate"))$root.proto.TokenAssociateTransactionBody.encode(m.tokenAssociate,w.uint32(322).fork()).ldelim();if(m.tokenDissociate!=null&&Object.hasOwnProperty.call(m,"tokenDissociate"))$root.proto.TokenDissociateTransactionBody.encode(m.tokenDissociate,w.uint32(330).fork()).ldelim();if(m.scheduleCreate!=null&&Object.hasOwnProperty.call(m,"scheduleCreate"))$root.proto.ScheduleCreateTransactionBody.encode(m.scheduleCreate,w.uint32(338).fork()).ldelim();if(m.scheduleDelete!=null&&Object.hasOwnProperty.call(m,"scheduleDelete"))$root.proto.ScheduleDeleteTransactionBody.encode(m.scheduleDelete,w.uint32(346).fork()).ldelim();if(m.scheduleSign!=null&&Object.hasOwnProperty.call(m,"scheduleSign"))$root.proto.ScheduleSignTransactionBody.encode(m.scheduleSign,w.uint32(354).fork()).ldelim();if(m.tokenFeeScheduleUpdate!=null&&Object.hasOwnProperty.call(m,"tokenFeeScheduleUpdate"))$root.proto.TokenFeeScheduleUpdateTransactionBody.encode(m.tokenFeeScheduleUpdate,w.uint32(362).fork()).ldelim();if(m.tokenPause!=null&&Object.hasOwnProperty.call(m,"tokenPause"))$root.proto.TokenPauseTransactionBody.encode(m.tokenPause,w.uint32(370).fork()).ldelim();if(m.tokenUnpause!=null&&Object.hasOwnProperty.call(m,"tokenUnpause"))$root.proto.TokenUnpauseTransactionBody.encode(m.tokenUnpause,w.uint32(378).fork()).ldelim();if(m.cryptoApproveAllowance!=null&&Object.hasOwnProperty.call(m,"cryptoApproveAllowance"))$root.proto.CryptoApproveAllowanceTransactionBody.encode(m.cryptoApproveAllowance,w.uint32(386).fork()).ldelim();if(m.cryptoDeleteAllowance!=null&&Object.hasOwnProperty.call(m,"cryptoDeleteAllowance"))$root.proto.CryptoDeleteAllowanceTransactionBody.encode(m.cryptoDeleteAllowance,w.uint32(394).fork()).ldelim();if(m.ethereumTransaction!=null&&Object.hasOwnProperty.call(m,"ethereumTransaction"))$root.proto.EthereumTransactionBody.encode(m.ethereumTransaction,w.uint32(402).fork()).ldelim();if(m.nodeStakeUpdate!=null&&Object.hasOwnProperty.call(m,"nodeStakeUpdate"))$root.proto.NodeStakeUpdateTransactionBody.encode(m.nodeStakeUpdate,w.uint32(410).fork()).ldelim();if(m.utilPrng!=null&&Object.hasOwnProperty.call(m,"utilPrng"))$root.proto.UtilPrngTransactionBody.encode(m.utilPrng,w.uint32(418).fork()).ldelim();if(m.tokenUpdateNfts!=null&&Object.hasOwnProperty.call(m,"tokenUpdateNfts"))$root.proto.TokenUpdateNftsTransactionBody.encode(m.tokenUpdateNfts,w.uint32(426).fork()).ldelim();if(m.nodeCreate!=null&&Object.hasOwnProperty.call(m,"nodeCreate"))$root.com.hedera.hapi.node.addressbook.NodeCreateTransactionBody.encode(m.nodeCreate,w.uint32(434).fork()).ldelim();if(m.nodeUpdate!=null&&Object.hasOwnProperty.call(m,"nodeUpdate"))$root.com.hedera.hapi.node.addressbook.NodeUpdateTransactionBody.encode(m.nodeUpdate,w.uint32(442).fork()).ldelim();if(m.nodeDelete!=null&&Object.hasOwnProperty.call(m,"nodeDelete"))$root.com.hedera.hapi.node.addressbook.NodeDeleteTransactionBody.encode(m.nodeDelete,w.uint32(450).fork()).ldelim();if(m.tokenReject!=null&&Object.hasOwnProperty.call(m,"tokenReject"))$root.proto.TokenRejectTransactionBody.encode(m.tokenReject,w.uint32(458).fork()).ldelim();if(m.tokenAirdrop!=null&&Object.hasOwnProperty.call(m,"tokenAirdrop"))$root.proto.TokenAirdropTransactionBody.encode(m.tokenAirdrop,w.uint32(466).fork()).ldelim();if(m.tokenCancelAirdrop!=null&&Object.hasOwnProperty.call(m,"tokenCancelAirdrop"))$root.proto.TokenCancelAirdropTransactionBody.encode(m.tokenCancelAirdrop,w.uint32(474).fork()).ldelim();if(m.tokenClaimAirdrop!=null&&Object.hasOwnProperty.call(m,"tokenClaimAirdrop"))$root.proto.TokenClaimAirdropTransactionBody.encode(m.tokenClaimAirdrop,w.uint32(482).fork()).ldelim();if(m.stateSignatureTransaction!=null&&Object.hasOwnProperty.call(m,"stateSignatureTransaction"))$root.com.hedera.hapi.platform.event.StateSignatureTransaction.encode(m.stateSignatureTransaction,w.uint32(522).fork()).ldelim();if(m.hintsPreprocessingVote!=null&&Object.hasOwnProperty.call(m,"hintsPreprocessingVote"))$root.com.hedera.hapi.services.auxiliary.hints.HintsPreprocessingVoteTransactionBody.encode(m.hintsPreprocessingVote,w.uint32(530).fork()).ldelim();if(m.hintsKeyPublication!=null&&Object.hasOwnProperty.call(m,"hintsKeyPublication"))$root.com.hedera.hapi.services.auxiliary.hints.HintsKeyPublicationTransactionBody.encode(m.hintsKeyPublication,w.uint32(538).fork()).ldelim();if(m.hintsPartialSignature!=null&&Object.hasOwnProperty.call(m,"hintsPartialSignature"))$root.com.hedera.hapi.services.auxiliary.hints.HintsPartialSignatureTransactionBody.encode(m.hintsPartialSignature,w.uint32(546).fork()).ldelim();if(m.historyProofSignature!=null&&Object.hasOwnProperty.call(m,"historyProofSignature"))$root.com.hedera.hapi.services.auxiliary.history.HistoryProofSignatureTransactionBody.encode(m.historyProofSignature,w.uint32(554).fork()).ldelim();if(m.historyProofKeyPublication!=null&&Object.hasOwnProperty.call(m,"historyProofKeyPublication"))$root.com.hedera.hapi.services.auxiliary.history.HistoryProofKeyPublicationTransactionBody.encode(m.historyProofKeyPublication,w.uint32(562).fork()).ldelim();if(m.historyProofVote!=null&&Object.hasOwnProperty.call(m,"historyProofVote"))$root.com.hedera.hapi.services.auxiliary.history.HistoryProofVoteTransactionBody.encode(m.historyProofVote,w.uint32(570).fork()).ldelim();if(m.crsPublication!=null&&Object.hasOwnProperty.call(m,"crsPublication"))$root.com.hedera.hapi.services.auxiliary.hints.CrsPublicationTransactionBody.encode(m.crsPublication,w.uint32(578).fork()).ldelim();if(m.batchKey!=null&&Object.hasOwnProperty.call(m,"batchKey"))$root.proto.Key.encode(m.batchKey,w.uint32(586).fork()).ldelim();if(m.atomicBatch!=null&&Object.hasOwnProperty.call(m,"atomicBatch"))$root.proto.AtomicBatchTransactionBody.encode(m.atomicBatch,w.uint32(594).fork()).ldelim();if(m.maxCustomFees!=null&&m.maxCustomFees.length){for(var i=0;i<m.maxCustomFees.length;++i)$root.proto.CustomFeeLimit.encode(m.maxCustomFees[i],w.uint32(8010).fork()).ldelim();}return w;};TransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.transactionID=$root.proto.TransactionID.decode(r,r.uint32());break;}case 2:{m.nodeAccountID=$root.proto.AccountID.decode(r,r.uint32());break;}case 3:{m.transactionFee=r.uint64();break;}case 4:{m.transactionValidDuration=$root.proto.Duration.decode(r,r.uint32());break;}case 5:{m.generateRecord=r.bool();break;}case 6:{m.memo=r.string();break;}case 73:{m.batchKey=$root.proto.Key.decode(r,r.uint32());break;}case 7:{m.contractCall=$root.proto.ContractCallTransactionBody.decode(r,r.uint32());break;}case 8:{m.contractCreateInstance=$root.proto.ContractCreateTransactionBody.decode(r,r.uint32());break;}case 9:{m.contractUpdateInstance=$root.proto.ContractUpdateTransactionBody.decode(r,r.uint32());break;}case 10:{m.cryptoAddLiveHash=$root.proto.CryptoAddLiveHashTransactionBody.decode(r,r.uint32());break;}case 11:{m.cryptoCreateAccount=$root.proto.CryptoCreateTransactionBody.decode(r,r.uint32());break;}case 12:{m.cryptoDelete=$root.proto.CryptoDeleteTransactionBody.decode(r,r.uint32());break;}case 13:{m.cryptoDeleteLiveHash=$root.proto.CryptoDeleteLiveHashTransactionBody.decode(r,r.uint32());break;}case 14:{m.cryptoTransfer=$root.proto.CryptoTransferTransactionBody.decode(r,r.uint32());break;}case 15:{m.cryptoUpdateAccount=$root.proto.CryptoUpdateTransactionBody.decode(r,r.uint32());break;}case 16:{m.fileAppend=$root.proto.FileAppendTransactionBody.decode(r,r.uint32());break;}case 17:{m.fileCreate=$root.proto.FileCreateTransactionBody.decode(r,r.uint32());break;}case 18:{m.fileDelete=$root.proto.FileDeleteTransactionBody.decode(r,r.uint32());break;}case 19:{m.fileUpdate=$root.proto.FileUpdateTransactionBody.decode(r,r.uint32());break;}case 20:{m.systemDelete=$root.proto.SystemDeleteTransactionBody.decode(r,r.uint32());break;}case 21:{m.systemUndelete=$root.proto.SystemUndeleteTransactionBody.decode(r,r.uint32());break;}case 22:{m.contractDeleteInstance=$root.proto.ContractDeleteTransactionBody.decode(r,r.uint32());break;}case 23:{m.freeze=$root.proto.FreezeTransactionBody.decode(r,r.uint32());break;}case 24:{m.consensusCreateTopic=$root.proto.ConsensusCreateTopicTransactionBody.decode(r,r.uint32());break;}case 25:{m.consensusUpdateTopic=$root.proto.ConsensusUpdateTopicTransactionBody.decode(r,r.uint32());break;}case 26:{m.consensusDeleteTopic=$root.proto.ConsensusDeleteTopicTransactionBody.decode(r,r.uint32());break;}case 27:{m.consensusSubmitMessage=$root.proto.ConsensusSubmitMessageTransactionBody.decode(r,r.uint32());break;}case 28:{m.uncheckedSubmit=$root.proto.UncheckedSubmitBody.decode(r,r.uint32());break;}case 29:{m.tokenCreation=$root.proto.TokenCreateTransactionBody.decode(r,r.uint32());break;}case 31:{m.tokenFreeze=$root.proto.TokenFreezeAccountTransactionBody.decode(r,r.uint32());break;}case 32:{m.tokenUnfreeze=$root.proto.TokenUnfreezeAccountTransactionBody.decode(r,r.uint32());break;}case 33:{m.tokenGrantKyc=$root.proto.TokenGrantKycTransactionBody.decode(r,r.uint32());break;}case 34:{m.tokenRevokeKyc=$root.proto.TokenRevokeKycTransactionBody.decode(r,r.uint32());break;}case 35:{m.tokenDeletion=$root.proto.TokenDeleteTransactionBody.decode(r,r.uint32());break;}case 36:{m.tokenUpdate=$root.proto.TokenUpdateTransactionBody.decode(r,r.uint32());break;}case 37:{m.tokenMint=$root.proto.TokenMintTransactionBody.decode(r,r.uint32());break;}case 38:{m.tokenBurn=$root.proto.TokenBurnTransactionBody.decode(r,r.uint32());break;}case 39:{m.tokenWipe=$root.proto.TokenWipeAccountTransactionBody.decode(r,r.uint32());break;}case 40:{m.tokenAssociate=$root.proto.TokenAssociateTransactionBody.decode(r,r.uint32());break;}case 41:{m.tokenDissociate=$root.proto.TokenDissociateTransactionBody.decode(r,r.uint32());break;}case 42:{m.scheduleCreate=$root.proto.ScheduleCreateTransactionBody.decode(r,r.uint32());break;}case 43:{m.scheduleDelete=$root.proto.ScheduleDeleteTransactionBody.decode(r,r.uint32());break;}case 44:{m.scheduleSign=$root.proto.ScheduleSignTransactionBody.decode(r,r.uint32());break;}case 45:{m.tokenFeeScheduleUpdate=$root.proto.TokenFeeScheduleUpdateTransactionBody.decode(r,r.uint32());break;}case 46:{m.tokenPause=$root.proto.TokenPauseTransactionBody.decode(r,r.uint32());break;}case 47:{m.tokenUnpause=$root.proto.TokenUnpauseTransactionBody.decode(r,r.uint32());break;}case 48:{m.cryptoApproveAllowance=$root.proto.CryptoApproveAllowanceTransactionBody.decode(r,r.uint32());break;}case 49:{m.cryptoDeleteAllowance=$root.proto.CryptoDeleteAllowanceTransactionBody.decode(r,r.uint32());break;}case 50:{m.ethereumTransaction=$root.proto.EthereumTransactionBody.decode(r,r.uint32());break;}case 51:{m.nodeStakeUpdate=$root.proto.NodeStakeUpdateTransactionBody.decode(r,r.uint32());break;}case 52:{m.utilPrng=$root.proto.UtilPrngTransactionBody.decode(r,r.uint32());break;}case 53:{m.tokenUpdateNfts=$root.proto.TokenUpdateNftsTransactionBody.decode(r,r.uint32());break;}case 54:{m.nodeCreate=$root.com.hedera.hapi.node.addressbook.NodeCreateTransactionBody.decode(r,r.uint32());break;}case 55:{m.nodeUpdate=$root.com.hedera.hapi.node.addressbook.NodeUpdateTransactionBody.decode(r,r.uint32());break;}case 56:{m.nodeDelete=$root.com.hedera.hapi.node.addressbook.NodeDeleteTransactionBody.decode(r,r.uint32());break;}case 57:{m.tokenReject=$root.proto.TokenRejectTransactionBody.decode(r,r.uint32());break;}case 58:{m.tokenAirdrop=$root.proto.TokenAirdropTransactionBody.decode(r,r.uint32());break;}case 59:{m.tokenCancelAirdrop=$root.proto.TokenCancelAirdropTransactionBody.decode(r,r.uint32());break;}case 60:{m.tokenClaimAirdrop=$root.proto.TokenClaimAirdropTransactionBody.decode(r,r.uint32());break;}case 65:{m.stateSignatureTransaction=$root.com.hedera.hapi.platform.event.StateSignatureTransaction.decode(r,r.uint32());break;}case 66:{m.hintsPreprocessingVote=$root.com.hedera.hapi.services.auxiliary.hints.HintsPreprocessingVoteTransactionBody.decode(r,r.uint32());break;}case 67:{m.hintsKeyPublication=$root.com.hedera.hapi.services.auxiliary.hints.HintsKeyPublicationTransactionBody.decode(r,r.uint32());break;}case 68:{m.hintsPartialSignature=$root.com.hedera.hapi.services.auxiliary.hints.HintsPartialSignatureTransactionBody.decode(r,r.uint32());break;}case 69:{m.historyProofSignature=$root.com.hedera.hapi.services.auxiliary.history.HistoryProofSignatureTransactionBody.decode(r,r.uint32());break;}case 70:{m.historyProofKeyPublication=$root.com.hedera.hapi.services.auxiliary.history.HistoryProofKeyPublicationTransactionBody.decode(r,r.uint32());break;}case 71:{m.historyProofVote=$root.com.hedera.hapi.services.auxiliary.history.HistoryProofVoteTransactionBody.decode(r,r.uint32());break;}case 72:{m.crsPublication=$root.com.hedera.hapi.services.auxiliary.hints.CrsPublicationTransactionBody.decode(r,r.uint32());break;}case 74:{m.atomicBatch=$root.proto.AtomicBatchTransactionBody.decode(r,r.uint32());break;}case 1001:{if(!(m.maxCustomFees&&m.maxCustomFees.length))m.maxCustomFees=[];m.maxCustomFees.push($root.proto.CustomFeeLimit.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};TransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TransactionBody";};return TransactionBody;}();proto.AtomicBatchTransactionBody=function(){function AtomicBatchTransactionBody(p){this.transactions=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}AtomicBatchTransactionBody.prototype.transactions=$util.emptyArray;AtomicBatchTransactionBody.create=function create(properties){return new AtomicBatchTransactionBody(properties);};AtomicBatchTransactionBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.transactions!=null&&m.transactions.length){for(var i=0;i<m.transactions.length;++i)w.uint32(10).bytes(m.transactions[i]);}return w;};AtomicBatchTransactionBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.AtomicBatchTransactionBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{if(!(m.transactions&&m.transactions.length))m.transactions=[];m.transactions.push(r.bytes());break;}default:r.skipType(t&7);break;}}return m;};AtomicBatchTransactionBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.AtomicBatchTransactionBody";};return AtomicBatchTransactionBody;}();proto.UncheckedSubmitBody=function(){function UncheckedSubmitBody(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}UncheckedSubmitBody.prototype.transactionBytes=$util.newBuffer([]);UncheckedSubmitBody.create=function create(properties){return new UncheckedSubmitBody(properties);};UncheckedSubmitBody.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.transactionBytes!=null&&Object.hasOwnProperty.call(m,"transactionBytes"))w.uint32(10).bytes(m.transactionBytes);return w;};UncheckedSubmitBody.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.UncheckedSubmitBody();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.transactionBytes=r.bytes();break;}default:r.skipType(t&7);break;}}return m;};UncheckedSubmitBody.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.UncheckedSubmitBody";};return UncheckedSubmitBody;}();proto.UtilService=function(){function UtilService(rpcImpl,requestDelimited,responseDelimited){$protobuf.rpc.Service.call(this,rpcImpl,requestDelimited,responseDelimited);}(UtilService.prototype=Object.create($protobuf.rpc.Service.prototype)).constructor=UtilService;UtilService.create=function create(rpcImpl,requestDelimited,responseDelimited){return new this(rpcImpl,requestDelimited,responseDelimited);};Object.defineProperty(UtilService.prototype.prng=function prng(request,callback){return this.rpcCall(prng,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"prng"});Object.defineProperty(UtilService.prototype.atomicBatch=function atomicBatch(request,callback){return this.rpcCall(atomicBatch,$root.proto.Transaction,$root.proto.TransactionResponse,request,callback);},"name",{value:"atomicBatch"});return UtilService;}();proto.TokenUnitBalance=function(){function TokenUnitBalance(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TokenUnitBalance.prototype.tokenId=null;TokenUnitBalance.prototype.balance=$util.Long?$util.Long.fromBits(0,0,true):0;TokenUnitBalance.create=function create(properties){return new TokenUnitBalance(properties);};TokenUnitBalance.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.tokenId!=null&&Object.hasOwnProperty.call(m,"tokenId"))$root.proto.TokenID.encode(m.tokenId,w.uint32(10).fork()).ldelim();if(m.balance!=null&&Object.hasOwnProperty.call(m,"balance"))w.uint32(16).uint64(m.balance);return w;};TokenUnitBalance.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TokenUnitBalance();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.tokenId=$root.proto.TokenID.decode(r,r.uint32());break;}case 2:{m.balance=r.uint64();break;}default:r.skipType(t&7);break;}}return m;};TokenUnitBalance.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TokenUnitBalance";};return TokenUnitBalance;}();proto.SingleAccountBalances=function(){function SingleAccountBalances(p){this.tokenUnitBalances=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}SingleAccountBalances.prototype.accountID=null;SingleAccountBalances.prototype.hbarBalance=$util.Long?$util.Long.fromBits(0,0,true):0;SingleAccountBalances.prototype.tokenUnitBalances=$util.emptyArray;SingleAccountBalances.create=function create(properties){return new SingleAccountBalances(properties);};SingleAccountBalances.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.accountID!=null&&Object.hasOwnProperty.call(m,"accountID"))$root.proto.AccountID.encode(m.accountID,w.uint32(10).fork()).ldelim();if(m.hbarBalance!=null&&Object.hasOwnProperty.call(m,"hbarBalance"))w.uint32(16).uint64(m.hbarBalance);if(m.tokenUnitBalances!=null&&m.tokenUnitBalances.length){for(var i=0;i<m.tokenUnitBalances.length;++i)$root.proto.TokenUnitBalance.encode(m.tokenUnitBalances[i],w.uint32(26).fork()).ldelim();}return w;};SingleAccountBalances.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.SingleAccountBalances();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.accountID=$root.proto.AccountID.decode(r,r.uint32());break;}case 2:{m.hbarBalance=r.uint64();break;}case 3:{if(!(m.tokenUnitBalances&&m.tokenUnitBalances.length))m.tokenUnitBalances=[];m.tokenUnitBalances.push($root.proto.TokenUnitBalance.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};SingleAccountBalances.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.SingleAccountBalances";};return SingleAccountBalances;}();proto.AllAccountBalances=function(){function AllAccountBalances(p){this.allAccounts=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}AllAccountBalances.prototype.consensusTimestamp=null;AllAccountBalances.prototype.allAccounts=$util.emptyArray;AllAccountBalances.create=function create(properties){return new AllAccountBalances(properties);};AllAccountBalances.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.consensusTimestamp!=null&&Object.hasOwnProperty.call(m,"consensusTimestamp"))$root.proto.Timestamp.encode(m.consensusTimestamp,w.uint32(10).fork()).ldelim();if(m.allAccounts!=null&&m.allAccounts.length){for(var i=0;i<m.allAccounts.length;++i)$root.proto.SingleAccountBalances.encode(m.allAccounts[i],w.uint32(18).fork()).ldelim();}return w;};AllAccountBalances.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.AllAccountBalances();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.consensusTimestamp=$root.proto.Timestamp.decode(r,r.uint32());break;}case 2:{if(!(m.allAccounts&&m.allAccounts.length))m.allAccounts=[];m.allAccounts.push($root.proto.SingleAccountBalances.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};AllAccountBalances.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.AllAccountBalances";};return AllAccountBalances;}();proto.ContractActions=function(){function ContractActions(p){this.contractActions=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ContractActions.prototype.contractActions=$util.emptyArray;ContractActions.create=function create(properties){return new ContractActions(properties);};ContractActions.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.contractActions!=null&&m.contractActions.length){for(var i=0;i<m.contractActions.length;++i)$root.proto.ContractAction.encode(m.contractActions[i],w.uint32(10).fork()).ldelim();}return w;};ContractActions.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ContractActions();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{if(!(m.contractActions&&m.contractActions.length))m.contractActions=[];m.contractActions.push($root.proto.ContractAction.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};ContractActions.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ContractActions";};return ContractActions;}();proto.ContractActionType=function(){const valuesById={},values=Object.create(valuesById);values[valuesById[0]="NO_ACTION"]=0;values[valuesById[1]="CALL"]=1;values[valuesById[2]="CREATE"]=2;values[valuesById[3]="PRECOMPILE"]=3;values[valuesById[4]="SYSTEM"]=4;return values;}();proto.CallOperationType=function(){const valuesById={},values=Object.create(valuesById);values[valuesById[0]="OP_UNKNOWN"]=0;values[valuesById[1]="OP_CALL"]=1;values[valuesById[2]="OP_CALLCODE"]=2;values[valuesById[3]="OP_DELEGATECALL"]=3;values[valuesById[4]="OP_STATICCALL"]=4;values[valuesById[5]="OP_CREATE"]=5;values[valuesById[6]="OP_CREATE2"]=6;return values;}();proto.ContractAction=function(){function ContractAction(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ContractAction.prototype.callType=0;ContractAction.prototype.callingAccount=null;ContractAction.prototype.callingContract=null;ContractAction.prototype.gas=$util.Long?$util.Long.fromBits(0,0,false):0;ContractAction.prototype.input=$util.newBuffer([]);ContractAction.prototype.recipientAccount=null;ContractAction.prototype.recipientContract=null;ContractAction.prototype.targetedAddress=null;ContractAction.prototype.value=$util.Long?$util.Long.fromBits(0,0,false):0;ContractAction.prototype.gasUsed=$util.Long?$util.Long.fromBits(0,0,false):0;ContractAction.prototype.output=null;ContractAction.prototype.revertReason=null;ContractAction.prototype.error=null;ContractAction.prototype.callDepth=0;ContractAction.prototype.callOperationType=0;let $oneOfFields;Object.defineProperty(ContractAction.prototype,"caller",{get:$util.oneOfGetter($oneOfFields=["callingAccount","callingContract"]),set:$util.oneOfSetter($oneOfFields)});Object.defineProperty(ContractAction.prototype,"recipient",{get:$util.oneOfGetter($oneOfFields=["recipientAccount","recipientContract","targetedAddress"]),set:$util.oneOfSetter($oneOfFields)});Object.defineProperty(ContractAction.prototype,"resultData",{get:$util.oneOfGetter($oneOfFields=["output","revertReason","error"]),set:$util.oneOfSetter($oneOfFields)});ContractAction.create=function create(properties){return new ContractAction(properties);};ContractAction.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.callType!=null&&Object.hasOwnProperty.call(m,"callType"))w.uint32(8).int32(m.callType);if(m.callingAccount!=null&&Object.hasOwnProperty.call(m,"callingAccount"))$root.proto.AccountID.encode(m.callingAccount,w.uint32(18).fork()).ldelim();if(m.callingContract!=null&&Object.hasOwnProperty.call(m,"callingContract"))$root.proto.ContractID.encode(m.callingContract,w.uint32(26).fork()).ldelim();if(m.gas!=null&&Object.hasOwnProperty.call(m,"gas"))w.uint32(32).int64(m.gas);if(m.input!=null&&Object.hasOwnProperty.call(m,"input"))w.uint32(42).bytes(m.input);if(m.recipientAccount!=null&&Object.hasOwnProperty.call(m,"recipientAccount"))$root.proto.AccountID.encode(m.recipientAccount,w.uint32(50).fork()).ldelim();if(m.recipientContract!=null&&Object.hasOwnProperty.call(m,"recipientContract"))$root.proto.ContractID.encode(m.recipientContract,w.uint32(58).fork()).ldelim();if(m.targetedAddress!=null&&Object.hasOwnProperty.call(m,"targetedAddress"))w.uint32(66).bytes(m.targetedAddress);if(m.value!=null&&Object.hasOwnProperty.call(m,"value"))w.uint32(72).int64(m.value);if(m.gasUsed!=null&&Object.hasOwnProperty.call(m,"gasUsed"))w.uint32(80).int64(m.gasUsed);if(m.output!=null&&Object.hasOwnProperty.call(m,"output"))w.uint32(90).bytes(m.output);if(m.revertReason!=null&&Object.hasOwnProperty.call(m,"revertReason"))w.uint32(98).bytes(m.revertReason);if(m.error!=null&&Object.hasOwnProperty.call(m,"error"))w.uint32(106).bytes(m.error);if(m.callDepth!=null&&Object.hasOwnProperty.call(m,"callDepth"))w.uint32(112).int32(m.callDepth);if(m.callOperationType!=null&&Object.hasOwnProperty.call(m,"callOperationType"))w.uint32(120).int32(m.callOperationType);return w;};ContractAction.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ContractAction();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.callType=r.int32();break;}case 2:{m.callingAccount=$root.proto.AccountID.decode(r,r.uint32());break;}case 3:{m.callingContract=$root.proto.ContractID.decode(r,r.uint32());break;}case 4:{m.gas=r.int64();break;}case 5:{m.input=r.bytes();break;}case 6:{m.recipientAccount=$root.proto.AccountID.decode(r,r.uint32());break;}case 7:{m.recipientContract=$root.proto.ContractID.decode(r,r.uint32());break;}case 8:{m.targetedAddress=r.bytes();break;}case 9:{m.value=r.int64();break;}case 10:{m.gasUsed=r.int64();break;}case 11:{m.output=r.bytes();break;}case 12:{m.revertReason=r.bytes();break;}case 13:{m.error=r.bytes();break;}case 14:{m.callDepth=r.int32();break;}case 15:{m.callOperationType=r.int32();break;}default:r.skipType(t&7);break;}}return m;};ContractAction.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ContractAction";};return ContractAction;}();proto.ContractBytecode=function(){function ContractBytecode(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ContractBytecode.prototype.contractId=null;ContractBytecode.prototype.initcode=$util.newBuffer([]);ContractBytecode.prototype.runtimeBytecode=$util.newBuffer([]);ContractBytecode.create=function create(properties){return new ContractBytecode(properties);};ContractBytecode.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.contractId!=null&&Object.hasOwnProperty.call(m,"contractId"))$root.proto.ContractID.encode(m.contractId,w.uint32(10).fork()).ldelim();if(m.initcode!=null&&Object.hasOwnProperty.call(m,"initcode"))w.uint32(18).bytes(m.initcode);if(m.runtimeBytecode!=null&&Object.hasOwnProperty.call(m,"runtimeBytecode"))w.uint32(26).bytes(m.runtimeBytecode);return w;};ContractBytecode.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ContractBytecode();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.contractId=$root.proto.ContractID.decode(r,r.uint32());break;}case 2:{m.initcode=r.bytes();break;}case 3:{m.runtimeBytecode=r.bytes();break;}default:r.skipType(t&7);break;}}return m;};ContractBytecode.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ContractBytecode";};return ContractBytecode;}();proto.ContractStateChanges=function(){function ContractStateChanges(p){this.contractStateChanges=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ContractStateChanges.prototype.contractStateChanges=$util.emptyArray;ContractStateChanges.create=function create(properties){return new ContractStateChanges(properties);};ContractStateChanges.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.contractStateChanges!=null&&m.contractStateChanges.length){for(var i=0;i<m.contractStateChanges.length;++i)$root.proto.ContractStateChange.encode(m.contractStateChanges[i],w.uint32(10).fork()).ldelim();}return w;};ContractStateChanges.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ContractStateChanges();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{if(!(m.contractStateChanges&&m.contractStateChanges.length))m.contractStateChanges=[];m.contractStateChanges.push($root.proto.ContractStateChange.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};ContractStateChanges.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ContractStateChanges";};return ContractStateChanges;}();proto.ContractStateChange=function(){function ContractStateChange(p){this.storageChanges=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}ContractStateChange.prototype.contractId=null;ContractStateChange.prototype.storageChanges=$util.emptyArray;ContractStateChange.create=function create(properties){return new ContractStateChange(properties);};ContractStateChange.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.contractId!=null&&Object.hasOwnProperty.call(m,"contractId"))$root.proto.ContractID.encode(m.contractId,w.uint32(10).fork()).ldelim();if(m.storageChanges!=null&&m.storageChanges.length){for(var i=0;i<m.storageChanges.length;++i)$root.proto.StorageChange.encode(m.storageChanges[i],w.uint32(18).fork()).ldelim();}return w;};ContractStateChange.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.ContractStateChange();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.contractId=$root.proto.ContractID.decode(r,r.uint32());break;}case 2:{if(!(m.storageChanges&&m.storageChanges.length))m.storageChanges=[];m.storageChanges.push($root.proto.StorageChange.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};ContractStateChange.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.ContractStateChange";};return ContractStateChange;}();proto.StorageChange=function(){function StorageChange(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}StorageChange.prototype.slot=$util.newBuffer([]);StorageChange.prototype.valueRead=$util.newBuffer([]);StorageChange.prototype.valueWritten=null;StorageChange.create=function create(properties){return new StorageChange(properties);};StorageChange.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.slot!=null&&Object.hasOwnProperty.call(m,"slot"))w.uint32(10).bytes(m.slot);if(m.valueRead!=null&&Object.hasOwnProperty.call(m,"valueRead"))w.uint32(18).bytes(m.valueRead);if(m.valueWritten!=null&&Object.hasOwnProperty.call(m,"valueWritten"))$root.google.protobuf.BytesValue.encode(m.valueWritten,w.uint32(26).fork()).ldelim();return w;};StorageChange.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.StorageChange();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.slot=r.bytes();break;}case 2:{m.valueRead=r.bytes();break;}case 3:{m.valueWritten=$root.google.protobuf.BytesValue.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};StorageChange.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.StorageChange";};return StorageChange;}();proto.HashAlgorithm=function(){const valuesById={},values=Object.create(valuesById);values[valuesById[0]="HASH_ALGORITHM_UNKNOWN"]=0;values[valuesById[1]="SHA_384"]=1;return values;}();proto.HashObject=function(){function HashObject(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}HashObject.prototype.algorithm=0;HashObject.prototype.length=0;HashObject.prototype.hash=$util.newBuffer([]);HashObject.create=function create(properties){return new HashObject(properties);};HashObject.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.algorithm!=null&&Object.hasOwnProperty.call(m,"algorithm"))w.uint32(8).int32(m.algorithm);if(m.length!=null&&Object.hasOwnProperty.call(m,"length"))w.uint32(16).int32(m.length);if(m.hash!=null&&Object.hasOwnProperty.call(m,"hash"))w.uint32(26).bytes(m.hash);return w;};HashObject.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.HashObject();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.algorithm=r.int32();break;}case 2:{m.length=r.int32();break;}case 3:{m.hash=r.bytes();break;}default:r.skipType(t&7);break;}}return m;};HashObject.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.HashObject";};return HashObject;}();proto.RecordStreamFile=function(){function RecordStreamFile(p){this.recordStreamItems=[];this.sidecars=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}RecordStreamFile.prototype.hapiProtoVersion=null;RecordStreamFile.prototype.startObjectRunningHash=null;RecordStreamFile.prototype.recordStreamItems=$util.emptyArray;RecordStreamFile.prototype.endObjectRunningHash=null;RecordStreamFile.prototype.blockNumber=$util.Long?$util.Long.fromBits(0,0,false):0;RecordStreamFile.prototype.sidecars=$util.emptyArray;RecordStreamFile.create=function create(properties){return new RecordStreamFile(properties);};RecordStreamFile.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.hapiProtoVersion!=null&&Object.hasOwnProperty.call(m,"hapiProtoVersion"))$root.proto.SemanticVersion.encode(m.hapiProtoVersion,w.uint32(10).fork()).ldelim();if(m.startObjectRunningHash!=null&&Object.hasOwnProperty.call(m,"startObjectRunningHash"))$root.proto.HashObject.encode(m.startObjectRunningHash,w.uint32(18).fork()).ldelim();if(m.recordStreamItems!=null&&m.recordStreamItems.length){for(var i=0;i<m.recordStreamItems.length;++i)$root.proto.RecordStreamItem.encode(m.recordStreamItems[i],w.uint32(26).fork()).ldelim();}if(m.endObjectRunningHash!=null&&Object.hasOwnProperty.call(m,"endObjectRunningHash"))$root.proto.HashObject.encode(m.endObjectRunningHash,w.uint32(34).fork()).ldelim();if(m.blockNumber!=null&&Object.hasOwnProperty.call(m,"blockNumber"))w.uint32(40).int64(m.blockNumber);if(m.sidecars!=null&&m.sidecars.length){for(var i=0;i<m.sidecars.length;++i)$root.proto.SidecarMetadata.encode(m.sidecars[i],w.uint32(50).fork()).ldelim();}return w;};RecordStreamFile.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.RecordStreamFile();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.hapiProtoVersion=$root.proto.SemanticVersion.decode(r,r.uint32());break;}case 2:{m.startObjectRunningHash=$root.proto.HashObject.decode(r,r.uint32());break;}case 3:{if(!(m.recordStreamItems&&m.recordStreamItems.length))m.recordStreamItems=[];m.recordStreamItems.push($root.proto.RecordStreamItem.decode(r,r.uint32()));break;}case 4:{m.endObjectRunningHash=$root.proto.HashObject.decode(r,r.uint32());break;}case 5:{m.blockNumber=r.int64();break;}case 6:{if(!(m.sidecars&&m.sidecars.length))m.sidecars=[];m.sidecars.push($root.proto.SidecarMetadata.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};RecordStreamFile.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.RecordStreamFile";};return RecordStreamFile;}();proto.RecordStreamItem=function(){function RecordStreamItem(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}RecordStreamItem.prototype.transaction=null;RecordStreamItem.prototype.record=null;RecordStreamItem.create=function create(properties){return new RecordStreamItem(properties);};RecordStreamItem.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.transaction!=null&&Object.hasOwnProperty.call(m,"transaction"))$root.proto.Transaction.encode(m.transaction,w.uint32(10).fork()).ldelim();if(m.record!=null&&Object.hasOwnProperty.call(m,"record"))$root.proto.TransactionRecord.encode(m.record,w.uint32(18).fork()).ldelim();return w;};RecordStreamItem.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.RecordStreamItem();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.transaction=$root.proto.Transaction.decode(r,r.uint32());break;}case 2:{m.record=$root.proto.TransactionRecord.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};RecordStreamItem.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.RecordStreamItem";};return RecordStreamItem;}();proto.SidecarMetadata=function(){function SidecarMetadata(p){this.types=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}SidecarMetadata.prototype.hash=null;SidecarMetadata.prototype.id=0;SidecarMetadata.prototype.types=$util.emptyArray;SidecarMetadata.create=function create(properties){return new SidecarMetadata(properties);};SidecarMetadata.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.hash!=null&&Object.hasOwnProperty.call(m,"hash"))$root.proto.HashObject.encode(m.hash,w.uint32(10).fork()).ldelim();if(m.id!=null&&Object.hasOwnProperty.call(m,"id"))w.uint32(16).int32(m.id);if(m.types!=null&&m.types.length){w.uint32(26).fork();for(var i=0;i<m.types.length;++i)w.int32(m.types[i]);w.ldelim();}return w;};SidecarMetadata.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.SidecarMetadata();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.hash=$root.proto.HashObject.decode(r,r.uint32());break;}case 2:{m.id=r.int32();break;}case 3:{if(!(m.types&&m.types.length))m.types=[];if((t&7)===2){var c2=r.uint32()+r.pos;while(r.pos<c2)m.types.push(r.int32());}else m.types.push(r.int32());break;}default:r.skipType(t&7);break;}}return m;};SidecarMetadata.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.SidecarMetadata";};return SidecarMetadata;}();proto.SidecarType=function(){const valuesById={},values=Object.create(valuesById);values[valuesById[0]="SIDECAR_TYPE_UNKNOWN"]=0;values[valuesById[1]="CONTRACT_STATE_CHANGE"]=1;values[valuesById[2]="CONTRACT_ACTION"]=2;values[valuesById[3]="CONTRACT_BYTECODE"]=3;return values;}();proto.SidecarFile=function(){function SidecarFile(p){this.sidecarRecords=[];if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}SidecarFile.prototype.sidecarRecords=$util.emptyArray;SidecarFile.create=function create(properties){return new SidecarFile(properties);};SidecarFile.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.sidecarRecords!=null&&m.sidecarRecords.length){for(var i=0;i<m.sidecarRecords.length;++i)$root.proto.TransactionSidecarRecord.encode(m.sidecarRecords[i],w.uint32(10).fork()).ldelim();}return w;};SidecarFile.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.SidecarFile();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{if(!(m.sidecarRecords&&m.sidecarRecords.length))m.sidecarRecords=[];m.sidecarRecords.push($root.proto.TransactionSidecarRecord.decode(r,r.uint32()));break;}default:r.skipType(t&7);break;}}return m;};SidecarFile.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.SidecarFile";};return SidecarFile;}();proto.TransactionSidecarRecord=function(){function TransactionSidecarRecord(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}TransactionSidecarRecord.prototype.consensusTimestamp=null;TransactionSidecarRecord.prototype.migration=false;TransactionSidecarRecord.prototype.stateChanges=null;TransactionSidecarRecord.prototype.actions=null;TransactionSidecarRecord.prototype.bytecode=null;let $oneOfFields;Object.defineProperty(TransactionSidecarRecord.prototype,"sidecarRecords",{get:$util.oneOfGetter($oneOfFields=["stateChanges","actions","bytecode"]),set:$util.oneOfSetter($oneOfFields)});TransactionSidecarRecord.create=function create(properties){return new TransactionSidecarRecord(properties);};TransactionSidecarRecord.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.consensusTimestamp!=null&&Object.hasOwnProperty.call(m,"consensusTimestamp"))$root.proto.Timestamp.encode(m.consensusTimestamp,w.uint32(10).fork()).ldelim();if(m.migration!=null&&Object.hasOwnProperty.call(m,"migration"))w.uint32(16).bool(m.migration);if(m.stateChanges!=null&&Object.hasOwnProperty.call(m,"stateChanges"))$root.proto.ContractStateChanges.encode(m.stateChanges,w.uint32(26).fork()).ldelim();if(m.actions!=null&&Object.hasOwnProperty.call(m,"actions"))$root.proto.ContractActions.encode(m.actions,w.uint32(34).fork()).ldelim();if(m.bytecode!=null&&Object.hasOwnProperty.call(m,"bytecode"))$root.proto.ContractBytecode.encode(m.bytecode,w.uint32(42).fork()).ldelim();return w;};TransactionSidecarRecord.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.TransactionSidecarRecord();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.consensusTimestamp=$root.proto.Timestamp.decode(r,r.uint32());break;}case 2:{m.migration=r.bool();break;}case 3:{m.stateChanges=$root.proto.ContractStateChanges.decode(r,r.uint32());break;}case 4:{m.actions=$root.proto.ContractActions.decode(r,r.uint32());break;}case 5:{m.bytecode=$root.proto.ContractBytecode.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};TransactionSidecarRecord.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.TransactionSidecarRecord";};return TransactionSidecarRecord;}();proto.SignatureFile=function(){function SignatureFile(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}SignatureFile.prototype.fileSignature=null;SignatureFile.prototype.metadataSignature=null;SignatureFile.create=function create(properties){return new SignatureFile(properties);};SignatureFile.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.fileSignature!=null&&Object.hasOwnProperty.call(m,"fileSignature"))$root.proto.SignatureObject.encode(m.fileSignature,w.uint32(10).fork()).ldelim();if(m.metadataSignature!=null&&Object.hasOwnProperty.call(m,"metadataSignature"))$root.proto.SignatureObject.encode(m.metadataSignature,w.uint32(18).fork()).ldelim();return w;};SignatureFile.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.SignatureFile();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.fileSignature=$root.proto.SignatureObject.decode(r,r.uint32());break;}case 2:{m.metadataSignature=$root.proto.SignatureObject.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};SignatureFile.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.SignatureFile";};return SignatureFile;}();proto.SignatureObject=function(){function SignatureObject(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}SignatureObject.prototype.type=0;SignatureObject.prototype.length=0;SignatureObject.prototype.checksum=0;SignatureObject.prototype.signature=$util.newBuffer([]);SignatureObject.prototype.hashObject=null;SignatureObject.create=function create(properties){return new SignatureObject(properties);};SignatureObject.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.type!=null&&Object.hasOwnProperty.call(m,"type"))w.uint32(8).int32(m.type);if(m.length!=null&&Object.hasOwnProperty.call(m,"length"))w.uint32(16).int32(m.length);if(m.checksum!=null&&Object.hasOwnProperty.call(m,"checksum"))w.uint32(24).int32(m.checksum);if(m.signature!=null&&Object.hasOwnProperty.call(m,"signature"))w.uint32(34).bytes(m.signature);if(m.hashObject!=null&&Object.hasOwnProperty.call(m,"hashObject"))$root.proto.HashObject.encode(m.hashObject,w.uint32(42).fork()).ldelim();return w;};SignatureObject.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.proto.SignatureObject();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.type=r.int32();break;}case 2:{m.length=r.int32();break;}case 3:{m.checksum=r.int32();break;}case 4:{m.signature=r.bytes();break;}case 5:{m.hashObject=$root.proto.HashObject.decode(r,r.uint32());break;}default:r.skipType(t&7);break;}}return m;};SignatureObject.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/proto.SignatureObject";};return SignatureObject;}();proto.SignatureType=function(){const valuesById={},values=Object.create(valuesById);values[valuesById[0]="SIGNATURE_TYPE_UNKNOWN"]=0;values[valuesById[1]="SHA_384_WITH_RSA"]=1;return values;}();return proto;})();proto$8.google=$root.google=(()=>{const google={};google.protobuf=function(){const protobuf={};protobuf.DoubleValue=function(){function DoubleValue(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}DoubleValue.prototype.value=0;DoubleValue.create=function create(properties){return new DoubleValue(properties);};DoubleValue.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.value!=null&&Object.hasOwnProperty.call(m,"value"))w.uint32(9).double(m.value);return w;};DoubleValue.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.google.protobuf.DoubleValue();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.value=r.double();break;}default:r.skipType(t&7);break;}}return m;};DoubleValue.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/google.protobuf.DoubleValue";};return DoubleValue;}();protobuf.FloatValue=function(){function FloatValue(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}FloatValue.prototype.value=0;FloatValue.create=function create(properties){return new FloatValue(properties);};FloatValue.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.value!=null&&Object.hasOwnProperty.call(m,"value"))w.uint32(13).float(m.value);return w;};FloatValue.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.google.protobuf.FloatValue();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.value=r.float();break;}default:r.skipType(t&7);break;}}return m;};FloatValue.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/google.protobuf.FloatValue";};return FloatValue;}();protobuf.Int64Value=function(){function Int64Value(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}Int64Value.prototype.value=$util.Long?$util.Long.fromBits(0,0,false):0;Int64Value.create=function create(properties){return new Int64Value(properties);};Int64Value.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.value!=null&&Object.hasOwnProperty.call(m,"value"))w.uint32(8).int64(m.value);return w;};Int64Value.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.google.protobuf.Int64Value();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.value=r.int64();break;}default:r.skipType(t&7);break;}}return m;};Int64Value.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/google.protobuf.Int64Value";};return Int64Value;}();protobuf.UInt64Value=function(){function UInt64Value(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}UInt64Value.prototype.value=$util.Long?$util.Long.fromBits(0,0,true):0;UInt64Value.create=function create(properties){return new UInt64Value(properties);};UInt64Value.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.value!=null&&Object.hasOwnProperty.call(m,"value"))w.uint32(8).uint64(m.value);return w;};UInt64Value.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.google.protobuf.UInt64Value();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.value=r.uint64();break;}default:r.skipType(t&7);break;}}return m;};UInt64Value.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/google.protobuf.UInt64Value";};return UInt64Value;}();protobuf.Int32Value=function(){function Int32Value(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}Int32Value.prototype.value=0;Int32Value.create=function create(properties){return new Int32Value(properties);};Int32Value.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.value!=null&&Object.hasOwnProperty.call(m,"value"))w.uint32(8).int32(m.value);return w;};Int32Value.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.google.protobuf.Int32Value();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.value=r.int32();break;}default:r.skipType(t&7);break;}}return m;};Int32Value.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/google.protobuf.Int32Value";};return Int32Value;}();protobuf.UInt32Value=function(){function UInt32Value(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}UInt32Value.prototype.value=0;UInt32Value.create=function create(properties){return new UInt32Value(properties);};UInt32Value.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.value!=null&&Object.hasOwnProperty.call(m,"value"))w.uint32(8).uint32(m.value);return w;};UInt32Value.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.google.protobuf.UInt32Value();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.value=r.uint32();break;}default:r.skipType(t&7);break;}}return m;};UInt32Value.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/google.protobuf.UInt32Value";};return UInt32Value;}();protobuf.BoolValue=function(){function BoolValue(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}BoolValue.prototype.value=false;BoolValue.create=function create(properties){return new BoolValue(properties);};BoolValue.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.value!=null&&Object.hasOwnProperty.call(m,"value"))w.uint32(8).bool(m.value);return w;};BoolValue.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.google.protobuf.BoolValue();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.value=r.bool();break;}default:r.skipType(t&7);break;}}return m;};BoolValue.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/google.protobuf.BoolValue";};return BoolValue;}();protobuf.StringValue=function(){function StringValue(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}StringValue.prototype.value="";StringValue.create=function create(properties){return new StringValue(properties);};StringValue.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.value!=null&&Object.hasOwnProperty.call(m,"value"))w.uint32(10).string(m.value);return w;};StringValue.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.google.protobuf.StringValue();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.value=r.string();break;}default:r.skipType(t&7);break;}}return m;};StringValue.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/google.protobuf.StringValue";};return StringValue;}();protobuf.BytesValue=function(){function BytesValue(p){if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)this[ks[i]]=p[ks[i]];}BytesValue.prototype.value=$util.newBuffer([]);BytesValue.create=function create(properties){return new BytesValue(properties);};BytesValue.encode=function encode(m,w){if(!w)w=$Writer.create();if(m.value!=null&&Object.hasOwnProperty.call(m,"value"))w.uint32(10).bytes(m.value);return w;};BytesValue.decode=function decode(r,l,e){if(!(r instanceof $Reader))r=$Reader.create(r);var c=l===undefined?r.len:r.pos+l,m=new $root.google.protobuf.BytesValue();while(r.pos<c){var t=r.uint32();if(t===e)break;switch(t>>>3){case 1:{m.value=r.bytes();break;}default:r.skipType(t&7);break;}}return m;};BytesValue.getTypeUrl=function getTypeUrl(typeUrlPrefix){if(typeUrlPrefix===undefined){typeUrlPrefix="type.googleapis.com";}return typeUrlPrefix+"/google.protobuf.BytesValue";};return BytesValue;}();return protobuf;}();return google;})();
  	return proto$8;
  }

  var hasRequiredLib;

  function requireLib () {
  	if (hasRequiredLib) return lib;
  	hasRequiredLib = 1;

  	Object.defineProperty(lib, "__esModule", {
  	  value: true
  	});
  	lib.proto = lib.google = lib.com = lib.Writer = lib.Reader = void 0;
  	var $protobuf = _interopRequireWildcard(requireMinimal());
  	var _long = _interopRequireDefault(requireUmd());
  	var $proto = _interopRequireWildcard(requireProto());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
  	function _interopRequireWildcard(e, r) { if (e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
  	(() => {
  	  var $util = $protobuf.util;
  	  if ($util.Long == null) {
  	    console.log(`Patching Protobuf Long.js instance...`);
  	    $util.Long = _long.default;
  	    if ($protobuf.Reader._configure != null) {
  	      $protobuf.Reader._configure($protobuf.BufferReader);
  	    }
  	  }
  	})();
  	lib.Reader = $protobuf.Reader;
  	lib.Writer = $protobuf.Writer;
  	lib.proto = $proto.proto;
  	lib.com = $proto.com;
  	lib.google = $proto.google;
  	return lib;
  }

  var libExports = requireLib();
  var index = /*@__PURE__*/getDefaultExportFromCjs(libExports);

  var HieroProto = /*#__PURE__*/_mergeNamespaces({
    __proto__: null,
    default: index
  }, [libExports]);

  let Key$1 = class Key {};

  /**
   * Signals that a key could not be realized from the input.
   */
  class BadKeyError extends Error {
      /**
       * @param {Error | string} messageOrCause
       */
      constructor(messageOrCause) {
          super(
              messageOrCause instanceof Error
                  ? messageOrCause.message
                  : messageOrCause,
          );

          this.name = "BadKeyError";

          if (messageOrCause instanceof Error) {
              /** @type {Error=} */
              this.cause = messageOrCause;
              this.stack = messageOrCause.stack;
          }
      }
  }

  function commonjsRequire(path) {
  	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
  }

  var naclFast = {exports: {}};

  var _nodeResolve_empty = {};

  var _nodeResolve_empty$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    default: _nodeResolve_empty
  });

  var require$$0 = /*@__PURE__*/getAugmentedNamespace(_nodeResolve_empty$1);

  var hasRequiredNaclFast;

  function requireNaclFast () {
  	if (hasRequiredNaclFast) return naclFast.exports;
  	hasRequiredNaclFast = 1;
  	(function (module) {
  		(function(nacl) {

  		// Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.
  		// Public domain.
  		//
  		// Implementation derived from TweetNaCl version 20140427.
  		// See for details: http://tweetnacl.cr.yp.to/

  		var gf = function(init) {
  		  var i, r = new Float64Array(16);
  		  if (init) for (i = 0; i < init.length; i++) r[i] = init[i];
  		  return r;
  		};

  		//  Pluggable, initialized in high-level API below.
  		var randombytes = function(/* x, n */) { throw new Error('no PRNG'); };

  		var _0 = new Uint8Array(16);
  		var _9 = new Uint8Array(32); _9[0] = 9;

  		var gf0 = gf(),
  		    gf1 = gf([1]),
  		    _121665 = gf([0xdb41, 1]),
  		    D = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]),
  		    D2 = gf([0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406]),
  		    X = gf([0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]),
  		    Y = gf([0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]),
  		    I = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);

  		function ts64(x, i, h, l) {
  		  x[i]   = (h >> 24) & 0xff;
  		  x[i+1] = (h >> 16) & 0xff;
  		  x[i+2] = (h >>  8) & 0xff;
  		  x[i+3] = h & 0xff;
  		  x[i+4] = (l >> 24)  & 0xff;
  		  x[i+5] = (l >> 16)  & 0xff;
  		  x[i+6] = (l >>  8)  & 0xff;
  		  x[i+7] = l & 0xff;
  		}

  		function vn(x, xi, y, yi, n) {
  		  var i,d = 0;
  		  for (i = 0; i < n; i++) d |= x[xi+i]^y[yi+i];
  		  return (1 & ((d - 1) >>> 8)) - 1;
  		}

  		function crypto_verify_16(x, xi, y, yi) {
  		  return vn(x,xi,y,yi,16);
  		}

  		function crypto_verify_32(x, xi, y, yi) {
  		  return vn(x,xi,y,yi,32);
  		}

  		function core_salsa20(o, p, k, c) {
  		  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
  		      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
  		      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
  		      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
  		      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
  		      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
  		      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
  		      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
  		      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
  		      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
  		      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
  		      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
  		      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
  		      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
  		      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
  		      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;

  		  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
  		      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
  		      x15 = j15, u;

  		  for (var i = 0; i < 20; i += 2) {
  		    u = x0 + x12 | 0;
  		    x4 ^= u<<7 | u>>>(32-7);
  		    u = x4 + x0 | 0;
  		    x8 ^= u<<9 | u>>>(32-9);
  		    u = x8 + x4 | 0;
  		    x12 ^= u<<13 | u>>>(32-13);
  		    u = x12 + x8 | 0;
  		    x0 ^= u<<18 | u>>>(32-18);

  		    u = x5 + x1 | 0;
  		    x9 ^= u<<7 | u>>>(32-7);
  		    u = x9 + x5 | 0;
  		    x13 ^= u<<9 | u>>>(32-9);
  		    u = x13 + x9 | 0;
  		    x1 ^= u<<13 | u>>>(32-13);
  		    u = x1 + x13 | 0;
  		    x5 ^= u<<18 | u>>>(32-18);

  		    u = x10 + x6 | 0;
  		    x14 ^= u<<7 | u>>>(32-7);
  		    u = x14 + x10 | 0;
  		    x2 ^= u<<9 | u>>>(32-9);
  		    u = x2 + x14 | 0;
  		    x6 ^= u<<13 | u>>>(32-13);
  		    u = x6 + x2 | 0;
  		    x10 ^= u<<18 | u>>>(32-18);

  		    u = x15 + x11 | 0;
  		    x3 ^= u<<7 | u>>>(32-7);
  		    u = x3 + x15 | 0;
  		    x7 ^= u<<9 | u>>>(32-9);
  		    u = x7 + x3 | 0;
  		    x11 ^= u<<13 | u>>>(32-13);
  		    u = x11 + x7 | 0;
  		    x15 ^= u<<18 | u>>>(32-18);

  		    u = x0 + x3 | 0;
  		    x1 ^= u<<7 | u>>>(32-7);
  		    u = x1 + x0 | 0;
  		    x2 ^= u<<9 | u>>>(32-9);
  		    u = x2 + x1 | 0;
  		    x3 ^= u<<13 | u>>>(32-13);
  		    u = x3 + x2 | 0;
  		    x0 ^= u<<18 | u>>>(32-18);

  		    u = x5 + x4 | 0;
  		    x6 ^= u<<7 | u>>>(32-7);
  		    u = x6 + x5 | 0;
  		    x7 ^= u<<9 | u>>>(32-9);
  		    u = x7 + x6 | 0;
  		    x4 ^= u<<13 | u>>>(32-13);
  		    u = x4 + x7 | 0;
  		    x5 ^= u<<18 | u>>>(32-18);

  		    u = x10 + x9 | 0;
  		    x11 ^= u<<7 | u>>>(32-7);
  		    u = x11 + x10 | 0;
  		    x8 ^= u<<9 | u>>>(32-9);
  		    u = x8 + x11 | 0;
  		    x9 ^= u<<13 | u>>>(32-13);
  		    u = x9 + x8 | 0;
  		    x10 ^= u<<18 | u>>>(32-18);

  		    u = x15 + x14 | 0;
  		    x12 ^= u<<7 | u>>>(32-7);
  		    u = x12 + x15 | 0;
  		    x13 ^= u<<9 | u>>>(32-9);
  		    u = x13 + x12 | 0;
  		    x14 ^= u<<13 | u>>>(32-13);
  		    u = x14 + x13 | 0;
  		    x15 ^= u<<18 | u>>>(32-18);
  		  }
  		   x0 =  x0 +  j0 | 0;
  		   x1 =  x1 +  j1 | 0;
  		   x2 =  x2 +  j2 | 0;
  		   x3 =  x3 +  j3 | 0;
  		   x4 =  x4 +  j4 | 0;
  		   x5 =  x5 +  j5 | 0;
  		   x6 =  x6 +  j6 | 0;
  		   x7 =  x7 +  j7 | 0;
  		   x8 =  x8 +  j8 | 0;
  		   x9 =  x9 +  j9 | 0;
  		  x10 = x10 + j10 | 0;
  		  x11 = x11 + j11 | 0;
  		  x12 = x12 + j12 | 0;
  		  x13 = x13 + j13 | 0;
  		  x14 = x14 + j14 | 0;
  		  x15 = x15 + j15 | 0;

  		  o[ 0] = x0 >>>  0 & 0xff;
  		  o[ 1] = x0 >>>  8 & 0xff;
  		  o[ 2] = x0 >>> 16 & 0xff;
  		  o[ 3] = x0 >>> 24 & 0xff;

  		  o[ 4] = x1 >>>  0 & 0xff;
  		  o[ 5] = x1 >>>  8 & 0xff;
  		  o[ 6] = x1 >>> 16 & 0xff;
  		  o[ 7] = x1 >>> 24 & 0xff;

  		  o[ 8] = x2 >>>  0 & 0xff;
  		  o[ 9] = x2 >>>  8 & 0xff;
  		  o[10] = x2 >>> 16 & 0xff;
  		  o[11] = x2 >>> 24 & 0xff;

  		  o[12] = x3 >>>  0 & 0xff;
  		  o[13] = x3 >>>  8 & 0xff;
  		  o[14] = x3 >>> 16 & 0xff;
  		  o[15] = x3 >>> 24 & 0xff;

  		  o[16] = x4 >>>  0 & 0xff;
  		  o[17] = x4 >>>  8 & 0xff;
  		  o[18] = x4 >>> 16 & 0xff;
  		  o[19] = x4 >>> 24 & 0xff;

  		  o[20] = x5 >>>  0 & 0xff;
  		  o[21] = x5 >>>  8 & 0xff;
  		  o[22] = x5 >>> 16 & 0xff;
  		  o[23] = x5 >>> 24 & 0xff;

  		  o[24] = x6 >>>  0 & 0xff;
  		  o[25] = x6 >>>  8 & 0xff;
  		  o[26] = x6 >>> 16 & 0xff;
  		  o[27] = x6 >>> 24 & 0xff;

  		  o[28] = x7 >>>  0 & 0xff;
  		  o[29] = x7 >>>  8 & 0xff;
  		  o[30] = x7 >>> 16 & 0xff;
  		  o[31] = x7 >>> 24 & 0xff;

  		  o[32] = x8 >>>  0 & 0xff;
  		  o[33] = x8 >>>  8 & 0xff;
  		  o[34] = x8 >>> 16 & 0xff;
  		  o[35] = x8 >>> 24 & 0xff;

  		  o[36] = x9 >>>  0 & 0xff;
  		  o[37] = x9 >>>  8 & 0xff;
  		  o[38] = x9 >>> 16 & 0xff;
  		  o[39] = x9 >>> 24 & 0xff;

  		  o[40] = x10 >>>  0 & 0xff;
  		  o[41] = x10 >>>  8 & 0xff;
  		  o[42] = x10 >>> 16 & 0xff;
  		  o[43] = x10 >>> 24 & 0xff;

  		  o[44] = x11 >>>  0 & 0xff;
  		  o[45] = x11 >>>  8 & 0xff;
  		  o[46] = x11 >>> 16 & 0xff;
  		  o[47] = x11 >>> 24 & 0xff;

  		  o[48] = x12 >>>  0 & 0xff;
  		  o[49] = x12 >>>  8 & 0xff;
  		  o[50] = x12 >>> 16 & 0xff;
  		  o[51] = x12 >>> 24 & 0xff;

  		  o[52] = x13 >>>  0 & 0xff;
  		  o[53] = x13 >>>  8 & 0xff;
  		  o[54] = x13 >>> 16 & 0xff;
  		  o[55] = x13 >>> 24 & 0xff;

  		  o[56] = x14 >>>  0 & 0xff;
  		  o[57] = x14 >>>  8 & 0xff;
  		  o[58] = x14 >>> 16 & 0xff;
  		  o[59] = x14 >>> 24 & 0xff;

  		  o[60] = x15 >>>  0 & 0xff;
  		  o[61] = x15 >>>  8 & 0xff;
  		  o[62] = x15 >>> 16 & 0xff;
  		  o[63] = x15 >>> 24 & 0xff;
  		}

  		function core_hsalsa20(o,p,k,c) {
  		  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
  		      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
  		      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
  		      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
  		      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
  		      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
  		      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
  		      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
  		      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
  		      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
  		      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
  		      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
  		      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
  		      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
  		      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
  		      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;

  		  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
  		      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
  		      x15 = j15, u;

  		  for (var i = 0; i < 20; i += 2) {
  		    u = x0 + x12 | 0;
  		    x4 ^= u<<7 | u>>>(32-7);
  		    u = x4 + x0 | 0;
  		    x8 ^= u<<9 | u>>>(32-9);
  		    u = x8 + x4 | 0;
  		    x12 ^= u<<13 | u>>>(32-13);
  		    u = x12 + x8 | 0;
  		    x0 ^= u<<18 | u>>>(32-18);

  		    u = x5 + x1 | 0;
  		    x9 ^= u<<7 | u>>>(32-7);
  		    u = x9 + x5 | 0;
  		    x13 ^= u<<9 | u>>>(32-9);
  		    u = x13 + x9 | 0;
  		    x1 ^= u<<13 | u>>>(32-13);
  		    u = x1 + x13 | 0;
  		    x5 ^= u<<18 | u>>>(32-18);

  		    u = x10 + x6 | 0;
  		    x14 ^= u<<7 | u>>>(32-7);
  		    u = x14 + x10 | 0;
  		    x2 ^= u<<9 | u>>>(32-9);
  		    u = x2 + x14 | 0;
  		    x6 ^= u<<13 | u>>>(32-13);
  		    u = x6 + x2 | 0;
  		    x10 ^= u<<18 | u>>>(32-18);

  		    u = x15 + x11 | 0;
  		    x3 ^= u<<7 | u>>>(32-7);
  		    u = x3 + x15 | 0;
  		    x7 ^= u<<9 | u>>>(32-9);
  		    u = x7 + x3 | 0;
  		    x11 ^= u<<13 | u>>>(32-13);
  		    u = x11 + x7 | 0;
  		    x15 ^= u<<18 | u>>>(32-18);

  		    u = x0 + x3 | 0;
  		    x1 ^= u<<7 | u>>>(32-7);
  		    u = x1 + x0 | 0;
  		    x2 ^= u<<9 | u>>>(32-9);
  		    u = x2 + x1 | 0;
  		    x3 ^= u<<13 | u>>>(32-13);
  		    u = x3 + x2 | 0;
  		    x0 ^= u<<18 | u>>>(32-18);

  		    u = x5 + x4 | 0;
  		    x6 ^= u<<7 | u>>>(32-7);
  		    u = x6 + x5 | 0;
  		    x7 ^= u<<9 | u>>>(32-9);
  		    u = x7 + x6 | 0;
  		    x4 ^= u<<13 | u>>>(32-13);
  		    u = x4 + x7 | 0;
  		    x5 ^= u<<18 | u>>>(32-18);

  		    u = x10 + x9 | 0;
  		    x11 ^= u<<7 | u>>>(32-7);
  		    u = x11 + x10 | 0;
  		    x8 ^= u<<9 | u>>>(32-9);
  		    u = x8 + x11 | 0;
  		    x9 ^= u<<13 | u>>>(32-13);
  		    u = x9 + x8 | 0;
  		    x10 ^= u<<18 | u>>>(32-18);

  		    u = x15 + x14 | 0;
  		    x12 ^= u<<7 | u>>>(32-7);
  		    u = x12 + x15 | 0;
  		    x13 ^= u<<9 | u>>>(32-9);
  		    u = x13 + x12 | 0;
  		    x14 ^= u<<13 | u>>>(32-13);
  		    u = x14 + x13 | 0;
  		    x15 ^= u<<18 | u>>>(32-18);
  		  }

  		  o[ 0] = x0 >>>  0 & 0xff;
  		  o[ 1] = x0 >>>  8 & 0xff;
  		  o[ 2] = x0 >>> 16 & 0xff;
  		  o[ 3] = x0 >>> 24 & 0xff;

  		  o[ 4] = x5 >>>  0 & 0xff;
  		  o[ 5] = x5 >>>  8 & 0xff;
  		  o[ 6] = x5 >>> 16 & 0xff;
  		  o[ 7] = x5 >>> 24 & 0xff;

  		  o[ 8] = x10 >>>  0 & 0xff;
  		  o[ 9] = x10 >>>  8 & 0xff;
  		  o[10] = x10 >>> 16 & 0xff;
  		  o[11] = x10 >>> 24 & 0xff;

  		  o[12] = x15 >>>  0 & 0xff;
  		  o[13] = x15 >>>  8 & 0xff;
  		  o[14] = x15 >>> 16 & 0xff;
  		  o[15] = x15 >>> 24 & 0xff;

  		  o[16] = x6 >>>  0 & 0xff;
  		  o[17] = x6 >>>  8 & 0xff;
  		  o[18] = x6 >>> 16 & 0xff;
  		  o[19] = x6 >>> 24 & 0xff;

  		  o[20] = x7 >>>  0 & 0xff;
  		  o[21] = x7 >>>  8 & 0xff;
  		  o[22] = x7 >>> 16 & 0xff;
  		  o[23] = x7 >>> 24 & 0xff;

  		  o[24] = x8 >>>  0 & 0xff;
  		  o[25] = x8 >>>  8 & 0xff;
  		  o[26] = x8 >>> 16 & 0xff;
  		  o[27] = x8 >>> 24 & 0xff;

  		  o[28] = x9 >>>  0 & 0xff;
  		  o[29] = x9 >>>  8 & 0xff;
  		  o[30] = x9 >>> 16 & 0xff;
  		  o[31] = x9 >>> 24 & 0xff;
  		}

  		function crypto_core_salsa20(out,inp,k,c) {
  		  core_salsa20(out,inp,k,c);
  		}

  		function crypto_core_hsalsa20(out,inp,k,c) {
  		  core_hsalsa20(out,inp,k,c);
  		}

  		var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
  		            // "expand 32-byte k"

  		function crypto_stream_salsa20_xor(c,cpos,m,mpos,b,n,k) {
  		  var z = new Uint8Array(16), x = new Uint8Array(64);
  		  var u, i;
  		  for (i = 0; i < 16; i++) z[i] = 0;
  		  for (i = 0; i < 8; i++) z[i] = n[i];
  		  while (b >= 64) {
  		    crypto_core_salsa20(x,z,k,sigma);
  		    for (i = 0; i < 64; i++) c[cpos+i] = m[mpos+i] ^ x[i];
  		    u = 1;
  		    for (i = 8; i < 16; i++) {
  		      u = u + (z[i] & 0xff) | 0;
  		      z[i] = u & 0xff;
  		      u >>>= 8;
  		    }
  		    b -= 64;
  		    cpos += 64;
  		    mpos += 64;
  		  }
  		  if (b > 0) {
  		    crypto_core_salsa20(x,z,k,sigma);
  		    for (i = 0; i < b; i++) c[cpos+i] = m[mpos+i] ^ x[i];
  		  }
  		  return 0;
  		}

  		function crypto_stream_salsa20(c,cpos,b,n,k) {
  		  var z = new Uint8Array(16), x = new Uint8Array(64);
  		  var u, i;
  		  for (i = 0; i < 16; i++) z[i] = 0;
  		  for (i = 0; i < 8; i++) z[i] = n[i];
  		  while (b >= 64) {
  		    crypto_core_salsa20(x,z,k,sigma);
  		    for (i = 0; i < 64; i++) c[cpos+i] = x[i];
  		    u = 1;
  		    for (i = 8; i < 16; i++) {
  		      u = u + (z[i] & 0xff) | 0;
  		      z[i] = u & 0xff;
  		      u >>>= 8;
  		    }
  		    b -= 64;
  		    cpos += 64;
  		  }
  		  if (b > 0) {
  		    crypto_core_salsa20(x,z,k,sigma);
  		    for (i = 0; i < b; i++) c[cpos+i] = x[i];
  		  }
  		  return 0;
  		}

  		function crypto_stream(c,cpos,d,n,k) {
  		  var s = new Uint8Array(32);
  		  crypto_core_hsalsa20(s,n,k,sigma);
  		  var sn = new Uint8Array(8);
  		  for (var i = 0; i < 8; i++) sn[i] = n[i+16];
  		  return crypto_stream_salsa20(c,cpos,d,sn,s);
  		}

  		function crypto_stream_xor(c,cpos,m,mpos,d,n,k) {
  		  var s = new Uint8Array(32);
  		  crypto_core_hsalsa20(s,n,k,sigma);
  		  var sn = new Uint8Array(8);
  		  for (var i = 0; i < 8; i++) sn[i] = n[i+16];
  		  return crypto_stream_salsa20_xor(c,cpos,m,mpos,d,sn,s);
  		}

  		/*
  		* Port of Andrew Moon's Poly1305-donna-16. Public domain.
  		* https://github.com/floodyberry/poly1305-donna
  		*/

  		var poly1305 = function(key) {
  		  this.buffer = new Uint8Array(16);
  		  this.r = new Uint16Array(10);
  		  this.h = new Uint16Array(10);
  		  this.pad = new Uint16Array(8);
  		  this.leftover = 0;
  		  this.fin = 0;

  		  var t0, t1, t2, t3, t4, t5, t6, t7;

  		  t0 = key[ 0] & 0xff | (key[ 1] & 0xff) << 8; this.r[0] = ( t0                     ) & 0x1fff;
  		  t1 = key[ 2] & 0xff | (key[ 3] & 0xff) << 8; this.r[1] = ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
  		  t2 = key[ 4] & 0xff | (key[ 5] & 0xff) << 8; this.r[2] = ((t1 >>> 10) | (t2 <<  6)) & 0x1f03;
  		  t3 = key[ 6] & 0xff | (key[ 7] & 0xff) << 8; this.r[3] = ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
  		  t4 = key[ 8] & 0xff | (key[ 9] & 0xff) << 8; this.r[4] = ((t3 >>>  4) | (t4 << 12)) & 0x00ff;
  		  this.r[5] = ((t4 >>>  1)) & 0x1ffe;
  		  t5 = key[10] & 0xff | (key[11] & 0xff) << 8; this.r[6] = ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
  		  t6 = key[12] & 0xff | (key[13] & 0xff) << 8; this.r[7] = ((t5 >>> 11) | (t6 <<  5)) & 0x1f81;
  		  t7 = key[14] & 0xff | (key[15] & 0xff) << 8; this.r[8] = ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
  		  this.r[9] = ((t7 >>>  5)) & 0x007f;

  		  this.pad[0] = key[16] & 0xff | (key[17] & 0xff) << 8;
  		  this.pad[1] = key[18] & 0xff | (key[19] & 0xff) << 8;
  		  this.pad[2] = key[20] & 0xff | (key[21] & 0xff) << 8;
  		  this.pad[3] = key[22] & 0xff | (key[23] & 0xff) << 8;
  		  this.pad[4] = key[24] & 0xff | (key[25] & 0xff) << 8;
  		  this.pad[5] = key[26] & 0xff | (key[27] & 0xff) << 8;
  		  this.pad[6] = key[28] & 0xff | (key[29] & 0xff) << 8;
  		  this.pad[7] = key[30] & 0xff | (key[31] & 0xff) << 8;
  		};

  		poly1305.prototype.blocks = function(m, mpos, bytes) {
  		  var hibit = this.fin ? 0 : (1 << 11);
  		  var t0, t1, t2, t3, t4, t5, t6, t7, c;
  		  var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;

  		  var h0 = this.h[0],
  		      h1 = this.h[1],
  		      h2 = this.h[2],
  		      h3 = this.h[3],
  		      h4 = this.h[4],
  		      h5 = this.h[5],
  		      h6 = this.h[6],
  		      h7 = this.h[7],
  		      h8 = this.h[8],
  		      h9 = this.h[9];

  		  var r0 = this.r[0],
  		      r1 = this.r[1],
  		      r2 = this.r[2],
  		      r3 = this.r[3],
  		      r4 = this.r[4],
  		      r5 = this.r[5],
  		      r6 = this.r[6],
  		      r7 = this.r[7],
  		      r8 = this.r[8],
  		      r9 = this.r[9];

  		  while (bytes >= 16) {
  		    t0 = m[mpos+ 0] & 0xff | (m[mpos+ 1] & 0xff) << 8; h0 += ( t0                     ) & 0x1fff;
  		    t1 = m[mpos+ 2] & 0xff | (m[mpos+ 3] & 0xff) << 8; h1 += ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
  		    t2 = m[mpos+ 4] & 0xff | (m[mpos+ 5] & 0xff) << 8; h2 += ((t1 >>> 10) | (t2 <<  6)) & 0x1fff;
  		    t3 = m[mpos+ 6] & 0xff | (m[mpos+ 7] & 0xff) << 8; h3 += ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
  		    t4 = m[mpos+ 8] & 0xff | (m[mpos+ 9] & 0xff) << 8; h4 += ((t3 >>>  4) | (t4 << 12)) & 0x1fff;
  		    h5 += ((t4 >>>  1)) & 0x1fff;
  		    t5 = m[mpos+10] & 0xff | (m[mpos+11] & 0xff) << 8; h6 += ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
  		    t6 = m[mpos+12] & 0xff | (m[mpos+13] & 0xff) << 8; h7 += ((t5 >>> 11) | (t6 <<  5)) & 0x1fff;
  		    t7 = m[mpos+14] & 0xff | (m[mpos+15] & 0xff) << 8; h8 += ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
  		    h9 += ((t7 >>> 5)) | hibit;

  		    c = 0;

  		    d0 = c;
  		    d0 += h0 * r0;
  		    d0 += h1 * (5 * r9);
  		    d0 += h2 * (5 * r8);
  		    d0 += h3 * (5 * r7);
  		    d0 += h4 * (5 * r6);
  		    c = (d0 >>> 13); d0 &= 0x1fff;
  		    d0 += h5 * (5 * r5);
  		    d0 += h6 * (5 * r4);
  		    d0 += h7 * (5 * r3);
  		    d0 += h8 * (5 * r2);
  		    d0 += h9 * (5 * r1);
  		    c += (d0 >>> 13); d0 &= 0x1fff;

  		    d1 = c;
  		    d1 += h0 * r1;
  		    d1 += h1 * r0;
  		    d1 += h2 * (5 * r9);
  		    d1 += h3 * (5 * r8);
  		    d1 += h4 * (5 * r7);
  		    c = (d1 >>> 13); d1 &= 0x1fff;
  		    d1 += h5 * (5 * r6);
  		    d1 += h6 * (5 * r5);
  		    d1 += h7 * (5 * r4);
  		    d1 += h8 * (5 * r3);
  		    d1 += h9 * (5 * r2);
  		    c += (d1 >>> 13); d1 &= 0x1fff;

  		    d2 = c;
  		    d2 += h0 * r2;
  		    d2 += h1 * r1;
  		    d2 += h2 * r0;
  		    d2 += h3 * (5 * r9);
  		    d2 += h4 * (5 * r8);
  		    c = (d2 >>> 13); d2 &= 0x1fff;
  		    d2 += h5 * (5 * r7);
  		    d2 += h6 * (5 * r6);
  		    d2 += h7 * (5 * r5);
  		    d2 += h8 * (5 * r4);
  		    d2 += h9 * (5 * r3);
  		    c += (d2 >>> 13); d2 &= 0x1fff;

  		    d3 = c;
  		    d3 += h0 * r3;
  		    d3 += h1 * r2;
  		    d3 += h2 * r1;
  		    d3 += h3 * r0;
  		    d3 += h4 * (5 * r9);
  		    c = (d3 >>> 13); d3 &= 0x1fff;
  		    d3 += h5 * (5 * r8);
  		    d3 += h6 * (5 * r7);
  		    d3 += h7 * (5 * r6);
  		    d3 += h8 * (5 * r5);
  		    d3 += h9 * (5 * r4);
  		    c += (d3 >>> 13); d3 &= 0x1fff;

  		    d4 = c;
  		    d4 += h0 * r4;
  		    d4 += h1 * r3;
  		    d4 += h2 * r2;
  		    d4 += h3 * r1;
  		    d4 += h4 * r0;
  		    c = (d4 >>> 13); d4 &= 0x1fff;
  		    d4 += h5 * (5 * r9);
  		    d4 += h6 * (5 * r8);
  		    d4 += h7 * (5 * r7);
  		    d4 += h8 * (5 * r6);
  		    d4 += h9 * (5 * r5);
  		    c += (d4 >>> 13); d4 &= 0x1fff;

  		    d5 = c;
  		    d5 += h0 * r5;
  		    d5 += h1 * r4;
  		    d5 += h2 * r3;
  		    d5 += h3 * r2;
  		    d5 += h4 * r1;
  		    c = (d5 >>> 13); d5 &= 0x1fff;
  		    d5 += h5 * r0;
  		    d5 += h6 * (5 * r9);
  		    d5 += h7 * (5 * r8);
  		    d5 += h8 * (5 * r7);
  		    d5 += h9 * (5 * r6);
  		    c += (d5 >>> 13); d5 &= 0x1fff;

  		    d6 = c;
  		    d6 += h0 * r6;
  		    d6 += h1 * r5;
  		    d6 += h2 * r4;
  		    d6 += h3 * r3;
  		    d6 += h4 * r2;
  		    c = (d6 >>> 13); d6 &= 0x1fff;
  		    d6 += h5 * r1;
  		    d6 += h6 * r0;
  		    d6 += h7 * (5 * r9);
  		    d6 += h8 * (5 * r8);
  		    d6 += h9 * (5 * r7);
  		    c += (d6 >>> 13); d6 &= 0x1fff;

  		    d7 = c;
  		    d7 += h0 * r7;
  		    d7 += h1 * r6;
  		    d7 += h2 * r5;
  		    d7 += h3 * r4;
  		    d7 += h4 * r3;
  		    c = (d7 >>> 13); d7 &= 0x1fff;
  		    d7 += h5 * r2;
  		    d7 += h6 * r1;
  		    d7 += h7 * r0;
  		    d7 += h8 * (5 * r9);
  		    d7 += h9 * (5 * r8);
  		    c += (d7 >>> 13); d7 &= 0x1fff;

  		    d8 = c;
  		    d8 += h0 * r8;
  		    d8 += h1 * r7;
  		    d8 += h2 * r6;
  		    d8 += h3 * r5;
  		    d8 += h4 * r4;
  		    c = (d8 >>> 13); d8 &= 0x1fff;
  		    d8 += h5 * r3;
  		    d8 += h6 * r2;
  		    d8 += h7 * r1;
  		    d8 += h8 * r0;
  		    d8 += h9 * (5 * r9);
  		    c += (d8 >>> 13); d8 &= 0x1fff;

  		    d9 = c;
  		    d9 += h0 * r9;
  		    d9 += h1 * r8;
  		    d9 += h2 * r7;
  		    d9 += h3 * r6;
  		    d9 += h4 * r5;
  		    c = (d9 >>> 13); d9 &= 0x1fff;
  		    d9 += h5 * r4;
  		    d9 += h6 * r3;
  		    d9 += h7 * r2;
  		    d9 += h8 * r1;
  		    d9 += h9 * r0;
  		    c += (d9 >>> 13); d9 &= 0x1fff;

  		    c = (((c << 2) + c)) | 0;
  		    c = (c + d0) | 0;
  		    d0 = c & 0x1fff;
  		    c = (c >>> 13);
  		    d1 += c;

  		    h0 = d0;
  		    h1 = d1;
  		    h2 = d2;
  		    h3 = d3;
  		    h4 = d4;
  		    h5 = d5;
  		    h6 = d6;
  		    h7 = d7;
  		    h8 = d8;
  		    h9 = d9;

  		    mpos += 16;
  		    bytes -= 16;
  		  }
  		  this.h[0] = h0;
  		  this.h[1] = h1;
  		  this.h[2] = h2;
  		  this.h[3] = h3;
  		  this.h[4] = h4;
  		  this.h[5] = h5;
  		  this.h[6] = h6;
  		  this.h[7] = h7;
  		  this.h[8] = h8;
  		  this.h[9] = h9;
  		};

  		poly1305.prototype.finish = function(mac, macpos) {
  		  var g = new Uint16Array(10);
  		  var c, mask, f, i;

  		  if (this.leftover) {
  		    i = this.leftover;
  		    this.buffer[i++] = 1;
  		    for (; i < 16; i++) this.buffer[i] = 0;
  		    this.fin = 1;
  		    this.blocks(this.buffer, 0, 16);
  		  }

  		  c = this.h[1] >>> 13;
  		  this.h[1] &= 0x1fff;
  		  for (i = 2; i < 10; i++) {
  		    this.h[i] += c;
  		    c = this.h[i] >>> 13;
  		    this.h[i] &= 0x1fff;
  		  }
  		  this.h[0] += (c * 5);
  		  c = this.h[0] >>> 13;
  		  this.h[0] &= 0x1fff;
  		  this.h[1] += c;
  		  c = this.h[1] >>> 13;
  		  this.h[1] &= 0x1fff;
  		  this.h[2] += c;

  		  g[0] = this.h[0] + 5;
  		  c = g[0] >>> 13;
  		  g[0] &= 0x1fff;
  		  for (i = 1; i < 10; i++) {
  		    g[i] = this.h[i] + c;
  		    c = g[i] >>> 13;
  		    g[i] &= 0x1fff;
  		  }
  		  g[9] -= (1 << 13);

  		  mask = (c ^ 1) - 1;
  		  for (i = 0; i < 10; i++) g[i] &= mask;
  		  mask = ~mask;
  		  for (i = 0; i < 10; i++) this.h[i] = (this.h[i] & mask) | g[i];

  		  this.h[0] = ((this.h[0]       ) | (this.h[1] << 13)                    ) & 0xffff;
  		  this.h[1] = ((this.h[1] >>>  3) | (this.h[2] << 10)                    ) & 0xffff;
  		  this.h[2] = ((this.h[2] >>>  6) | (this.h[3] <<  7)                    ) & 0xffff;
  		  this.h[3] = ((this.h[3] >>>  9) | (this.h[4] <<  4)                    ) & 0xffff;
  		  this.h[4] = ((this.h[4] >>> 12) | (this.h[5] <<  1) | (this.h[6] << 14)) & 0xffff;
  		  this.h[5] = ((this.h[6] >>>  2) | (this.h[7] << 11)                    ) & 0xffff;
  		  this.h[6] = ((this.h[7] >>>  5) | (this.h[8] <<  8)                    ) & 0xffff;
  		  this.h[7] = ((this.h[8] >>>  8) | (this.h[9] <<  5)                    ) & 0xffff;

  		  f = this.h[0] + this.pad[0];
  		  this.h[0] = f & 0xffff;
  		  for (i = 1; i < 8; i++) {
  		    f = (((this.h[i] + this.pad[i]) | 0) + (f >>> 16)) | 0;
  		    this.h[i] = f & 0xffff;
  		  }

  		  mac[macpos+ 0] = (this.h[0] >>> 0) & 0xff;
  		  mac[macpos+ 1] = (this.h[0] >>> 8) & 0xff;
  		  mac[macpos+ 2] = (this.h[1] >>> 0) & 0xff;
  		  mac[macpos+ 3] = (this.h[1] >>> 8) & 0xff;
  		  mac[macpos+ 4] = (this.h[2] >>> 0) & 0xff;
  		  mac[macpos+ 5] = (this.h[2] >>> 8) & 0xff;
  		  mac[macpos+ 6] = (this.h[3] >>> 0) & 0xff;
  		  mac[macpos+ 7] = (this.h[3] >>> 8) & 0xff;
  		  mac[macpos+ 8] = (this.h[4] >>> 0) & 0xff;
  		  mac[macpos+ 9] = (this.h[4] >>> 8) & 0xff;
  		  mac[macpos+10] = (this.h[5] >>> 0) & 0xff;
  		  mac[macpos+11] = (this.h[5] >>> 8) & 0xff;
  		  mac[macpos+12] = (this.h[6] >>> 0) & 0xff;
  		  mac[macpos+13] = (this.h[6] >>> 8) & 0xff;
  		  mac[macpos+14] = (this.h[7] >>> 0) & 0xff;
  		  mac[macpos+15] = (this.h[7] >>> 8) & 0xff;
  		};

  		poly1305.prototype.update = function(m, mpos, bytes) {
  		  var i, want;

  		  if (this.leftover) {
  		    want = (16 - this.leftover);
  		    if (want > bytes)
  		      want = bytes;
  		    for (i = 0; i < want; i++)
  		      this.buffer[this.leftover + i] = m[mpos+i];
  		    bytes -= want;
  		    mpos += want;
  		    this.leftover += want;
  		    if (this.leftover < 16)
  		      return;
  		    this.blocks(this.buffer, 0, 16);
  		    this.leftover = 0;
  		  }

  		  if (bytes >= 16) {
  		    want = bytes - (bytes % 16);
  		    this.blocks(m, mpos, want);
  		    mpos += want;
  		    bytes -= want;
  		  }

  		  if (bytes) {
  		    for (i = 0; i < bytes; i++)
  		      this.buffer[this.leftover + i] = m[mpos+i];
  		    this.leftover += bytes;
  		  }
  		};

  		function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
  		  var s = new poly1305(k);
  		  s.update(m, mpos, n);
  		  s.finish(out, outpos);
  		  return 0;
  		}

  		function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
  		  var x = new Uint8Array(16);
  		  crypto_onetimeauth(x,0,m,mpos,n,k);
  		  return crypto_verify_16(h,hpos,x,0);
  		}

  		function crypto_secretbox(c,m,d,n,k) {
  		  var i;
  		  if (d < 32) return -1;
  		  crypto_stream_xor(c,0,m,0,d,n,k);
  		  crypto_onetimeauth(c, 16, c, 32, d - 32, c);
  		  for (i = 0; i < 16; i++) c[i] = 0;
  		  return 0;
  		}

  		function crypto_secretbox_open(m,c,d,n,k) {
  		  var i;
  		  var x = new Uint8Array(32);
  		  if (d < 32) return -1;
  		  crypto_stream(x,0,32,n,k);
  		  if (crypto_onetimeauth_verify(c, 16,c, 32,d - 32,x) !== 0) return -1;
  		  crypto_stream_xor(m,0,c,0,d,n,k);
  		  for (i = 0; i < 32; i++) m[i] = 0;
  		  return 0;
  		}

  		function set25519(r, a) {
  		  var i;
  		  for (i = 0; i < 16; i++) r[i] = a[i]|0;
  		}

  		function car25519(o) {
  		  var i, v, c = 1;
  		  for (i = 0; i < 16; i++) {
  		    v = o[i] + c + 65535;
  		    c = Math.floor(v / 65536);
  		    o[i] = v - c * 65536;
  		  }
  		  o[0] += c-1 + 37 * (c-1);
  		}

  		function sel25519(p, q, b) {
  		  var t, c = ~(b-1);
  		  for (var i = 0; i < 16; i++) {
  		    t = c & (p[i] ^ q[i]);
  		    p[i] ^= t;
  		    q[i] ^= t;
  		  }
  		}

  		function pack25519(o, n) {
  		  var i, j, b;
  		  var m = gf(), t = gf();
  		  for (i = 0; i < 16; i++) t[i] = n[i];
  		  car25519(t);
  		  car25519(t);
  		  car25519(t);
  		  for (j = 0; j < 2; j++) {
  		    m[0] = t[0] - 0xffed;
  		    for (i = 1; i < 15; i++) {
  		      m[i] = t[i] - 0xffff - ((m[i-1]>>16) & 1);
  		      m[i-1] &= 0xffff;
  		    }
  		    m[15] = t[15] - 0x7fff - ((m[14]>>16) & 1);
  		    b = (m[15]>>16) & 1;
  		    m[14] &= 0xffff;
  		    sel25519(t, m, 1-b);
  		  }
  		  for (i = 0; i < 16; i++) {
  		    o[2*i] = t[i] & 0xff;
  		    o[2*i+1] = t[i]>>8;
  		  }
  		}

  		function neq25519(a, b) {
  		  var c = new Uint8Array(32), d = new Uint8Array(32);
  		  pack25519(c, a);
  		  pack25519(d, b);
  		  return crypto_verify_32(c, 0, d, 0);
  		}

  		function par25519(a) {
  		  var d = new Uint8Array(32);
  		  pack25519(d, a);
  		  return d[0] & 1;
  		}

  		function unpack25519(o, n) {
  		  var i;
  		  for (i = 0; i < 16; i++) o[i] = n[2*i] + (n[2*i+1] << 8);
  		  o[15] &= 0x7fff;
  		}

  		function A(o, a, b) {
  		  for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];
  		}

  		function Z(o, a, b) {
  		  for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];
  		}

  		function M(o, a, b) {
  		  var v, c,
  		     t0 = 0,  t1 = 0,  t2 = 0,  t3 = 0,  t4 = 0,  t5 = 0,  t6 = 0,  t7 = 0,
  		     t8 = 0,  t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0,
  		    t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0,
  		    t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0,
  		    b0 = b[0],
  		    b1 = b[1],
  		    b2 = b[2],
  		    b3 = b[3],
  		    b4 = b[4],
  		    b5 = b[5],
  		    b6 = b[6],
  		    b7 = b[7],
  		    b8 = b[8],
  		    b9 = b[9],
  		    b10 = b[10],
  		    b11 = b[11],
  		    b12 = b[12],
  		    b13 = b[13],
  		    b14 = b[14],
  		    b15 = b[15];

  		  v = a[0];
  		  t0 += v * b0;
  		  t1 += v * b1;
  		  t2 += v * b2;
  		  t3 += v * b3;
  		  t4 += v * b4;
  		  t5 += v * b5;
  		  t6 += v * b6;
  		  t7 += v * b7;
  		  t8 += v * b8;
  		  t9 += v * b9;
  		  t10 += v * b10;
  		  t11 += v * b11;
  		  t12 += v * b12;
  		  t13 += v * b13;
  		  t14 += v * b14;
  		  t15 += v * b15;
  		  v = a[1];
  		  t1 += v * b0;
  		  t2 += v * b1;
  		  t3 += v * b2;
  		  t4 += v * b3;
  		  t5 += v * b4;
  		  t6 += v * b5;
  		  t7 += v * b6;
  		  t8 += v * b7;
  		  t9 += v * b8;
  		  t10 += v * b9;
  		  t11 += v * b10;
  		  t12 += v * b11;
  		  t13 += v * b12;
  		  t14 += v * b13;
  		  t15 += v * b14;
  		  t16 += v * b15;
  		  v = a[2];
  		  t2 += v * b0;
  		  t3 += v * b1;
  		  t4 += v * b2;
  		  t5 += v * b3;
  		  t6 += v * b4;
  		  t7 += v * b5;
  		  t8 += v * b6;
  		  t9 += v * b7;
  		  t10 += v * b8;
  		  t11 += v * b9;
  		  t12 += v * b10;
  		  t13 += v * b11;
  		  t14 += v * b12;
  		  t15 += v * b13;
  		  t16 += v * b14;
  		  t17 += v * b15;
  		  v = a[3];
  		  t3 += v * b0;
  		  t4 += v * b1;
  		  t5 += v * b2;
  		  t6 += v * b3;
  		  t7 += v * b4;
  		  t8 += v * b5;
  		  t9 += v * b6;
  		  t10 += v * b7;
  		  t11 += v * b8;
  		  t12 += v * b9;
  		  t13 += v * b10;
  		  t14 += v * b11;
  		  t15 += v * b12;
  		  t16 += v * b13;
  		  t17 += v * b14;
  		  t18 += v * b15;
  		  v = a[4];
  		  t4 += v * b0;
  		  t5 += v * b1;
  		  t6 += v * b2;
  		  t7 += v * b3;
  		  t8 += v * b4;
  		  t9 += v * b5;
  		  t10 += v * b6;
  		  t11 += v * b7;
  		  t12 += v * b8;
  		  t13 += v * b9;
  		  t14 += v * b10;
  		  t15 += v * b11;
  		  t16 += v * b12;
  		  t17 += v * b13;
  		  t18 += v * b14;
  		  t19 += v * b15;
  		  v = a[5];
  		  t5 += v * b0;
  		  t6 += v * b1;
  		  t7 += v * b2;
  		  t8 += v * b3;
  		  t9 += v * b4;
  		  t10 += v * b5;
  		  t11 += v * b6;
  		  t12 += v * b7;
  		  t13 += v * b8;
  		  t14 += v * b9;
  		  t15 += v * b10;
  		  t16 += v * b11;
  		  t17 += v * b12;
  		  t18 += v * b13;
  		  t19 += v * b14;
  		  t20 += v * b15;
  		  v = a[6];
  		  t6 += v * b0;
  		  t7 += v * b1;
  		  t8 += v * b2;
  		  t9 += v * b3;
  		  t10 += v * b4;
  		  t11 += v * b5;
  		  t12 += v * b6;
  		  t13 += v * b7;
  		  t14 += v * b8;
  		  t15 += v * b9;
  		  t16 += v * b10;
  		  t17 += v * b11;
  		  t18 += v * b12;
  		  t19 += v * b13;
  		  t20 += v * b14;
  		  t21 += v * b15;
  		  v = a[7];
  		  t7 += v * b0;
  		  t8 += v * b1;
  		  t9 += v * b2;
  		  t10 += v * b3;
  		  t11 += v * b4;
  		  t12 += v * b5;
  		  t13 += v * b6;
  		  t14 += v * b7;
  		  t15 += v * b8;
  		  t16 += v * b9;
  		  t17 += v * b10;
  		  t18 += v * b11;
  		  t19 += v * b12;
  		  t20 += v * b13;
  		  t21 += v * b14;
  		  t22 += v * b15;
  		  v = a[8];
  		  t8 += v * b0;
  		  t9 += v * b1;
  		  t10 += v * b2;
  		  t11 += v * b3;
  		  t12 += v * b4;
  		  t13 += v * b5;
  		  t14 += v * b6;
  		  t15 += v * b7;
  		  t16 += v * b8;
  		  t17 += v * b9;
  		  t18 += v * b10;
  		  t19 += v * b11;
  		  t20 += v * b12;
  		  t21 += v * b13;
  		  t22 += v * b14;
  		  t23 += v * b15;
  		  v = a[9];
  		  t9 += v * b0;
  		  t10 += v * b1;
  		  t11 += v * b2;
  		  t12 += v * b3;
  		  t13 += v * b4;
  		  t14 += v * b5;
  		  t15 += v * b6;
  		  t16 += v * b7;
  		  t17 += v * b8;
  		  t18 += v * b9;
  		  t19 += v * b10;
  		  t20 += v * b11;
  		  t21 += v * b12;
  		  t22 += v * b13;
  		  t23 += v * b14;
  		  t24 += v * b15;
  		  v = a[10];
  		  t10 += v * b0;
  		  t11 += v * b1;
  		  t12 += v * b2;
  		  t13 += v * b3;
  		  t14 += v * b4;
  		  t15 += v * b5;
  		  t16 += v * b6;
  		  t17 += v * b7;
  		  t18 += v * b8;
  		  t19 += v * b9;
  		  t20 += v * b10;
  		  t21 += v * b11;
  		  t22 += v * b12;
  		  t23 += v * b13;
  		  t24 += v * b14;
  		  t25 += v * b15;
  		  v = a[11];
  		  t11 += v * b0;
  		  t12 += v * b1;
  		  t13 += v * b2;
  		  t14 += v * b3;
  		  t15 += v * b4;
  		  t16 += v * b5;
  		  t17 += v * b6;
  		  t18 += v * b7;
  		  t19 += v * b8;
  		  t20 += v * b9;
  		  t21 += v * b10;
  		  t22 += v * b11;
  		  t23 += v * b12;
  		  t24 += v * b13;
  		  t25 += v * b14;
  		  t26 += v * b15;
  		  v = a[12];
  		  t12 += v * b0;
  		  t13 += v * b1;
  		  t14 += v * b2;
  		  t15 += v * b3;
  		  t16 += v * b4;
  		  t17 += v * b5;
  		  t18 += v * b6;
  		  t19 += v * b7;
  		  t20 += v * b8;
  		  t21 += v * b9;
  		  t22 += v * b10;
  		  t23 += v * b11;
  		  t24 += v * b12;
  		  t25 += v * b13;
  		  t26 += v * b14;
  		  t27 += v * b15;
  		  v = a[13];
  		  t13 += v * b0;
  		  t14 += v * b1;
  		  t15 += v * b2;
  		  t16 += v * b3;
  		  t17 += v * b4;
  		  t18 += v * b5;
  		  t19 += v * b6;
  		  t20 += v * b7;
  		  t21 += v * b8;
  		  t22 += v * b9;
  		  t23 += v * b10;
  		  t24 += v * b11;
  		  t25 += v * b12;
  		  t26 += v * b13;
  		  t27 += v * b14;
  		  t28 += v * b15;
  		  v = a[14];
  		  t14 += v * b0;
  		  t15 += v * b1;
  		  t16 += v * b2;
  		  t17 += v * b3;
  		  t18 += v * b4;
  		  t19 += v * b5;
  		  t20 += v * b6;
  		  t21 += v * b7;
  		  t22 += v * b8;
  		  t23 += v * b9;
  		  t24 += v * b10;
  		  t25 += v * b11;
  		  t26 += v * b12;
  		  t27 += v * b13;
  		  t28 += v * b14;
  		  t29 += v * b15;
  		  v = a[15];
  		  t15 += v * b0;
  		  t16 += v * b1;
  		  t17 += v * b2;
  		  t18 += v * b3;
  		  t19 += v * b4;
  		  t20 += v * b5;
  		  t21 += v * b6;
  		  t22 += v * b7;
  		  t23 += v * b8;
  		  t24 += v * b9;
  		  t25 += v * b10;
  		  t26 += v * b11;
  		  t27 += v * b12;
  		  t28 += v * b13;
  		  t29 += v * b14;
  		  t30 += v * b15;

  		  t0  += 38 * t16;
  		  t1  += 38 * t17;
  		  t2  += 38 * t18;
  		  t3  += 38 * t19;
  		  t4  += 38 * t20;
  		  t5  += 38 * t21;
  		  t6  += 38 * t22;
  		  t7  += 38 * t23;
  		  t8  += 38 * t24;
  		  t9  += 38 * t25;
  		  t10 += 38 * t26;
  		  t11 += 38 * t27;
  		  t12 += 38 * t28;
  		  t13 += 38 * t29;
  		  t14 += 38 * t30;
  		  // t15 left as is

  		  // first car
  		  c = 1;
  		  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
  		  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
  		  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
  		  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
  		  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
  		  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
  		  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
  		  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
  		  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
  		  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
  		  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
  		  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
  		  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
  		  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
  		  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
  		  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
  		  t0 += c-1 + 37 * (c-1);

  		  // second car
  		  c = 1;
  		  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
  		  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
  		  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
  		  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
  		  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
  		  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
  		  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
  		  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
  		  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
  		  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
  		  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
  		  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
  		  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
  		  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
  		  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
  		  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
  		  t0 += c-1 + 37 * (c-1);

  		  o[ 0] = t0;
  		  o[ 1] = t1;
  		  o[ 2] = t2;
  		  o[ 3] = t3;
  		  o[ 4] = t4;
  		  o[ 5] = t5;
  		  o[ 6] = t6;
  		  o[ 7] = t7;
  		  o[ 8] = t8;
  		  o[ 9] = t9;
  		  o[10] = t10;
  		  o[11] = t11;
  		  o[12] = t12;
  		  o[13] = t13;
  		  o[14] = t14;
  		  o[15] = t15;
  		}

  		function S(o, a) {
  		  M(o, a, a);
  		}

  		function inv25519(o, i) {
  		  var c = gf();
  		  var a;
  		  for (a = 0; a < 16; a++) c[a] = i[a];
  		  for (a = 253; a >= 0; a--) {
  		    S(c, c);
  		    if(a !== 2 && a !== 4) M(c, c, i);
  		  }
  		  for (a = 0; a < 16; a++) o[a] = c[a];
  		}

  		function pow2523(o, i) {
  		  var c = gf();
  		  var a;
  		  for (a = 0; a < 16; a++) c[a] = i[a];
  		  for (a = 250; a >= 0; a--) {
  		      S(c, c);
  		      if(a !== 1) M(c, c, i);
  		  }
  		  for (a = 0; a < 16; a++) o[a] = c[a];
  		}

  		function crypto_scalarmult(q, n, p) {
  		  var z = new Uint8Array(32);
  		  var x = new Float64Array(80), r, i;
  		  var a = gf(), b = gf(), c = gf(),
  		      d = gf(), e = gf(), f = gf();
  		  for (i = 0; i < 31; i++) z[i] = n[i];
  		  z[31]=(n[31]&127)|64;
  		  z[0]&=248;
  		  unpack25519(x,p);
  		  for (i = 0; i < 16; i++) {
  		    b[i]=x[i];
  		    d[i]=a[i]=c[i]=0;
  		  }
  		  a[0]=d[0]=1;
  		  for (i=254; i>=0; --i) {
  		    r=(z[i>>>3]>>>(i&7))&1;
  		    sel25519(a,b,r);
  		    sel25519(c,d,r);
  		    A(e,a,c);
  		    Z(a,a,c);
  		    A(c,b,d);
  		    Z(b,b,d);
  		    S(d,e);
  		    S(f,a);
  		    M(a,c,a);
  		    M(c,b,e);
  		    A(e,a,c);
  		    Z(a,a,c);
  		    S(b,a);
  		    Z(c,d,f);
  		    M(a,c,_121665);
  		    A(a,a,d);
  		    M(c,c,a);
  		    M(a,d,f);
  		    M(d,b,x);
  		    S(b,e);
  		    sel25519(a,b,r);
  		    sel25519(c,d,r);
  		  }
  		  for (i = 0; i < 16; i++) {
  		    x[i+16]=a[i];
  		    x[i+32]=c[i];
  		    x[i+48]=b[i];
  		    x[i+64]=d[i];
  		  }
  		  var x32 = x.subarray(32);
  		  var x16 = x.subarray(16);
  		  inv25519(x32,x32);
  		  M(x16,x16,x32);
  		  pack25519(q,x16);
  		  return 0;
  		}

  		function crypto_scalarmult_base(q, n) {
  		  return crypto_scalarmult(q, n, _9);
  		}

  		function crypto_box_keypair(y, x) {
  		  randombytes(x, 32);
  		  return crypto_scalarmult_base(y, x);
  		}

  		function crypto_box_beforenm(k, y, x) {
  		  var s = new Uint8Array(32);
  		  crypto_scalarmult(s, x, y);
  		  return crypto_core_hsalsa20(k, _0, s, sigma);
  		}

  		var crypto_box_afternm = crypto_secretbox;
  		var crypto_box_open_afternm = crypto_secretbox_open;

  		function crypto_box(c, m, d, n, y, x) {
  		  var k = new Uint8Array(32);
  		  crypto_box_beforenm(k, y, x);
  		  return crypto_box_afternm(c, m, d, n, k);
  		}

  		function crypto_box_open(m, c, d, n, y, x) {
  		  var k = new Uint8Array(32);
  		  crypto_box_beforenm(k, y, x);
  		  return crypto_box_open_afternm(m, c, d, n, k);
  		}

  		var K = [
  		  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  		  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  		  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  		  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  		  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  		  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  		  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  		  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  		  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  		  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  		  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  		  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  		  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  		  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  		  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  		  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  		  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  		  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  		  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  		  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  		  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  		  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  		  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  		  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  		  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  		  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  		  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  		  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  		  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  		  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  		  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  		  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  		  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  		  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  		  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  		  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  		  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  		  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  		  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  		  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
  		];

  		function crypto_hashblocks_hl(hh, hl, m, n) {
  		  var wh = new Int32Array(16), wl = new Int32Array(16),
  		      bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7,
  		      bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7,
  		      th, tl, i, j, h, l, a, b, c, d;

  		  var ah0 = hh[0],
  		      ah1 = hh[1],
  		      ah2 = hh[2],
  		      ah3 = hh[3],
  		      ah4 = hh[4],
  		      ah5 = hh[5],
  		      ah6 = hh[6],
  		      ah7 = hh[7],

  		      al0 = hl[0],
  		      al1 = hl[1],
  		      al2 = hl[2],
  		      al3 = hl[3],
  		      al4 = hl[4],
  		      al5 = hl[5],
  		      al6 = hl[6],
  		      al7 = hl[7];

  		  var pos = 0;
  		  while (n >= 128) {
  		    for (i = 0; i < 16; i++) {
  		      j = 8 * i + pos;
  		      wh[i] = (m[j+0] << 24) | (m[j+1] << 16) | (m[j+2] << 8) | m[j+3];
  		      wl[i] = (m[j+4] << 24) | (m[j+5] << 16) | (m[j+6] << 8) | m[j+7];
  		    }
  		    for (i = 0; i < 80; i++) {
  		      bh0 = ah0;
  		      bh1 = ah1;
  		      bh2 = ah2;
  		      bh3 = ah3;
  		      bh4 = ah4;
  		      bh5 = ah5;
  		      bh6 = ah6;
  		      bh7 = ah7;

  		      bl0 = al0;
  		      bl1 = al1;
  		      bl2 = al2;
  		      bl3 = al3;
  		      bl4 = al4;
  		      bl5 = al5;
  		      bl6 = al6;
  		      bl7 = al7;

  		      // add
  		      h = ah7;
  		      l = al7;

  		      a = l & 0xffff; b = l >>> 16;
  		      c = h & 0xffff; d = h >>> 16;

  		      // Sigma1
  		      h = ((ah4 >>> 14) | (al4 << (32-14))) ^ ((ah4 >>> 18) | (al4 << (32-18))) ^ ((al4 >>> (41-32)) | (ah4 << (32-(41-32))));
  		      l = ((al4 >>> 14) | (ah4 << (32-14))) ^ ((al4 >>> 18) | (ah4 << (32-18))) ^ ((ah4 >>> (41-32)) | (al4 << (32-(41-32))));

  		      a += l & 0xffff; b += l >>> 16;
  		      c += h & 0xffff; d += h >>> 16;

  		      // Ch
  		      h = (ah4 & ah5) ^ (~ah4 & ah6);
  		      l = (al4 & al5) ^ (~al4 & al6);

  		      a += l & 0xffff; b += l >>> 16;
  		      c += h & 0xffff; d += h >>> 16;

  		      // K
  		      h = K[i*2];
  		      l = K[i*2+1];

  		      a += l & 0xffff; b += l >>> 16;
  		      c += h & 0xffff; d += h >>> 16;

  		      // w
  		      h = wh[i%16];
  		      l = wl[i%16];

  		      a += l & 0xffff; b += l >>> 16;
  		      c += h & 0xffff; d += h >>> 16;

  		      b += a >>> 16;
  		      c += b >>> 16;
  		      d += c >>> 16;

  		      th = c & 0xffff | d << 16;
  		      tl = a & 0xffff | b << 16;

  		      // add
  		      h = th;
  		      l = tl;

  		      a = l & 0xffff; b = l >>> 16;
  		      c = h & 0xffff; d = h >>> 16;

  		      // Sigma0
  		      h = ((ah0 >>> 28) | (al0 << (32-28))) ^ ((al0 >>> (34-32)) | (ah0 << (32-(34-32)))) ^ ((al0 >>> (39-32)) | (ah0 << (32-(39-32))));
  		      l = ((al0 >>> 28) | (ah0 << (32-28))) ^ ((ah0 >>> (34-32)) | (al0 << (32-(34-32)))) ^ ((ah0 >>> (39-32)) | (al0 << (32-(39-32))));

  		      a += l & 0xffff; b += l >>> 16;
  		      c += h & 0xffff; d += h >>> 16;

  		      // Maj
  		      h = (ah0 & ah1) ^ (ah0 & ah2) ^ (ah1 & ah2);
  		      l = (al0 & al1) ^ (al0 & al2) ^ (al1 & al2);

  		      a += l & 0xffff; b += l >>> 16;
  		      c += h & 0xffff; d += h >>> 16;

  		      b += a >>> 16;
  		      c += b >>> 16;
  		      d += c >>> 16;

  		      bh7 = (c & 0xffff) | (d << 16);
  		      bl7 = (a & 0xffff) | (b << 16);

  		      // add
  		      h = bh3;
  		      l = bl3;

  		      a = l & 0xffff; b = l >>> 16;
  		      c = h & 0xffff; d = h >>> 16;

  		      h = th;
  		      l = tl;

  		      a += l & 0xffff; b += l >>> 16;
  		      c += h & 0xffff; d += h >>> 16;

  		      b += a >>> 16;
  		      c += b >>> 16;
  		      d += c >>> 16;

  		      bh3 = (c & 0xffff) | (d << 16);
  		      bl3 = (a & 0xffff) | (b << 16);

  		      ah1 = bh0;
  		      ah2 = bh1;
  		      ah3 = bh2;
  		      ah4 = bh3;
  		      ah5 = bh4;
  		      ah6 = bh5;
  		      ah7 = bh6;
  		      ah0 = bh7;

  		      al1 = bl0;
  		      al2 = bl1;
  		      al3 = bl2;
  		      al4 = bl3;
  		      al5 = bl4;
  		      al6 = bl5;
  		      al7 = bl6;
  		      al0 = bl7;

  		      if (i%16 === 15) {
  		        for (j = 0; j < 16; j++) {
  		          // add
  		          h = wh[j];
  		          l = wl[j];

  		          a = l & 0xffff; b = l >>> 16;
  		          c = h & 0xffff; d = h >>> 16;

  		          h = wh[(j+9)%16];
  		          l = wl[(j+9)%16];

  		          a += l & 0xffff; b += l >>> 16;
  		          c += h & 0xffff; d += h >>> 16;

  		          // sigma0
  		          th = wh[(j+1)%16];
  		          tl = wl[(j+1)%16];
  		          h = ((th >>> 1) | (tl << (32-1))) ^ ((th >>> 8) | (tl << (32-8))) ^ (th >>> 7);
  		          l = ((tl >>> 1) | (th << (32-1))) ^ ((tl >>> 8) | (th << (32-8))) ^ ((tl >>> 7) | (th << (32-7)));

  		          a += l & 0xffff; b += l >>> 16;
  		          c += h & 0xffff; d += h >>> 16;

  		          // sigma1
  		          th = wh[(j+14)%16];
  		          tl = wl[(j+14)%16];
  		          h = ((th >>> 19) | (tl << (32-19))) ^ ((tl >>> (61-32)) | (th << (32-(61-32)))) ^ (th >>> 6);
  		          l = ((tl >>> 19) | (th << (32-19))) ^ ((th >>> (61-32)) | (tl << (32-(61-32)))) ^ ((tl >>> 6) | (th << (32-6)));

  		          a += l & 0xffff; b += l >>> 16;
  		          c += h & 0xffff; d += h >>> 16;

  		          b += a >>> 16;
  		          c += b >>> 16;
  		          d += c >>> 16;

  		          wh[j] = (c & 0xffff) | (d << 16);
  		          wl[j] = (a & 0xffff) | (b << 16);
  		        }
  		      }
  		    }

  		    // add
  		    h = ah0;
  		    l = al0;

  		    a = l & 0xffff; b = l >>> 16;
  		    c = h & 0xffff; d = h >>> 16;

  		    h = hh[0];
  		    l = hl[0];

  		    a += l & 0xffff; b += l >>> 16;
  		    c += h & 0xffff; d += h >>> 16;

  		    b += a >>> 16;
  		    c += b >>> 16;
  		    d += c >>> 16;

  		    hh[0] = ah0 = (c & 0xffff) | (d << 16);
  		    hl[0] = al0 = (a & 0xffff) | (b << 16);

  		    h = ah1;
  		    l = al1;

  		    a = l & 0xffff; b = l >>> 16;
  		    c = h & 0xffff; d = h >>> 16;

  		    h = hh[1];
  		    l = hl[1];

  		    a += l & 0xffff; b += l >>> 16;
  		    c += h & 0xffff; d += h >>> 16;

  		    b += a >>> 16;
  		    c += b >>> 16;
  		    d += c >>> 16;

  		    hh[1] = ah1 = (c & 0xffff) | (d << 16);
  		    hl[1] = al1 = (a & 0xffff) | (b << 16);

  		    h = ah2;
  		    l = al2;

  		    a = l & 0xffff; b = l >>> 16;
  		    c = h & 0xffff; d = h >>> 16;

  		    h = hh[2];
  		    l = hl[2];

  		    a += l & 0xffff; b += l >>> 16;
  		    c += h & 0xffff; d += h >>> 16;

  		    b += a >>> 16;
  		    c += b >>> 16;
  		    d += c >>> 16;

  		    hh[2] = ah2 = (c & 0xffff) | (d << 16);
  		    hl[2] = al2 = (a & 0xffff) | (b << 16);

  		    h = ah3;
  		    l = al3;

  		    a = l & 0xffff; b = l >>> 16;
  		    c = h & 0xffff; d = h >>> 16;

  		    h = hh[3];
  		    l = hl[3];

  		    a += l & 0xffff; b += l >>> 16;
  		    c += h & 0xffff; d += h >>> 16;

  		    b += a >>> 16;
  		    c += b >>> 16;
  		    d += c >>> 16;

  		    hh[3] = ah3 = (c & 0xffff) | (d << 16);
  		    hl[3] = al3 = (a & 0xffff) | (b << 16);

  		    h = ah4;
  		    l = al4;

  		    a = l & 0xffff; b = l >>> 16;
  		    c = h & 0xffff; d = h >>> 16;

  		    h = hh[4];
  		    l = hl[4];

  		    a += l & 0xffff; b += l >>> 16;
  		    c += h & 0xffff; d += h >>> 16;

  		    b += a >>> 16;
  		    c += b >>> 16;
  		    d += c >>> 16;

  		    hh[4] = ah4 = (c & 0xffff) | (d << 16);
  		    hl[4] = al4 = (a & 0xffff) | (b << 16);

  		    h = ah5;
  		    l = al5;

  		    a = l & 0xffff; b = l >>> 16;
  		    c = h & 0xffff; d = h >>> 16;

  		    h = hh[5];
  		    l = hl[5];

  		    a += l & 0xffff; b += l >>> 16;
  		    c += h & 0xffff; d += h >>> 16;

  		    b += a >>> 16;
  		    c += b >>> 16;
  		    d += c >>> 16;

  		    hh[5] = ah5 = (c & 0xffff) | (d << 16);
  		    hl[5] = al5 = (a & 0xffff) | (b << 16);

  		    h = ah6;
  		    l = al6;

  		    a = l & 0xffff; b = l >>> 16;
  		    c = h & 0xffff; d = h >>> 16;

  		    h = hh[6];
  		    l = hl[6];

  		    a += l & 0xffff; b += l >>> 16;
  		    c += h & 0xffff; d += h >>> 16;

  		    b += a >>> 16;
  		    c += b >>> 16;
  		    d += c >>> 16;

  		    hh[6] = ah6 = (c & 0xffff) | (d << 16);
  		    hl[6] = al6 = (a & 0xffff) | (b << 16);

  		    h = ah7;
  		    l = al7;

  		    a = l & 0xffff; b = l >>> 16;
  		    c = h & 0xffff; d = h >>> 16;

  		    h = hh[7];
  		    l = hl[7];

  		    a += l & 0xffff; b += l >>> 16;
  		    c += h & 0xffff; d += h >>> 16;

  		    b += a >>> 16;
  		    c += b >>> 16;
  		    d += c >>> 16;

  		    hh[7] = ah7 = (c & 0xffff) | (d << 16);
  		    hl[7] = al7 = (a & 0xffff) | (b << 16);

  		    pos += 128;
  		    n -= 128;
  		  }

  		  return n;
  		}

  		function crypto_hash(out, m, n) {
  		  var hh = new Int32Array(8),
  		      hl = new Int32Array(8),
  		      x = new Uint8Array(256),
  		      i, b = n;

  		  hh[0] = 0x6a09e667;
  		  hh[1] = 0xbb67ae85;
  		  hh[2] = 0x3c6ef372;
  		  hh[3] = 0xa54ff53a;
  		  hh[4] = 0x510e527f;
  		  hh[5] = 0x9b05688c;
  		  hh[6] = 0x1f83d9ab;
  		  hh[7] = 0x5be0cd19;

  		  hl[0] = 0xf3bcc908;
  		  hl[1] = 0x84caa73b;
  		  hl[2] = 0xfe94f82b;
  		  hl[3] = 0x5f1d36f1;
  		  hl[4] = 0xade682d1;
  		  hl[5] = 0x2b3e6c1f;
  		  hl[6] = 0xfb41bd6b;
  		  hl[7] = 0x137e2179;

  		  crypto_hashblocks_hl(hh, hl, m, n);
  		  n %= 128;

  		  for (i = 0; i < n; i++) x[i] = m[b-n+i];
  		  x[n] = 128;

  		  n = 256-128*(n<112?1:0);
  		  x[n-9] = 0;
  		  ts64(x, n-8,  (b / 0x20000000) | 0, b << 3);
  		  crypto_hashblocks_hl(hh, hl, x, n);

  		  for (i = 0; i < 8; i++) ts64(out, 8*i, hh[i], hl[i]);

  		  return 0;
  		}

  		function add(p, q) {
  		  var a = gf(), b = gf(), c = gf(),
  		      d = gf(), e = gf(), f = gf(),
  		      g = gf(), h = gf(), t = gf();

  		  Z(a, p[1], p[0]);
  		  Z(t, q[1], q[0]);
  		  M(a, a, t);
  		  A(b, p[0], p[1]);
  		  A(t, q[0], q[1]);
  		  M(b, b, t);
  		  M(c, p[3], q[3]);
  		  M(c, c, D2);
  		  M(d, p[2], q[2]);
  		  A(d, d, d);
  		  Z(e, b, a);
  		  Z(f, d, c);
  		  A(g, d, c);
  		  A(h, b, a);

  		  M(p[0], e, f);
  		  M(p[1], h, g);
  		  M(p[2], g, f);
  		  M(p[3], e, h);
  		}

  		function cswap(p, q, b) {
  		  var i;
  		  for (i = 0; i < 4; i++) {
  		    sel25519(p[i], q[i], b);
  		  }
  		}

  		function pack(r, p) {
  		  var tx = gf(), ty = gf(), zi = gf();
  		  inv25519(zi, p[2]);
  		  M(tx, p[0], zi);
  		  M(ty, p[1], zi);
  		  pack25519(r, ty);
  		  r[31] ^= par25519(tx) << 7;
  		}

  		function scalarmult(p, q, s) {
  		  var b, i;
  		  set25519(p[0], gf0);
  		  set25519(p[1], gf1);
  		  set25519(p[2], gf1);
  		  set25519(p[3], gf0);
  		  for (i = 255; i >= 0; --i) {
  		    b = (s[(i/8)|0] >> (i&7)) & 1;
  		    cswap(p, q, b);
  		    add(q, p);
  		    add(p, p);
  		    cswap(p, q, b);
  		  }
  		}

  		function scalarbase(p, s) {
  		  var q = [gf(), gf(), gf(), gf()];
  		  set25519(q[0], X);
  		  set25519(q[1], Y);
  		  set25519(q[2], gf1);
  		  M(q[3], X, Y);
  		  scalarmult(p, q, s);
  		}

  		function crypto_sign_keypair(pk, sk, seeded) {
  		  var d = new Uint8Array(64);
  		  var p = [gf(), gf(), gf(), gf()];
  		  var i;

  		  if (!seeded) randombytes(sk, 32);
  		  crypto_hash(d, sk, 32);
  		  d[0] &= 248;
  		  d[31] &= 127;
  		  d[31] |= 64;

  		  scalarbase(p, d);
  		  pack(pk, p);

  		  for (i = 0; i < 32; i++) sk[i+32] = pk[i];
  		  return 0;
  		}

  		var L = new Float64Array([0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10]);

  		function modL(r, x) {
  		  var carry, i, j, k;
  		  for (i = 63; i >= 32; --i) {
  		    carry = 0;
  		    for (j = i - 32, k = i - 12; j < k; ++j) {
  		      x[j] += carry - 16 * x[i] * L[j - (i - 32)];
  		      carry = Math.floor((x[j] + 128) / 256);
  		      x[j] -= carry * 256;
  		    }
  		    x[j] += carry;
  		    x[i] = 0;
  		  }
  		  carry = 0;
  		  for (j = 0; j < 32; j++) {
  		    x[j] += carry - (x[31] >> 4) * L[j];
  		    carry = x[j] >> 8;
  		    x[j] &= 255;
  		  }
  		  for (j = 0; j < 32; j++) x[j] -= carry * L[j];
  		  for (i = 0; i < 32; i++) {
  		    x[i+1] += x[i] >> 8;
  		    r[i] = x[i] & 255;
  		  }
  		}

  		function reduce(r) {
  		  var x = new Float64Array(64), i;
  		  for (i = 0; i < 64; i++) x[i] = r[i];
  		  for (i = 0; i < 64; i++) r[i] = 0;
  		  modL(r, x);
  		}

  		// Note: difference from C - smlen returned, not passed as argument.
  		function crypto_sign(sm, m, n, sk) {
  		  var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
  		  var i, j, x = new Float64Array(64);
  		  var p = [gf(), gf(), gf(), gf()];

  		  crypto_hash(d, sk, 32);
  		  d[0] &= 248;
  		  d[31] &= 127;
  		  d[31] |= 64;

  		  var smlen = n + 64;
  		  for (i = 0; i < n; i++) sm[64 + i] = m[i];
  		  for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];

  		  crypto_hash(r, sm.subarray(32), n+32);
  		  reduce(r);
  		  scalarbase(p, r);
  		  pack(sm, p);

  		  for (i = 32; i < 64; i++) sm[i] = sk[i];
  		  crypto_hash(h, sm, n + 64);
  		  reduce(h);

  		  for (i = 0; i < 64; i++) x[i] = 0;
  		  for (i = 0; i < 32; i++) x[i] = r[i];
  		  for (i = 0; i < 32; i++) {
  		    for (j = 0; j < 32; j++) {
  		      x[i+j] += h[i] * d[j];
  		    }
  		  }

  		  modL(sm.subarray(32), x);
  		  return smlen;
  		}

  		function unpackneg(r, p) {
  		  var t = gf(), chk = gf(), num = gf(),
  		      den = gf(), den2 = gf(), den4 = gf(),
  		      den6 = gf();

  		  set25519(r[2], gf1);
  		  unpack25519(r[1], p);
  		  S(num, r[1]);
  		  M(den, num, D);
  		  Z(num, num, r[2]);
  		  A(den, r[2], den);

  		  S(den2, den);
  		  S(den4, den2);
  		  M(den6, den4, den2);
  		  M(t, den6, num);
  		  M(t, t, den);

  		  pow2523(t, t);
  		  M(t, t, num);
  		  M(t, t, den);
  		  M(t, t, den);
  		  M(r[0], t, den);

  		  S(chk, r[0]);
  		  M(chk, chk, den);
  		  if (neq25519(chk, num)) M(r[0], r[0], I);

  		  S(chk, r[0]);
  		  M(chk, chk, den);
  		  if (neq25519(chk, num)) return -1;

  		  if (par25519(r[0]) === (p[31]>>7)) Z(r[0], gf0, r[0]);

  		  M(r[3], r[0], r[1]);
  		  return 0;
  		}

  		function crypto_sign_open(m, sm, n, pk) {
  		  var i;
  		  var t = new Uint8Array(32), h = new Uint8Array(64);
  		  var p = [gf(), gf(), gf(), gf()],
  		      q = [gf(), gf(), gf(), gf()];

  		  if (n < 64) return -1;

  		  if (unpackneg(q, pk)) return -1;

  		  for (i = 0; i < n; i++) m[i] = sm[i];
  		  for (i = 0; i < 32; i++) m[i+32] = pk[i];
  		  crypto_hash(h, m, n);
  		  reduce(h);
  		  scalarmult(p, q, h);

  		  scalarbase(q, sm.subarray(32));
  		  add(p, q);
  		  pack(t, p);

  		  n -= 64;
  		  if (crypto_verify_32(sm, 0, t, 0)) {
  		    for (i = 0; i < n; i++) m[i] = 0;
  		    return -1;
  		  }

  		  for (i = 0; i < n; i++) m[i] = sm[i + 64];
  		  return n;
  		}

  		var crypto_secretbox_KEYBYTES = 32,
  		    crypto_secretbox_NONCEBYTES = 24,
  		    crypto_secretbox_ZEROBYTES = 32,
  		    crypto_secretbox_BOXZEROBYTES = 16,
  		    crypto_scalarmult_BYTES = 32,
  		    crypto_scalarmult_SCALARBYTES = 32,
  		    crypto_box_PUBLICKEYBYTES = 32,
  		    crypto_box_SECRETKEYBYTES = 32,
  		    crypto_box_BEFORENMBYTES = 32,
  		    crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES,
  		    crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES,
  		    crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES,
  		    crypto_sign_BYTES = 64,
  		    crypto_sign_PUBLICKEYBYTES = 32,
  		    crypto_sign_SECRETKEYBYTES = 64,
  		    crypto_sign_SEEDBYTES = 32,
  		    crypto_hash_BYTES = 64;

  		nacl.lowlevel = {
  		  crypto_core_hsalsa20: crypto_core_hsalsa20,
  		  crypto_stream_xor: crypto_stream_xor,
  		  crypto_stream: crypto_stream,
  		  crypto_stream_salsa20_xor: crypto_stream_salsa20_xor,
  		  crypto_stream_salsa20: crypto_stream_salsa20,
  		  crypto_onetimeauth: crypto_onetimeauth,
  		  crypto_onetimeauth_verify: crypto_onetimeauth_verify,
  		  crypto_verify_16: crypto_verify_16,
  		  crypto_verify_32: crypto_verify_32,
  		  crypto_secretbox: crypto_secretbox,
  		  crypto_secretbox_open: crypto_secretbox_open,
  		  crypto_scalarmult: crypto_scalarmult,
  		  crypto_scalarmult_base: crypto_scalarmult_base,
  		  crypto_box_beforenm: crypto_box_beforenm,
  		  crypto_box_afternm: crypto_box_afternm,
  		  crypto_box: crypto_box,
  		  crypto_box_open: crypto_box_open,
  		  crypto_box_keypair: crypto_box_keypair,
  		  crypto_hash: crypto_hash,
  		  crypto_sign: crypto_sign,
  		  crypto_sign_keypair: crypto_sign_keypair,
  		  crypto_sign_open: crypto_sign_open,

  		  crypto_secretbox_KEYBYTES: crypto_secretbox_KEYBYTES,
  		  crypto_secretbox_NONCEBYTES: crypto_secretbox_NONCEBYTES,
  		  crypto_secretbox_ZEROBYTES: crypto_secretbox_ZEROBYTES,
  		  crypto_secretbox_BOXZEROBYTES: crypto_secretbox_BOXZEROBYTES,
  		  crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,
  		  crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,
  		  crypto_box_PUBLICKEYBYTES: crypto_box_PUBLICKEYBYTES,
  		  crypto_box_SECRETKEYBYTES: crypto_box_SECRETKEYBYTES,
  		  crypto_box_BEFORENMBYTES: crypto_box_BEFORENMBYTES,
  		  crypto_box_NONCEBYTES: crypto_box_NONCEBYTES,
  		  crypto_box_ZEROBYTES: crypto_box_ZEROBYTES,
  		  crypto_box_BOXZEROBYTES: crypto_box_BOXZEROBYTES,
  		  crypto_sign_BYTES: crypto_sign_BYTES,
  		  crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,
  		  crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,
  		  crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,
  		  crypto_hash_BYTES: crypto_hash_BYTES,

  		  gf: gf,
  		  D: D,
  		  L: L,
  		  pack25519: pack25519,
  		  unpack25519: unpack25519,
  		  M: M,
  		  A: A,
  		  S: S,
  		  Z: Z,
  		  pow2523: pow2523,
  		  add: add,
  		  set25519: set25519,
  		  modL: modL,
  		  scalarmult: scalarmult,
  		  scalarbase: scalarbase,
  		};

  		/* High-level API */

  		function checkLengths(k, n) {
  		  if (k.length !== crypto_secretbox_KEYBYTES) throw new Error('bad key size');
  		  if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error('bad nonce size');
  		}

  		function checkBoxLengths(pk, sk) {
  		  if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error('bad public key size');
  		  if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');
  		}

  		function checkArrayTypes() {
  		  for (var i = 0; i < arguments.length; i++) {
  		    if (!(arguments[i] instanceof Uint8Array))
  		      throw new TypeError('unexpected type, use Uint8Array');
  		  }
  		}

  		function cleanup(arr) {
  		  for (var i = 0; i < arr.length; i++) arr[i] = 0;
  		}

  		nacl.randomBytes = function(n) {
  		  var b = new Uint8Array(n);
  		  randombytes(b, n);
  		  return b;
  		};

  		nacl.secretbox = function(msg, nonce, key) {
  		  checkArrayTypes(msg, nonce, key);
  		  checkLengths(key, nonce);
  		  var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
  		  var c = new Uint8Array(m.length);
  		  for (var i = 0; i < msg.length; i++) m[i+crypto_secretbox_ZEROBYTES] = msg[i];
  		  crypto_secretbox(c, m, m.length, nonce, key);
  		  return c.subarray(crypto_secretbox_BOXZEROBYTES);
  		};

  		nacl.secretbox.open = function(box, nonce, key) {
  		  checkArrayTypes(box, nonce, key);
  		  checkLengths(key, nonce);
  		  var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
  		  var m = new Uint8Array(c.length);
  		  for (var i = 0; i < box.length; i++) c[i+crypto_secretbox_BOXZEROBYTES] = box[i];
  		  if (c.length < 32) return null;
  		  if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return null;
  		  return m.subarray(crypto_secretbox_ZEROBYTES);
  		};

  		nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
  		nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
  		nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;

  		nacl.scalarMult = function(n, p) {
  		  checkArrayTypes(n, p);
  		  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
  		  if (p.length !== crypto_scalarmult_BYTES) throw new Error('bad p size');
  		  var q = new Uint8Array(crypto_scalarmult_BYTES);
  		  crypto_scalarmult(q, n, p);
  		  return q;
  		};

  		nacl.scalarMult.base = function(n) {
  		  checkArrayTypes(n);
  		  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
  		  var q = new Uint8Array(crypto_scalarmult_BYTES);
  		  crypto_scalarmult_base(q, n);
  		  return q;
  		};

  		nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
  		nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;

  		nacl.box = function(msg, nonce, publicKey, secretKey) {
  		  var k = nacl.box.before(publicKey, secretKey);
  		  return nacl.secretbox(msg, nonce, k);
  		};

  		nacl.box.before = function(publicKey, secretKey) {
  		  checkArrayTypes(publicKey, secretKey);
  		  checkBoxLengths(publicKey, secretKey);
  		  var k = new Uint8Array(crypto_box_BEFORENMBYTES);
  		  crypto_box_beforenm(k, publicKey, secretKey);
  		  return k;
  		};

  		nacl.box.after = nacl.secretbox;

  		nacl.box.open = function(msg, nonce, publicKey, secretKey) {
  		  var k = nacl.box.before(publicKey, secretKey);
  		  return nacl.secretbox.open(msg, nonce, k);
  		};

  		nacl.box.open.after = nacl.secretbox.open;

  		nacl.box.keyPair = function() {
  		  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
  		  var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
  		  crypto_box_keypair(pk, sk);
  		  return {publicKey: pk, secretKey: sk};
  		};

  		nacl.box.keyPair.fromSecretKey = function(secretKey) {
  		  checkArrayTypes(secretKey);
  		  if (secretKey.length !== crypto_box_SECRETKEYBYTES)
  		    throw new Error('bad secret key size');
  		  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
  		  crypto_scalarmult_base(pk, secretKey);
  		  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
  		};

  		nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
  		nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
  		nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
  		nacl.box.nonceLength = crypto_box_NONCEBYTES;
  		nacl.box.overheadLength = nacl.secretbox.overheadLength;

  		nacl.sign = function(msg, secretKey) {
  		  checkArrayTypes(msg, secretKey);
  		  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
  		    throw new Error('bad secret key size');
  		  var signedMsg = new Uint8Array(crypto_sign_BYTES+msg.length);
  		  crypto_sign(signedMsg, msg, msg.length, secretKey);
  		  return signedMsg;
  		};

  		nacl.sign.open = function(signedMsg, publicKey) {
  		  checkArrayTypes(signedMsg, publicKey);
  		  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
  		    throw new Error('bad public key size');
  		  var tmp = new Uint8Array(signedMsg.length);
  		  var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
  		  if (mlen < 0) return null;
  		  var m = new Uint8Array(mlen);
  		  for (var i = 0; i < m.length; i++) m[i] = tmp[i];
  		  return m;
  		};

  		nacl.sign.detached = function(msg, secretKey) {
  		  var signedMsg = nacl.sign(msg, secretKey);
  		  var sig = new Uint8Array(crypto_sign_BYTES);
  		  for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];
  		  return sig;
  		};

  		nacl.sign.detached.verify = function(msg, sig, publicKey) {
  		  checkArrayTypes(msg, sig, publicKey);
  		  if (sig.length !== crypto_sign_BYTES)
  		    throw new Error('bad signature size');
  		  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
  		    throw new Error('bad public key size');
  		  var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
  		  var m = new Uint8Array(crypto_sign_BYTES + msg.length);
  		  var i;
  		  for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];
  		  for (i = 0; i < msg.length; i++) sm[i+crypto_sign_BYTES] = msg[i];
  		  return (crypto_sign_open(m, sm, sm.length, publicKey) >= 0);
  		};

  		nacl.sign.keyPair = function() {
  		  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  		  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
  		  crypto_sign_keypair(pk, sk);
  		  return {publicKey: pk, secretKey: sk};
  		};

  		nacl.sign.keyPair.fromSecretKey = function(secretKey) {
  		  checkArrayTypes(secretKey);
  		  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
  		    throw new Error('bad secret key size');
  		  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  		  for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32+i];
  		  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
  		};

  		nacl.sign.keyPair.fromSeed = function(seed) {
  		  checkArrayTypes(seed);
  		  if (seed.length !== crypto_sign_SEEDBYTES)
  		    throw new Error('bad seed size');
  		  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  		  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
  		  for (var i = 0; i < 32; i++) sk[i] = seed[i];
  		  crypto_sign_keypair(pk, sk, true);
  		  return {publicKey: pk, secretKey: sk};
  		};

  		nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
  		nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
  		nacl.sign.seedLength = crypto_sign_SEEDBYTES;
  		nacl.sign.signatureLength = crypto_sign_BYTES;

  		nacl.hash = function(msg) {
  		  checkArrayTypes(msg);
  		  var h = new Uint8Array(crypto_hash_BYTES);
  		  crypto_hash(h, msg, msg.length);
  		  return h;
  		};

  		nacl.hash.hashLength = crypto_hash_BYTES;

  		nacl.verify = function(x, y) {
  		  checkArrayTypes(x, y);
  		  // Zero length arguments are considered not equal.
  		  if (x.length === 0 || y.length === 0) return false;
  		  if (x.length !== y.length) return false;
  		  return (vn(x, 0, y, 0, x.length) === 0) ? true : false;
  		};

  		nacl.setPRNG = function(fn) {
  		  randombytes = fn;
  		};

  		(function() {
  		  // Initialize PRNG if environment provides CSPRNG.
  		  // If not, methods calling randombytes will throw.
  		  var crypto = typeof self !== 'undefined' ? (self.crypto || self.msCrypto) : null;
  		  if (crypto && crypto.getRandomValues) {
  		    // Browsers.
  		    var QUOTA = 65536;
  		    nacl.setPRNG(function(x, n) {
  		      var i, v = new Uint8Array(n);
  		      for (i = 0; i < n; i += QUOTA) {
  		        crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
  		      }
  		      for (i = 0; i < n; i++) x[i] = v[i];
  		      cleanup(v);
  		    });
  		  } else if (typeof commonjsRequire !== 'undefined') {
  		    // Node.js.
  		    crypto = require$$0;
  		    if (crypto && crypto.randomBytes) {
  		      nacl.setPRNG(function(x, n) {
  		        var i, v = crypto.randomBytes(n);
  		        for (i = 0; i < n; i++) x[i] = v[i];
  		        cleanup(v);
  		      });
  		    }
  		  }
  		})();

  		})(module.exports ? module.exports : (self.nacl = self.nacl || {})); 
  	} (naclFast));
  	return naclFast.exports;
  }

  var naclFastExports = requireNaclFast();
  var nacl = /*@__PURE__*/getDefaultExportFromCjs(naclFastExports);

  /**
   * @param {Uint8Array} array1
   * @param {Uint8Array} array2
   * @returns {boolean}
   */
  function arrayEqual$1(array1, array2) {
      if (array1 === array2) {
          return true;
      }

      if (array1.byteLength !== array2.byteLength) {
          return false;
      }

      const view1 = new DataView(
          array1.buffer,
          array1.byteOffset,
          array1.byteLength,
      );
      const view2 = new DataView(
          array2.buffer,
          array2.byteOffset,
          array2.byteLength,
      );

      let i = array1.byteLength;

      while (i--) {
          if (view1.getUint8(i) !== view2.getUint8(i)) {
              return false;
          }
      }

      return true;
  }

  /**
   * @param {Uint8Array} array
   * @param {Uint8Array} arrayPrefix
   * @returns {boolean}
   */
  function arrayStartsWith(array, arrayPrefix) {
      if (array.byteLength < arrayPrefix.byteLength) {
          return false;
      }

      let i = arrayPrefix.byteLength;

      while (i--) {
          if (array[i] !== arrayPrefix[i]) {
              return false;
          }
      }

      return true;
  }

  /**
   * @type {string[]}
   */
  const byteToHex = [];

  for (let n = 0; n <= 0xff; n += 1) {
      byteToHex.push(n.toString(16).padStart(2, "0"));
  }

  /**
   * @param {Uint8Array} data
   * @returns {string}
   */
  function encode$3(data) {
      let string = "";

      for (const byte of data) {
          string += byteToHex[byte];
      }

      return string;
  }

  /**
   * @param {string} text
   * @returns {Uint8Array}
   */
  function decode$6(text) {
      const str = text.startsWith("0x") ? text.substring(2) : text;
      const result = str.match(/.{1,2}/gu);

      return new Uint8Array(
          (result == null ? [] : result).map((byte) => parseInt(byte, 16)),
      );
  }

  const derPrefix$3 = "302a300506032b6570032100";
  const derPrefixBytes$3 = decode$6(derPrefix$3);

  /**
   * An public key on the Hedera network.
   */
  class Ed25519PublicKey extends Key$1 {
      /**
       * @internal
       * @hideconstructor
       * @param {Uint8Array} keyData
       */
      constructor(keyData) {
          super();

          /**
           * @type {Uint8Array}
           * @private
           * @readonly
           */
          this._keyData = keyData;
      }

      /**
       * @returns {string}
       */
      get _type() {
          return "ED25519";
      }

      /**
       * @param {Uint8Array} data
       * @returns {Ed25519PublicKey}
       */
      static fromBytes(data) {
          switch (data.length) {
              case 32:
                  return Ed25519PublicKey.fromBytesRaw(data);
              case 44:
                  return Ed25519PublicKey.fromBytesDer(data);
              default:
                  throw new BadKeyError(
                      `invalid public key length: ${data.length} bytes`,
                  );
          }
      }

      /**
       * @param {Uint8Array} data
       * @returns {Ed25519PublicKey}
       */
      static fromBytesDer(data) {
          try {
              // Verify minimum length (44 bytes is standard for Ed25519 public key in DER)
              if (data.length !== 44) {
                  throw new Error(`invalid length: ${data.length} bytes`);
              }

              const actualPrefix = data.subarray(0, 12);

              if (!actualPrefix.every((byte, i) => byte === derPrefixBytes$3[i])) {
                  throw new Error("invalid DER prefix");
              }
              // Extract the public key (last 32 bytes)
              const publicKey = data.subarray(12);
              return new Ed25519PublicKey(publicKey);
          } catch (error) {
              throw new BadKeyError(
                  `cannot decode ED25519 public key data from DER format: ${
                    error instanceof Error ? error.message : "unknown error"
                }`,
              );
          }
      }

      /**
       * @param {Uint8Array} data
       * @returns {Ed25519PublicKey}
       */
      static fromBytesRaw(data) {
          if (data.length != 32) {
              throw new BadKeyError(
                  `invalid public key length: ${data.length} bytes`,
              );
          }

          return new Ed25519PublicKey(data);
      }

      /**
       * Parse a public key from a string of hexadecimal digits.
       *
       * The public key may optionally be prefixed with
       * the DER header.
       * @param {string} text
       * @returns {Ed25519PublicKey}
       */
      static fromString(text) {
          return Ed25519PublicKey.fromBytes(decode$6(text));
      }

      /**
       * Verify a signature on a message with this public key.
       * @param {Uint8Array} message
       * @param {Uint8Array} signature
       * @returns {boolean}
       */
      verify(message, signature) {
          return nacl.sign.detached.verify(message, signature, this._keyData);
      }

      /**
       * @returns {Uint8Array}
       */
      toBytesDer() {
          const bytes = new Uint8Array(derPrefixBytes$3.length + 32);

          bytes.set(derPrefixBytes$3, 0);
          bytes.set(this._keyData.subarray(0, 32), derPrefixBytes$3.length);

          return bytes;
      }

      /**
       * @returns {Uint8Array}
       */
      toBytesRaw() {
          return this._keyData.slice();
      }

      /**
       * @param {Ed25519PublicKey} other
       * @returns {boolean}
       */
      equals(other) {
          return arrayEqual$1(this._keyData, other._keyData);
      }
  }

  /**
   * @param {number} count
   * @returns {Uint8Array}
   */
  function bytes(count) {
      return nacl.randomBytes(count);
  }

  /**
   * @param {number} count
   * @returns {Promise<Uint8Array>}
   */
  function bytesAsync(count) {
      return Promise.resolve(nacl.randomBytes(count));
  }

  /**
   * @param {Uint8Array} data
   * @returns {string}
   */
  function decode$5(data) {
      // eslint-disable-next-line n/no-unsupported-features/node-builtins
      return new TextDecoder().decode(data);
  }

  /**
   * @param {string} text
   * @returns {Uint8Array}
   */
  function encode$2(text) {
      // eslint-disable-next-line n/no-unsupported-features/node-builtins
      return new TextEncoder().encode(text);
  }

  // this will be executed in browser environment so we can use window.crypto
  /* eslint-disable n/no-unsupported-features/node-builtins */

  /**
   * @enum {string}
   */
  const HashAlgorithm = {
      Sha256: "SHA-256",
      Sha384: "SHA-384",
      Sha512: "SHA-512",
  };

  /**
   * @param {HashAlgorithm} algorithm
   * @param {Uint8Array | string} secretKey
   * @param {Uint8Array | string} data
   * @returns {Promise<Uint8Array>}
   */
  async function hash(algorithm, secretKey, data) {
      const key =
          typeof secretKey === "string" ? encode$2(secretKey) : secretKey;
      const value = typeof data === "string" ? encode$2(data) : data;

      try {
          const key_ = await window.crypto.subtle.importKey(
              "raw",
              key,
              {
                  name: "HMAC",
                  hash: algorithm,
              },
              false,
              ["sign"],
          );

          return new Uint8Array(
              await window.crypto.subtle.sign("HMAC", key_, value),
          );
      } catch {
          throw new Error("Fallback if SubtleCrypto fails is not implemented");
      }
  }

  /**
   * Internal assertion helpers.
   * @module
   */
  /** Asserts something is positive integer. */
  function anumber(n) {
      if (!Number.isSafeInteger(n) || n < 0)
          throw new Error('positive integer expected, got ' + n);
  }
  /** Is number an Uint8Array? Copied from utils for perf. */
  function isBytes$2(a) {
      return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');
  }
  /** Asserts something is Uint8Array. */
  function abytes$1(b, ...lengths) {
      if (!isBytes$2(b))
          throw new Error('Uint8Array expected');
      if (lengths.length > 0 && !lengths.includes(b.length))
          throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);
  }
  /** Asserts something is hash */
  function ahash(h) {
      if (typeof h !== 'function' || typeof h.create !== 'function')
          throw new Error('Hash should be wrapped by utils.wrapConstructor');
      anumber(h.outputLen);
      anumber(h.blockLen);
  }
  /** Asserts a hash instance has not been destroyed / finished */
  function aexists(instance, checkFinished = true) {
      if (instance.destroyed)
          throw new Error('Hash instance has been destroyed');
      if (checkFinished && instance.finished)
          throw new Error('Hash#digest() has already been called');
  }
  /** Asserts output is properly-sized byte array */
  function aoutput(out, instance) {
      abytes$1(out);
      const min = instance.outputLen;
      if (out.length < min) {
          throw new Error('digestInto() expects output buffer of length at least ' + min);
      }
  }

  const crypto$1 = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;

  /**
   * Utilities for hex, bytes, CSPRNG.
   * @module
   */
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  // We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
  // node.js versions earlier than v19 don't declare it in global scope.
  // For node.js, package.json#exports field mapping rewrites import
  // from `crypto` to `cryptoNode`, which imports native module.
  // Makes the utils un-importable in browsers without a bundler.
  // Once node.js 18 is deprecated (2025-04-30), we can just drop the import.
  // Cast array to view
  function createView(arr) {
      return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  }
  /** The rotate right (circular right shift) operation for uint32 */
  function rotr(word, shift) {
      return (word << (32 - shift)) | (word >>> shift);
  }
  /**
   * Convert JS string to byte array.
   * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
   */
  function utf8ToBytes$1(str) {
      if (typeof str !== 'string')
          throw new Error('utf8ToBytes expected string, got ' + typeof str);
      return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
  }
  /**
   * Normalizes (non-hex) string or Uint8Array to Uint8Array.
   * Warning: when Uint8Array is passed, it would NOT get copied.
   * Keep in mind for future mutable operations.
   */
  function toBytes(data) {
      if (typeof data === 'string')
          data = utf8ToBytes$1(data);
      abytes$1(data);
      return data;
  }
  /**
   * Copies several Uint8Arrays into one.
   */
  function concatBytes$1(...arrays) {
      let sum = 0;
      for (let i = 0; i < arrays.length; i++) {
          const a = arrays[i];
          abytes$1(a);
          sum += a.length;
      }
      const res = new Uint8Array(sum);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
          const a = arrays[i];
          res.set(a, pad);
          pad += a.length;
      }
      return res;
  }
  /** For runtime check if class implements interface */
  class Hash {
      // Safe version that clones internal state
      clone() {
          return this._cloneInto();
      }
  }
  /** Wraps hash function, creating an interface on top of it */
  function wrapConstructor(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
  }
  /** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */
  function randomBytes(bytesLength = 32) {
      if (crypto$1 && typeof crypto$1.getRandomValues === 'function') {
          return crypto$1.getRandomValues(new Uint8Array(bytesLength));
      }
      // Legacy Node.js compatibility
      if (crypto$1 && typeof crypto$1.randomBytes === 'function') {
          return crypto$1.randomBytes(bytesLength);
      }
      throw new Error('crypto.getRandomValues must be defined');
  }

  /**
   * Internal Merkle-Damgard hash utils.
   * @module
   */
  /** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */
  function setBigUint64(view, byteOffset, value, isLE) {
      if (typeof view.setBigUint64 === 'function')
          return view.setBigUint64(byteOffset, value, isLE);
      const _32n = BigInt(32);
      const _u32_max = BigInt(0xffffffff);
      const wh = Number((value >> _32n) & _u32_max);
      const wl = Number(value & _u32_max);
      const h = isLE ? 4 : 0;
      const l = isLE ? 0 : 4;
      view.setUint32(byteOffset + h, wh, isLE);
      view.setUint32(byteOffset + l, wl, isLE);
  }
  /** Choice: a ? b : c */
  function Chi(a, b, c) {
      return (a & b) ^ (~a & c);
  }
  /** Majority function, true if any two inputs is true. */
  function Maj(a, b, c) {
      return (a & b) ^ (a & c) ^ (b & c);
  }
  /**
   * Merkle-Damgard hash construction base class.
   * Could be used to create MD5, RIPEMD, SHA1, SHA2.
   */
  class HashMD extends Hash {
      constructor(blockLen, outputLen, padOffset, isLE) {
          super();
          this.blockLen = blockLen;
          this.outputLen = outputLen;
          this.padOffset = padOffset;
          this.isLE = isLE;
          this.finished = false;
          this.length = 0;
          this.pos = 0;
          this.destroyed = false;
          this.buffer = new Uint8Array(blockLen);
          this.view = createView(this.buffer);
      }
      update(data) {
          aexists(this);
          const { view, buffer, blockLen } = this;
          data = toBytes(data);
          const len = data.length;
          for (let pos = 0; pos < len;) {
              const take = Math.min(blockLen - this.pos, len - pos);
              // Fast path: we have at least one block in input, cast it to view and process
              if (take === blockLen) {
                  const dataView = createView(data);
                  for (; blockLen <= len - pos; pos += blockLen)
                      this.process(dataView, pos);
                  continue;
              }
              buffer.set(data.subarray(pos, pos + take), this.pos);
              this.pos += take;
              pos += take;
              if (this.pos === blockLen) {
                  this.process(view, 0);
                  this.pos = 0;
              }
          }
          this.length += data.length;
          this.roundClean();
          return this;
      }
      digestInto(out) {
          aexists(this);
          aoutput(out, this);
          this.finished = true;
          // Padding
          // We can avoid allocation of buffer for padding completely if it
          // was previously not allocated here. But it won't change performance.
          const { buffer, view, blockLen, isLE } = this;
          let { pos } = this;
          // append the bit '1' to the message
          buffer[pos++] = 0b10000000;
          this.buffer.subarray(pos).fill(0);
          // we have less than padOffset left in buffer, so we cannot put length in
          // current block, need process it and pad again
          if (this.padOffset > blockLen - pos) {
              this.process(view, 0);
              pos = 0;
          }
          // Pad until full block byte with zeros
          for (let i = pos; i < blockLen; i++)
              buffer[i] = 0;
          // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
          // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
          // So we just write lowest 64 bits of that value.
          setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
          this.process(view, 0);
          const oview = createView(out);
          const len = this.outputLen;
          // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
          if (len % 4)
              throw new Error('_sha2: outputLen should be aligned to 32bit');
          const outLen = len / 4;
          const state = this.get();
          if (outLen > state.length)
              throw new Error('_sha2: outputLen bigger than state');
          for (let i = 0; i < outLen; i++)
              oview.setUint32(4 * i, state[i], isLE);
      }
      digest() {
          const { buffer, outputLen } = this;
          this.digestInto(buffer);
          const res = buffer.slice(0, outputLen);
          this.destroy();
          return res;
      }
      _cloneInto(to) {
          to || (to = new this.constructor());
          to.set(...this.get());
          const { blockLen, buffer, length, finished, destroyed, pos } = this;
          to.length = length;
          to.pos = pos;
          to.finished = finished;
          to.destroyed = destroyed;
          if (length % blockLen)
              to.buffer.set(buffer);
          return to;
      }
  }

  /**
   * SHA2-256 a.k.a. sha256. In JS, it is the fastest hash, even faster than Blake3.
   *
   * To break sha256 using birthday attack, attackers need to try 2^128 hashes.
   * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.
   *
   * Check out [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).
   * @module
   */
  /** Round constants: first 32 bits of fractional parts of the cube roots of the first 64 primes 2..311). */
  // prettier-ignore
  const SHA256_K = /* @__PURE__ */ new Uint32Array([
      0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
      0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
      0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
      0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
      0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
      0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
      0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
      0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
  ]);
  /** Initial state: first 32 bits of fractional parts of the square roots of the first 8 primes 2..19. */
  // prettier-ignore
  const SHA256_IV = /* @__PURE__ */ new Uint32Array([
      0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  ]);
  /**
   * Temporary buffer, not used to store anything between runs.
   * Named this way because it matches specification.
   */
  const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
  class SHA256 extends HashMD {
      constructor() {
          super(64, 32, 8, false);
          // We cannot use array here since array allows indexing by variable
          // which means optimizer/compiler cannot use registers.
          this.A = SHA256_IV[0] | 0;
          this.B = SHA256_IV[1] | 0;
          this.C = SHA256_IV[2] | 0;
          this.D = SHA256_IV[3] | 0;
          this.E = SHA256_IV[4] | 0;
          this.F = SHA256_IV[5] | 0;
          this.G = SHA256_IV[6] | 0;
          this.H = SHA256_IV[7] | 0;
      }
      get() {
          const { A, B, C, D, E, F, G, H } = this;
          return [A, B, C, D, E, F, G, H];
      }
      // prettier-ignore
      set(A, B, C, D, E, F, G, H) {
          this.A = A | 0;
          this.B = B | 0;
          this.C = C | 0;
          this.D = D | 0;
          this.E = E | 0;
          this.F = F | 0;
          this.G = G | 0;
          this.H = H | 0;
      }
      process(view, offset) {
          // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
          for (let i = 0; i < 16; i++, offset += 4)
              SHA256_W[i] = view.getUint32(offset, false);
          for (let i = 16; i < 64; i++) {
              const W15 = SHA256_W[i - 15];
              const W2 = SHA256_W[i - 2];
              const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);
              const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);
              SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;
          }
          // Compression function main loop, 64 rounds
          let { A, B, C, D, E, F, G, H } = this;
          for (let i = 0; i < 64; i++) {
              const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
              const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
              const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
              const T2 = (sigma0 + Maj(A, B, C)) | 0;
              H = G;
              G = F;
              F = E;
              E = (D + T1) | 0;
              D = C;
              C = B;
              B = A;
              A = (T1 + T2) | 0;
          }
          // Add the compressed chunk to the current hash value
          A = (A + this.A) | 0;
          B = (B + this.B) | 0;
          C = (C + this.C) | 0;
          D = (D + this.D) | 0;
          E = (E + this.E) | 0;
          F = (F + this.F) | 0;
          G = (G + this.G) | 0;
          H = (H + this.H) | 0;
          this.set(A, B, C, D, E, F, G, H);
      }
      roundClean() {
          SHA256_W.fill(0);
      }
      destroy() {
          this.set(0, 0, 0, 0, 0, 0, 0, 0);
          this.buffer.fill(0);
      }
  }
  /** SHA2-256 hash function */
  const sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());

  /**
   * HMAC: RFC2104 message authentication code.
   * @module
   */
  class HMAC extends Hash {
      constructor(hash, _key) {
          super();
          this.finished = false;
          this.destroyed = false;
          ahash(hash);
          const key = toBytes(_key);
          this.iHash = hash.create();
          if (typeof this.iHash.update !== 'function')
              throw new Error('Expected instance of class which extends utils.Hash');
          this.blockLen = this.iHash.blockLen;
          this.outputLen = this.iHash.outputLen;
          const blockLen = this.blockLen;
          const pad = new Uint8Array(blockLen);
          // blockLen can be bigger than outputLen
          pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
          for (let i = 0; i < pad.length; i++)
              pad[i] ^= 0x36;
          this.iHash.update(pad);
          // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone
          this.oHash = hash.create();
          // Undo internal XOR && apply outer XOR
          for (let i = 0; i < pad.length; i++)
              pad[i] ^= 0x36 ^ 0x5c;
          this.oHash.update(pad);
          pad.fill(0);
      }
      update(buf) {
          aexists(this);
          this.iHash.update(buf);
          return this;
      }
      digestInto(out) {
          aexists(this);
          abytes$1(out, this.outputLen);
          this.finished = true;
          this.iHash.digestInto(out);
          this.oHash.update(out);
          this.oHash.digestInto(out);
          this.destroy();
      }
      digest() {
          const out = new Uint8Array(this.oHash.outputLen);
          this.digestInto(out);
          return out;
      }
      _cloneInto(to) {
          // Create new instance without calling constructor since key already in state and we don't know it.
          to || (to = Object.create(Object.getPrototypeOf(this), {}));
          const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
          to = to;
          to.finished = finished;
          to.destroyed = destroyed;
          to.blockLen = blockLen;
          to.outputLen = outputLen;
          to.oHash = oHash._cloneInto(to.oHash);
          to.iHash = iHash._cloneInto(to.iHash);
          return to;
      }
      destroy() {
          this.destroyed = true;
          this.oHash.destroy();
          this.iHash.destroy();
      }
  }
  /**
   * HMAC: RFC2104 message authentication code.
   * @param hash - function that would be used e.g. sha256
   * @param key - message key
   * @param message - message data
   * @example
   * import { hmac } from '@noble/hashes/hmac';
   * import { sha256 } from '@noble/hashes/sha2';
   * const mac1 = hmac(sha256, 'key', 'message');
   */
  const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
  hmac.create = (hash, key) => new HMAC(hash, key);

  /**
   * Hex, bytes and number utilities.
   * @module
   */
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  // 100 lines of code in the file are duplicated from noble-hashes (utils).
  // This is OK: `abstract` directory does not use noble-hashes.
  // User may opt-in into using different hashing library. This way, noble-hashes
  // won't be included into their bundle.
  const _0n$3 = /* @__PURE__ */ BigInt(0);
  const _1n$4 = /* @__PURE__ */ BigInt(1);
  const _2n$2 = /* @__PURE__ */ BigInt(2);
  function isBytes$1(a) {
      return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');
  }
  function abytes(item) {
      if (!isBytes$1(item))
          throw new Error('Uint8Array expected');
  }
  function abool(title, value) {
      if (typeof value !== 'boolean')
          throw new Error(title + ' boolean expected, got ' + value);
  }
  // Array where index 0xf0 (240) is mapped to string 'f0'
  const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));
  /**
   * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
   */
  function bytesToHex(bytes) {
      abytes(bytes);
      // pre-caching improves the speed 6x
      let hex = '';
      for (let i = 0; i < bytes.length; i++) {
          hex += hexes[bytes[i]];
      }
      return hex;
  }
  function numberToHexUnpadded(num) {
      const hex = num.toString(16);
      return hex.length & 1 ? '0' + hex : hex;
  }
  function hexToNumber(hex) {
      if (typeof hex !== 'string')
          throw new Error('hex string expected, got ' + typeof hex);
      return hex === '' ? _0n$3 : BigInt('0x' + hex); // Big Endian
  }
  // We use optimized technique to convert hex string to byte array
  const asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
  function asciiToBase16(ch) {
      if (ch >= asciis._0 && ch <= asciis._9)
          return ch - asciis._0; // '2' => 50-48
      if (ch >= asciis.A && ch <= asciis.F)
          return ch - (asciis.A - 10); // 'B' => 66-(65-10)
      if (ch >= asciis.a && ch <= asciis.f)
          return ch - (asciis.a - 10); // 'b' => 98-(97-10)
      return;
  }
  /**
   * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
   */
  function hexToBytes(hex) {
      if (typeof hex !== 'string')
          throw new Error('hex string expected, got ' + typeof hex);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2)
          throw new Error('hex string expected, got unpadded hex of length ' + hl);
      const array = new Uint8Array(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
          const n1 = asciiToBase16(hex.charCodeAt(hi));
          const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
          if (n1 === undefined || n2 === undefined) {
              const char = hex[hi] + hex[hi + 1];
              throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
          }
          array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163
      }
      return array;
  }
  // BE: Big Endian, LE: Little Endian
  function bytesToNumberBE(bytes) {
      return hexToNumber(bytesToHex(bytes));
  }
  function bytesToNumberLE(bytes) {
      abytes(bytes);
      return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
  }
  function numberToBytesBE(n, len) {
      return hexToBytes(n.toString(16).padStart(len * 2, '0'));
  }
  function numberToBytesLE(n, len) {
      return numberToBytesBE(n, len).reverse();
  }
  // Unpadded, rarely used
  function numberToVarBytesBE(n) {
      return hexToBytes(numberToHexUnpadded(n));
  }
  /**
   * Takes hex string or Uint8Array, converts to Uint8Array.
   * Validates output length.
   * Will throw error for other types.
   * @param title descriptive title for an error e.g. 'private key'
   * @param hex hex string or Uint8Array
   * @param expectedLength optional, will compare to result array's length
   * @returns
   */
  function ensureBytes(title, hex, expectedLength) {
      let res;
      if (typeof hex === 'string') {
          try {
              res = hexToBytes(hex);
          }
          catch (e) {
              throw new Error(title + ' must be hex string or Uint8Array, cause: ' + e);
          }
      }
      else if (isBytes$1(hex)) {
          // Uint8Array.from() instead of hash.slice() because node.js Buffer
          // is instance of Uint8Array, and its slice() creates **mutable** copy
          res = Uint8Array.from(hex);
      }
      else {
          throw new Error(title + ' must be hex string or Uint8Array');
      }
      const len = res.length;
      if (typeof expectedLength === 'number' && len !== expectedLength)
          throw new Error(title + ' of length ' + expectedLength + ' expected, got ' + len);
      return res;
  }
  /**
   * Copies several Uint8Arrays into one.
   */
  function concatBytes(...arrays) {
      let sum = 0;
      for (let i = 0; i < arrays.length; i++) {
          const a = arrays[i];
          abytes(a);
          sum += a.length;
      }
      const res = new Uint8Array(sum);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
          const a = arrays[i];
          res.set(a, pad);
          pad += a.length;
      }
      return res;
  }
  // Compares 2 u8a-s in kinda constant time
  function equalBytes$1(a, b) {
      if (a.length !== b.length)
          return false;
      let diff = 0;
      for (let i = 0; i < a.length; i++)
          diff |= a[i] ^ b[i];
      return diff === 0;
  }
  /**
   * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
   */
  function utf8ToBytes(str) {
      if (typeof str !== 'string')
          throw new Error('string expected');
      return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
  }
  // Is positive bigint
  const isPosBig = (n) => typeof n === 'bigint' && _0n$3 <= n;
  function inRange(n, min, max) {
      return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
  }
  /**
   * Asserts min <= n < max. NOTE: It's < max and not <= max.
   * @example
   * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)
   */
  function aInRange(title, n, min, max) {
      // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?
      // consider P=256n, min=0n, max=P
      // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`
      // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`
      // - our way is the cleanest:               `inRange('x', x, 0n, P)
      if (!inRange(n, min, max))
          throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);
  }
  // Bit operations
  /**
   * Calculates amount of bits in a bigint.
   * Same as `n.toString(2).length`
   */
  function bitLen(n) {
      let len;
      for (len = 0; n > _0n$3; n >>= _1n$4, len += 1)
          ;
      return len;
  }
  /**
   * Gets single bit at position.
   * NOTE: first bit position is 0 (same as arrays)
   * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`
   */
  function bitGet(n, pos) {
      return (n >> BigInt(pos)) & _1n$4;
  }
  /**
   * Sets single bit at position.
   */
  function bitSet(n, pos, value) {
      return n | ((value ? _1n$4 : _0n$3) << BigInt(pos));
  }
  /**
   * Calculate mask for N bits. Not using ** operator with bigints because of old engines.
   * Same as BigInt(`0b${Array(i).fill('1').join('')}`)
   */
  const bitMask = (n) => (_2n$2 << BigInt(n - 1)) - _1n$4;
  // DRBG
  const u8n = (data) => new Uint8Array(data); // creates Uint8Array
  const u8fr = (arr) => Uint8Array.from(arr); // another shortcut
  /**
   * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
   * @returns function that will call DRBG until 2nd arg returns something meaningful
   * @example
   *   const drbg = createHmacDRBG<Key>(32, 32, hmac);
   *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined
   */
  function createHmacDrbg(hashLen, qByteLen, hmacFn) {
      if (typeof hashLen !== 'number' || hashLen < 2)
          throw new Error('hashLen must be a number');
      if (typeof qByteLen !== 'number' || qByteLen < 2)
          throw new Error('qByteLen must be a number');
      if (typeof hmacFn !== 'function')
          throw new Error('hmacFn must be a function');
      // Step B, Step C: set hashLen to 8*ceil(hlen/8)
      let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
      let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same
      let i = 0; // Iterations counter, will throw when over 1000
      const reset = () => {
          v.fill(1);
          k.fill(0);
          i = 0;
      };
      const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)
      const reseed = (seed = u8n()) => {
          // HMAC-DRBG reseed() function. Steps D-G
          k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)
          v = h(); // v = hmac(k || v)
          if (seed.length === 0)
              return;
          k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)
          v = h(); // v = hmac(k || v)
      };
      const gen = () => {
          // HMAC-DRBG generate() function
          if (i++ >= 1000)
              throw new Error('drbg: tried 1000 values');
          let len = 0;
          const out = [];
          while (len < qByteLen) {
              v = h();
              const sl = v.slice();
              out.push(sl);
              len += v.length;
          }
          return concatBytes(...out);
      };
      const genUntil = (seed, pred) => {
          reset();
          reseed(seed); // Steps D-G
          let res = undefined; // Step H: grind until k is in [1..n-1]
          while (!(res = pred(gen())))
              reseed();
          reset();
          return res;
      };
      return genUntil;
  }
  // Validating curves and fields
  const validatorFns = {
      bigint: (val) => typeof val === 'bigint',
      function: (val) => typeof val === 'function',
      boolean: (val) => typeof val === 'boolean',
      string: (val) => typeof val === 'string',
      stringOrUint8Array: (val) => typeof val === 'string' || isBytes$1(val),
      isSafeInteger: (val) => Number.isSafeInteger(val),
      array: (val) => Array.isArray(val),
      field: (val, object) => object.Fp.isValid(val),
      hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),
  };
  // type Record<K extends string | number | symbol, T> = { [P in K]: T; }
  function validateObject(object, validators, optValidators = {}) {
      const checkField = (fieldName, type, isOptional) => {
          const checkVal = validatorFns[type];
          if (typeof checkVal !== 'function')
              throw new Error('invalid validator function');
          const val = object[fieldName];
          if (isOptional && val === undefined)
              return;
          if (!checkVal(val, object)) {
              throw new Error('param ' + String(fieldName) + ' is invalid. Expected ' + type + ', got ' + val);
          }
      };
      for (const [fieldName, type] of Object.entries(validators))
          checkField(fieldName, type, false);
      for (const [fieldName, type] of Object.entries(optValidators))
          checkField(fieldName, type, true);
      return object;
  }
  // validate type tests
  // const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };
  // const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!
  // // Should fail type-check
  // const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });
  // const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });
  // const z3 = validateObject(o, { test: 'boolean', z: 'bug' });
  // const z4 = validateObject(o, { a: 'boolean', z: 'bug' });
  /**
   * throws not implemented error
   */
  const notImplemented = () => {
      throw new Error('not implemented');
  };
  /**
   * Memoizes (caches) computation result.
   * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.
   */
  function memoized(fn) {
      const map = new WeakMap();
      return (arg, ...args) => {
          const val = map.get(arg);
          if (val !== undefined)
              return val;
          const computed = fn(arg, ...args);
          map.set(arg, computed);
          return computed;
      };
  }

  var ut = /*#__PURE__*/Object.freeze({
    __proto__: null,
    aInRange: aInRange,
    abool: abool,
    abytes: abytes,
    bitGet: bitGet,
    bitLen: bitLen,
    bitMask: bitMask,
    bitSet: bitSet,
    bytesToHex: bytesToHex,
    bytesToNumberBE: bytesToNumberBE,
    bytesToNumberLE: bytesToNumberLE,
    concatBytes: concatBytes,
    createHmacDrbg: createHmacDrbg,
    ensureBytes: ensureBytes,
    equalBytes: equalBytes$1,
    hexToBytes: hexToBytes,
    hexToNumber: hexToNumber,
    inRange: inRange,
    isBytes: isBytes$1,
    memoized: memoized,
    notImplemented: notImplemented,
    numberToBytesBE: numberToBytesBE,
    numberToBytesLE: numberToBytesLE,
    numberToHexUnpadded: numberToHexUnpadded,
    numberToVarBytesBE: numberToVarBytesBE,
    utf8ToBytes: utf8ToBytes,
    validateObject: validateObject
  });

  /**
   * Utils for modular division and finite fields.
   * A finite field over 11 is integer number operations `mod 11`.
   * There is no division: it is replaced by modular multiplicative inverse.
   * @module
   */
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  // prettier-ignore
  const _0n$2 = BigInt(0), _1n$3 = BigInt(1), _2n$1 = /* @__PURE__ */ BigInt(2), _3n$1 = /* @__PURE__ */ BigInt(3);
  // prettier-ignore
  const _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5), _8n = /* @__PURE__ */ BigInt(8);
  // Calculates a modulo b
  function mod(a, b) {
      const result = a % b;
      return result >= _0n$2 ? result : b + result;
  }
  /**
   * Efficiently raise num to power and do modular division.
   * Unsafe in some contexts: uses ladder, so can expose bigint bits.
   * @todo use field version && remove
   * @example
   * pow(2n, 6n, 11n) // 64n % 11n == 9n
   */
  function pow(num, power, modulo) {
      if (power < _0n$2)
          throw new Error('invalid exponent, negatives unsupported');
      if (modulo <= _0n$2)
          throw new Error('invalid modulus');
      if (modulo === _1n$3)
          return _0n$2;
      let res = _1n$3;
      while (power > _0n$2) {
          if (power & _1n$3)
              res = (res * num) % modulo;
          num = (num * num) % modulo;
          power >>= _1n$3;
      }
      return res;
  }
  /** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */
  function pow2(x, power, modulo) {
      let res = x;
      while (power-- > _0n$2) {
          res *= res;
          res %= modulo;
      }
      return res;
  }
  /**
   * Inverses number over modulo.
   * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).
   */
  function invert(number, modulo) {
      if (number === _0n$2)
          throw new Error('invert: expected non-zero number');
      if (modulo <= _0n$2)
          throw new Error('invert: expected positive modulus, got ' + modulo);
      // Fermat's little theorem "CT-like" version inv(n) = n^(m-2) mod m is 30x slower.
      let a = mod(number, modulo);
      let b = modulo;
      // prettier-ignore
      let x = _0n$2, u = _1n$3;
      while (a !== _0n$2) {
          // JIT applies optimization if those two lines follow each other
          const q = b / a;
          const r = b % a;
          const m = x - u * q;
          // prettier-ignore
          b = a, a = r, x = u, u = m;
      }
      const gcd = b;
      if (gcd !== _1n$3)
          throw new Error('invert: does not exist');
      return mod(x, modulo);
  }
  /**
   * Tonelli-Shanks square root search algorithm.
   * 1. https://eprint.iacr.org/2012/685.pdf (page 12)
   * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks
   * Will start an infinite loop if field order P is not prime.
   * @param P field order
   * @returns function that takes field Fp (created from P) and number n
   */
  function tonelliShanks(P) {
      // Legendre constant: used to calculate Legendre symbol (a | p),
      // which denotes the value of a^((p-1)/2) (mod p).
      // (a | p)  1    if a is a square (mod p)
      // (a | p)  -1   if a is not a square (mod p)
      // (a | p)  0    if a  0 (mod p)
      const legendreC = (P - _1n$3) / _2n$1;
      let Q, S, Z;
      // Step 1: By factoring out powers of 2 from p - 1,
      // find q and s such that p - 1 = q*(2^s) with q odd
      for (Q = P - _1n$3, S = 0; Q % _2n$1 === _0n$2; Q /= _2n$1, S++)
          ;
      // Step 2: Select a non-square z such that (z | p)  -1 and set c  zq
      for (Z = _2n$1; Z < P && pow(Z, legendreC, P) !== P - _1n$3; Z++) {
          // Crash instead of infinity loop, we cannot reasonable count until P.
          if (Z > 1000)
              throw new Error('Cannot find square root: likely non-prime P');
      }
      // Fast-path
      if (S === 1) {
          const p1div4 = (P + _1n$3) / _4n;
          return function tonelliFast(Fp, n) {
              const root = Fp.pow(n, p1div4);
              if (!Fp.eql(Fp.sqr(root), n))
                  throw new Error('Cannot find square root');
              return root;
          };
      }
      // Slow-path
      const Q1div2 = (Q + _1n$3) / _2n$1;
      return function tonelliSlow(Fp, n) {
          // Step 0: Check that n is indeed a square: (n | p) should not be  -1
          if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))
              throw new Error('Cannot find square root');
          let r = S;
          // TODO: will fail at Fp2/etc
          let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b
          let x = Fp.pow(n, Q1div2); // first guess at the square root
          let b = Fp.pow(n, Q); // first guess at the fudge factor
          while (!Fp.eql(b, Fp.ONE)) {
              if (Fp.eql(b, Fp.ZERO))
                  return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)
              // Find m such b^(2^m)==1
              let m = 1;
              for (let t2 = Fp.sqr(b); m < r; m++) {
                  if (Fp.eql(t2, Fp.ONE))
                      break;
                  t2 = Fp.sqr(t2); // t2 *= t2
              }
              // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow
              const ge = Fp.pow(g, _1n$3 << BigInt(r - m - 1)); // ge = 2^(r-m-1)
              g = Fp.sqr(ge); // g = ge * ge
              x = Fp.mul(x, ge); // x *= ge
              b = Fp.mul(b, g); // b *= g
              r = m;
          }
          return x;
      };
  }
  /**
   * Square root for a finite field. It will try to check if optimizations are applicable and fall back to 4:
   *
   * 1. P  3 (mod 4)
   * 2. P  5 (mod 8)
   * 3. P  9 (mod 16)
   * 4. Tonelli-Shanks algorithm
   *
   * Different algorithms can give different roots, it is up to user to decide which one they want.
   * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).
   */
  function FpSqrt(P) {
      // P  3 (mod 4)
      // n = n^((P+1)/4)
      if (P % _4n === _3n$1) {
          // Not all roots possible!
          // const ORDER =
          //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;
          // const NUM = 72057594037927816n;
          const p1div4 = (P + _1n$3) / _4n;
          return function sqrt3mod4(Fp, n) {
              const root = Fp.pow(n, p1div4);
              // Throw if root**2 != n
              if (!Fp.eql(Fp.sqr(root), n))
                  throw new Error('Cannot find square root');
              return root;
          };
      }
      // Atkin algorithm for q  5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)
      if (P % _8n === _5n) {
          const c1 = (P - _5n) / _8n;
          return function sqrt5mod8(Fp, n) {
              const n2 = Fp.mul(n, _2n$1);
              const v = Fp.pow(n2, c1);
              const nv = Fp.mul(n, v);
              const i = Fp.mul(Fp.mul(nv, _2n$1), v);
              const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
              if (!Fp.eql(Fp.sqr(root), n))
                  throw new Error('Cannot find square root');
              return root;
          };
      }
      // Other cases: Tonelli-Shanks algorithm
      return tonelliShanks(P);
  }
  // prettier-ignore
  const FIELD_FIELDS = [
      'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',
      'eql', 'add', 'sub', 'mul', 'pow', 'div',
      'addN', 'subN', 'mulN', 'sqrN'
  ];
  function validateField(field) {
      const initial = {
          ORDER: 'bigint',
          MASK: 'bigint',
          BYTES: 'isSafeInteger',
          BITS: 'isSafeInteger',
      };
      const opts = FIELD_FIELDS.reduce((map, val) => {
          map[val] = 'function';
          return map;
      }, initial);
      return validateObject(field, opts);
  }
  // Generic field functions
  /**
   * Same as `pow` but for Fp: non-constant-time.
   * Unsafe in some contexts: uses ladder, so can expose bigint bits.
   */
  function FpPow(f, num, power) {
      // Should have same speed as pow for bigints
      // TODO: benchmark!
      if (power < _0n$2)
          throw new Error('invalid exponent, negatives unsupported');
      if (power === _0n$2)
          return f.ONE;
      if (power === _1n$3)
          return num;
      let p = f.ONE;
      let d = num;
      while (power > _0n$2) {
          if (power & _1n$3)
              p = f.mul(p, d);
          d = f.sqr(d);
          power >>= _1n$3;
      }
      return p;
  }
  /**
   * Efficiently invert an array of Field elements.
   * `inv(0)` will return `undefined` here: make sure to throw an error.
   */
  function FpInvertBatch(f, nums) {
      const tmp = new Array(nums.length);
      // Walk from first to last, multiply them by each other MOD p
      const lastMultiplied = nums.reduce((acc, num, i) => {
          if (f.is0(num))
              return acc;
          tmp[i] = acc;
          return f.mul(acc, num);
      }, f.ONE);
      // Invert last element
      const inverted = f.inv(lastMultiplied);
      // Walk from last to first, multiply them by inverted each other MOD p
      nums.reduceRight((acc, num, i) => {
          if (f.is0(num))
              return acc;
          tmp[i] = f.mul(acc, tmp[i]);
          return f.mul(acc, num);
      }, inverted);
      return tmp;
  }
  // CURVE.n lengths
  function nLength(n, nBitLength) {
      // Bit size, byte size of CURVE.n
      const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;
      const nByteLength = Math.ceil(_nBitLength / 8);
      return { nBitLength: _nBitLength, nByteLength };
  }
  /**
   * Initializes a finite field over prime.
   * Major performance optimizations:
   * * a) denormalized operations like mulN instead of mul
   * * b) same object shape: never add or remove keys
   * * c) Object.freeze
   * Fragile: always run a benchmark on a change.
   * Security note: operations don't check 'isValid' for all elements for performance reasons,
   * it is caller responsibility to check this.
   * This is low-level code, please make sure you know what you're doing.
   * @param ORDER prime positive bigint
   * @param bitLen how many bits the field consumes
   * @param isLE (def: false) if encoding / decoding should be in little-endian
   * @param redef optional faster redefinitions of sqrt and other methods
   */
  function Field(ORDER, bitLen, isLE = false, redef = {}) {
      if (ORDER <= _0n$2)
          throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);
      const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);
      if (BYTES > 2048)
          throw new Error('invalid field: expected ORDER of <= 2048 bytes');
      let sqrtP; // cached sqrtP
      const f = Object.freeze({
          ORDER,
          isLE,
          BITS,
          BYTES,
          MASK: bitMask(BITS),
          ZERO: _0n$2,
          ONE: _1n$3,
          create: (num) => mod(num, ORDER),
          isValid: (num) => {
              if (typeof num !== 'bigint')
                  throw new Error('invalid field element: expected bigint, got ' + typeof num);
              return _0n$2 <= num && num < ORDER; // 0 is valid element, but it's not invertible
          },
          is0: (num) => num === _0n$2,
          isOdd: (num) => (num & _1n$3) === _1n$3,
          neg: (num) => mod(-num, ORDER),
          eql: (lhs, rhs) => lhs === rhs,
          sqr: (num) => mod(num * num, ORDER),
          add: (lhs, rhs) => mod(lhs + rhs, ORDER),
          sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
          mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
          pow: (num, power) => FpPow(f, num, power),
          div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
          // Same as above, but doesn't normalize
          sqrN: (num) => num * num,
          addN: (lhs, rhs) => lhs + rhs,
          subN: (lhs, rhs) => lhs - rhs,
          mulN: (lhs, rhs) => lhs * rhs,
          inv: (num) => invert(num, ORDER),
          sqrt: redef.sqrt ||
              ((n) => {
                  if (!sqrtP)
                      sqrtP = FpSqrt(ORDER);
                  return sqrtP(f, n);
              }),
          invertBatch: (lst) => FpInvertBatch(f, lst),
          // TODO: do we really need constant cmov?
          // We don't have const-time bigints anyway, so probably will be not very useful
          cmov: (a, b, c) => (c ? b : a),
          toBytes: (num) => (isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES)),
          fromBytes: (bytes) => {
              if (bytes.length !== BYTES)
                  throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);
              return isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);
          },
      });
      return Object.freeze(f);
  }
  /**
   * Returns total number of bytes consumed by the field element.
   * For example, 32 bytes for usual 256-bit weierstrass curve.
   * @param fieldOrder number of field elements, usually CURVE.n
   * @returns byte length of field
   */
  function getFieldBytesLength(fieldOrder) {
      if (typeof fieldOrder !== 'bigint')
          throw new Error('field order must be bigint');
      const bitLength = fieldOrder.toString(2).length;
      return Math.ceil(bitLength / 8);
  }
  /**
   * Returns minimal amount of bytes that can be safely reduced
   * by field order.
   * Should be 2^-128 for 128-bit curve such as P256.
   * @param fieldOrder number of field elements, usually CURVE.n
   * @returns byte length of target hash
   */
  function getMinHashLength(fieldOrder) {
      const length = getFieldBytesLength(fieldOrder);
      return length + Math.ceil(length / 2);
  }
  /**
   * "Constant-time" private key generation utility.
   * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF
   * and convert them into private scalar, with the modulo bias being negligible.
   * Needs at least 48 bytes of input for 32-byte private key.
   * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/
   * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final
   * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5
   * @param hash hash output from SHA3 or a similar function
   * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)
   * @param isLE interpret hash bytes as LE num
   * @returns valid private scalar
   */
  function mapHashToField(key, fieldOrder, isLE = false) {
      const len = key.length;
      const fieldLen = getFieldBytesLength(fieldOrder);
      const minLen = getMinHashLength(fieldOrder);
      // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.
      if (len < 16 || len < minLen || len > 1024)
          throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);
      const num = isLE ? bytesToNumberLE(key) : bytesToNumberBE(key);
      // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0
      const reduced = mod(num, fieldOrder - _1n$3) + _1n$3;
      return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
  }

  /**
   * Methods for elliptic curve multiplication by scalars.
   * Contains wNAF, pippenger
   * @module
   */
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  const _0n$1 = BigInt(0);
  const _1n$2 = BigInt(1);
  function constTimeNegate(condition, item) {
      const neg = item.negate();
      return condition ? neg : item;
  }
  function validateW(W, bits) {
      if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
          throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);
  }
  function calcWOpts(W, bits) {
      validateW(W, bits);
      const windows = Math.ceil(bits / W) + 1; // +1, because
      const windowSize = 2 ** (W - 1); // -1 because we skip zero
      return { windows, windowSize };
  }
  function validateMSMPoints(points, c) {
      if (!Array.isArray(points))
          throw new Error('array expected');
      points.forEach((p, i) => {
          if (!(p instanceof c))
              throw new Error('invalid point at index ' + i);
      });
  }
  function validateMSMScalars(scalars, field) {
      if (!Array.isArray(scalars))
          throw new Error('array of scalars expected');
      scalars.forEach((s, i) => {
          if (!field.isValid(s))
              throw new Error('invalid scalar at index ' + i);
      });
  }
  // Since points in different groups cannot be equal (different object constructor),
  // we can have single place to store precomputes
  const pointPrecomputes = new WeakMap();
  const pointWindowSizes = new WeakMap(); // This allows use make points immutable (nothing changes inside)
  function getW(P) {
      return pointWindowSizes.get(P) || 1;
  }
  /**
   * Elliptic curve multiplication of Point by scalar. Fragile.
   * Scalars should always be less than curve order: this should be checked inside of a curve itself.
   * Creates precomputation tables for fast multiplication:
   * - private scalar is split by fixed size windows of W bits
   * - every window point is collected from window's table & added to accumulator
   * - since windows are different, same point inside tables won't be accessed more than once per calc
   * - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)
   * - +1 window is neccessary for wNAF
   * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication
   *
   * @todo Research returning 2d JS array of windows, instead of a single window.
   * This would allow windows to be in different memory locations
   */
  function wNAF(c, bits) {
      return {
          constTimeNegate,
          hasPrecomputes(elm) {
              return getW(elm) !== 1;
          },
          // non-const time multiplication ladder
          unsafeLadder(elm, n, p = c.ZERO) {
              let d = elm;
              while (n > _0n$1) {
                  if (n & _1n$2)
                      p = p.add(d);
                  d = d.double();
                  n >>= _1n$2;
              }
              return p;
          },
          /**
           * Creates a wNAF precomputation window. Used for caching.
           * Default window size is set by `utils.precompute()` and is equal to 8.
           * Number of precomputed points depends on the curve size:
           * 2^(1) * (Math.ceil( / ) + 1), where:
           * -  is the window size
           * -  is the bitlength of the curve order.
           * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
           * @param elm Point instance
           * @param W window size
           * @returns precomputed point tables flattened to a single array
           */
          precomputeWindow(elm, W) {
              const { windows, windowSize } = calcWOpts(W, bits);
              const points = [];
              let p = elm;
              let base = p;
              for (let window = 0; window < windows; window++) {
                  base = p;
                  points.push(base);
                  // =1, because we skip zero
                  for (let i = 1; i < windowSize; i++) {
                      base = base.add(p);
                      points.push(base);
                  }
                  p = base.double();
              }
              return points;
          },
          /**
           * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
           * @param W window size
           * @param precomputes precomputed tables
           * @param n scalar (we don't check here, but should be less than curve order)
           * @returns real and fake (for const-time) points
           */
          wNAF(W, precomputes, n) {
              // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise
              // But need to carefully remove other checks before wNAF. ORDER == bits here
              const { windows, windowSize } = calcWOpts(W, bits);
              let p = c.ZERO;
              let f = c.BASE;
              const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.
              const maxNumber = 2 ** W;
              const shiftBy = BigInt(W);
              for (let window = 0; window < windows; window++) {
                  const offset = window * windowSize;
                  // Extract W bits.
                  let wbits = Number(n & mask);
                  // Shift number by W bits.
                  n >>= shiftBy;
                  // If the bits are bigger than max size, we'll split those.
                  // +224 => 256 - 32
                  if (wbits > windowSize) {
                      wbits -= maxNumber;
                      n += _1n$2;
                  }
                  // This code was first written with assumption that 'f' and 'p' will never be infinity point:
                  // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,
                  // there is negate now: it is possible that negated element from low value
                  // would be the same as high element, which will create carry into next window.
                  // It's not obvious how this can fail, but still worth investigating later.
                  // Check if we're onto Zero point.
                  // Add random point inside current window to f.
                  const offset1 = offset;
                  const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero
                  const cond1 = window % 2 !== 0;
                  const cond2 = wbits < 0;
                  if (wbits === 0) {
                      // The most important part for const-time getPublicKey
                      f = f.add(constTimeNegate(cond1, precomputes[offset1]));
                  }
                  else {
                      p = p.add(constTimeNegate(cond2, precomputes[offset2]));
                  }
              }
              // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()
              // Even if the variable is still unused, there are some checks which will
              // throw an exception, so compiler needs to prove they won't happen, which is hard.
              // At this point there is a way to F be infinity-point even if p is not,
              // which makes it less const-time: around 1 bigint multiply.
              return { p, f };
          },
          /**
           * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
           * @param W window size
           * @param precomputes precomputed tables
           * @param n scalar (we don't check here, but should be less than curve order)
           * @param acc accumulator point to add result of multiplication
           * @returns point
           */
          wNAFUnsafe(W, precomputes, n, acc = c.ZERO) {
              const { windows, windowSize } = calcWOpts(W, bits);
              const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.
              const maxNumber = 2 ** W;
              const shiftBy = BigInt(W);
              for (let window = 0; window < windows; window++) {
                  const offset = window * windowSize;
                  if (n === _0n$1)
                      break; // No need to go over empty scalar
                  // Extract W bits.
                  let wbits = Number(n & mask);
                  // Shift number by W bits.
                  n >>= shiftBy;
                  // If the bits are bigger than max size, we'll split those.
                  // +224 => 256 - 32
                  if (wbits > windowSize) {
                      wbits -= maxNumber;
                      n += _1n$2;
                  }
                  if (wbits === 0)
                      continue;
                  let curr = precomputes[offset + Math.abs(wbits) - 1]; // -1 because we skip zero
                  if (wbits < 0)
                      curr = curr.negate();
                  // NOTE: by re-using acc, we can save a lot of additions in case of MSM
                  acc = acc.add(curr);
              }
              return acc;
          },
          getPrecomputes(W, P, transform) {
              // Calculate precomputes on a first run, reuse them after
              let comp = pointPrecomputes.get(P);
              if (!comp) {
                  comp = this.precomputeWindow(P, W);
                  if (W !== 1)
                      pointPrecomputes.set(P, transform(comp));
              }
              return comp;
          },
          wNAFCached(P, n, transform) {
              const W = getW(P);
              return this.wNAF(W, this.getPrecomputes(W, P, transform), n);
          },
          wNAFCachedUnsafe(P, n, transform, prev) {
              const W = getW(P);
              if (W === 1)
                  return this.unsafeLadder(P, n, prev); // For W=1 ladder is ~x2 faster
              return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);
          },
          // We calculate precomputes for elliptic curve point multiplication
          // using windowed method. This specifies window size and
          // stores precomputed values. Usually only base point would be precomputed.
          setWindowSize(P, W) {
              validateW(W, bits);
              pointWindowSizes.set(P, W);
              pointPrecomputes.delete(P);
          },
      };
  }
  /**
   * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).
   * 30x faster vs naive addition on L=4096, 10x faster with precomputes.
   * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.
   * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.
   * @param c Curve Point constructor
   * @param fieldN field over CURVE.N - important that it's not over CURVE.P
   * @param points array of L curve points
   * @param scalars array of L scalars (aka private keys / bigints)
   */
  function pippenger(c, fieldN, points, scalars) {
      // If we split scalars by some window (let's say 8 bits), every chunk will only
      // take 256 buckets even if there are 4096 scalars, also re-uses double.
      // TODO:
      // - https://eprint.iacr.org/2024/750.pdf
      // - https://tches.iacr.org/index.php/TCHES/article/view/10287
      // 0 is accepted in scalars
      validateMSMPoints(points, c);
      validateMSMScalars(scalars, fieldN);
      if (points.length !== scalars.length)
          throw new Error('arrays of points and scalars must have equal length');
      const zero = c.ZERO;
      const wbits = bitLen(BigInt(points.length));
      const windowSize = wbits > 12 ? wbits - 3 : wbits > 4 ? wbits - 2 : wbits ? 2 : 1; // in bits
      const MASK = (1 << windowSize) - 1;
      const buckets = new Array(MASK + 1).fill(zero); // +1 for zero array
      const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
      let sum = zero;
      for (let i = lastBits; i >= 0; i -= windowSize) {
          buckets.fill(zero);
          for (let j = 0; j < scalars.length; j++) {
              const scalar = scalars[j];
              const wbits = Number((scalar >> BigInt(i)) & BigInt(MASK));
              buckets[wbits] = buckets[wbits].add(points[j]);
          }
          let resI = zero; // not using this will do small speed-up, but will lose ct
          // Skip first bucket, because it is zero
          for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {
              sumI = sumI.add(buckets[j]);
              resI = resI.add(sumI);
          }
          sum = sum.add(resI);
          if (i !== 0)
              for (let j = 0; j < windowSize; j++)
                  sum = sum.double();
      }
      return sum;
  }
  function validateBasic(curve) {
      validateField(curve.Fp);
      validateObject(curve, {
          n: 'bigint',
          h: 'bigint',
          Gx: 'field',
          Gy: 'field',
      }, {
          nBitLength: 'isSafeInteger',
          nByteLength: 'isSafeInteger',
      });
      // Set defaults
      return Object.freeze({
          ...nLength(curve.n, curve.nBitLength),
          ...curve,
          ...{ p: curve.Fp.ORDER },
      });
  }

  /**
   * Short Weierstrass curve methods. The formula is: y = x + ax + b.
   *
   * ### Design rationale for types
   *
   * * Interaction between classes from different curves should fail:
   *   `k256.Point.BASE.add(p256.Point.BASE)`
   * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime
   * * Different calls of `curve()` would return different classes -
   *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,
   *   it won't affect others
   *
   * TypeScript can't infer types for classes created inside a function. Classes is one instance
   * of nominative types in TypeScript and interfaces only check for shape, so it's hard to create
   * unique type for every function call.
   *
   * We can use generic types via some param, like curve opts, but that would:
   *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)
   *     which is hard to debug.
   *     2. Params can be generic and we can't enforce them to be constant value:
   *     if somebody creates curve from non-constant params,
   *     it would be allowed to interact with other curves with non-constant params
   *
   * @todo https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol
   * @module
   */
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  function validateSigVerOpts(opts) {
      if (opts.lowS !== undefined)
          abool('lowS', opts.lowS);
      if (opts.prehash !== undefined)
          abool('prehash', opts.prehash);
  }
  function validatePointOpts(curve) {
      const opts = validateBasic(curve);
      validateObject(opts, {
          a: 'field',
          b: 'field',
      }, {
          allowedPrivateKeyLengths: 'array',
          wrapPrivateKey: 'boolean',
          isTorsionFree: 'function',
          clearCofactor: 'function',
          allowInfinityPoint: 'boolean',
          fromBytes: 'function',
          toBytes: 'function',
      });
      const { endo, Fp, a } = opts;
      if (endo) {
          if (!Fp.eql(a, Fp.ZERO)) {
              throw new Error('invalid endomorphism, can only be defined for Koblitz curves that have a=0');
          }
          if (typeof endo !== 'object' ||
              typeof endo.beta !== 'bigint' ||
              typeof endo.splitScalar !== 'function') {
              throw new Error('invalid endomorphism, expected beta: bigint and splitScalar: function');
          }
      }
      return Object.freeze({ ...opts });
  }
  const { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;
  class DERErr extends Error {
      constructor(m = '') {
          super(m);
      }
  }
  /**
   * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:
   *
   *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]
   *
   * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html
   */
  const DER = {
      // asn.1 DER encoding utils
      Err: DERErr,
      // Basic building block is TLV (Tag-Length-Value)
      _tlv: {
          encode: (tag, data) => {
              const { Err: E } = DER;
              if (tag < 0 || tag > 256)
                  throw new E('tlv.encode: wrong tag');
              if (data.length & 1)
                  throw new E('tlv.encode: unpadded data');
              const dataLen = data.length / 2;
              const len = numberToHexUnpadded(dataLen);
              if ((len.length / 2) & 128)
                  throw new E('tlv.encode: long form length too big');
              // length of length with long form flag
              const lenLen = dataLen > 127 ? numberToHexUnpadded((len.length / 2) | 128) : '';
              const t = numberToHexUnpadded(tag);
              return t + lenLen + len + data;
          },
          // v - value, l - left bytes (unparsed)
          decode(tag, data) {
              const { Err: E } = DER;
              let pos = 0;
              if (tag < 0 || tag > 256)
                  throw new E('tlv.encode: wrong tag');
              if (data.length < 2 || data[pos++] !== tag)
                  throw new E('tlv.decode: wrong tlv');
              const first = data[pos++];
              const isLong = !!(first & 128); // First bit of first length byte is flag for short/long form
              let length = 0;
              if (!isLong)
                  length = first;
              else {
                  // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]
                  const lenLen = first & 127;
                  if (!lenLen)
                      throw new E('tlv.decode(long): indefinite length not supported');
                  if (lenLen > 4)
                      throw new E('tlv.decode(long): byte length is too big'); // this will overflow u32 in js
                  const lengthBytes = data.subarray(pos, pos + lenLen);
                  if (lengthBytes.length !== lenLen)
                      throw new E('tlv.decode: length bytes not complete');
                  if (lengthBytes[0] === 0)
                      throw new E('tlv.decode(long): zero leftmost byte');
                  for (const b of lengthBytes)
                      length = (length << 8) | b;
                  pos += lenLen;
                  if (length < 128)
                      throw new E('tlv.decode(long): not minimal encoding');
              }
              const v = data.subarray(pos, pos + length);
              if (v.length !== length)
                  throw new E('tlv.decode: wrong value length');
              return { v, l: data.subarray(pos + length) };
          },
      },
      // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
      // since we always use positive integers here. It must always be empty:
      // - add zero byte if exists
      // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
      _int: {
          encode(num) {
              const { Err: E } = DER;
              if (num < _0n)
                  throw new E('integer: negative integers are not allowed');
              let hex = numberToHexUnpadded(num);
              // Pad with zero byte if negative flag is present
              if (Number.parseInt(hex[0], 16) & 0b1000)
                  hex = '00' + hex;
              if (hex.length & 1)
                  throw new E('unexpected DER parsing assertion: unpadded hex');
              return hex;
          },
          decode(data) {
              const { Err: E } = DER;
              if (data[0] & 128)
                  throw new E('invalid signature integer: negative');
              if (data[0] === 0x00 && !(data[1] & 128))
                  throw new E('invalid signature integer: unnecessary leading zero');
              return b2n(data);
          },
      },
      toSig(hex) {
          // parse DER signature
          const { Err: E, _int: int, _tlv: tlv } = DER;
          const data = typeof hex === 'string' ? h2b(hex) : hex;
          abytes(data);
          const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);
          if (seqLeftBytes.length)
              throw new E('invalid signature: left bytes after parsing');
          const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);
          const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);
          if (sLeftBytes.length)
              throw new E('invalid signature: left bytes after parsing');
          return { r: int.decode(rBytes), s: int.decode(sBytes) };
      },
      hexFromSig(sig) {
          const { _tlv: tlv, _int: int } = DER;
          const rs = tlv.encode(0x02, int.encode(sig.r));
          const ss = tlv.encode(0x02, int.encode(sig.s));
          const seq = rs + ss;
          return tlv.encode(0x30, seq);
      },
  };
  // Be friendly to bad ECMAScript parsers by not using bigint literals
  // prettier-ignore
  const _0n = BigInt(0), _1n$1 = BigInt(1); BigInt(2); const _3n = BigInt(3); BigInt(4);
  function weierstrassPoints(opts) {
      const CURVE = validatePointOpts(opts);
      const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ
      const Fn = Field(CURVE.n, CURVE.nBitLength);
      const toBytes = CURVE.toBytes ||
          ((_c, point, _isCompressed) => {
              const a = point.toAffine();
              return concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));
          });
      const fromBytes = CURVE.fromBytes ||
          ((bytes) => {
              // const head = bytes[0];
              const tail = bytes.subarray(1);
              // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');
              const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
              const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
              return { x, y };
          });
      /**
       * y = x + ax + b: Short weierstrass curve formula
       * @returns y
       */
      function weierstrassEquation(x) {
          const { a, b } = CURVE;
          const x2 = Fp.sqr(x); // x * x
          const x3 = Fp.mul(x2, x); // x2 * x
          return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b
      }
      // Validate whether the passed curve params are valid.
      // We check if curve equation works for generator point.
      // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.
      // ProjectivePoint class has not been initialized yet.
      if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
          throw new Error('bad generator point: equation left != right');
      // Valid group elements reside in range 1..n-1
      function isWithinCurveOrder(num) {
          return inRange(num, _1n$1, CURVE.n);
      }
      // Validates if priv key is valid and converts it to bigint.
      // Supports options allowedPrivateKeyLengths and wrapPrivateKey.
      function normPrivateKeyToScalar(key) {
          const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N } = CURVE;
          if (lengths && typeof key !== 'bigint') {
              if (isBytes$1(key))
                  key = bytesToHex(key);
              // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes
              if (typeof key !== 'string' || !lengths.includes(key.length))
                  throw new Error('invalid private key');
              key = key.padStart(nByteLength * 2, '0');
          }
          let num;
          try {
              num =
                  typeof key === 'bigint'
                      ? key
                      : bytesToNumberBE(ensureBytes('private key', key, nByteLength));
          }
          catch (error) {
              throw new Error('invalid private key, expected hex or ' + nByteLength + ' bytes, got ' + typeof key);
          }
          if (wrapPrivateKey)
              num = mod(num, N); // disabled by default, enabled for BLS
          aInRange('private key', num, _1n$1, N); // num in range [1..N-1]
          return num;
      }
      function assertPrjPoint(other) {
          if (!(other instanceof Point))
              throw new Error('ProjectivePoint expected');
      }
      // Memoized toAffine / validity check. They are heavy. Points are immutable.
      // Converts Projective point to affine (x, y) coordinates.
      // Can accept precomputed Z^-1 - for example, from invertBatch.
      // (x, y, z)  (x=x/z, y=y/z)
      const toAffineMemo = memoized((p, iz) => {
          const { px: x, py: y, pz: z } = p;
          // Fast-path for normalized points
          if (Fp.eql(z, Fp.ONE))
              return { x, y };
          const is0 = p.is0();
          // If invZ was 0, we return zero point. However we still want to execute
          // all operations, so we replace invZ with a random number, 1.
          if (iz == null)
              iz = is0 ? Fp.ONE : Fp.inv(z);
          const ax = Fp.mul(x, iz);
          const ay = Fp.mul(y, iz);
          const zz = Fp.mul(z, iz);
          if (is0)
              return { x: Fp.ZERO, y: Fp.ZERO };
          if (!Fp.eql(zz, Fp.ONE))
              throw new Error('invZ was invalid');
          return { x: ax, y: ay };
      });
      // NOTE: on exception this will crash 'cached' and no value will be set.
      // Otherwise true will be return
      const assertValidMemo = memoized((p) => {
          if (p.is0()) {
              // (0, 1, 0) aka ZERO is invalid in most contexts.
              // In BLS, ZERO can be serialized, so we allow it.
              // (0, 0, 0) is invalid representation of ZERO.
              if (CURVE.allowInfinityPoint && !Fp.is0(p.py))
                  return;
              throw new Error('bad point: ZERO');
          }
          // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`
          const { x, y } = p.toAffine();
          // Check if x, y are valid field elements
          if (!Fp.isValid(x) || !Fp.isValid(y))
              throw new Error('bad point: x or y not FE');
          const left = Fp.sqr(y); // y
          const right = weierstrassEquation(x); // x + ax + b
          if (!Fp.eql(left, right))
              throw new Error('bad point: equation left != right');
          if (!p.isTorsionFree())
              throw new Error('bad point: not in prime-order subgroup');
          return true;
      });
      /**
       * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z)  (x=x/z, y=y/z)
       * Default Point works in 2d / affine coordinates: (x, y)
       * We're doing calculations in projective, because its operations don't require costly inversion.
       */
      class Point {
          constructor(px, py, pz) {
              this.px = px;
              this.py = py;
              this.pz = pz;
              if (px == null || !Fp.isValid(px))
                  throw new Error('x required');
              if (py == null || !Fp.isValid(py))
                  throw new Error('y required');
              if (pz == null || !Fp.isValid(pz))
                  throw new Error('z required');
              Object.freeze(this);
          }
          // Does not validate if the point is on-curve.
          // Use fromHex instead, or call assertValidity() later.
          static fromAffine(p) {
              const { x, y } = p || {};
              if (!p || !Fp.isValid(x) || !Fp.isValid(y))
                  throw new Error('invalid affine point');
              if (p instanceof Point)
                  throw new Error('projective point not allowed');
              const is0 = (i) => Fp.eql(i, Fp.ZERO);
              // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)
              if (is0(x) && is0(y))
                  return Point.ZERO;
              return new Point(x, y, Fp.ONE);
          }
          get x() {
              return this.toAffine().x;
          }
          get y() {
              return this.toAffine().y;
          }
          /**
           * Takes a bunch of Projective Points but executes only one
           * inversion on all of them. Inversion is very slow operation,
           * so this improves performance massively.
           * Optimization: converts a list of projective points to a list of identical points with Z=1.
           */
          static normalizeZ(points) {
              const toInv = Fp.invertBatch(points.map((p) => p.pz));
              return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
          }
          /**
           * Converts hash string or Uint8Array to Point.
           * @param hex short/long ECDSA hex
           */
          static fromHex(hex) {
              const P = Point.fromAffine(fromBytes(ensureBytes('pointHex', hex)));
              P.assertValidity();
              return P;
          }
          // Multiplies generator point by privateKey.
          static fromPrivateKey(privateKey) {
              return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
          }
          // Multiscalar Multiplication
          static msm(points, scalars) {
              return pippenger(Point, Fn, points, scalars);
          }
          // "Private method", don't use it directly
          _setWindowSize(windowSize) {
              wnaf.setWindowSize(this, windowSize);
          }
          // A point on curve is valid if it conforms to equation.
          assertValidity() {
              assertValidMemo(this);
          }
          hasEvenY() {
              const { y } = this.toAffine();
              if (Fp.isOdd)
                  return !Fp.isOdd(y);
              throw new Error("Field doesn't support isOdd");
          }
          /**
           * Compare one point to another.
           */
          equals(other) {
              assertPrjPoint(other);
              const { px: X1, py: Y1, pz: Z1 } = this;
              const { px: X2, py: Y2, pz: Z2 } = other;
              const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
              const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
              return U1 && U2;
          }
          /**
           * Flips point to one corresponding to (x, -y) in Affine coordinates.
           */
          negate() {
              return new Point(this.px, Fp.neg(this.py), this.pz);
          }
          // Renes-Costello-Batina exception-free doubling formula.
          // There is 30% faster Jacobian formula, but it is not complete.
          // https://eprint.iacr.org/2015/1060, algorithm 3
          // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
          double() {
              const { a, b } = CURVE;
              const b3 = Fp.mul(b, _3n);
              const { px: X1, py: Y1, pz: Z1 } = this;
              let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
              let t0 = Fp.mul(X1, X1); // step 1
              let t1 = Fp.mul(Y1, Y1);
              let t2 = Fp.mul(Z1, Z1);
              let t3 = Fp.mul(X1, Y1);
              t3 = Fp.add(t3, t3); // step 5
              Z3 = Fp.mul(X1, Z1);
              Z3 = Fp.add(Z3, Z3);
              X3 = Fp.mul(a, Z3);
              Y3 = Fp.mul(b3, t2);
              Y3 = Fp.add(X3, Y3); // step 10
              X3 = Fp.sub(t1, Y3);
              Y3 = Fp.add(t1, Y3);
              Y3 = Fp.mul(X3, Y3);
              X3 = Fp.mul(t3, X3);
              Z3 = Fp.mul(b3, Z3); // step 15
              t2 = Fp.mul(a, t2);
              t3 = Fp.sub(t0, t2);
              t3 = Fp.mul(a, t3);
              t3 = Fp.add(t3, Z3);
              Z3 = Fp.add(t0, t0); // step 20
              t0 = Fp.add(Z3, t0);
              t0 = Fp.add(t0, t2);
              t0 = Fp.mul(t0, t3);
              Y3 = Fp.add(Y3, t0);
              t2 = Fp.mul(Y1, Z1); // step 25
              t2 = Fp.add(t2, t2);
              t0 = Fp.mul(t2, t3);
              X3 = Fp.sub(X3, t0);
              Z3 = Fp.mul(t2, t1);
              Z3 = Fp.add(Z3, Z3); // step 30
              Z3 = Fp.add(Z3, Z3);
              return new Point(X3, Y3, Z3);
          }
          // Renes-Costello-Batina exception-free addition formula.
          // There is 30% faster Jacobian formula, but it is not complete.
          // https://eprint.iacr.org/2015/1060, algorithm 1
          // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
          add(other) {
              assertPrjPoint(other);
              const { px: X1, py: Y1, pz: Z1 } = this;
              const { px: X2, py: Y2, pz: Z2 } = other;
              let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
              const a = CURVE.a;
              const b3 = Fp.mul(CURVE.b, _3n);
              let t0 = Fp.mul(X1, X2); // step 1
              let t1 = Fp.mul(Y1, Y2);
              let t2 = Fp.mul(Z1, Z2);
              let t3 = Fp.add(X1, Y1);
              let t4 = Fp.add(X2, Y2); // step 5
              t3 = Fp.mul(t3, t4);
              t4 = Fp.add(t0, t1);
              t3 = Fp.sub(t3, t4);
              t4 = Fp.add(X1, Z1);
              let t5 = Fp.add(X2, Z2); // step 10
              t4 = Fp.mul(t4, t5);
              t5 = Fp.add(t0, t2);
              t4 = Fp.sub(t4, t5);
              t5 = Fp.add(Y1, Z1);
              X3 = Fp.add(Y2, Z2); // step 15
              t5 = Fp.mul(t5, X3);
              X3 = Fp.add(t1, t2);
              t5 = Fp.sub(t5, X3);
              Z3 = Fp.mul(a, t4);
              X3 = Fp.mul(b3, t2); // step 20
              Z3 = Fp.add(X3, Z3);
              X3 = Fp.sub(t1, Z3);
              Z3 = Fp.add(t1, Z3);
              Y3 = Fp.mul(X3, Z3);
              t1 = Fp.add(t0, t0); // step 25
              t1 = Fp.add(t1, t0);
              t2 = Fp.mul(a, t2);
              t4 = Fp.mul(b3, t4);
              t1 = Fp.add(t1, t2);
              t2 = Fp.sub(t0, t2); // step 30
              t2 = Fp.mul(a, t2);
              t4 = Fp.add(t4, t2);
              t0 = Fp.mul(t1, t4);
              Y3 = Fp.add(Y3, t0);
              t0 = Fp.mul(t5, t4); // step 35
              X3 = Fp.mul(t3, X3);
              X3 = Fp.sub(X3, t0);
              t0 = Fp.mul(t3, t1);
              Z3 = Fp.mul(t5, Z3);
              Z3 = Fp.add(Z3, t0); // step 40
              return new Point(X3, Y3, Z3);
          }
          subtract(other) {
              return this.add(other.negate());
          }
          is0() {
              return this.equals(Point.ZERO);
          }
          wNAF(n) {
              return wnaf.wNAFCached(this, n, Point.normalizeZ);
          }
          /**
           * Non-constant-time multiplication. Uses double-and-add algorithm.
           * It's faster, but should only be used when you don't care about
           * an exposed private key e.g. sig verification, which works over *public* keys.
           */
          multiplyUnsafe(sc) {
              const { endo, n: N } = CURVE;
              aInRange('scalar', sc, _0n, N);
              const I = Point.ZERO;
              if (sc === _0n)
                  return I;
              if (this.is0() || sc === _1n$1)
                  return this;
              // Case a: no endomorphism. Case b: has precomputes.
              if (!endo || wnaf.hasPrecomputes(this))
                  return wnaf.wNAFCachedUnsafe(this, sc, Point.normalizeZ);
              // Case c: endomorphism
              let { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc);
              let k1p = I;
              let k2p = I;
              let d = this;
              while (k1 > _0n || k2 > _0n) {
                  if (k1 & _1n$1)
                      k1p = k1p.add(d);
                  if (k2 & _1n$1)
                      k2p = k2p.add(d);
                  d = d.double();
                  k1 >>= _1n$1;
                  k2 >>= _1n$1;
              }
              if (k1neg)
                  k1p = k1p.negate();
              if (k2neg)
                  k2p = k2p.negate();
              k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
              return k1p.add(k2p);
          }
          /**
           * Constant time multiplication.
           * Uses wNAF method. Windowed method may be 10% faster,
           * but takes 2x longer to generate and consumes 2x memory.
           * Uses precomputes when available.
           * Uses endomorphism for Koblitz curves.
           * @param scalar by which the point would be multiplied
           * @returns New point
           */
          multiply(scalar) {
              const { endo, n: N } = CURVE;
              aInRange('scalar', scalar, _1n$1, N);
              let point, fake; // Fake point is used to const-time mult
              if (endo) {
                  const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);
                  let { p: k1p, f: f1p } = this.wNAF(k1);
                  let { p: k2p, f: f2p } = this.wNAF(k2);
                  k1p = wnaf.constTimeNegate(k1neg, k1p);
                  k2p = wnaf.constTimeNegate(k2neg, k2p);
                  k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
                  point = k1p.add(k2p);
                  fake = f1p.add(f2p);
              }
              else {
                  const { p, f } = this.wNAF(scalar);
                  point = p;
                  fake = f;
              }
              // Normalize `z` for both points, but return only real one
              return Point.normalizeZ([point, fake])[0];
          }
          /**
           * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
           * Not using Strauss-Shamir trick: precomputation tables are faster.
           * The trick could be useful if both P and Q are not G (not in our case).
           * @returns non-zero affine point
           */
          multiplyAndAddUnsafe(Q, a, b) {
              const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes
              const mul = (P, a // Select faster multiply() method
              ) => (a === _0n || a === _1n$1 || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));
              const sum = mul(this, a).add(mul(Q, b));
              return sum.is0() ? undefined : sum;
          }
          // Converts Projective point to affine (x, y) coordinates.
          // Can accept precomputed Z^-1 - for example, from invertBatch.
          // (x, y, z)  (x=x/z, y=y/z)
          toAffine(iz) {
              return toAffineMemo(this, iz);
          }
          isTorsionFree() {
              const { h: cofactor, isTorsionFree } = CURVE;
              if (cofactor === _1n$1)
                  return true; // No subgroups, always torsion-free
              if (isTorsionFree)
                  return isTorsionFree(Point, this);
              throw new Error('isTorsionFree() has not been declared for the elliptic curve');
          }
          clearCofactor() {
              const { h: cofactor, clearCofactor } = CURVE;
              if (cofactor === _1n$1)
                  return this; // Fast-path
              if (clearCofactor)
                  return clearCofactor(Point, this);
              return this.multiplyUnsafe(CURVE.h);
          }
          toRawBytes(isCompressed = true) {
              abool('isCompressed', isCompressed);
              this.assertValidity();
              return toBytes(Point, this, isCompressed);
          }
          toHex(isCompressed = true) {
              abool('isCompressed', isCompressed);
              return bytesToHex(this.toRawBytes(isCompressed));
          }
      }
      Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
      Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
      const _bits = CURVE.nBitLength;
      const wnaf = wNAF(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
      // Validate if generator point is on curve
      return {
          CURVE,
          ProjectivePoint: Point,
          normPrivateKeyToScalar,
          weierstrassEquation,
          isWithinCurveOrder,
      };
  }
  function validateOpts(curve) {
      const opts = validateBasic(curve);
      validateObject(opts, {
          hash: 'hash',
          hmac: 'function',
          randomBytes: 'function',
      }, {
          bits2int: 'function',
          bits2int_modN: 'function',
          lowS: 'boolean',
      });
      return Object.freeze({ lowS: true, ...opts });
  }
  /**
   * Creates short weierstrass curve and ECDSA signature methods for it.
   * @example
   * import { Field } from '@noble/curves/abstract/modular';
   * // Before that, define BigInt-s: a, b, p, n, Gx, Gy
   * const curve = weierstrass({ a, b, Fp: Field(p), n, Gx, Gy, h: 1n })
   */
  function weierstrass(curveDef) {
      const CURVE = validateOpts(curveDef);
      const { Fp, n: CURVE_ORDER } = CURVE;
      const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32
      const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32
      function modN(a) {
          return mod(a, CURVE_ORDER);
      }
      function invN(a) {
          return invert(a, CURVE_ORDER);
      }
      const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({
          ...CURVE,
          toBytes(_c, point, isCompressed) {
              const a = point.toAffine();
              const x = Fp.toBytes(a.x);
              const cat = concatBytes;
              abool('isCompressed', isCompressed);
              if (isCompressed) {
                  return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);
              }
              else {
                  return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));
              }
          },
          fromBytes(bytes) {
              const len = bytes.length;
              const head = bytes[0];
              const tail = bytes.subarray(1);
              // this.assertValidity() is done inside of fromHex
              if (len === compressedLen && (head === 0x02 || head === 0x03)) {
                  const x = bytesToNumberBE(tail);
                  if (!inRange(x, _1n$1, Fp.ORDER))
                      throw new Error('Point is not on curve');
                  const y2 = weierstrassEquation(x); // y = x + ax + b
                  let y;
                  try {
                      y = Fp.sqrt(y2); // y = y ^ (p+1)/4
                  }
                  catch (sqrtError) {
                      const suffix = sqrtError instanceof Error ? ': ' + sqrtError.message : '';
                      throw new Error('Point is not on curve' + suffix);
                  }
                  const isYOdd = (y & _1n$1) === _1n$1;
                  // ECDSA
                  const isHeadOdd = (head & 1) === 1;
                  if (isHeadOdd !== isYOdd)
                      y = Fp.neg(y);
                  return { x, y };
              }
              else if (len === uncompressedLen && head === 0x04) {
                  const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
                  const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
                  return { x, y };
              }
              else {
                  const cl = compressedLen;
                  const ul = uncompressedLen;
                  throw new Error('invalid Point, expected length of ' + cl + ', or uncompressed ' + ul + ', got ' + len);
              }
          },
      });
      const numToNByteStr = (num) => bytesToHex(numberToBytesBE(num, CURVE.nByteLength));
      function isBiggerThanHalfOrder(number) {
          const HALF = CURVE_ORDER >> _1n$1;
          return number > HALF;
      }
      function normalizeS(s) {
          return isBiggerThanHalfOrder(s) ? modN(-s) : s;
      }
      // slice bytes num
      const slcNum = (b, from, to) => bytesToNumberBE(b.slice(from, to));
      /**
       * ECDSA signature with its (r, s) properties. Supports DER & compact representations.
       */
      class Signature {
          constructor(r, s, recovery) {
              this.r = r;
              this.s = s;
              this.recovery = recovery;
              this.assertValidity();
          }
          // pair (bytes of r, bytes of s)
          static fromCompact(hex) {
              const l = CURVE.nByteLength;
              hex = ensureBytes('compactSignature', hex, l * 2);
              return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
          }
          // DER encoded ECDSA signature
          // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
          static fromDER(hex) {
              const { r, s } = DER.toSig(ensureBytes('DER', hex));
              return new Signature(r, s);
          }
          assertValidity() {
              aInRange('r', this.r, _1n$1, CURVE_ORDER); // r in [1..N]
              aInRange('s', this.s, _1n$1, CURVE_ORDER); // s in [1..N]
          }
          addRecoveryBit(recovery) {
              return new Signature(this.r, this.s, recovery);
          }
          recoverPublicKey(msgHash) {
              const { r, s, recovery: rec } = this;
              const h = bits2int_modN(ensureBytes('msgHash', msgHash)); // Truncate hash
              if (rec == null || ![0, 1, 2, 3].includes(rec))
                  throw new Error('recovery id invalid');
              const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
              if (radj >= Fp.ORDER)
                  throw new Error('recovery id 2 or 3 invalid');
              const prefix = (rec & 1) === 0 ? '02' : '03';
              const R = Point.fromHex(prefix + numToNByteStr(radj));
              const ir = invN(radj); // r^-1
              const u1 = modN(-h * ir); // -hr^-1
              const u2 = modN(s * ir); // sr^-1
              const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)
              if (!Q)
                  throw new Error('point at infinify'); // unsafe is fine: no priv data leaked
              Q.assertValidity();
              return Q;
          }
          // Signatures should be low-s, to prevent malleability.
          hasHighS() {
              return isBiggerThanHalfOrder(this.s);
          }
          normalizeS() {
              return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
          }
          // DER-encoded
          toDERRawBytes() {
              return hexToBytes(this.toDERHex());
          }
          toDERHex() {
              return DER.hexFromSig({ r: this.r, s: this.s });
          }
          // padded bytes of r, then padded bytes of s
          toCompactRawBytes() {
              return hexToBytes(this.toCompactHex());
          }
          toCompactHex() {
              return numToNByteStr(this.r) + numToNByteStr(this.s);
          }
      }
      const utils = {
          isValidPrivateKey(privateKey) {
              try {
                  normPrivateKeyToScalar(privateKey);
                  return true;
              }
              catch (error) {
                  return false;
              }
          },
          normPrivateKeyToScalar: normPrivateKeyToScalar,
          /**
           * Produces cryptographically secure private key from random of size
           * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
           */
          randomPrivateKey: () => {
              const length = getMinHashLength(CURVE.n);
              return mapHashToField(CURVE.randomBytes(length), CURVE.n);
          },
          /**
           * Creates precompute table for an arbitrary EC point. Makes point "cached".
           * Allows to massively speed-up `point.multiply(scalar)`.
           * @returns cached point
           * @example
           * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
           * fast.multiply(privKey); // much faster ECDH now
           */
          precompute(windowSize = 8, point = Point.BASE) {
              point._setWindowSize(windowSize);
              point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here
              return point;
          },
      };
      /**
       * Computes public key for a private key. Checks for validity of the private key.
       * @param privateKey private key
       * @param isCompressed whether to return compact (default), or full key
       * @returns Public key, full when isCompressed=false; short when isCompressed=true
       */
      function getPublicKey(privateKey, isCompressed = true) {
          return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
      }
      /**
       * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.
       */
      function isProbPub(item) {
          const arr = isBytes$1(item);
          const str = typeof item === 'string';
          const len = (arr || str) && item.length;
          if (arr)
              return len === compressedLen || len === uncompressedLen;
          if (str)
              return len === 2 * compressedLen || len === 2 * uncompressedLen;
          if (item instanceof Point)
              return true;
          return false;
      }
      /**
       * ECDH (Elliptic Curve Diffie Hellman).
       * Computes shared public key from private key and public key.
       * Checks: 1) private key validity 2) shared key is on-curve.
       * Does NOT hash the result.
       * @param privateA private key
       * @param publicB different public key
       * @param isCompressed whether to return compact (default), or full key
       * @returns shared public key
       */
      function getSharedSecret(privateA, publicB, isCompressed = true) {
          if (isProbPub(privateA))
              throw new Error('first arg must be private key');
          if (!isProbPub(publicB))
              throw new Error('second arg must be public key');
          const b = Point.fromHex(publicB); // check for being on-curve
          return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
      }
      // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.
      // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.
      // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.
      // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors
      const bits2int = CURVE.bits2int ||
          function (bytes) {
              // Our custom check "just in case"
              if (bytes.length > 8192)
                  throw new Error('input is too large');
              // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)
              // for some cases, since bytes.length * 8 is not actual bitLength.
              const num = bytesToNumberBE(bytes); // check for == u8 done here
              const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits
              return delta > 0 ? num >> BigInt(delta) : num;
          };
      const bits2int_modN = CURVE.bits2int_modN ||
          function (bytes) {
              return modN(bits2int(bytes)); // can't use bytesToNumberBE here
          };
      // NOTE: pads output with zero as per spec
      const ORDER_MASK = bitMask(CURVE.nBitLength);
      /**
       * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.
       */
      function int2octets(num) {
          aInRange('num < 2^' + CURVE.nBitLength, num, _0n, ORDER_MASK);
          // works with order, can have different size than numToField!
          return numberToBytesBE(num, CURVE.nByteLength);
      }
      // Steps A, D of RFC6979 3.2
      // Creates RFC6979 seed; converts msg/privKey to numbers.
      // Used only in sign, not in verify.
      // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order,
      // this will be invalid at least for P521. Also it can be bigger for P224 + SHA256
      function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
          if (['recovered', 'canonical'].some((k) => k in opts))
              throw new Error('sign() legacy options not supported');
          const { hash, randomBytes } = CURVE;
          let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default
          if (lowS == null)
              lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash
          msgHash = ensureBytes('msgHash', msgHash);
          validateSigVerOpts(opts);
          if (prehash)
              msgHash = ensureBytes('prehashed msgHash', hash(msgHash));
          // We can't later call bits2octets, since nested bits2int is broken for curves
          // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.
          // const bits2octets = (bits) => int2octets(bits2int_modN(bits))
          const h1int = bits2int_modN(msgHash);
          const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint
          const seedArgs = [int2octets(d), int2octets(h1int)];
          // extraEntropy. RFC6979 3.6: additional k' (optional).
          if (ent != null && ent !== false) {
              // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')
              const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is
              seedArgs.push(ensureBytes('extraEntropy', e)); // check for being bytes
          }
          const seed = concatBytes(...seedArgs); // Step D of RFC6979 3.2
          const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!
          // Converts signature params into point w r/s, checks result for validity.
          function k2sig(kBytes) {
              // RFC 6979 Section 3.2, step 3: k = bits2int(T)
              const k = bits2int(kBytes); // Cannot use fields methods, since it is group element
              if (!isWithinCurveOrder(k))
                  return; // Important: all mod() calls here must be done over N
              const ik = invN(k); // k^-1 mod n
              const q = Point.BASE.multiply(k).toAffine(); // q = Gk
              const r = modN(q.x); // r = q.x mod n
              if (r === _0n)
                  return;
              // Can use scalar blinding b^-1(bm + bdr) where b  [1,q1] according to
              // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:
              // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT
              const s = modN(ik * modN(m + r * d)); // Not using blinding here
              if (s === _0n)
                  return;
              let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n$1); // recovery bit (2 or 3, when q.x > n)
              let normS = s;
              if (lowS && isBiggerThanHalfOrder(s)) {
                  normS = normalizeS(s); // if lowS was passed, ensure s is always
                  recovery ^= 1; // // in the bottom half of N
              }
              return new Signature(r, normS, recovery); // use normS, not s
          }
          return { seed, k2sig };
      }
      const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
      const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
      /**
       * Signs message hash with a private key.
       * ```
       * sign(m, d, k) where
       *   (x, y) = G  k
       *   r = x mod n
       *   s = (m + dr)/k mod n
       * ```
       * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.
       * @param privKey private key
       * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.
       * @returns signature with recovery param
       */
      function sign(msgHash, privKey, opts = defaultSigOpts) {
          const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.
          const C = CURVE;
          const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
          return drbg(seed, k2sig); // Steps B, C, D, E, F, G
      }
      // Enable precomputes. Slows down first publicKey computation by 20ms.
      Point.BASE._setWindowSize(8);
      // utils.precompute(8, ProjectivePoint.BASE)
      /**
       * Verifies a signature against message hash and public key.
       * Rejects lowS signatures by default: to override,
       * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:
       *
       * ```
       * verify(r, s, h, P) where
       *   U1 = hs^-1 mod n
       *   U2 = rs^-1 mod n
       *   R = U1G - U2P
       *   mod(R.x, n) == r
       * ```
       */
      function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
          const sg = signature;
          msgHash = ensureBytes('msgHash', msgHash);
          publicKey = ensureBytes('publicKey', publicKey);
          const { lowS, prehash, format } = opts;
          // Verify opts, deduce signature format
          validateSigVerOpts(opts);
          if ('strict' in opts)
              throw new Error('options.strict was renamed to lowS');
          if (format !== undefined && format !== 'compact' && format !== 'der')
              throw new Error('format must be compact or der');
          const isHex = typeof sg === 'string' || isBytes$1(sg);
          const isObj = !isHex &&
              !format &&
              typeof sg === 'object' &&
              sg !== null &&
              typeof sg.r === 'bigint' &&
              typeof sg.s === 'bigint';
          if (!isHex && !isObj)
              throw new Error('invalid signature, expected Uint8Array, hex string or Signature instance');
          let _sig = undefined;
          let P;
          try {
              if (isObj)
                  _sig = new Signature(sg.r, sg.s);
              if (isHex) {
                  // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).
                  // Since DER can also be 2*nByteLength bytes, we check for it first.
                  try {
                      if (format !== 'compact')
                          _sig = Signature.fromDER(sg);
                  }
                  catch (derError) {
                      if (!(derError instanceof DER.Err))
                          throw derError;
                  }
                  if (!_sig && format !== 'der')
                      _sig = Signature.fromCompact(sg);
              }
              P = Point.fromHex(publicKey);
          }
          catch (error) {
              return false;
          }
          if (!_sig)
              return false;
          if (lowS && _sig.hasHighS())
              return false;
          if (prehash)
              msgHash = CURVE.hash(msgHash);
          const { r, s } = _sig;
          const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element
          const is = invN(s); // s^-1
          const u1 = modN(h * is); // u1 = hs^-1 mod n
          const u2 = modN(r * is); // u2 = rs^-1 mod n
          const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1G + u2P
          if (!R)
              return false;
          const v = modN(R.x);
          return v === r;
      }
      return {
          CURVE,
          getPublicKey,
          getSharedSecret,
          sign,
          verify,
          ProjectivePoint: Point,
          Signature,
          utils,
      };
  }

  /**
   * Utilities for short weierstrass curves, combined with noble-hashes.
   * @module
   */
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  /** connects noble-curves to noble-hashes */
  function getHash(hash) {
      return {
          hash,
          hmac: (key, ...msgs) => hmac(hash, key, concatBytes$1(...msgs)),
          randomBytes,
      };
  }
  function createCurve(curveDef, defHash) {
      const create = (hash) => weierstrass({ ...curveDef, ...getHash(hash) });
      return { ...create(defHash), create };
  }

  /**
   * NIST secp256k1. See [pdf](https://www.secg.org/sec2-v2.pdf).
   *
   * Seems to be rigid (not backdoored)
   * [as per discussion](https://bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975).
   *
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * [See explanation](https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066).
   * @module
   */
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  const secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');
  const secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');
  const _1n = BigInt(1);
  const _2n = BigInt(2);
  const divNearest = (a, b) => (a + b / _2n) / b;
  /**
   * n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.
   * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]
   */
  function sqrtMod(y) {
      const P = secp256k1P;
      // prettier-ignore
      const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
      // prettier-ignore
      const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
      const b2 = (y * y * y) % P; // x^3, 11
      const b3 = (b2 * b2 * y) % P; // x^7
      const b6 = (pow2(b3, _3n, P) * b3) % P;
      const b9 = (pow2(b6, _3n, P) * b3) % P;
      const b11 = (pow2(b9, _2n, P) * b2) % P;
      const b22 = (pow2(b11, _11n, P) * b11) % P;
      const b44 = (pow2(b22, _22n, P) * b22) % P;
      const b88 = (pow2(b44, _44n, P) * b44) % P;
      const b176 = (pow2(b88, _88n, P) * b88) % P;
      const b220 = (pow2(b176, _44n, P) * b44) % P;
      const b223 = (pow2(b220, _3n, P) * b3) % P;
      const t1 = (pow2(b223, _23n, P) * b22) % P;
      const t2 = (pow2(t1, _6n, P) * b2) % P;
      const root = pow2(t2, _2n, P);
      if (!Fpk1.eql(Fpk1.sqr(root), y))
          throw new Error('Cannot find square root');
      return root;
  }
  const Fpk1 = Field(secp256k1P, undefined, undefined, { sqrt: sqrtMod });
  /**
   * secp256k1 short weierstrass curve and ECDSA signatures over it.
   *
   * @example
   * import { secp256k1 } from '@noble/curves/secp256k1';
   *
   * const priv = secp256k1.utils.randomPrivateKey();
   * const pub = secp256k1.getPublicKey(priv);
   * const msg = new Uint8Array(32).fill(1); // message hash (not message) in ecdsa
   * const sig = secp256k1.sign(msg, priv); // `{prehash: true}` option is available
   * const isValid = secp256k1.verify(sig, msg, pub) === true;
   */
  const secp256k1 = createCurve({
      a: BigInt(0), // equation params: a, b
      b: BigInt(7),
      Fp: Fpk1, // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
      n: secp256k1N, // Curve order, total count of valid points in the field
      // Base point (x, y) aka generator point
      Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),
      Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),
      h: BigInt(1), // Cofactor
      lowS: true, // Allow only low-S signatures by default in sign() and verify()
      endo: {
          // Endomorphism, see above
          beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),
          splitScalar: (k) => {
              const n = secp256k1N;
              const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');
              const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');
              const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');
              const b2 = a1;
              const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)
              const c1 = divNearest(b2 * k, n);
              const c2 = divNearest(-b1 * k, n);
              let k1 = mod(k - c1 * a1 - c2 * a2, n);
              let k2 = mod(-c1 * b1 - c2 * b2, n);
              const k1neg = k1 > POW_2_128;
              const k2neg = k2 > POW_2_128;
              if (k1neg)
                  k1 = n - k1;
              if (k2neg)
                  k2 = n - k2;
              if (k1 > POW_2_128 || k2 > POW_2_128) {
                  throw new Error('splitScalar: Endomorphism failed, k=' + k);
              }
              return { k1neg, k1, k2neg, k2 };
          },
      },
  }, sha256);
  // Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.
  // https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki
  BigInt(0);
  secp256k1.ProjectivePoint;

  const N = secp256k1.CURVE.n;
  const HARDENED_BIT$1 = 0x80000000;

  /**
   * Mostly copied from https://github.com/bitcoinjs/bip32/blob/master/ts-src/bip32.ts
   * We cannot use that library directly because it uses `Buffer` and we want to avoid
   * polyfills as much as possible. Also, we only need the `derive` function.
   * @param {Uint8Array} parentKey
   * @param {Uint8Array} chainCode
   * @param {number} index
   * @returns {Promise<{ keyData: Uint8Array; chainCode: Uint8Array }>}
   */
  async function derive$1(parentKey, chainCode, index) {
      const isHardened = isHardenedIndex(index);
      const data = new Uint8Array(37);

      const publicKey = secp256k1.getPublicKey(parentKey, true);

      // Hardened child
      if (isHardened) {
          // data = 0x00 || ser256(kpar) || ser32(index)
          data[0] = 0x00;
          data.set(parentKey, 1);

          // Normal child
      } else {
          // data = serP(point(kpar)) || ser32(index)
          //      = serP(Kpar) || ser32(index)
          data.set(publicKey, 0);
      }

      new DataView(data.buffer, data.byteOffset, data.byteLength).setUint32(
          33,
          index,
          false,
      );

      const I = await hash(HashAlgorithm.Sha512, chainCode, data);
      const IL = I.subarray(0, 32);
      const IR = I.subarray(32);

      // if parse256(IL) >= n, proceed with the next value for i
      try {
          // ki = parse256(IL) + kpar (mod n)
          const parentKeyBigInt = bytesToNumberBE(parentKey);
          const ILBigInt = bytesToNumberBE(IL);

          // Add private keys mod N
          const ki = (parentKeyBigInt + ILBigInt) % N;

          // In case ki == 0, proceed with the next value for i
          if (ki === 0n) {
              return derive$1(parentKey, chainCode, index + 1);
          }

          const keyData = numberToBytesBE(ki, 32);

          return {
              keyData,
              chainCode: IR,
          };
      } catch {
          return derive$1(parentKey, chainCode, index + 1);
      }
  }

  /**
   * @param {Uint8Array} seed
   * @returns {Promise<{ keyData: Uint8Array; chainCode: Uint8Array }>}
   */
  async function fromSeed$1(seed) {
      if (seed.length < 16)
          throw new TypeError("Seed should be at least 128 bits");
      if (seed.length > 64)
          throw new TypeError("Seed should be at most 512 bits");

      const I = await hash(HashAlgorithm.Sha512, "Bitcoin seed", seed);

      const IL = I.subarray(0, 32);
      const IR = I.subarray(32);

      return { keyData: IL, chainCode: IR };
  }

  /**
   * Harden the index
   * @param {number} index         the derivation index
   * @returns {number}              the hardened index
   */
  function toHardenedIndex(index) {
      return index | HARDENED_BIT$1;
  }

  /**
   * Check if the index is hardened
   * @param {number} index         the derivation index
   * @returns {boolean}            true if the index is hardened
   */
  function isHardenedIndex(index) {
      return (index & HARDENED_BIT$1) !== 0;
  }

  /**
   * @param {Uint8Array} parentKey
   * @param {Uint8Array} chainCode
   * @param {number} index
   * @returns {Promise<{ keyData: Uint8Array; chainCode: Uint8Array }>}
   */
  async function derive(parentKey, chainCode, index) {
      if (isHardenedIndex(index)) {
          throw new Error("the index should not be pre-hardened");
      }

      const input = new Uint8Array(37);

      // 0x00 + parentKey + index(BE)
      input[0] = 0;
      input.set(parentKey, 1);
      new DataView(input.buffer, input.byteOffset, input.byteLength).setUint32(
          33,
          index,
          false,
      );

      // set the index to hardened
      input[33] |= 128;

      const digest = await hash(HashAlgorithm.Sha512, chainCode, input);

      return { keyData: digest.subarray(0, 32), chainCode: digest.subarray(32) };
  }

  /**
   * @param {Uint8Array} seed
   * @returns {Promise<{ keyData: Uint8Array; chainCode: Uint8Array }>}
   */
  async function fromSeed(seed) {
      const digest = await hash(
          HashAlgorithm.Sha512,
          "ed25519 seed",
          seed,
      );

      return { keyData: digest.subarray(0, 32), chainCode: digest.subarray(32) };
  }

  const derPrefix$2 = "302e020100300506032b657004220420";
  const derPrefixBytes$2 = decode$6(derPrefix$2);

  class Ed25519PrivateKey {
      /**
       * @hideconstructor
       * @internal
       * @param {nacl.SignKeyPair | Uint8Array} keyPair
       * @param {Uint8Array=} chainCode
       */
      constructor(keyPair, chainCode) {
          /**
           * @type {nacl.SignKeyPair}
           * @readonly
           * @private
           */
          this._keyPair =
              keyPair instanceof Uint8Array
                  ? nacl.sign.keyPair.fromSeed(keyPair)
                  : keyPair;

          /**
           * @type {?Uint8Array}
           * @readonly
           */
          this._chainCode = chainCode != null ? chainCode : null;
      }

      /**
       * @returns {string}
       */
      get _type() {
          return "ED25519";
      }

      /**
       * Generate a random Ed25519 private key.
       * @returns {Ed25519PrivateKey}
       */
      static generate() {
          // 32 bytes for the secret key
          // 32 bytes for the chain code (to support derivation)
          const entropy = bytes(64);

          return new Ed25519PrivateKey(
              nacl.sign.keyPair.fromSeed(entropy.subarray(0, 32)),
              entropy.subarray(32),
          );
      }

      /**
       * Generate a random Ed25519 private key.
       * @returns {Promise<Ed25519PrivateKey>}
       */
      static async generateAsync() {
          // 32 bytes for the secret key
          // 32 bytes for the chain code (to support derivation)
          const entropy = await bytesAsync(64);

          return new Ed25519PrivateKey(
              nacl.sign.keyPair.fromSeed(entropy.subarray(0, 32)),
              entropy.subarray(32),
          );
      }

      /**
       * Construct a private key from bytes.
       * @param {Uint8Array} data
       * @returns {Ed25519PrivateKey}
       */
      static fromBytes(data) {
          switch (data.length) {
              case 48:
                  return Ed25519PrivateKey.fromBytesDer(data);
              case 32:
              case 64:
                  return Ed25519PrivateKey.fromBytesRaw(data);
              default:
                  throw new BadKeyError(
                      `invalid private key length: ${data.length} bytes`,
                  );
          }
      }

      /**
       * Construct a private key from bytes with DER header.
       * @param {Uint8Array} data
       * @returns {Ed25519PrivateKey}
       */
      static fromBytesDer(data) {
          /** * @type {Uint8Array} */
          let privateKey;
          try {
              const arr = new Uint8Array(data);
              const header = arr.subarray(0, data.length - 32);
              const isValidED25519 = header.every((byte, index) => {
                  return derPrefixBytes$2[index] === byte;
              });

              if (!isValidED25519) {
                  throw new BadKeyError(
                      `invalid DER prefix for ED25519 private key`,
                  );
              }

              privateKey = arr.slice(data.length - 32);
          } catch (error) {
              const message =
                  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                  error != null && /** @type {Error} */ (error).message != null
                      ? // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                        /** @type {Error} */ (error).message
                      : "";
              throw new BadKeyError(
                  `cannot decode ED25519 private key data from DER format: ${message}`,
              );
          }

          const keyPair = nacl.sign.keyPair.fromSeed(privateKey);
          return new Ed25519PrivateKey(keyPair);
      }

      /**
       * Construct a private key from bytes without DER header.
       * @param {Uint8Array} data
       * @returns {Ed25519PrivateKey}
       */
      static fromBytesRaw(data) {
          switch (data.length) {
              case 32:
                  return new Ed25519PrivateKey(nacl.sign.keyPair.fromSeed(data));

              case 64:
                  // priv + pub key
                  return new Ed25519PrivateKey(
                      nacl.sign.keyPair.fromSecretKey(data),
                  );
          }

          throw new BadKeyError(
              `invalid private key length: ${data.length} bytes`,
          );
      }

      /**
       * Construct a private key from a hex-encoded string.
       * @param {string} text
       * @returns {Ed25519PrivateKey}
       */
      static fromString(text) {
          return Ed25519PrivateKey.fromBytes(decode$6(text));
      }

      /**
       * Construct a private key from a hex-encoded string.
       * @param {string} text
       * @returns {Ed25519PrivateKey}
       */
      static fromStringDer(text) {
          return Ed25519PrivateKey.fromBytesDer(decode$6(text));
      }

      /**
       * Construct a private key from a hex-encoded string.
       * @param {string} text
       * @returns {Ed25519PrivateKey}
       */
      static fromStringRaw(text) {
          return Ed25519PrivateKey.fromBytesRaw(decode$6(text));
      }

      /**
       * Construct a ED25519 private key from a Uint8Array seed.
       * @param {Uint8Array} seed
       * @returns {Promise<Ed25519PrivateKey>}
       */
      static async fromSeed(seed) {
          const { keyData, chainCode } = await fromSeed(seed);
          return new Ed25519PrivateKey(keyData, chainCode);
      }

      /**
       * Get the public key associated with this private key.
       *
       * The public key can be freely given and used by other parties to verify
       * the signatures generated by this private key.
       * @returns {Ed25519PublicKey}
       */
      get publicKey() {
          return new Ed25519PublicKey(this._keyPair.publicKey);
      }

      /**
       * Sign a message with this private key.
       * @param {Uint8Array} bytes
       * @returns {Uint8Array} - The signature bytes without the message
       */
      sign(bytes) {
          return nacl.sign.detached(bytes, this._keyPair.secretKey);
      }

      /**
       * @returns {Uint8Array}
       */
      toBytesDer() {
          const bytes = new Uint8Array(derPrefixBytes$2.length + 32);
          const privateKey = this._keyPair.secretKey.subarray(0, 32);
          const leadingZeroes = 32 - privateKey.length;
          const privateKeyOffset = derPrefixBytes$2.length + leadingZeroes;

          bytes.set(derPrefixBytes$2, 0);
          bytes.set(privateKey, privateKeyOffset);

          return bytes;
      }

      /**
       * @returns {Uint8Array}
       */
      toBytesRaw() {
          // copy the bytes so they can't be modified accidentally
          return this._keyPair.secretKey.slice(0, 32);
      }
  }

  // Originally sourced from:
  // https://github.com/MaiaVictor/eth-lib/blob/da0971f5b09964d9c8449975fa87933f0c9fef35/src/hash.js
  //  - added type declarations
  //  - switched to es6 module syntax
  //
  // Disable linting for entire file because it's nearly all pure JS
  // eslint-disable

  const HEX_CHARS$1 = "0123456789abcdef".split("");
  const KECCAK_PADDING$1 = [1, 256, 65536, 16777216];
  const SHIFT$1 = [0, 8, 16, 24];
  const RC$1 = [
      1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0,
      2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0,
      2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905,
      2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0,
      2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648,
      2147483649, 0, 2147516424, 2147483648,
  ];

  /**
   * @typedef {object} KeccakT
   * @property {number[]} blocks
   * @property {number} blockCount
   * @property {number} outputBlocks
   * @property {number[]} s
   * @property {number} start
   * @property {number} block
   * @property {boolean} reset
   * @property {number=} lastByteIndex
   */

  /** @type {(bits: number) => KeccakT} */
  const Keccak$1 = (bits) => ({
      blocks: [],
      reset: true,
      block: 0,
      start: 0,
      blockCount: (1600 - (bits << 1)) >> 5,
      outputBlocks: bits >> 5,
      // @ts-ignore
      s: ((s) => [].concat(s, s, s, s, s))([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
  });

  /** @type {(state: KeccakT, message: string | number[]) => string} */
  const update$1 = (state, /** @type {string | number[]} */ message) => {
      var length = message.length,
          blocks = state.blocks,
          byteCount = state.blockCount << 2,
          blockCount = state.blockCount,
          outputBlocks = state.outputBlocks,
          s = state.s,
          index = 0,
          i,
          code;

      // update
      while (index < length) {
          if (state.reset) {
              state.reset = false;
              blocks[0] = state.block;
              for (i = 1; i < blockCount + 1; ++i) {
                  blocks[i] = 0;
              }
          }
          if (typeof message !== "string") {
              for (i = state.start; index < length && i < byteCount; ++index) {
                  blocks[i >> 2] |= message[index] << SHIFT$1[i++ & 3];
              }
          } else {
              for (i = state.start; index < length && i < byteCount; ++index) {
                  code = message.charCodeAt(index);
                  if (code < 0x80) {
                      blocks[i >> 2] |= code << SHIFT$1[i++ & 3];
                  } else if (code < 0x800) {
                      blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT$1[i++ & 3];
                      blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT$1[i++ & 3];
                  } else if (code < 0xd800 || code >= 0xe000) {
                      blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT$1[i++ & 3];
                      blocks[i >> 2] |=
                          (0x80 | ((code >> 6) & 0x3f)) << SHIFT$1[i++ & 3];
                      blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT$1[i++ & 3];
                  } else {
                      code =
                          0x10000 +
                          (((code & 0x3ff) << 10) |
                              (message.charCodeAt(++index) & 0x3ff));
                      blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT$1[i++ & 3];
                      blocks[i >> 2] |=
                          (0x80 | ((code >> 12) & 0x3f)) << SHIFT$1[i++ & 3];
                      blocks[i >> 2] |=
                          (0x80 | ((code >> 6) & 0x3f)) << SHIFT$1[i++ & 3];
                      blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT$1[i++ & 3];
                  }
              }
          }
          state.lastByteIndex = i;
          if (i >= byteCount) {
              state.start = i - byteCount;
              state.block = blocks[blockCount];
              for (i = 0; i < blockCount; ++i) {
                  s[i] ^= blocks[i];
              }
              f$1(s);
              state.reset = true;
          } else {
              state.start = i;
          }
      }

      // finalize
      i = state.lastByteIndex;
      // @ts-ignore
      blocks[i >> 2] |= KECCAK_PADDING$1[i & 3];
      if (state.lastByteIndex === byteCount) {
          blocks[0] = blocks[blockCount];
          for (i = 1; i < blockCount + 1; ++i) {
              blocks[i] = 0;
          }
      }
      blocks[blockCount - 1] |= 0x80000000;
      for (i = 0; i < blockCount; ++i) {
          s[i] ^= blocks[i];
      }
      f$1(s);

      // toString
      var hex = "";
      var block;
      var j = 0;
      i = 0;
      while (j < outputBlocks) {
          for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
              block = s[i];
              hex +=
                  HEX_CHARS$1[(block >> 4) & 0x0f] +
                  HEX_CHARS$1[block & 0x0f] +
                  HEX_CHARS$1[(block >> 12) & 0x0f] +
                  HEX_CHARS$1[(block >> 8) & 0x0f] +
                  HEX_CHARS$1[(block >> 20) & 0x0f] +
                  HEX_CHARS$1[(block >> 16) & 0x0f] +
                  HEX_CHARS$1[(block >> 28) & 0x0f] +
                  HEX_CHARS$1[(block >> 24) & 0x0f];
          }
          if (j % blockCount === 0) {
              f$1(s);
              i = 0;
          }
      }
      // @ts-ignore
      return "0x" + hex;
  };

  /** @type {(s: number[]) => void} */
  const f$1 = (s) => {
      var h,
          l,
          n,
          c0,
          c1,
          c2,
          c3,
          c4,
          c5,
          c6,
          c7,
          c8,
          c9,
          b0,
          b1,
          b2,
          b3,
          b4,
          b5,
          b6,
          b7,
          b8,
          b9,
          b10,
          b11,
          b12,
          b13,
          b14,
          b15,
          b16,
          b17,
          b18,
          b19,
          b20,
          b21,
          b22,
          b23,
          b24,
          b25,
          b26,
          b27,
          b28,
          b29,
          b30,
          b31,
          b32,
          b33,
          b34,
          b35,
          b36,
          b37,
          b38,
          b39,
          b40,
          b41,
          b42,
          b43,
          b44,
          b45,
          b46,
          b47,
          b48,
          b49;

      for (n = 0; n < 48; n += 2) {
          c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
          c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
          c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
          c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
          c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
          c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
          c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
          c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
          c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
          c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];

          h = c8 ^ ((c2 << 1) | (c3 >>> 31));
          l = c9 ^ ((c3 << 1) | (c2 >>> 31));
          s[0] ^= h;
          s[1] ^= l;
          s[10] ^= h;
          s[11] ^= l;
          s[20] ^= h;
          s[21] ^= l;
          s[30] ^= h;
          s[31] ^= l;
          s[40] ^= h;
          s[41] ^= l;
          h = c0 ^ ((c4 << 1) | (c5 >>> 31));
          l = c1 ^ ((c5 << 1) | (c4 >>> 31));
          s[2] ^= h;
          s[3] ^= l;
          s[12] ^= h;
          s[13] ^= l;
          s[22] ^= h;
          s[23] ^= l;
          s[32] ^= h;
          s[33] ^= l;
          s[42] ^= h;
          s[43] ^= l;
          h = c2 ^ ((c6 << 1) | (c7 >>> 31));
          l = c3 ^ ((c7 << 1) | (c6 >>> 31));
          s[4] ^= h;
          s[5] ^= l;
          s[14] ^= h;
          s[15] ^= l;
          s[24] ^= h;
          s[25] ^= l;
          s[34] ^= h;
          s[35] ^= l;
          s[44] ^= h;
          s[45] ^= l;
          h = c4 ^ ((c8 << 1) | (c9 >>> 31));
          l = c5 ^ ((c9 << 1) | (c8 >>> 31));
          s[6] ^= h;
          s[7] ^= l;
          s[16] ^= h;
          s[17] ^= l;
          s[26] ^= h;
          s[27] ^= l;
          s[36] ^= h;
          s[37] ^= l;
          s[46] ^= h;
          s[47] ^= l;
          h = c6 ^ ((c0 << 1) | (c1 >>> 31));
          l = c7 ^ ((c1 << 1) | (c0 >>> 31));
          s[8] ^= h;
          s[9] ^= l;
          s[18] ^= h;
          s[19] ^= l;
          s[28] ^= h;
          s[29] ^= l;
          s[38] ^= h;
          s[39] ^= l;
          s[48] ^= h;
          s[49] ^= l;

          b0 = s[0];
          b1 = s[1];
          b32 = (s[11] << 4) | (s[10] >>> 28);
          b33 = (s[10] << 4) | (s[11] >>> 28);
          b14 = (s[20] << 3) | (s[21] >>> 29);
          b15 = (s[21] << 3) | (s[20] >>> 29);
          b46 = (s[31] << 9) | (s[30] >>> 23);
          b47 = (s[30] << 9) | (s[31] >>> 23);
          b28 = (s[40] << 18) | (s[41] >>> 14);
          b29 = (s[41] << 18) | (s[40] >>> 14);
          b20 = (s[2] << 1) | (s[3] >>> 31);
          b21 = (s[3] << 1) | (s[2] >>> 31);
          b2 = (s[13] << 12) | (s[12] >>> 20);
          b3 = (s[12] << 12) | (s[13] >>> 20);
          b34 = (s[22] << 10) | (s[23] >>> 22);
          b35 = (s[23] << 10) | (s[22] >>> 22);
          b16 = (s[33] << 13) | (s[32] >>> 19);
          b17 = (s[32] << 13) | (s[33] >>> 19);
          b48 = (s[42] << 2) | (s[43] >>> 30);
          b49 = (s[43] << 2) | (s[42] >>> 30);
          b40 = (s[5] << 30) | (s[4] >>> 2);
          b41 = (s[4] << 30) | (s[5] >>> 2);
          b22 = (s[14] << 6) | (s[15] >>> 26);
          b23 = (s[15] << 6) | (s[14] >>> 26);
          b4 = (s[25] << 11) | (s[24] >>> 21);
          b5 = (s[24] << 11) | (s[25] >>> 21);
          b36 = (s[34] << 15) | (s[35] >>> 17);
          b37 = (s[35] << 15) | (s[34] >>> 17);
          b18 = (s[45] << 29) | (s[44] >>> 3);
          b19 = (s[44] << 29) | (s[45] >>> 3);
          b10 = (s[6] << 28) | (s[7] >>> 4);
          b11 = (s[7] << 28) | (s[6] >>> 4);
          b42 = (s[17] << 23) | (s[16] >>> 9);
          b43 = (s[16] << 23) | (s[17] >>> 9);
          b24 = (s[26] << 25) | (s[27] >>> 7);
          b25 = (s[27] << 25) | (s[26] >>> 7);
          b6 = (s[36] << 21) | (s[37] >>> 11);
          b7 = (s[37] << 21) | (s[36] >>> 11);
          b38 = (s[47] << 24) | (s[46] >>> 8);
          b39 = (s[46] << 24) | (s[47] >>> 8);
          b30 = (s[8] << 27) | (s[9] >>> 5);
          b31 = (s[9] << 27) | (s[8] >>> 5);
          b12 = (s[18] << 20) | (s[19] >>> 12);
          b13 = (s[19] << 20) | (s[18] >>> 12);
          b44 = (s[29] << 7) | (s[28] >>> 25);
          b45 = (s[28] << 7) | (s[29] >>> 25);
          b26 = (s[38] << 8) | (s[39] >>> 24);
          b27 = (s[39] << 8) | (s[38] >>> 24);
          b8 = (s[48] << 14) | (s[49] >>> 18);
          b9 = (s[49] << 14) | (s[48] >>> 18);

          s[0] = b0 ^ (~b2 & b4);
          s[1] = b1 ^ (~b3 & b5);
          s[10] = b10 ^ (~b12 & b14);
          s[11] = b11 ^ (~b13 & b15);
          s[20] = b20 ^ (~b22 & b24);
          s[21] = b21 ^ (~b23 & b25);
          s[30] = b30 ^ (~b32 & b34);
          s[31] = b31 ^ (~b33 & b35);
          s[40] = b40 ^ (~b42 & b44);
          s[41] = b41 ^ (~b43 & b45);
          s[2] = b2 ^ (~b4 & b6);
          s[3] = b3 ^ (~b5 & b7);
          s[12] = b12 ^ (~b14 & b16);
          s[13] = b13 ^ (~b15 & b17);
          s[22] = b22 ^ (~b24 & b26);
          s[23] = b23 ^ (~b25 & b27);
          s[32] = b32 ^ (~b34 & b36);
          s[33] = b33 ^ (~b35 & b37);
          s[42] = b42 ^ (~b44 & b46);
          s[43] = b43 ^ (~b45 & b47);
          s[4] = b4 ^ (~b6 & b8);
          s[5] = b5 ^ (~b7 & b9);
          s[14] = b14 ^ (~b16 & b18);
          s[15] = b15 ^ (~b17 & b19);
          s[24] = b24 ^ (~b26 & b28);
          s[25] = b25 ^ (~b27 & b29);
          s[34] = b34 ^ (~b36 & b38);
          s[35] = b35 ^ (~b37 & b39);
          s[44] = b44 ^ (~b46 & b48);
          s[45] = b45 ^ (~b47 & b49);
          s[6] = b6 ^ (~b8 & b0);
          s[7] = b7 ^ (~b9 & b1);
          s[16] = b16 ^ (~b18 & b10);
          s[17] = b17 ^ (~b19 & b11);
          s[26] = b26 ^ (~b28 & b20);
          s[27] = b27 ^ (~b29 & b21);
          s[36] = b36 ^ (~b38 & b30);
          s[37] = b37 ^ (~b39 & b31);
          s[46] = b46 ^ (~b48 & b40);
          s[47] = b47 ^ (~b49 & b41);
          s[8] = b8 ^ (~b0 & b2);
          s[9] = b9 ^ (~b1 & b3);
          s[18] = b18 ^ (~b10 & b12);
          s[19] = b19 ^ (~b11 & b13);
          s[28] = b28 ^ (~b20 & b22);
          s[29] = b29 ^ (~b21 & b23);
          s[38] = b38 ^ (~b30 & b32);
          s[39] = b39 ^ (~b31 & b33);
          s[48] = b48 ^ (~b40 & b42);
          s[49] = b49 ^ (~b41 & b43);

          s[0] ^= RC$1[n];
          s[1] ^= RC$1[n + 1];
      }
  };

  const keccak$1 = (/** @type {number} */ bits) => (/** @type {string} */ str) => {
      var msg;
      if (str.slice(0, 2) === "0x") {
          msg = [];
          for (var i = 2, l = str.length; i < l; i += 2)
              msg.push(parseInt(str.slice(i, i + 2), 16));
      } else {
          msg = str;
      }
      // @ts-ignore
      return update$1(Keccak$1(bits), msg);
  };

  /**
   * @type {(message: string) => string}
   */
  const keccak256$2 = keccak$1(256);

  /**
   * Byte comparison utility
   * @param {Uint8Array} a
   * @param {Uint8Array} b
   * @returns {boolean}
   */
  function equalBytes(a, b) {
      if (a.length !== b.length) {
          return false;
      }

      for (let i = 0; i < a.length; i++) {
          if (a[i] !== b[i]) return false;
      }
      return true;
  }

  /**
   * @typedef {import("../EcdsaPrivateKey.js").KeyPair} KeyPair
   */

  /**
   * @returns {KeyPair}
   */
  function generate() {
      const privateKey = secp256k1.utils.randomPrivateKey();
      const publicKey = secp256k1.getPublicKey(privateKey, true);

      return {
          privateKey,
          publicKey,
      };
  }

  /**
   * @returns {Promise<KeyPair>}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async function generateAsync() {
      return Promise.resolve(generate());
  }

  /**
   * @param {Uint8Array} data
   * @returns {KeyPair}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  function fromBytes(data) {
      const privateKey = new Uint8Array(data);
      const publicKey = secp256k1.getPublicKey(privateKey, true);

      return {
          privateKey: privateKey,
          publicKey: publicKey,
      };
  }

  /**
   * @param {Uint8Array} keydata
   * @param {Uint8Array} message
   * @returns {Uint8Array}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  function sign(keydata, message) {
      const msg = encode$3(message);
      const data = decode$6(keccak256$2(`0x${msg}`));
      const signature = secp256k1.sign(data, keydata);

      return signature.toCompactRawBytes();
  }

  /**
   * @param {Uint8Array} keydata
   * @param {Uint8Array} message
   * @param {Uint8Array} signature
   * @returns {boolean}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  function verify(keydata, message, signature) {
      const msg = encode$3(message);
      const data = decode$6(keccak256$2(`0x${msg}`));

      const r = BigInt("0x" + encode$3(signature.subarray(0, 32)));
      const s = BigInt("0x" + encode$3(signature.subarray(32, 64)));

      return secp256k1.verify({ r, s }, data, keydata);
  }

  /**
   * @param {Uint8Array} privateKey
   * @param {Uint8Array} signature - 64-byte compact signature (r || s)
   * @param {Uint8Array} message - Original message (not hashed)
   * @returns {number} Recovery ID (03), or -1
   */
  function getRecoveryId(privateKey, signature, message) {
      const expectedPubKey = secp256k1.getPublicKey(privateKey, false);
      const hash = decode$6(keccak256$2(`0x${encode$3(message)}`));

      for (let recovery = 0; recovery < 4; recovery++) {
          try {
              const sig =
                  secp256k1.Signature.fromCompact(signature).addRecoveryBit(
                      recovery,
                  );

              const recovered = sig.recoverPublicKey(hash).toRawBytes(false);

              if (equalBytes(recovered, expectedPubKey)) {
                  return recovery;
              }
          } catch {
              // Ignore invalid recoveries
          }
      }

      throw new Error("Unexpected error: could not construct a recoverable key.");
  }

  const legacyDerPrefix = "302d300706052b8104000a032200";
  const legacyDerPrefixBytes = decode$6(legacyDerPrefix);

  const derPrefix$1 = "3036301006072a8648ce3d020106052b8104000a032200";
  const derPrefixBytes$1 = decode$6(derPrefix$1);

  /**
   * A public key on the Hedera network.
   */
  class EcdsaPublicKey extends Key$1 {
      /**
       * @internal
       * @hideconstructor
       * @param {Uint8Array} keyData
       */
      constructor(keyData) {
          super();

          /**
           * @type {Uint8Array}
           * @private
           * @readonly
           */
          this._keyData = keyData;
      }

      /**
       * @returns {string}
       */
      get _type() {
          return "secp256k1";
      }

      /**
       * @param {Uint8Array} data
       * @returns {EcdsaPublicKey}
       */
      static fromBytes(data) {
          switch (data.length) {
              case 33:
                  return EcdsaPublicKey.fromBytesRaw(data);
              default:
                  return EcdsaPublicKey.fromBytesDer(data);
          }
      }

      /**
       * @param {Uint8Array} data
       * @returns {EcdsaPublicKey}
       */
      static fromBytesDer(data) {
          let ecdsaPublicKeyBytes;

          switch (data.length) {
              case 47: // Legacy DER prefix
                  ecdsaPublicKeyBytes = data.subarray(
                      legacyDerPrefixBytes.length,
                  );
                  break;
              case 56: // Standard DER prefix
                  ecdsaPublicKeyBytes = data.subarray(
                      derPrefixBytes$1.length,
                      derPrefixBytes$1.length + 33,
                  );
                  break;
              default: // Uncompressed DER public keys
                  try {
                      const keyPair = secp256k1.ProjectivePoint.fromHex(
                          data.subarray(derPrefixBytes$1.length),
                      );
                      ecdsaPublicKeyBytes = keyPair.toRawBytes(true); // Compressed format
                  } catch (error) {
                      throw new BadKeyError(
                          `cannot decode ECDSA public key from this DER format`,
                      );
                  }
                  break;
          }

          if (!ecdsaPublicKeyBytes || ecdsaPublicKeyBytes.length === 0) {
              throw new BadKeyError(
                  `cannot decode ECDSA public key from this DER format`,
              );
          }
          return new EcdsaPublicKey(ecdsaPublicKeyBytes);
      }

      /**
       * @param {Uint8Array} data
       * @returns {EcdsaPublicKey}
       */
      static fromBytesRaw(data) {
          if (data.length !== 33) {
              throw new BadKeyError(
                  `invalid public key length: ${data.length} bytes`,
              );
          }
          return new EcdsaPublicKey(data);
      }

      /**
       * Parse a public key from a hexadecimal string.
       *
       * The public key may optionally be prefixed with
       * the DER header.
       * @param {string} text
       * @returns {EcdsaPublicKey}
       */
      static fromString(text) {
          return EcdsaPublicKey.fromBytes(decode$6(text));
      }

      /**
       * Verify a signature on a message with this public key.
       * @param {Uint8Array} message
       * @param {Uint8Array} signature
       * @returns {boolean}
       */
      verify(message, signature) {
          return verify(this._keyData, message, signature);
      }

      /**
       * @returns {Uint8Array}
       */
      toBytesDer() {
          const bytes = new Uint8Array(
              legacyDerPrefixBytes.length + this._keyData.length,
          );

          bytes.set(legacyDerPrefixBytes, 0);
          bytes.set(this._keyData, legacyDerPrefixBytes.length);

          return bytes;
      }

      /**
       * @returns {Uint8Array}
       */
      toBytesRaw() {
          return new Uint8Array(this._keyData.subarray());
      }

      /**
       * @returns {string}
       */
      toEthereumAddress() {
          const publicKey = secp256k1.ProjectivePoint.fromHex(
              this._keyData,
          ).toRawBytes(false);
          const hash = decode$6(
              keccak256$2(`0x${encode$3(publicKey.subarray(1))}`),
          );
          return encode$3(hash.subarray(12));
      }

      /**
       * @param {EcdsaPublicKey} other
       * @returns {boolean}
       */
      equals(other) {
          return arrayEqual$1(this._keyData, other._keyData);
      }
  }

  const derPrefix = "3030020100300706052b8104000a04220420";
  const derPrefixBytes = decode$6(derPrefix);

  const derPrefix2 = "30540201010420";
  const derPrefixBytes2 = decode$6(derPrefix2);

  /**
   * @typedef {object} KeyPair
   * @property {Uint8Array} publicKey
   * @property {Uint8Array} privateKey
   */

  class EcdsaPrivateKey {
      /**
       * @hideconstructor
       * @internal
       * @param {KeyPair} keyPair
       * @param {(Uint8Array)=} chainCode
       */
      constructor(keyPair, chainCode) {
          /**
           * @type {KeyPair}
           * @readonly
           * @private
           */
          this._keyPair = keyPair;

          /**
           * @type {?Uint8Array}
           * @readonly
           */
          this._chainCode = chainCode != null ? chainCode : null;
      }

      /**
       * @returns {string}
       */
      get _type() {
          return "secp256k1";
      }

      /**
       * Generate a random ECDSA private key.
       * @returns {EcdsaPrivateKey}
       */
      static generate() {
          return new EcdsaPrivateKey(generate());
      }

      /**
       * Generate a random Ed25519 private key.
       * @returns {Promise<EcdsaPrivateKey>}
       */
      static async generateAsync() {
          return new EcdsaPrivateKey(await generateAsync());
      }

      /**
       * Construct a private key from bytes.
       * @param {Uint8Array} data
       * @returns {EcdsaPrivateKey}
       */
      static fromBytes(data) {
          switch (data.length) {
              case 32:
                  return EcdsaPrivateKey.fromBytesRaw(data);
              default:
                  return EcdsaPrivateKey.fromBytesDer(data);
          }
      }

      /**
       * Construct a private key from bytes.
       * @param {Uint8Array} data
       * @returns {EcdsaPrivateKey}
       */
      static fromBytesDer(data) {
          /** @type {Uint8Array} */
          let ecdsaPrivateKeyBytes = new Uint8Array();

          if (arrayStartsWith(data, derPrefixBytes)) {
              ecdsaPrivateKeyBytes = data.subarray(derPrefixBytes.length);
          } else {
              // For now, we assume that if we get to the `else` statement
              // the lengths of all other bytePrefixes is equal, so we treat them equally
              ecdsaPrivateKeyBytes = data.subarray(
                  derPrefixBytes2.length,
                  derPrefixBytes2.length + 32,
              );
          }

          return new EcdsaPrivateKey(fromBytes(ecdsaPrivateKeyBytes));
      }

      /**
       * Construct a private key from bytes.
       * @param {Uint8Array} data
       * @returns {EcdsaPrivateKey}
       */
      static fromBytesRaw(data) {
          return new EcdsaPrivateKey(fromBytes(data));
      }

      /**
       * Construct a private key from a hex-encoded string.
       * @param {string} text
       * @returns {EcdsaPrivateKey}
       */
      static fromString(text) {
          return EcdsaPrivateKey.fromBytes(decode$6(text));
      }

      /**
       * Construct a private key from a hex-encoded string.
       * @param {string} text
       * @returns {EcdsaPrivateKey}
       */
      static fromStringDer(text) {
          return EcdsaPrivateKey.fromBytesDer(decode$6(text));
      }

      /**
       * Construct a private key from a hex-encoded string.
       * @param {string} text
       * @returns {EcdsaPrivateKey}
       */
      static fromStringRaw(text) {
          return EcdsaPrivateKey.fromBytesRaw(decode$6(text));
      }

      /**
       * Construct a ECDSA private key from a Uint8Array seed.
       * @param {Uint8Array} seed
       * @returns {Promise<EcdsaPrivateKey>}
       */
      static async fromSeed(seed) {
          const { keyData, chainCode } = await fromSeed$1(seed);
          return new EcdsaPrivateKey(fromBytes(keyData), chainCode);
      }

      /**
       * Get the public key associated with this private key.
       *
       * The public key can be freely given and used by other parties to verify
       * the signatures generated by this private key.
       * @returns {EcdsaPublicKey}
       */
      get publicKey() {
          return new EcdsaPublicKey(this._keyPair.publicKey);
      }

      /**
       * Sign a message with this private key.
       * @param {Uint8Array} bytes
       * @returns {Uint8Array} - The signature bytes without the message
       */
      sign(bytes) {
          return sign(this._keyPair.privateKey, bytes);
      }

      /**
       * @returns {Uint8Array}
       */
      toBytesDer() {
          const bytes = new Uint8Array(derPrefixBytes.length + 32);
          const privateKey = this._keyPair.privateKey.subarray(0, 32);
          const leadingZeroes = 32 - privateKey.length;
          const privateKeyOffset = derPrefixBytes.length + leadingZeroes;
          bytes.set(derPrefixBytes, 0);
          bytes.set(privateKey, privateKeyOffset);
          return bytes;
      }

      /**
       * @returns {Uint8Array}
       */
      toBytesRaw() {
          const privateKey = this._keyPair.privateKey.subarray(-32); // Takes the last 32 bytes (or fewer if shorter)
          const leadingZeroes = 32 - privateKey.length;
          const bytes = new Uint8Array(32);
          bytes.set(privateKey, leadingZeroes);
          return bytes;
      }

      /**
       * Recover the recovery ID used in the signature for the given message.
       * @param {Uint8Array} signature - 64-byte compact signature (r || s)
       * @param {Uint8Array} message - The original (unhashed) message
       * @returns {number} Recovery ID (03), or -1 if not found
       */
      getRecoveryId(signature, message) {
          return getRecoveryId(
              this._keyPair.privateKey,
              signature,
              message,
          );
      }
  }

  /**
   * @typedef {import("./PrivateKey.js").Transaction} Transaction
   */

  /**
   * An public key on the Hedera network.
   */
  let PublicKey$1 = class PublicKey extends Key$1 {
      /**
       * @internal
       * @hideconstructor
       * @param {Ed25519PublicKey | EcdsaPublicKey} key
       */
      constructor(key) {
          super();

          /**
           * @type {Ed25519PublicKey | EcdsaPublicKey}
           * @private
           * @readonly
           */
          this._key = key;
      }

      /**
       * @returns {string}
       */
      get _type() {
          return this._key._type;
      }

      /**
       * @param {Uint8Array} data
       * @returns {PublicKey}
       */
      static fromBytes(data) {
          let message;
          try {
              return new PublicKey(Ed25519PublicKey.fromBytes(data));
          } catch (error) {
              message =
                  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                  error != null && /** @type {Error} */ (error).message != null
                      ? // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                        /** @type {Error} */ (error).message
                      : "";
          }

          try {
              return new PublicKey(EcdsaPublicKey.fromBytes(data));
          } catch (error) {
              message =
                  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                  error != null && /** @type {Error} */ (error).message != null
                      ? // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                        /** @type {Error} */ (error).message
                      : "";
          }

          throw new BadKeyError(
              `public key cannot be decoded from bytes: ${message}`,
          );
      }

      /**
       * @param {Uint8Array} data
       * @returns {PublicKey}
       */
      static fromBytesED25519(data) {
          return new PublicKey(Ed25519PublicKey.fromBytes(data));
      }

      /**
       * @param {Uint8Array} data
       * @returns {PublicKey}
       */
      static fromBytesECDSA(data) {
          return new PublicKey(EcdsaPublicKey.fromBytes(data));
      }

      /**
       * Parse a public key from a string of hexadecimal digits.
       *
       * The public key may optionally be prefixed with
       * the DER header.
       * @param {string} text
       * @returns {PublicKey}
       */
      static fromString(text) {
          return PublicKey.fromBytes(decode$6(text));
      }

      /**
       * @param {string} text
       * @returns {PublicKey}
       */
      static fromStringED25519(text) {
          return PublicKey.fromBytesED25519(decode$6(text));
      }

      /**
       * @param {string} text
       * @returns {PublicKey}
       */
      static fromStringECDSA(text) {
          return PublicKey.fromBytesECDSA(decode$6(text));
      }

      /**
       * Verify a signature on a message with this public key.
       * @param {Uint8Array} message
       * @param {Uint8Array} signature
       * @returns {boolean}
       */
      verify(message, signature) {
          return this._key.verify(message, signature);
      }

      /**
       * @deprecated - use `@hashgraph/sdk`.PublicKey instead
       * @param {Transaction} transaction
       * @returns {boolean}
       */
      verifyTransaction(transaction) {
          //NOSONAR
          console.log("Deprecated: use `@hashgraph/sdk`.PublicKey instead");

          transaction._requireFrozen();

          if (!transaction.isFrozen()) {
              transaction.freeze();
          }

          for (const signedTransaction of transaction._signedTransactions) {
              if (
                  signedTransaction.sigMap != null &&
                  signedTransaction.sigMap.sigPair != null
              ) {
                  let found = false;
                  for (const sigPair of signedTransaction.sigMap.sigPair) {
                      const pubKeyPrefix = /** @type {Uint8Array} */ (
                          sigPair.pubKeyPrefix
                      );
                      if (arrayEqual$1(pubKeyPrefix, this.toBytesRaw())) {
                          found = true;
                          const bodyBytes = /** @type {Uint8Array} */ (
                              signedTransaction.bodyBytes
                          );
                          const signature =
                              sigPair.ed25519 != null
                                  ? sigPair.ed25519
                                  : /** @type {Uint8Array} */ (
                                        sigPair.ECDSASecp256k1
                                    );
                          if (!this.verify(bodyBytes, signature)) {
                              return false;
                          }
                      }
                  }

                  if (!found) {
                      return false;
                  }
              }
          }

          return true;
      }

      /**
       * @returns {Uint8Array}
       */
      toBytes() {
          if (this._key instanceof Ed25519PublicKey) {
              return this.toBytesRaw();
          } else {
              return this.toBytesDer();
          }
      }

      /**
       * @returns {Uint8Array}
       */
      toBytesDer() {
          return this._key.toBytesDer();
      }

      /**
       * @returns {Uint8Array}
       */
      toBytesRaw() {
          return this._key.toBytesRaw();
      }

      /**
       * @returns {string}
       */
      toString() {
          return this.toStringDer();
      }

      /**
       * @returns {string}
       */
      toStringDer() {
          return encode$3(this.toBytesDer());
      }

      /**
       * @returns {string}
       */
      toStringRaw() {
          return encode$3(this.toBytesRaw());
      }

      /**
       * @returns {string}
       */
      toEthereumAddress() {
          if (this._key instanceof EcdsaPublicKey) {
              return this._key.toEthereumAddress();
          } else {
              throw new Error("unsupported operation on Ed25519PublicKey");
          }
      }

      /**
       * @param {PublicKey} other
       * @returns {boolean}
       */
      equals(other) {
          if (
              this._key instanceof Ed25519PublicKey &&
              other._key instanceof Ed25519PublicKey
          ) {
              return this._key.equals(other._key);
          } else if (
              this._key instanceof EcdsaPublicKey &&
              other._key instanceof EcdsaPublicKey
          ) {
              return this._key.equals(other._key);
          } else {
              return false;
          }
      }
  };

  var sparkMd5 = {exports: {}};

  var hasRequiredSparkMd5;

  function requireSparkMd5 () {
  	if (hasRequiredSparkMd5) return sparkMd5.exports;
  	hasRequiredSparkMd5 = 1;
  	(function (module, exports) {
  		(function (factory) {
  		    {
  		        // Node/CommonJS
  		        module.exports = factory();
  		    }
  		}(function (undefined$1) {

  		    /*
  		     * Fastest md5 implementation around (JKM md5).
  		     * Credits: Joseph Myers
  		     *
  		     * @see http://www.myersdaily.org/joseph/javascript/md5-text.html
  		     * @see http://jsperf.com/md5-shootout/7
  		     */

  		    /* this function is much faster,
  		      so if possible we use it. Some IEs
  		      are the only ones I know of that
  		      need the idiotic second function,
  		      generated by an if clause.  */
  		    var hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];

  		    function md5cycle(x, k) {
  		        var a = x[0],
  		            b = x[1],
  		            c = x[2],
  		            d = x[3];

  		        a += (b & c | ~b & d) + k[0] - 680876936 | 0;
  		        a  = (a << 7 | a >>> 25) + b | 0;
  		        d += (a & b | ~a & c) + k[1] - 389564586 | 0;
  		        d  = (d << 12 | d >>> 20) + a | 0;
  		        c += (d & a | ~d & b) + k[2] + 606105819 | 0;
  		        c  = (c << 17 | c >>> 15) + d | 0;
  		        b += (c & d | ~c & a) + k[3] - 1044525330 | 0;
  		        b  = (b << 22 | b >>> 10) + c | 0;
  		        a += (b & c | ~b & d) + k[4] - 176418897 | 0;
  		        a  = (a << 7 | a >>> 25) + b | 0;
  		        d += (a & b | ~a & c) + k[5] + 1200080426 | 0;
  		        d  = (d << 12 | d >>> 20) + a | 0;
  		        c += (d & a | ~d & b) + k[6] - 1473231341 | 0;
  		        c  = (c << 17 | c >>> 15) + d | 0;
  		        b += (c & d | ~c & a) + k[7] - 45705983 | 0;
  		        b  = (b << 22 | b >>> 10) + c | 0;
  		        a += (b & c | ~b & d) + k[8] + 1770035416 | 0;
  		        a  = (a << 7 | a >>> 25) + b | 0;
  		        d += (a & b | ~a & c) + k[9] - 1958414417 | 0;
  		        d  = (d << 12 | d >>> 20) + a | 0;
  		        c += (d & a | ~d & b) + k[10] - 42063 | 0;
  		        c  = (c << 17 | c >>> 15) + d | 0;
  		        b += (c & d | ~c & a) + k[11] - 1990404162 | 0;
  		        b  = (b << 22 | b >>> 10) + c | 0;
  		        a += (b & c | ~b & d) + k[12] + 1804603682 | 0;
  		        a  = (a << 7 | a >>> 25) + b | 0;
  		        d += (a & b | ~a & c) + k[13] - 40341101 | 0;
  		        d  = (d << 12 | d >>> 20) + a | 0;
  		        c += (d & a | ~d & b) + k[14] - 1502002290 | 0;
  		        c  = (c << 17 | c >>> 15) + d | 0;
  		        b += (c & d | ~c & a) + k[15] + 1236535329 | 0;
  		        b  = (b << 22 | b >>> 10) + c | 0;

  		        a += (b & d | c & ~d) + k[1] - 165796510 | 0;
  		        a  = (a << 5 | a >>> 27) + b | 0;
  		        d += (a & c | b & ~c) + k[6] - 1069501632 | 0;
  		        d  = (d << 9 | d >>> 23) + a | 0;
  		        c += (d & b | a & ~b) + k[11] + 643717713 | 0;
  		        c  = (c << 14 | c >>> 18) + d | 0;
  		        b += (c & a | d & ~a) + k[0] - 373897302 | 0;
  		        b  = (b << 20 | b >>> 12) + c | 0;
  		        a += (b & d | c & ~d) + k[5] - 701558691 | 0;
  		        a  = (a << 5 | a >>> 27) + b | 0;
  		        d += (a & c | b & ~c) + k[10] + 38016083 | 0;
  		        d  = (d << 9 | d >>> 23) + a | 0;
  		        c += (d & b | a & ~b) + k[15] - 660478335 | 0;
  		        c  = (c << 14 | c >>> 18) + d | 0;
  		        b += (c & a | d & ~a) + k[4] - 405537848 | 0;
  		        b  = (b << 20 | b >>> 12) + c | 0;
  		        a += (b & d | c & ~d) + k[9] + 568446438 | 0;
  		        a  = (a << 5 | a >>> 27) + b | 0;
  		        d += (a & c | b & ~c) + k[14] - 1019803690 | 0;
  		        d  = (d << 9 | d >>> 23) + a | 0;
  		        c += (d & b | a & ~b) + k[3] - 187363961 | 0;
  		        c  = (c << 14 | c >>> 18) + d | 0;
  		        b += (c & a | d & ~a) + k[8] + 1163531501 | 0;
  		        b  = (b << 20 | b >>> 12) + c | 0;
  		        a += (b & d | c & ~d) + k[13] - 1444681467 | 0;
  		        a  = (a << 5 | a >>> 27) + b | 0;
  		        d += (a & c | b & ~c) + k[2] - 51403784 | 0;
  		        d  = (d << 9 | d >>> 23) + a | 0;
  		        c += (d & b | a & ~b) + k[7] + 1735328473 | 0;
  		        c  = (c << 14 | c >>> 18) + d | 0;
  		        b += (c & a | d & ~a) + k[12] - 1926607734 | 0;
  		        b  = (b << 20 | b >>> 12) + c | 0;

  		        a += (b ^ c ^ d) + k[5] - 378558 | 0;
  		        a  = (a << 4 | a >>> 28) + b | 0;
  		        d += (a ^ b ^ c) + k[8] - 2022574463 | 0;
  		        d  = (d << 11 | d >>> 21) + a | 0;
  		        c += (d ^ a ^ b) + k[11] + 1839030562 | 0;
  		        c  = (c << 16 | c >>> 16) + d | 0;
  		        b += (c ^ d ^ a) + k[14] - 35309556 | 0;
  		        b  = (b << 23 | b >>> 9) + c | 0;
  		        a += (b ^ c ^ d) + k[1] - 1530992060 | 0;
  		        a  = (a << 4 | a >>> 28) + b | 0;
  		        d += (a ^ b ^ c) + k[4] + 1272893353 | 0;
  		        d  = (d << 11 | d >>> 21) + a | 0;
  		        c += (d ^ a ^ b) + k[7] - 155497632 | 0;
  		        c  = (c << 16 | c >>> 16) + d | 0;
  		        b += (c ^ d ^ a) + k[10] - 1094730640 | 0;
  		        b  = (b << 23 | b >>> 9) + c | 0;
  		        a += (b ^ c ^ d) + k[13] + 681279174 | 0;
  		        a  = (a << 4 | a >>> 28) + b | 0;
  		        d += (a ^ b ^ c) + k[0] - 358537222 | 0;
  		        d  = (d << 11 | d >>> 21) + a | 0;
  		        c += (d ^ a ^ b) + k[3] - 722521979 | 0;
  		        c  = (c << 16 | c >>> 16) + d | 0;
  		        b += (c ^ d ^ a) + k[6] + 76029189 | 0;
  		        b  = (b << 23 | b >>> 9) + c | 0;
  		        a += (b ^ c ^ d) + k[9] - 640364487 | 0;
  		        a  = (a << 4 | a >>> 28) + b | 0;
  		        d += (a ^ b ^ c) + k[12] - 421815835 | 0;
  		        d  = (d << 11 | d >>> 21) + a | 0;
  		        c += (d ^ a ^ b) + k[15] + 530742520 | 0;
  		        c  = (c << 16 | c >>> 16) + d | 0;
  		        b += (c ^ d ^ a) + k[2] - 995338651 | 0;
  		        b  = (b << 23 | b >>> 9) + c | 0;

  		        a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;
  		        a  = (a << 6 | a >>> 26) + b | 0;
  		        d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;
  		        d  = (d << 10 | d >>> 22) + a | 0;
  		        c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;
  		        c  = (c << 15 | c >>> 17) + d | 0;
  		        b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;
  		        b  = (b << 21 |b >>> 11) + c | 0;
  		        a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;
  		        a  = (a << 6 | a >>> 26) + b | 0;
  		        d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;
  		        d  = (d << 10 | d >>> 22) + a | 0;
  		        c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;
  		        c  = (c << 15 | c >>> 17) + d | 0;
  		        b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;
  		        b  = (b << 21 |b >>> 11) + c | 0;
  		        a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;
  		        a  = (a << 6 | a >>> 26) + b | 0;
  		        d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;
  		        d  = (d << 10 | d >>> 22) + a | 0;
  		        c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;
  		        c  = (c << 15 | c >>> 17) + d | 0;
  		        b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;
  		        b  = (b << 21 |b >>> 11) + c | 0;
  		        a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;
  		        a  = (a << 6 | a >>> 26) + b | 0;
  		        d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;
  		        d  = (d << 10 | d >>> 22) + a | 0;
  		        c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;
  		        c  = (c << 15 | c >>> 17) + d | 0;
  		        b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;
  		        b  = (b << 21 | b >>> 11) + c | 0;

  		        x[0] = a + x[0] | 0;
  		        x[1] = b + x[1] | 0;
  		        x[2] = c + x[2] | 0;
  		        x[3] = d + x[3] | 0;
  		    }

  		    function md5blk(s) {
  		        var md5blks = [],
  		            i; /* Andy King said do it this way. */

  		        for (i = 0; i < 64; i += 4) {
  		            md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
  		        }
  		        return md5blks;
  		    }

  		    function md5blk_array(a) {
  		        var md5blks = [],
  		            i; /* Andy King said do it this way. */

  		        for (i = 0; i < 64; i += 4) {
  		            md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);
  		        }
  		        return md5blks;
  		    }

  		    function md51(s) {
  		        var n = s.length,
  		            state = [1732584193, -271733879, -1732584194, 271733878],
  		            i,
  		            length,
  		            tail,
  		            tmp,
  		            lo,
  		            hi;

  		        for (i = 64; i <= n; i += 64) {
  		            md5cycle(state, md5blk(s.substring(i - 64, i)));
  		        }
  		        s = s.substring(i - 64);
  		        length = s.length;
  		        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  		        for (i = 0; i < length; i += 1) {
  		            tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);
  		        }
  		        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
  		        if (i > 55) {
  		            md5cycle(state, tail);
  		            for (i = 0; i < 16; i += 1) {
  		                tail[i] = 0;
  		            }
  		        }

  		        // Beware that the final length might not fit in 32 bits so we take care of that
  		        tmp = n * 8;
  		        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
  		        lo = parseInt(tmp[2], 16);
  		        hi = parseInt(tmp[1], 16) || 0;

  		        tail[14] = lo;
  		        tail[15] = hi;

  		        md5cycle(state, tail);
  		        return state;
  		    }

  		    function md51_array(a) {
  		        var n = a.length,
  		            state = [1732584193, -271733879, -1732584194, 271733878],
  		            i,
  		            length,
  		            tail,
  		            tmp,
  		            lo,
  		            hi;

  		        for (i = 64; i <= n; i += 64) {
  		            md5cycle(state, md5blk_array(a.subarray(i - 64, i)));
  		        }

  		        // Not sure if it is a bug, however IE10 will always produce a sub array of length 1
  		        // containing the last element of the parent array if the sub array specified starts
  		        // beyond the length of the parent array - weird.
  		        // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue
  		        a = (i - 64) < n ? a.subarray(i - 64) : new Uint8Array(0);

  		        length = a.length;
  		        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  		        for (i = 0; i < length; i += 1) {
  		            tail[i >> 2] |= a[i] << ((i % 4) << 3);
  		        }

  		        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
  		        if (i > 55) {
  		            md5cycle(state, tail);
  		            for (i = 0; i < 16; i += 1) {
  		                tail[i] = 0;
  		            }
  		        }

  		        // Beware that the final length might not fit in 32 bits so we take care of that
  		        tmp = n * 8;
  		        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
  		        lo = parseInt(tmp[2], 16);
  		        hi = parseInt(tmp[1], 16) || 0;

  		        tail[14] = lo;
  		        tail[15] = hi;

  		        md5cycle(state, tail);

  		        return state;
  		    }

  		    function rhex(n) {
  		        var s = '',
  		            j;
  		        for (j = 0; j < 4; j += 1) {
  		            s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];
  		        }
  		        return s;
  		    }

  		    function hex(x) {
  		        var i;
  		        for (i = 0; i < x.length; i += 1) {
  		            x[i] = rhex(x[i]);
  		        }
  		        return x.join('');
  		    }

  		    // In some cases the fast add32 function cannot be used..
  		    if (hex(md51('hello')) !== '5d41402abc4b2a76b9719d911017c592') ;

  		    // ---------------------------------------------------

  		    /**
  		     * ArrayBuffer slice polyfill.
  		     *
  		     * @see https://github.com/ttaubert/node-arraybuffer-slice
  		     */

  		    if (typeof ArrayBuffer !== 'undefined' && !ArrayBuffer.prototype.slice) {
  		        (function () {
  		            function clamp(val, length) {
  		                val = (val | 0) || 0;

  		                if (val < 0) {
  		                    return Math.max(val + length, 0);
  		                }

  		                return Math.min(val, length);
  		            }

  		            ArrayBuffer.prototype.slice = function (from, to) {
  		                var length = this.byteLength,
  		                    begin = clamp(from, length),
  		                    end = length,
  		                    num,
  		                    target,
  		                    targetArray,
  		                    sourceArray;

  		                if (to !== undefined$1) {
  		                    end = clamp(to, length);
  		                }

  		                if (begin > end) {
  		                    return new ArrayBuffer(0);
  		                }

  		                num = end - begin;
  		                target = new ArrayBuffer(num);
  		                targetArray = new Uint8Array(target);

  		                sourceArray = new Uint8Array(this, begin, num);
  		                targetArray.set(sourceArray);

  		                return target;
  		            };
  		        })();
  		    }

  		    // ---------------------------------------------------

  		    /**
  		     * Helpers.
  		     */

  		    function toUtf8(str) {
  		        if (/[\u0080-\uFFFF]/.test(str)) {
  		            str = unescape(encodeURIComponent(str));
  		        }

  		        return str;
  		    }

  		    function utf8Str2ArrayBuffer(str, returnUInt8Array) {
  		        var length = str.length,
  		           buff = new ArrayBuffer(length),
  		           arr = new Uint8Array(buff),
  		           i;

  		        for (i = 0; i < length; i += 1) {
  		            arr[i] = str.charCodeAt(i);
  		        }

  		        return returnUInt8Array ? arr : buff;
  		    }

  		    function arrayBuffer2Utf8Str(buff) {
  		        return String.fromCharCode.apply(null, new Uint8Array(buff));
  		    }

  		    function concatenateArrayBuffers(first, second, returnUInt8Array) {
  		        var result = new Uint8Array(first.byteLength + second.byteLength);

  		        result.set(new Uint8Array(first));
  		        result.set(new Uint8Array(second), first.byteLength);

  		        return result ;
  		    }

  		    function hexToBinaryString(hex) {
  		        var bytes = [],
  		            length = hex.length,
  		            x;

  		        for (x = 0; x < length - 1; x += 2) {
  		            bytes.push(parseInt(hex.substr(x, 2), 16));
  		        }

  		        return String.fromCharCode.apply(String, bytes);
  		    }

  		    // ---------------------------------------------------

  		    /**
  		     * SparkMD5 OOP implementation.
  		     *
  		     * Use this class to perform an incremental md5, otherwise use the
  		     * static methods instead.
  		     */

  		    function SparkMD5() {
  		        // call reset to init the instance
  		        this.reset();
  		    }

  		    /**
  		     * Appends a string.
  		     * A conversion will be applied if an utf8 string is detected.
  		     *
  		     * @param {String} str The string to be appended
  		     *
  		     * @return {SparkMD5} The instance itself
  		     */
  		    SparkMD5.prototype.append = function (str) {
  		        // Converts the string to utf8 bytes if necessary
  		        // Then append as binary
  		        this.appendBinary(toUtf8(str));

  		        return this;
  		    };

  		    /**
  		     * Appends a binary string.
  		     *
  		     * @param {String} contents The binary string to be appended
  		     *
  		     * @return {SparkMD5} The instance itself
  		     */
  		    SparkMD5.prototype.appendBinary = function (contents) {
  		        this._buff += contents;
  		        this._length += contents.length;

  		        var length = this._buff.length,
  		            i;

  		        for (i = 64; i <= length; i += 64) {
  		            md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));
  		        }

  		        this._buff = this._buff.substring(i - 64);

  		        return this;
  		    };

  		    /**
  		     * Finishes the incremental computation, reseting the internal state and
  		     * returning the result.
  		     *
  		     * @param {Boolean} raw True to get the raw string, false to get the hex string
  		     *
  		     * @return {String} The result
  		     */
  		    SparkMD5.prototype.end = function (raw) {
  		        var buff = this._buff,
  		            length = buff.length,
  		            i,
  		            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  		            ret;

  		        for (i = 0; i < length; i += 1) {
  		            tail[i >> 2] |= buff.charCodeAt(i) << ((i % 4) << 3);
  		        }

  		        this._finish(tail, length);
  		        ret = hex(this._hash);

  		        if (raw) {
  		            ret = hexToBinaryString(ret);
  		        }

  		        this.reset();

  		        return ret;
  		    };

  		    /**
  		     * Resets the internal state of the computation.
  		     *
  		     * @return {SparkMD5} The instance itself
  		     */
  		    SparkMD5.prototype.reset = function () {
  		        this._buff = '';
  		        this._length = 0;
  		        this._hash = [1732584193, -271733879, -1732584194, 271733878];

  		        return this;
  		    };

  		    /**
  		     * Gets the internal state of the computation.
  		     *
  		     * @return {Object} The state
  		     */
  		    SparkMD5.prototype.getState = function () {
  		        return {
  		            buff: this._buff,
  		            length: this._length,
  		            hash: this._hash.slice()
  		        };
  		    };

  		    /**
  		     * Gets the internal state of the computation.
  		     *
  		     * @param {Object} state The state
  		     *
  		     * @return {SparkMD5} The instance itself
  		     */
  		    SparkMD5.prototype.setState = function (state) {
  		        this._buff = state.buff;
  		        this._length = state.length;
  		        this._hash = state.hash;

  		        return this;
  		    };

  		    /**
  		     * Releases memory used by the incremental buffer and other additional
  		     * resources. If you plan to use the instance again, use reset instead.
  		     */
  		    SparkMD5.prototype.destroy = function () {
  		        delete this._hash;
  		        delete this._buff;
  		        delete this._length;
  		    };

  		    /**
  		     * Finish the final calculation based on the tail.
  		     *
  		     * @param {Array}  tail   The tail (will be modified)
  		     * @param {Number} length The length of the remaining buffer
  		     */
  		    SparkMD5.prototype._finish = function (tail, length) {
  		        var i = length,
  		            tmp,
  		            lo,
  		            hi;

  		        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
  		        if (i > 55) {
  		            md5cycle(this._hash, tail);
  		            for (i = 0; i < 16; i += 1) {
  		                tail[i] = 0;
  		            }
  		        }

  		        // Do the final computation based on the tail and length
  		        // Beware that the final length may not fit in 32 bits so we take care of that
  		        tmp = this._length * 8;
  		        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
  		        lo = parseInt(tmp[2], 16);
  		        hi = parseInt(tmp[1], 16) || 0;

  		        tail[14] = lo;
  		        tail[15] = hi;
  		        md5cycle(this._hash, tail);
  		    };

  		    /**
  		     * Performs the md5 hash on a string.
  		     * A conversion will be applied if utf8 string is detected.
  		     *
  		     * @param {String}  str The string
  		     * @param {Boolean} [raw] True to get the raw string, false to get the hex string
  		     *
  		     * @return {String} The result
  		     */
  		    SparkMD5.hash = function (str, raw) {
  		        // Converts the string to utf8 bytes if necessary
  		        // Then compute it using the binary function
  		        return SparkMD5.hashBinary(toUtf8(str), raw);
  		    };

  		    /**
  		     * Performs the md5 hash on a binary string.
  		     *
  		     * @param {String}  content The binary string
  		     * @param {Boolean} [raw]     True to get the raw string, false to get the hex string
  		     *
  		     * @return {String} The result
  		     */
  		    SparkMD5.hashBinary = function (content, raw) {
  		        var hash = md51(content),
  		            ret = hex(hash);

  		        return raw ? hexToBinaryString(ret) : ret;
  		    };

  		    // ---------------------------------------------------

  		    /**
  		     * SparkMD5 OOP implementation for array buffers.
  		     *
  		     * Use this class to perform an incremental md5 ONLY for array buffers.
  		     */
  		    SparkMD5.ArrayBuffer = function () {
  		        // call reset to init the instance
  		        this.reset();
  		    };

  		    /**
  		     * Appends an array buffer.
  		     *
  		     * @param {ArrayBuffer} arr The array to be appended
  		     *
  		     * @return {SparkMD5.ArrayBuffer} The instance itself
  		     */
  		    SparkMD5.ArrayBuffer.prototype.append = function (arr) {
  		        var buff = concatenateArrayBuffers(this._buff.buffer, arr),
  		            length = buff.length,
  		            i;

  		        this._length += arr.byteLength;

  		        for (i = 64; i <= length; i += 64) {
  		            md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));
  		        }

  		        this._buff = (i - 64) < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);

  		        return this;
  		    };

  		    /**
  		     * Finishes the incremental computation, reseting the internal state and
  		     * returning the result.
  		     *
  		     * @param {Boolean} raw True to get the raw string, false to get the hex string
  		     *
  		     * @return {String} The result
  		     */
  		    SparkMD5.ArrayBuffer.prototype.end = function (raw) {
  		        var buff = this._buff,
  		            length = buff.length,
  		            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  		            i,
  		            ret;

  		        for (i = 0; i < length; i += 1) {
  		            tail[i >> 2] |= buff[i] << ((i % 4) << 3);
  		        }

  		        this._finish(tail, length);
  		        ret = hex(this._hash);

  		        if (raw) {
  		            ret = hexToBinaryString(ret);
  		        }

  		        this.reset();

  		        return ret;
  		    };

  		    /**
  		     * Resets the internal state of the computation.
  		     *
  		     * @return {SparkMD5.ArrayBuffer} The instance itself
  		     */
  		    SparkMD5.ArrayBuffer.prototype.reset = function () {
  		        this._buff = new Uint8Array(0);
  		        this._length = 0;
  		        this._hash = [1732584193, -271733879, -1732584194, 271733878];

  		        return this;
  		    };

  		    /**
  		     * Gets the internal state of the computation.
  		     *
  		     * @return {Object} The state
  		     */
  		    SparkMD5.ArrayBuffer.prototype.getState = function () {
  		        var state = SparkMD5.prototype.getState.call(this);

  		        // Convert buffer to a string
  		        state.buff = arrayBuffer2Utf8Str(state.buff);

  		        return state;
  		    };

  		    /**
  		     * Gets the internal state of the computation.
  		     *
  		     * @param {Object} state The state
  		     *
  		     * @return {SparkMD5.ArrayBuffer} The instance itself
  		     */
  		    SparkMD5.ArrayBuffer.prototype.setState = function (state) {
  		        // Convert string to buffer
  		        state.buff = utf8Str2ArrayBuffer(state.buff, true);

  		        return SparkMD5.prototype.setState.call(this, state);
  		    };

  		    SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;

  		    SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;

  		    /**
  		     * Performs the md5 hash on an array buffer.
  		     *
  		     * @param {ArrayBuffer} arr The array buffer
  		     * @param {Boolean}     [raw] True to get the raw string, false to get the hex one
  		     *
  		     * @return {String} The result
  		     */
  		    SparkMD5.ArrayBuffer.hash = function (arr, raw) {
  		        var hash = md51_array(new Uint8Array(arr)),
  		            ret = hex(hash);

  		        return raw ? hexToBinaryString(ret) : ret;
  		    };

  		    return SparkMD5;
  		})); 
  	} (sparkMd5));
  	return sparkMd5.exports;
  }

  var sparkMd5Exports = requireSparkMd5();
  var SparkMD5 = /*@__PURE__*/getDefaultExportFromCjs(sparkMd5Exports);

  var buffer = {};

  var base64Js = {};

  var hasRequiredBase64Js;

  function requireBase64Js () {
  	if (hasRequiredBase64Js) return base64Js;
  	hasRequiredBase64Js = 1;

  	base64Js.byteLength = byteLength;
  	base64Js.toByteArray = toByteArray;
  	base64Js.fromByteArray = fromByteArray;

  	var lookup = [];
  	var revLookup = [];
  	var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

  	var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  	for (var i = 0, len = code.length; i < len; ++i) {
  	  lookup[i] = code[i];
  	  revLookup[code.charCodeAt(i)] = i;
  	}

  	// Support decoding URL-safe base64 strings, as Node.js does.
  	// See: https://en.wikipedia.org/wiki/Base64#URL_applications
  	revLookup['-'.charCodeAt(0)] = 62;
  	revLookup['_'.charCodeAt(0)] = 63;

  	function getLens (b64) {
  	  var len = b64.length;

  	  if (len % 4 > 0) {
  	    throw new Error('Invalid string. Length must be a multiple of 4')
  	  }

  	  // Trim off extra bytes after placeholder bytes are found
  	  // See: https://github.com/beatgammit/base64-js/issues/42
  	  var validLen = b64.indexOf('=');
  	  if (validLen === -1) validLen = len;

  	  var placeHoldersLen = validLen === len
  	    ? 0
  	    : 4 - (validLen % 4);

  	  return [validLen, placeHoldersLen]
  	}

  	// base64 is 4/3 + up to two characters of the original data
  	function byteLength (b64) {
  	  var lens = getLens(b64);
  	  var validLen = lens[0];
  	  var placeHoldersLen = lens[1];
  	  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
  	}

  	function _byteLength (b64, validLen, placeHoldersLen) {
  	  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
  	}

  	function toByteArray (b64) {
  	  var tmp;
  	  var lens = getLens(b64);
  	  var validLen = lens[0];
  	  var placeHoldersLen = lens[1];

  	  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));

  	  var curByte = 0;

  	  // if there are placeholders, only get up to the last complete 4 chars
  	  var len = placeHoldersLen > 0
  	    ? validLen - 4
  	    : validLen;

  	  var i;
  	  for (i = 0; i < len; i += 4) {
  	    tmp =
  	      (revLookup[b64.charCodeAt(i)] << 18) |
  	      (revLookup[b64.charCodeAt(i + 1)] << 12) |
  	      (revLookup[b64.charCodeAt(i + 2)] << 6) |
  	      revLookup[b64.charCodeAt(i + 3)];
  	    arr[curByte++] = (tmp >> 16) & 0xFF;
  	    arr[curByte++] = (tmp >> 8) & 0xFF;
  	    arr[curByte++] = tmp & 0xFF;
  	  }

  	  if (placeHoldersLen === 2) {
  	    tmp =
  	      (revLookup[b64.charCodeAt(i)] << 2) |
  	      (revLookup[b64.charCodeAt(i + 1)] >> 4);
  	    arr[curByte++] = tmp & 0xFF;
  	  }

  	  if (placeHoldersLen === 1) {
  	    tmp =
  	      (revLookup[b64.charCodeAt(i)] << 10) |
  	      (revLookup[b64.charCodeAt(i + 1)] << 4) |
  	      (revLookup[b64.charCodeAt(i + 2)] >> 2);
  	    arr[curByte++] = (tmp >> 8) & 0xFF;
  	    arr[curByte++] = tmp & 0xFF;
  	  }

  	  return arr
  	}

  	function tripletToBase64 (num) {
  	  return lookup[num >> 18 & 0x3F] +
  	    lookup[num >> 12 & 0x3F] +
  	    lookup[num >> 6 & 0x3F] +
  	    lookup[num & 0x3F]
  	}

  	function encodeChunk (uint8, start, end) {
  	  var tmp;
  	  var output = [];
  	  for (var i = start; i < end; i += 3) {
  	    tmp =
  	      ((uint8[i] << 16) & 0xFF0000) +
  	      ((uint8[i + 1] << 8) & 0xFF00) +
  	      (uint8[i + 2] & 0xFF);
  	    output.push(tripletToBase64(tmp));
  	  }
  	  return output.join('')
  	}

  	function fromByteArray (uint8) {
  	  var tmp;
  	  var len = uint8.length;
  	  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
  	  var parts = [];
  	  var maxChunkLength = 16383; // must be multiple of 3

  	  // go through the array every three bytes, we'll deal with trailing stuff later
  	  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
  	    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
  	  }

  	  // pad the end with zeros, but make sure to not forget the extra bytes
  	  if (extraBytes === 1) {
  	    tmp = uint8[len - 1];
  	    parts.push(
  	      lookup[tmp >> 2] +
  	      lookup[(tmp << 4) & 0x3F] +
  	      '=='
  	    );
  	  } else if (extraBytes === 2) {
  	    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
  	    parts.push(
  	      lookup[tmp >> 10] +
  	      lookup[(tmp >> 4) & 0x3F] +
  	      lookup[(tmp << 2) & 0x3F] +
  	      '='
  	    );
  	  }

  	  return parts.join('')
  	}
  	return base64Js;
  }

  var ieee754 = {};

  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */

  var hasRequiredIeee754;

  function requireIeee754 () {
  	if (hasRequiredIeee754) return ieee754;
  	hasRequiredIeee754 = 1;
  	ieee754.read = function (buffer, offset, isLE, mLen, nBytes) {
  	  var e, m;
  	  var eLen = (nBytes * 8) - mLen - 1;
  	  var eMax = (1 << eLen) - 1;
  	  var eBias = eMax >> 1;
  	  var nBits = -7;
  	  var i = isLE ? (nBytes - 1) : 0;
  	  var d = isLE ? -1 : 1;
  	  var s = buffer[offset + i];

  	  i += d;

  	  e = s & ((1 << (-nBits)) - 1);
  	  s >>= (-nBits);
  	  nBits += eLen;
  	  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  	  m = e & ((1 << (-nBits)) - 1);
  	  e >>= (-nBits);
  	  nBits += mLen;
  	  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  	  if (e === 0) {
  	    e = 1 - eBias;
  	  } else if (e === eMax) {
  	    return m ? NaN : ((s ? -1 : 1) * Infinity)
  	  } else {
  	    m = m + Math.pow(2, mLen);
  	    e = e - eBias;
  	  }
  	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
  	};

  	ieee754.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  	  var e, m, c;
  	  var eLen = (nBytes * 8) - mLen - 1;
  	  var eMax = (1 << eLen) - 1;
  	  var eBias = eMax >> 1;
  	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
  	  var i = isLE ? 0 : (nBytes - 1);
  	  var d = isLE ? 1 : -1;
  	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  	  value = Math.abs(value);

  	  if (isNaN(value) || value === Infinity) {
  	    m = isNaN(value) ? 1 : 0;
  	    e = eMax;
  	  } else {
  	    e = Math.floor(Math.log(value) / Math.LN2);
  	    if (value * (c = Math.pow(2, -e)) < 1) {
  	      e--;
  	      c *= 2;
  	    }
  	    if (e + eBias >= 1) {
  	      value += rt / c;
  	    } else {
  	      value += rt * Math.pow(2, 1 - eBias);
  	    }
  	    if (value * c >= 2) {
  	      e++;
  	      c /= 2;
  	    }

  	    if (e + eBias >= eMax) {
  	      m = 0;
  	      e = eMax;
  	    } else if (e + eBias >= 1) {
  	      m = ((value * c) - 1) * Math.pow(2, mLen);
  	      e = e + eBias;
  	    } else {
  	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
  	      e = 0;
  	    }
  	  }

  	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  	  e = (e << mLen) | m;
  	  eLen += mLen;
  	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  	  buffer[offset + i - d] |= s * 128;
  	};
  	return ieee754;
  }

  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */

  var hasRequiredBuffer;

  function requireBuffer () {
  	if (hasRequiredBuffer) return buffer;
  	hasRequiredBuffer = 1;
  	(function (exports) {

  		const base64 = requireBase64Js();
  		const ieee754 = requireIeee754();
  		const customInspectSymbol =
  		  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
  		    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
  		    : null;

  		exports.Buffer = Buffer;
  		exports.SlowBuffer = SlowBuffer;
  		exports.INSPECT_MAX_BYTES = 50;

  		const K_MAX_LENGTH = 0x7fffffff;
  		exports.kMaxLength = K_MAX_LENGTH;

  		/**
  		 * If `Buffer.TYPED_ARRAY_SUPPORT`:
  		 *   === true    Use Uint8Array implementation (fastest)
  		 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
  		 *               implementation (most compatible, even IE6)
  		 *
  		 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
  		 * Opera 11.6+, iOS 4.2+.
  		 *
  		 * We report that the browser does not support typed arrays if the are not subclassable
  		 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
  		 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
  		 * for __proto__ and has a buggy typed array implementation.
  		 */
  		Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();

  		if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
  		    typeof console.error === 'function') {
  		  console.error(
  		    'This browser lacks typed array (Uint8Array) support which is required by ' +
  		    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  		  );
  		}

  		function typedArraySupport () {
  		  // Can typed array instances can be augmented?
  		  try {
  		    const arr = new Uint8Array(1);
  		    const proto = { foo: function () { return 42 } };
  		    Object.setPrototypeOf(proto, Uint8Array.prototype);
  		    Object.setPrototypeOf(arr, proto);
  		    return arr.foo() === 42
  		  } catch (e) {
  		    return false
  		  }
  		}

  		Object.defineProperty(Buffer.prototype, 'parent', {
  		  enumerable: true,
  		  get: function () {
  		    if (!Buffer.isBuffer(this)) return undefined
  		    return this.buffer
  		  }
  		});

  		Object.defineProperty(Buffer.prototype, 'offset', {
  		  enumerable: true,
  		  get: function () {
  		    if (!Buffer.isBuffer(this)) return undefined
  		    return this.byteOffset
  		  }
  		});

  		function createBuffer (length) {
  		  if (length > K_MAX_LENGTH) {
  		    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  		  }
  		  // Return an augmented `Uint8Array` instance
  		  const buf = new Uint8Array(length);
  		  Object.setPrototypeOf(buf, Buffer.prototype);
  		  return buf
  		}

  		/**
  		 * The Buffer constructor returns instances of `Uint8Array` that have their
  		 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
  		 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
  		 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
  		 * returns a single octet.
  		 *
  		 * The `Uint8Array` prototype remains unmodified.
  		 */

  		function Buffer (arg, encodingOrOffset, length) {
  		  // Common case.
  		  if (typeof arg === 'number') {
  		    if (typeof encodingOrOffset === 'string') {
  		      throw new TypeError(
  		        'The "string" argument must be of type string. Received type number'
  		      )
  		    }
  		    return allocUnsafe(arg)
  		  }
  		  return from(arg, encodingOrOffset, length)
  		}

  		Buffer.poolSize = 8192; // not used by this implementation

  		function from (value, encodingOrOffset, length) {
  		  if (typeof value === 'string') {
  		    return fromString(value, encodingOrOffset)
  		  }

  		  if (ArrayBuffer.isView(value)) {
  		    return fromArrayView(value)
  		  }

  		  if (value == null) {
  		    throw new TypeError(
  		      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
  		      'or Array-like Object. Received type ' + (typeof value)
  		    )
  		  }

  		  if (isInstance(value, ArrayBuffer) ||
  		      (value && isInstance(value.buffer, ArrayBuffer))) {
  		    return fromArrayBuffer(value, encodingOrOffset, length)
  		  }

  		  if (typeof SharedArrayBuffer !== 'undefined' &&
  		      (isInstance(value, SharedArrayBuffer) ||
  		      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
  		    return fromArrayBuffer(value, encodingOrOffset, length)
  		  }

  		  if (typeof value === 'number') {
  		    throw new TypeError(
  		      'The "value" argument must not be of type number. Received type number'
  		    )
  		  }

  		  const valueOf = value.valueOf && value.valueOf();
  		  if (valueOf != null && valueOf !== value) {
  		    return Buffer.from(valueOf, encodingOrOffset, length)
  		  }

  		  const b = fromObject(value);
  		  if (b) return b

  		  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
  		      typeof value[Symbol.toPrimitive] === 'function') {
  		    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)
  		  }

  		  throw new TypeError(
  		    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
  		    'or Array-like Object. Received type ' + (typeof value)
  		  )
  		}

  		/**
  		 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
  		 * if value is a number.
  		 * Buffer.from(str[, encoding])
  		 * Buffer.from(array)
  		 * Buffer.from(buffer)
  		 * Buffer.from(arrayBuffer[, byteOffset[, length]])
  		 **/
  		Buffer.from = function (value, encodingOrOffset, length) {
  		  return from(value, encodingOrOffset, length)
  		};

  		// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
  		// https://github.com/feross/buffer/pull/148
  		Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
  		Object.setPrototypeOf(Buffer, Uint8Array);

  		function assertSize (size) {
  		  if (typeof size !== 'number') {
  		    throw new TypeError('"size" argument must be of type number')
  		  } else if (size < 0) {
  		    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  		  }
  		}

  		function alloc (size, fill, encoding) {
  		  assertSize(size);
  		  if (size <= 0) {
  		    return createBuffer(size)
  		  }
  		  if (fill !== undefined) {
  		    // Only pay attention to encoding if it's a string. This
  		    // prevents accidentally sending in a number that would
  		    // be interpreted as a start offset.
  		    return typeof encoding === 'string'
  		      ? createBuffer(size).fill(fill, encoding)
  		      : createBuffer(size).fill(fill)
  		  }
  		  return createBuffer(size)
  		}

  		/**
  		 * Creates a new filled Buffer instance.
  		 * alloc(size[, fill[, encoding]])
  		 **/
  		Buffer.alloc = function (size, fill, encoding) {
  		  return alloc(size, fill, encoding)
  		};

  		function allocUnsafe (size) {
  		  assertSize(size);
  		  return createBuffer(size < 0 ? 0 : checked(size) | 0)
  		}

  		/**
  		 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
  		 * */
  		Buffer.allocUnsafe = function (size) {
  		  return allocUnsafe(size)
  		};
  		/**
  		 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
  		 */
  		Buffer.allocUnsafeSlow = function (size) {
  		  return allocUnsafe(size)
  		};

  		function fromString (string, encoding) {
  		  if (typeof encoding !== 'string' || encoding === '') {
  		    encoding = 'utf8';
  		  }

  		  if (!Buffer.isEncoding(encoding)) {
  		    throw new TypeError('Unknown encoding: ' + encoding)
  		  }

  		  const length = byteLength(string, encoding) | 0;
  		  let buf = createBuffer(length);

  		  const actual = buf.write(string, encoding);

  		  if (actual !== length) {
  		    // Writing a hex string, for example, that contains invalid characters will
  		    // cause everything after the first invalid character to be ignored. (e.g.
  		    // 'abxxcd' will be treated as 'ab')
  		    buf = buf.slice(0, actual);
  		  }

  		  return buf
  		}

  		function fromArrayLike (array) {
  		  const length = array.length < 0 ? 0 : checked(array.length) | 0;
  		  const buf = createBuffer(length);
  		  for (let i = 0; i < length; i += 1) {
  		    buf[i] = array[i] & 255;
  		  }
  		  return buf
  		}

  		function fromArrayView (arrayView) {
  		  if (isInstance(arrayView, Uint8Array)) {
  		    const copy = new Uint8Array(arrayView);
  		    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
  		  }
  		  return fromArrayLike(arrayView)
  		}

  		function fromArrayBuffer (array, byteOffset, length) {
  		  if (byteOffset < 0 || array.byteLength < byteOffset) {
  		    throw new RangeError('"offset" is outside of buffer bounds')
  		  }

  		  if (array.byteLength < byteOffset + (length || 0)) {
  		    throw new RangeError('"length" is outside of buffer bounds')
  		  }

  		  let buf;
  		  if (byteOffset === undefined && length === undefined) {
  		    buf = new Uint8Array(array);
  		  } else if (length === undefined) {
  		    buf = new Uint8Array(array, byteOffset);
  		  } else {
  		    buf = new Uint8Array(array, byteOffset, length);
  		  }

  		  // Return an augmented `Uint8Array` instance
  		  Object.setPrototypeOf(buf, Buffer.prototype);

  		  return buf
  		}

  		function fromObject (obj) {
  		  if (Buffer.isBuffer(obj)) {
  		    const len = checked(obj.length) | 0;
  		    const buf = createBuffer(len);

  		    if (buf.length === 0) {
  		      return buf
  		    }

  		    obj.copy(buf, 0, 0, len);
  		    return buf
  		  }

  		  if (obj.length !== undefined) {
  		    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
  		      return createBuffer(0)
  		    }
  		    return fromArrayLike(obj)
  		  }

  		  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
  		    return fromArrayLike(obj.data)
  		  }
  		}

  		function checked (length) {
  		  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  		  // length is NaN (which is otherwise coerced to zero.)
  		  if (length >= K_MAX_LENGTH) {
  		    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
  		                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  		  }
  		  return length | 0
  		}

  		function SlowBuffer (length) {
  		  if (+length != length) { // eslint-disable-line eqeqeq
  		    length = 0;
  		  }
  		  return Buffer.alloc(+length)
  		}

  		Buffer.isBuffer = function isBuffer (b) {
  		  return b != null && b._isBuffer === true &&
  		    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
  		};

  		Buffer.compare = function compare (a, b) {
  		  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
  		  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
  		  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
  		    throw new TypeError(
  		      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
  		    )
  		  }

  		  if (a === b) return 0

  		  let x = a.length;
  		  let y = b.length;

  		  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
  		    if (a[i] !== b[i]) {
  		      x = a[i];
  		      y = b[i];
  		      break
  		    }
  		  }

  		  if (x < y) return -1
  		  if (y < x) return 1
  		  return 0
  		};

  		Buffer.isEncoding = function isEncoding (encoding) {
  		  switch (String(encoding).toLowerCase()) {
  		    case 'hex':
  		    case 'utf8':
  		    case 'utf-8':
  		    case 'ascii':
  		    case 'latin1':
  		    case 'binary':
  		    case 'base64':
  		    case 'ucs2':
  		    case 'ucs-2':
  		    case 'utf16le':
  		    case 'utf-16le':
  		      return true
  		    default:
  		      return false
  		  }
  		};

  		Buffer.concat = function concat (list, length) {
  		  if (!Array.isArray(list)) {
  		    throw new TypeError('"list" argument must be an Array of Buffers')
  		  }

  		  if (list.length === 0) {
  		    return Buffer.alloc(0)
  		  }

  		  let i;
  		  if (length === undefined) {
  		    length = 0;
  		    for (i = 0; i < list.length; ++i) {
  		      length += list[i].length;
  		    }
  		  }

  		  const buffer = Buffer.allocUnsafe(length);
  		  let pos = 0;
  		  for (i = 0; i < list.length; ++i) {
  		    let buf = list[i];
  		    if (isInstance(buf, Uint8Array)) {
  		      if (pos + buf.length > buffer.length) {
  		        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
  		        buf.copy(buffer, pos);
  		      } else {
  		        Uint8Array.prototype.set.call(
  		          buffer,
  		          buf,
  		          pos
  		        );
  		      }
  		    } else if (!Buffer.isBuffer(buf)) {
  		      throw new TypeError('"list" argument must be an Array of Buffers')
  		    } else {
  		      buf.copy(buffer, pos);
  		    }
  		    pos += buf.length;
  		  }
  		  return buffer
  		};

  		function byteLength (string, encoding) {
  		  if (Buffer.isBuffer(string)) {
  		    return string.length
  		  }
  		  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
  		    return string.byteLength
  		  }
  		  if (typeof string !== 'string') {
  		    throw new TypeError(
  		      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
  		      'Received type ' + typeof string
  		    )
  		  }

  		  const len = string.length;
  		  const mustMatch = (arguments.length > 2 && arguments[2] === true);
  		  if (!mustMatch && len === 0) return 0

  		  // Use a for loop to avoid recursion
  		  let loweredCase = false;
  		  for (;;) {
  		    switch (encoding) {
  		      case 'ascii':
  		      case 'latin1':
  		      case 'binary':
  		        return len
  		      case 'utf8':
  		      case 'utf-8':
  		        return utf8ToBytes(string).length
  		      case 'ucs2':
  		      case 'ucs-2':
  		      case 'utf16le':
  		      case 'utf-16le':
  		        return len * 2
  		      case 'hex':
  		        return len >>> 1
  		      case 'base64':
  		        return base64ToBytes(string).length
  		      default:
  		        if (loweredCase) {
  		          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
  		        }
  		        encoding = ('' + encoding).toLowerCase();
  		        loweredCase = true;
  		    }
  		  }
  		}
  		Buffer.byteLength = byteLength;

  		function slowToString (encoding, start, end) {
  		  let loweredCase = false;

  		  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  		  // property of a typed array.

  		  // This behaves neither like String nor Uint8Array in that we set start/end
  		  // to their upper/lower bounds if the value passed is out of range.
  		  // undefined is handled specially as per ECMA-262 6th Edition,
  		  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  		  if (start === undefined || start < 0) {
  		    start = 0;
  		  }
  		  // Return early if start > this.length. Done here to prevent potential uint32
  		  // coercion fail below.
  		  if (start > this.length) {
  		    return ''
  		  }

  		  if (end === undefined || end > this.length) {
  		    end = this.length;
  		  }

  		  if (end <= 0) {
  		    return ''
  		  }

  		  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
  		  end >>>= 0;
  		  start >>>= 0;

  		  if (end <= start) {
  		    return ''
  		  }

  		  if (!encoding) encoding = 'utf8';

  		  while (true) {
  		    switch (encoding) {
  		      case 'hex':
  		        return hexSlice(this, start, end)

  		      case 'utf8':
  		      case 'utf-8':
  		        return utf8Slice(this, start, end)

  		      case 'ascii':
  		        return asciiSlice(this, start, end)

  		      case 'latin1':
  		      case 'binary':
  		        return latin1Slice(this, start, end)

  		      case 'base64':
  		        return base64Slice(this, start, end)

  		      case 'ucs2':
  		      case 'ucs-2':
  		      case 'utf16le':
  		      case 'utf-16le':
  		        return utf16leSlice(this, start, end)

  		      default:
  		        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
  		        encoding = (encoding + '').toLowerCase();
  		        loweredCase = true;
  		    }
  		  }
  		}

  		// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
  		// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
  		// reliably in a browserify context because there could be multiple different
  		// copies of the 'buffer' package in use. This method works even for Buffer
  		// instances that were created from another copy of the `buffer` package.
  		// See: https://github.com/feross/buffer/issues/154
  		Buffer.prototype._isBuffer = true;

  		function swap (b, n, m) {
  		  const i = b[n];
  		  b[n] = b[m];
  		  b[m] = i;
  		}

  		Buffer.prototype.swap16 = function swap16 () {
  		  const len = this.length;
  		  if (len % 2 !== 0) {
  		    throw new RangeError('Buffer size must be a multiple of 16-bits')
  		  }
  		  for (let i = 0; i < len; i += 2) {
  		    swap(this, i, i + 1);
  		  }
  		  return this
  		};

  		Buffer.prototype.swap32 = function swap32 () {
  		  const len = this.length;
  		  if (len % 4 !== 0) {
  		    throw new RangeError('Buffer size must be a multiple of 32-bits')
  		  }
  		  for (let i = 0; i < len; i += 4) {
  		    swap(this, i, i + 3);
  		    swap(this, i + 1, i + 2);
  		  }
  		  return this
  		};

  		Buffer.prototype.swap64 = function swap64 () {
  		  const len = this.length;
  		  if (len % 8 !== 0) {
  		    throw new RangeError('Buffer size must be a multiple of 64-bits')
  		  }
  		  for (let i = 0; i < len; i += 8) {
  		    swap(this, i, i + 7);
  		    swap(this, i + 1, i + 6);
  		    swap(this, i + 2, i + 5);
  		    swap(this, i + 3, i + 4);
  		  }
  		  return this
  		};

  		Buffer.prototype.toString = function toString () {
  		  const length = this.length;
  		  if (length === 0) return ''
  		  if (arguments.length === 0) return utf8Slice(this, 0, length)
  		  return slowToString.apply(this, arguments)
  		};

  		Buffer.prototype.toLocaleString = Buffer.prototype.toString;

  		Buffer.prototype.equals = function equals (b) {
  		  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  		  if (this === b) return true
  		  return Buffer.compare(this, b) === 0
  		};

  		Buffer.prototype.inspect = function inspect () {
  		  let str = '';
  		  const max = exports.INSPECT_MAX_BYTES;
  		  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
  		  if (this.length > max) str += ' ... ';
  		  return '<Buffer ' + str + '>'
  		};
  		if (customInspectSymbol) {
  		  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
  		}

  		Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  		  if (isInstance(target, Uint8Array)) {
  		    target = Buffer.from(target, target.offset, target.byteLength);
  		  }
  		  if (!Buffer.isBuffer(target)) {
  		    throw new TypeError(
  		      'The "target" argument must be one of type Buffer or Uint8Array. ' +
  		      'Received type ' + (typeof target)
  		    )
  		  }

  		  if (start === undefined) {
  		    start = 0;
  		  }
  		  if (end === undefined) {
  		    end = target ? target.length : 0;
  		  }
  		  if (thisStart === undefined) {
  		    thisStart = 0;
  		  }
  		  if (thisEnd === undefined) {
  		    thisEnd = this.length;
  		  }

  		  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
  		    throw new RangeError('out of range index')
  		  }

  		  if (thisStart >= thisEnd && start >= end) {
  		    return 0
  		  }
  		  if (thisStart >= thisEnd) {
  		    return -1
  		  }
  		  if (start >= end) {
  		    return 1
  		  }

  		  start >>>= 0;
  		  end >>>= 0;
  		  thisStart >>>= 0;
  		  thisEnd >>>= 0;

  		  if (this === target) return 0

  		  let x = thisEnd - thisStart;
  		  let y = end - start;
  		  const len = Math.min(x, y);

  		  const thisCopy = this.slice(thisStart, thisEnd);
  		  const targetCopy = target.slice(start, end);

  		  for (let i = 0; i < len; ++i) {
  		    if (thisCopy[i] !== targetCopy[i]) {
  		      x = thisCopy[i];
  		      y = targetCopy[i];
  		      break
  		    }
  		  }

  		  if (x < y) return -1
  		  if (y < x) return 1
  		  return 0
  		};

  		// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
  		// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
  		//
  		// Arguments:
  		// - buffer - a Buffer to search
  		// - val - a string, Buffer, or number
  		// - byteOffset - an index into `buffer`; will be clamped to an int32
  		// - encoding - an optional encoding, relevant is val is a string
  		// - dir - true for indexOf, false for lastIndexOf
  		function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  		  // Empty buffer means no match
  		  if (buffer.length === 0) return -1

  		  // Normalize byteOffset
  		  if (typeof byteOffset === 'string') {
  		    encoding = byteOffset;
  		    byteOffset = 0;
  		  } else if (byteOffset > 0x7fffffff) {
  		    byteOffset = 0x7fffffff;
  		  } else if (byteOffset < -2147483648) {
  		    byteOffset = -2147483648;
  		  }
  		  byteOffset = +byteOffset; // Coerce to Number.
  		  if (numberIsNaN(byteOffset)) {
  		    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
  		    byteOffset = dir ? 0 : (buffer.length - 1);
  		  }

  		  // Normalize byteOffset: negative offsets start from the end of the buffer
  		  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  		  if (byteOffset >= buffer.length) {
  		    if (dir) return -1
  		    else byteOffset = buffer.length - 1;
  		  } else if (byteOffset < 0) {
  		    if (dir) byteOffset = 0;
  		    else return -1
  		  }

  		  // Normalize val
  		  if (typeof val === 'string') {
  		    val = Buffer.from(val, encoding);
  		  }

  		  // Finally, search either indexOf (if dir is true) or lastIndexOf
  		  if (Buffer.isBuffer(val)) {
  		    // Special case: looking for empty string/buffer always fails
  		    if (val.length === 0) {
  		      return -1
  		    }
  		    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  		  } else if (typeof val === 'number') {
  		    val = val & 0xFF; // Search for a byte value [0-255]
  		    if (typeof Uint8Array.prototype.indexOf === 'function') {
  		      if (dir) {
  		        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
  		      } else {
  		        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
  		      }
  		    }
  		    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  		  }

  		  throw new TypeError('val must be string, number or Buffer')
  		}

  		function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  		  let indexSize = 1;
  		  let arrLength = arr.length;
  		  let valLength = val.length;

  		  if (encoding !== undefined) {
  		    encoding = String(encoding).toLowerCase();
  		    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
  		        encoding === 'utf16le' || encoding === 'utf-16le') {
  		      if (arr.length < 2 || val.length < 2) {
  		        return -1
  		      }
  		      indexSize = 2;
  		      arrLength /= 2;
  		      valLength /= 2;
  		      byteOffset /= 2;
  		    }
  		  }

  		  function read (buf, i) {
  		    if (indexSize === 1) {
  		      return buf[i]
  		    } else {
  		      return buf.readUInt16BE(i * indexSize)
  		    }
  		  }

  		  let i;
  		  if (dir) {
  		    let foundIndex = -1;
  		    for (i = byteOffset; i < arrLength; i++) {
  		      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
  		        if (foundIndex === -1) foundIndex = i;
  		        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
  		      } else {
  		        if (foundIndex !== -1) i -= i - foundIndex;
  		        foundIndex = -1;
  		      }
  		    }
  		  } else {
  		    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
  		    for (i = byteOffset; i >= 0; i--) {
  		      let found = true;
  		      for (let j = 0; j < valLength; j++) {
  		        if (read(arr, i + j) !== read(val, j)) {
  		          found = false;
  		          break
  		        }
  		      }
  		      if (found) return i
  		    }
  		  }

  		  return -1
  		}

  		Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  		  return this.indexOf(val, byteOffset, encoding) !== -1
  		};

  		Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  		  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
  		};

  		Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  		  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
  		};

  		function hexWrite (buf, string, offset, length) {
  		  offset = Number(offset) || 0;
  		  const remaining = buf.length - offset;
  		  if (!length) {
  		    length = remaining;
  		  } else {
  		    length = Number(length);
  		    if (length > remaining) {
  		      length = remaining;
  		    }
  		  }

  		  const strLen = string.length;

  		  if (length > strLen / 2) {
  		    length = strLen / 2;
  		  }
  		  let i;
  		  for (i = 0; i < length; ++i) {
  		    const parsed = parseInt(string.substr(i * 2, 2), 16);
  		    if (numberIsNaN(parsed)) return i
  		    buf[offset + i] = parsed;
  		  }
  		  return i
  		}

  		function utf8Write (buf, string, offset, length) {
  		  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
  		}

  		function asciiWrite (buf, string, offset, length) {
  		  return blitBuffer(asciiToBytes(string), buf, offset, length)
  		}

  		function base64Write (buf, string, offset, length) {
  		  return blitBuffer(base64ToBytes(string), buf, offset, length)
  		}

  		function ucs2Write (buf, string, offset, length) {
  		  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
  		}

  		Buffer.prototype.write = function write (string, offset, length, encoding) {
  		  // Buffer#write(string)
  		  if (offset === undefined) {
  		    encoding = 'utf8';
  		    length = this.length;
  		    offset = 0;
  		  // Buffer#write(string, encoding)
  		  } else if (length === undefined && typeof offset === 'string') {
  		    encoding = offset;
  		    length = this.length;
  		    offset = 0;
  		  // Buffer#write(string, offset[, length][, encoding])
  		  } else if (isFinite(offset)) {
  		    offset = offset >>> 0;
  		    if (isFinite(length)) {
  		      length = length >>> 0;
  		      if (encoding === undefined) encoding = 'utf8';
  		    } else {
  		      encoding = length;
  		      length = undefined;
  		    }
  		  } else {
  		    throw new Error(
  		      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
  		    )
  		  }

  		  const remaining = this.length - offset;
  		  if (length === undefined || length > remaining) length = remaining;

  		  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
  		    throw new RangeError('Attempt to write outside buffer bounds')
  		  }

  		  if (!encoding) encoding = 'utf8';

  		  let loweredCase = false;
  		  for (;;) {
  		    switch (encoding) {
  		      case 'hex':
  		        return hexWrite(this, string, offset, length)

  		      case 'utf8':
  		      case 'utf-8':
  		        return utf8Write(this, string, offset, length)

  		      case 'ascii':
  		      case 'latin1':
  		      case 'binary':
  		        return asciiWrite(this, string, offset, length)

  		      case 'base64':
  		        // Warning: maxLength not taken into account in base64Write
  		        return base64Write(this, string, offset, length)

  		      case 'ucs2':
  		      case 'ucs-2':
  		      case 'utf16le':
  		      case 'utf-16le':
  		        return ucs2Write(this, string, offset, length)

  		      default:
  		        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
  		        encoding = ('' + encoding).toLowerCase();
  		        loweredCase = true;
  		    }
  		  }
  		};

  		Buffer.prototype.toJSON = function toJSON () {
  		  return {
  		    type: 'Buffer',
  		    data: Array.prototype.slice.call(this._arr || this, 0)
  		  }
  		};

  		function base64Slice (buf, start, end) {
  		  if (start === 0 && end === buf.length) {
  		    return base64.fromByteArray(buf)
  		  } else {
  		    return base64.fromByteArray(buf.slice(start, end))
  		  }
  		}

  		function utf8Slice (buf, start, end) {
  		  end = Math.min(buf.length, end);
  		  const res = [];

  		  let i = start;
  		  while (i < end) {
  		    const firstByte = buf[i];
  		    let codePoint = null;
  		    let bytesPerSequence = (firstByte > 0xEF)
  		      ? 4
  		      : (firstByte > 0xDF)
  		          ? 3
  		          : (firstByte > 0xBF)
  		              ? 2
  		              : 1;

  		    if (i + bytesPerSequence <= end) {
  		      let secondByte, thirdByte, fourthByte, tempCodePoint;

  		      switch (bytesPerSequence) {
  		        case 1:
  		          if (firstByte < 0x80) {
  		            codePoint = firstByte;
  		          }
  		          break
  		        case 2:
  		          secondByte = buf[i + 1];
  		          if ((secondByte & 0xC0) === 0x80) {
  		            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
  		            if (tempCodePoint > 0x7F) {
  		              codePoint = tempCodePoint;
  		            }
  		          }
  		          break
  		        case 3:
  		          secondByte = buf[i + 1];
  		          thirdByte = buf[i + 2];
  		          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
  		            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
  		            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
  		              codePoint = tempCodePoint;
  		            }
  		          }
  		          break
  		        case 4:
  		          secondByte = buf[i + 1];
  		          thirdByte = buf[i + 2];
  		          fourthByte = buf[i + 3];
  		          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
  		            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
  		            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
  		              codePoint = tempCodePoint;
  		            }
  		          }
  		      }
  		    }

  		    if (codePoint === null) {
  		      // we did not generate a valid codePoint so insert a
  		      // replacement char (U+FFFD) and advance only 1 byte
  		      codePoint = 0xFFFD;
  		      bytesPerSequence = 1;
  		    } else if (codePoint > 0xFFFF) {
  		      // encode to utf16 (surrogate pair dance)
  		      codePoint -= 0x10000;
  		      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
  		      codePoint = 0xDC00 | codePoint & 0x3FF;
  		    }

  		    res.push(codePoint);
  		    i += bytesPerSequence;
  		  }

  		  return decodeCodePointsArray(res)
  		}

  		// Based on http://stackoverflow.com/a/22747272/680742, the browser with
  		// the lowest limit is Chrome, with 0x10000 args.
  		// We go 1 magnitude less, for safety
  		const MAX_ARGUMENTS_LENGTH = 0x1000;

  		function decodeCodePointsArray (codePoints) {
  		  const len = codePoints.length;
  		  if (len <= MAX_ARGUMENTS_LENGTH) {
  		    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  		  }

  		  // Decode in chunks to avoid "call stack size exceeded".
  		  let res = '';
  		  let i = 0;
  		  while (i < len) {
  		    res += String.fromCharCode.apply(
  		      String,
  		      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
  		    );
  		  }
  		  return res
  		}

  		function asciiSlice (buf, start, end) {
  		  let ret = '';
  		  end = Math.min(buf.length, end);

  		  for (let i = start; i < end; ++i) {
  		    ret += String.fromCharCode(buf[i] & 0x7F);
  		  }
  		  return ret
  		}

  		function latin1Slice (buf, start, end) {
  		  let ret = '';
  		  end = Math.min(buf.length, end);

  		  for (let i = start; i < end; ++i) {
  		    ret += String.fromCharCode(buf[i]);
  		  }
  		  return ret
  		}

  		function hexSlice (buf, start, end) {
  		  const len = buf.length;

  		  if (!start || start < 0) start = 0;
  		  if (!end || end < 0 || end > len) end = len;

  		  let out = '';
  		  for (let i = start; i < end; ++i) {
  		    out += hexSliceLookupTable[buf[i]];
  		  }
  		  return out
  		}

  		function utf16leSlice (buf, start, end) {
  		  const bytes = buf.slice(start, end);
  		  let res = '';
  		  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
  		  for (let i = 0; i < bytes.length - 1; i += 2) {
  		    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256));
  		  }
  		  return res
  		}

  		Buffer.prototype.slice = function slice (start, end) {
  		  const len = this.length;
  		  start = ~~start;
  		  end = end === undefined ? len : ~~end;

  		  if (start < 0) {
  		    start += len;
  		    if (start < 0) start = 0;
  		  } else if (start > len) {
  		    start = len;
  		  }

  		  if (end < 0) {
  		    end += len;
  		    if (end < 0) end = 0;
  		  } else if (end > len) {
  		    end = len;
  		  }

  		  if (end < start) end = start;

  		  const newBuf = this.subarray(start, end);
  		  // Return an augmented `Uint8Array` instance
  		  Object.setPrototypeOf(newBuf, Buffer.prototype);

  		  return newBuf
  		};

  		/*
  		 * Need to make sure that buffer isn't trying to write out of bounds.
  		 */
  		function checkOffset (offset, ext, length) {
  		  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  		  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
  		}

  		Buffer.prototype.readUintLE =
  		Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  		  offset = offset >>> 0;
  		  byteLength = byteLength >>> 0;
  		  if (!noAssert) checkOffset(offset, byteLength, this.length);

  		  let val = this[offset];
  		  let mul = 1;
  		  let i = 0;
  		  while (++i < byteLength && (mul *= 0x100)) {
  		    val += this[offset + i] * mul;
  		  }

  		  return val
  		};

  		Buffer.prototype.readUintBE =
  		Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  		  offset = offset >>> 0;
  		  byteLength = byteLength >>> 0;
  		  if (!noAssert) {
  		    checkOffset(offset, byteLength, this.length);
  		  }

  		  let val = this[offset + --byteLength];
  		  let mul = 1;
  		  while (byteLength > 0 && (mul *= 0x100)) {
  		    val += this[offset + --byteLength] * mul;
  		  }

  		  return val
  		};

  		Buffer.prototype.readUint8 =
  		Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  		  offset = offset >>> 0;
  		  if (!noAssert) checkOffset(offset, 1, this.length);
  		  return this[offset]
  		};

  		Buffer.prototype.readUint16LE =
  		Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  		  offset = offset >>> 0;
  		  if (!noAssert) checkOffset(offset, 2, this.length);
  		  return this[offset] | (this[offset + 1] << 8)
  		};

  		Buffer.prototype.readUint16BE =
  		Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  		  offset = offset >>> 0;
  		  if (!noAssert) checkOffset(offset, 2, this.length);
  		  return (this[offset] << 8) | this[offset + 1]
  		};

  		Buffer.prototype.readUint32LE =
  		Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  		  offset = offset >>> 0;
  		  if (!noAssert) checkOffset(offset, 4, this.length);

  		  return ((this[offset]) |
  		      (this[offset + 1] << 8) |
  		      (this[offset + 2] << 16)) +
  		      (this[offset + 3] * 0x1000000)
  		};

  		Buffer.prototype.readUint32BE =
  		Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  		  offset = offset >>> 0;
  		  if (!noAssert) checkOffset(offset, 4, this.length);

  		  return (this[offset] * 0x1000000) +
  		    ((this[offset + 1] << 16) |
  		    (this[offset + 2] << 8) |
  		    this[offset + 3])
  		};

  		Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {
  		  offset = offset >>> 0;
  		  validateNumber(offset, 'offset');
  		  const first = this[offset];
  		  const last = this[offset + 7];
  		  if (first === undefined || last === undefined) {
  		    boundsError(offset, this.length - 8);
  		  }

  		  const lo = first +
  		    this[++offset] * 2 ** 8 +
  		    this[++offset] * 2 ** 16 +
  		    this[++offset] * 2 ** 24;

  		  const hi = this[++offset] +
  		    this[++offset] * 2 ** 8 +
  		    this[++offset] * 2 ** 16 +
  		    last * 2 ** 24;

  		  return BigInt(lo) + (BigInt(hi) << BigInt(32))
  		});

  		Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {
  		  offset = offset >>> 0;
  		  validateNumber(offset, 'offset');
  		  const first = this[offset];
  		  const last = this[offset + 7];
  		  if (first === undefined || last === undefined) {
  		    boundsError(offset, this.length - 8);
  		  }

  		  const hi = first * 2 ** 24 +
  		    this[++offset] * 2 ** 16 +
  		    this[++offset] * 2 ** 8 +
  		    this[++offset];

  		  const lo = this[++offset] * 2 ** 24 +
  		    this[++offset] * 2 ** 16 +
  		    this[++offset] * 2 ** 8 +
  		    last;

  		  return (BigInt(hi) << BigInt(32)) + BigInt(lo)
  		});

  		Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  		  offset = offset >>> 0;
  		  byteLength = byteLength >>> 0;
  		  if (!noAssert) checkOffset(offset, byteLength, this.length);

  		  let val = this[offset];
  		  let mul = 1;
  		  let i = 0;
  		  while (++i < byteLength && (mul *= 0x100)) {
  		    val += this[offset + i] * mul;
  		  }
  		  mul *= 0x80;

  		  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  		  return val
  		};

  		Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  		  offset = offset >>> 0;
  		  byteLength = byteLength >>> 0;
  		  if (!noAssert) checkOffset(offset, byteLength, this.length);

  		  let i = byteLength;
  		  let mul = 1;
  		  let val = this[offset + --i];
  		  while (i > 0 && (mul *= 0x100)) {
  		    val += this[offset + --i] * mul;
  		  }
  		  mul *= 0x80;

  		  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  		  return val
  		};

  		Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  		  offset = offset >>> 0;
  		  if (!noAssert) checkOffset(offset, 1, this.length);
  		  if (!(this[offset] & 0x80)) return (this[offset])
  		  return ((0xff - this[offset] + 1) * -1)
  		};

  		Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  		  offset = offset >>> 0;
  		  if (!noAssert) checkOffset(offset, 2, this.length);
  		  const val = this[offset] | (this[offset + 1] << 8);
  		  return (val & 0x8000) ? val | 0xFFFF0000 : val
  		};

  		Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  		  offset = offset >>> 0;
  		  if (!noAssert) checkOffset(offset, 2, this.length);
  		  const val = this[offset + 1] | (this[offset] << 8);
  		  return (val & 0x8000) ? val | 0xFFFF0000 : val
  		};

  		Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  		  offset = offset >>> 0;
  		  if (!noAssert) checkOffset(offset, 4, this.length);

  		  return (this[offset]) |
  		    (this[offset + 1] << 8) |
  		    (this[offset + 2] << 16) |
  		    (this[offset + 3] << 24)
  		};

  		Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  		  offset = offset >>> 0;
  		  if (!noAssert) checkOffset(offset, 4, this.length);

  		  return (this[offset] << 24) |
  		    (this[offset + 1] << 16) |
  		    (this[offset + 2] << 8) |
  		    (this[offset + 3])
  		};

  		Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {
  		  offset = offset >>> 0;
  		  validateNumber(offset, 'offset');
  		  const first = this[offset];
  		  const last = this[offset + 7];
  		  if (first === undefined || last === undefined) {
  		    boundsError(offset, this.length - 8);
  		  }

  		  const val = this[offset + 4] +
  		    this[offset + 5] * 2 ** 8 +
  		    this[offset + 6] * 2 ** 16 +
  		    (last << 24); // Overflow

  		  return (BigInt(val) << BigInt(32)) +
  		    BigInt(first +
  		    this[++offset] * 2 ** 8 +
  		    this[++offset] * 2 ** 16 +
  		    this[++offset] * 2 ** 24)
  		});

  		Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {
  		  offset = offset >>> 0;
  		  validateNumber(offset, 'offset');
  		  const first = this[offset];
  		  const last = this[offset + 7];
  		  if (first === undefined || last === undefined) {
  		    boundsError(offset, this.length - 8);
  		  }

  		  const val = (first << 24) + // Overflow
  		    this[++offset] * 2 ** 16 +
  		    this[++offset] * 2 ** 8 +
  		    this[++offset];

  		  return (BigInt(val) << BigInt(32)) +
  		    BigInt(this[++offset] * 2 ** 24 +
  		    this[++offset] * 2 ** 16 +
  		    this[++offset] * 2 ** 8 +
  		    last)
  		});

  		Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  		  offset = offset >>> 0;
  		  if (!noAssert) checkOffset(offset, 4, this.length);
  		  return ieee754.read(this, offset, true, 23, 4)
  		};

  		Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  		  offset = offset >>> 0;
  		  if (!noAssert) checkOffset(offset, 4, this.length);
  		  return ieee754.read(this, offset, false, 23, 4)
  		};

  		Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  		  offset = offset >>> 0;
  		  if (!noAssert) checkOffset(offset, 8, this.length);
  		  return ieee754.read(this, offset, true, 52, 8)
  		};

  		Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  		  offset = offset >>> 0;
  		  if (!noAssert) checkOffset(offset, 8, this.length);
  		  return ieee754.read(this, offset, false, 52, 8)
  		};

  		function checkInt (buf, value, offset, ext, max, min) {
  		  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  		  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  		  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  		}

  		Buffer.prototype.writeUintLE =
  		Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  		  value = +value;
  		  offset = offset >>> 0;
  		  byteLength = byteLength >>> 0;
  		  if (!noAssert) {
  		    const maxBytes = Math.pow(2, 8 * byteLength) - 1;
  		    checkInt(this, value, offset, byteLength, maxBytes, 0);
  		  }

  		  let mul = 1;
  		  let i = 0;
  		  this[offset] = value & 0xFF;
  		  while (++i < byteLength && (mul *= 0x100)) {
  		    this[offset + i] = (value / mul) & 0xFF;
  		  }

  		  return offset + byteLength
  		};

  		Buffer.prototype.writeUintBE =
  		Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  		  value = +value;
  		  offset = offset >>> 0;
  		  byteLength = byteLength >>> 0;
  		  if (!noAssert) {
  		    const maxBytes = Math.pow(2, 8 * byteLength) - 1;
  		    checkInt(this, value, offset, byteLength, maxBytes, 0);
  		  }

  		  let i = byteLength - 1;
  		  let mul = 1;
  		  this[offset + i] = value & 0xFF;
  		  while (--i >= 0 && (mul *= 0x100)) {
  		    this[offset + i] = (value / mul) & 0xFF;
  		  }

  		  return offset + byteLength
  		};

  		Buffer.prototype.writeUint8 =
  		Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  		  value = +value;
  		  offset = offset >>> 0;
  		  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  		  this[offset] = (value & 0xff);
  		  return offset + 1
  		};

  		Buffer.prototype.writeUint16LE =
  		Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  		  value = +value;
  		  offset = offset >>> 0;
  		  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  		  this[offset] = (value & 0xff);
  		  this[offset + 1] = (value >>> 8);
  		  return offset + 2
  		};

  		Buffer.prototype.writeUint16BE =
  		Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  		  value = +value;
  		  offset = offset >>> 0;
  		  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  		  this[offset] = (value >>> 8);
  		  this[offset + 1] = (value & 0xff);
  		  return offset + 2
  		};

  		Buffer.prototype.writeUint32LE =
  		Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  		  value = +value;
  		  offset = offset >>> 0;
  		  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  		  this[offset + 3] = (value >>> 24);
  		  this[offset + 2] = (value >>> 16);
  		  this[offset + 1] = (value >>> 8);
  		  this[offset] = (value & 0xff);
  		  return offset + 4
  		};

  		Buffer.prototype.writeUint32BE =
  		Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  		  value = +value;
  		  offset = offset >>> 0;
  		  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  		  this[offset] = (value >>> 24);
  		  this[offset + 1] = (value >>> 16);
  		  this[offset + 2] = (value >>> 8);
  		  this[offset + 3] = (value & 0xff);
  		  return offset + 4
  		};

  		function wrtBigUInt64LE (buf, value, offset, min, max) {
  		  checkIntBI(value, min, max, buf, offset, 7);

  		  let lo = Number(value & BigInt(0xffffffff));
  		  buf[offset++] = lo;
  		  lo = lo >> 8;
  		  buf[offset++] = lo;
  		  lo = lo >> 8;
  		  buf[offset++] = lo;
  		  lo = lo >> 8;
  		  buf[offset++] = lo;
  		  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
  		  buf[offset++] = hi;
  		  hi = hi >> 8;
  		  buf[offset++] = hi;
  		  hi = hi >> 8;
  		  buf[offset++] = hi;
  		  hi = hi >> 8;
  		  buf[offset++] = hi;
  		  return offset
  		}

  		function wrtBigUInt64BE (buf, value, offset, min, max) {
  		  checkIntBI(value, min, max, buf, offset, 7);

  		  let lo = Number(value & BigInt(0xffffffff));
  		  buf[offset + 7] = lo;
  		  lo = lo >> 8;
  		  buf[offset + 6] = lo;
  		  lo = lo >> 8;
  		  buf[offset + 5] = lo;
  		  lo = lo >> 8;
  		  buf[offset + 4] = lo;
  		  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
  		  buf[offset + 3] = hi;
  		  hi = hi >> 8;
  		  buf[offset + 2] = hi;
  		  hi = hi >> 8;
  		  buf[offset + 1] = hi;
  		  hi = hi >> 8;
  		  buf[offset] = hi;
  		  return offset + 8
  		}

  		Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {
  		  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
  		});

  		Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {
  		  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
  		});

  		Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  		  value = +value;
  		  offset = offset >>> 0;
  		  if (!noAssert) {
  		    const limit = Math.pow(2, (8 * byteLength) - 1);

  		    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  		  }

  		  let i = 0;
  		  let mul = 1;
  		  let sub = 0;
  		  this[offset] = value & 0xFF;
  		  while (++i < byteLength && (mul *= 0x100)) {
  		    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
  		      sub = 1;
  		    }
  		    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
  		  }

  		  return offset + byteLength
  		};

  		Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  		  value = +value;
  		  offset = offset >>> 0;
  		  if (!noAssert) {
  		    const limit = Math.pow(2, (8 * byteLength) - 1);

  		    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  		  }

  		  let i = byteLength - 1;
  		  let mul = 1;
  		  let sub = 0;
  		  this[offset + i] = value & 0xFF;
  		  while (--i >= 0 && (mul *= 0x100)) {
  		    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
  		      sub = 1;
  		    }
  		    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
  		  }

  		  return offset + byteLength
  		};

  		Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  		  value = +value;
  		  offset = offset >>> 0;
  		  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -128);
  		  if (value < 0) value = 0xff + value + 1;
  		  this[offset] = (value & 0xff);
  		  return offset + 1
  		};

  		Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  		  value = +value;
  		  offset = offset >>> 0;
  		  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
  		  this[offset] = (value & 0xff);
  		  this[offset + 1] = (value >>> 8);
  		  return offset + 2
  		};

  		Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  		  value = +value;
  		  offset = offset >>> 0;
  		  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
  		  this[offset] = (value >>> 8);
  		  this[offset + 1] = (value & 0xff);
  		  return offset + 2
  		};

  		Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  		  value = +value;
  		  offset = offset >>> 0;
  		  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
  		  this[offset] = (value & 0xff);
  		  this[offset + 1] = (value >>> 8);
  		  this[offset + 2] = (value >>> 16);
  		  this[offset + 3] = (value >>> 24);
  		  return offset + 4
  		};

  		Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  		  value = +value;
  		  offset = offset >>> 0;
  		  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
  		  if (value < 0) value = 0xffffffff + value + 1;
  		  this[offset] = (value >>> 24);
  		  this[offset + 1] = (value >>> 16);
  		  this[offset + 2] = (value >>> 8);
  		  this[offset + 3] = (value & 0xff);
  		  return offset + 4
  		};

  		Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {
  		  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
  		});

  		Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {
  		  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
  		});

  		function checkIEEE754 (buf, value, offset, ext, max, min) {
  		  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  		  if (offset < 0) throw new RangeError('Index out of range')
  		}

  		function writeFloat (buf, value, offset, littleEndian, noAssert) {
  		  value = +value;
  		  offset = offset >>> 0;
  		  if (!noAssert) {
  		    checkIEEE754(buf, value, offset, 4);
  		  }
  		  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  		  return offset + 4
  		}

  		Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  		  return writeFloat(this, value, offset, true, noAssert)
  		};

  		Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  		  return writeFloat(this, value, offset, false, noAssert)
  		};

  		function writeDouble (buf, value, offset, littleEndian, noAssert) {
  		  value = +value;
  		  offset = offset >>> 0;
  		  if (!noAssert) {
  		    checkIEEE754(buf, value, offset, 8);
  		  }
  		  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  		  return offset + 8
  		}

  		Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  		  return writeDouble(this, value, offset, true, noAssert)
  		};

  		Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  		  return writeDouble(this, value, offset, false, noAssert)
  		};

  		// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
  		Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  		  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  		  if (!start) start = 0;
  		  if (!end && end !== 0) end = this.length;
  		  if (targetStart >= target.length) targetStart = target.length;
  		  if (!targetStart) targetStart = 0;
  		  if (end > 0 && end < start) end = start;

  		  // Copy 0 bytes; we're done
  		  if (end === start) return 0
  		  if (target.length === 0 || this.length === 0) return 0

  		  // Fatal error conditions
  		  if (targetStart < 0) {
  		    throw new RangeError('targetStart out of bounds')
  		  }
  		  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  		  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  		  // Are we oob?
  		  if (end > this.length) end = this.length;
  		  if (target.length - targetStart < end - start) {
  		    end = target.length - targetStart + start;
  		  }

  		  const len = end - start;

  		  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
  		    // Use built-in when available, missing from IE11
  		    this.copyWithin(targetStart, start, end);
  		  } else {
  		    Uint8Array.prototype.set.call(
  		      target,
  		      this.subarray(start, end),
  		      targetStart
  		    );
  		  }

  		  return len
  		};

  		// Usage:
  		//    buffer.fill(number[, offset[, end]])
  		//    buffer.fill(buffer[, offset[, end]])
  		//    buffer.fill(string[, offset[, end]][, encoding])
  		Buffer.prototype.fill = function fill (val, start, end, encoding) {
  		  // Handle string cases:
  		  if (typeof val === 'string') {
  		    if (typeof start === 'string') {
  		      encoding = start;
  		      start = 0;
  		      end = this.length;
  		    } else if (typeof end === 'string') {
  		      encoding = end;
  		      end = this.length;
  		    }
  		    if (encoding !== undefined && typeof encoding !== 'string') {
  		      throw new TypeError('encoding must be a string')
  		    }
  		    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
  		      throw new TypeError('Unknown encoding: ' + encoding)
  		    }
  		    if (val.length === 1) {
  		      const code = val.charCodeAt(0);
  		      if ((encoding === 'utf8' && code < 128) ||
  		          encoding === 'latin1') {
  		        // Fast path: If `val` fits into a single byte, use that numeric value.
  		        val = code;
  		      }
  		    }
  		  } else if (typeof val === 'number') {
  		    val = val & 255;
  		  } else if (typeof val === 'boolean') {
  		    val = Number(val);
  		  }

  		  // Invalid ranges are not set to a default, so can range check early.
  		  if (start < 0 || this.length < start || this.length < end) {
  		    throw new RangeError('Out of range index')
  		  }

  		  if (end <= start) {
  		    return this
  		  }

  		  start = start >>> 0;
  		  end = end === undefined ? this.length : end >>> 0;

  		  if (!val) val = 0;

  		  let i;
  		  if (typeof val === 'number') {
  		    for (i = start; i < end; ++i) {
  		      this[i] = val;
  		    }
  		  } else {
  		    const bytes = Buffer.isBuffer(val)
  		      ? val
  		      : Buffer.from(val, encoding);
  		    const len = bytes.length;
  		    if (len === 0) {
  		      throw new TypeError('The value "' + val +
  		        '" is invalid for argument "value"')
  		    }
  		    for (i = 0; i < end - start; ++i) {
  		      this[i + start] = bytes[i % len];
  		    }
  		  }

  		  return this
  		};

  		// CUSTOM ERRORS
  		// =============

  		// Simplified versions from Node, changed for Buffer-only usage
  		const errors = {};
  		function E (sym, getMessage, Base) {
  		  errors[sym] = class NodeError extends Base {
  		    constructor () {
  		      super();

  		      Object.defineProperty(this, 'message', {
  		        value: getMessage.apply(this, arguments),
  		        writable: true,
  		        configurable: true
  		      });

  		      // Add the error code to the name to include it in the stack trace.
  		      this.name = `${this.name} [${sym}]`;
  		      // Access the stack to generate the error message including the error code
  		      // from the name.
  		      this.stack; // eslint-disable-line no-unused-expressions
  		      // Reset the name to the actual name.
  		      delete this.name;
  		    }

  		    get code () {
  		      return sym
  		    }

  		    set code (value) {
  		      Object.defineProperty(this, 'code', {
  		        configurable: true,
  		        enumerable: true,
  		        value,
  		        writable: true
  		      });
  		    }

  		    toString () {
  		      return `${this.name} [${sym}]: ${this.message}`
  		    }
  		  };
  		}

  		E('ERR_BUFFER_OUT_OF_BOUNDS',
  		  function (name) {
  		    if (name) {
  		      return `${name} is outside of buffer bounds`
  		    }

  		    return 'Attempt to access memory outside buffer bounds'
  		  }, RangeError);
  		E('ERR_INVALID_ARG_TYPE',
  		  function (name, actual) {
  		    return `The "${name}" argument must be of type number. Received type ${typeof actual}`
  		  }, TypeError);
  		E('ERR_OUT_OF_RANGE',
  		  function (str, range, input) {
  		    let msg = `The value of "${str}" is out of range.`;
  		    let received = input;
  		    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
  		      received = addNumericalSeparator(String(input));
  		    } else if (typeof input === 'bigint') {
  		      received = String(input);
  		      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
  		        received = addNumericalSeparator(received);
  		      }
  		      received += 'n';
  		    }
  		    msg += ` It must be ${range}. Received ${received}`;
  		    return msg
  		  }, RangeError);

  		function addNumericalSeparator (val) {
  		  let res = '';
  		  let i = val.length;
  		  const start = val[0] === '-' ? 1 : 0;
  		  for (; i >= start + 4; i -= 3) {
  		    res = `_${val.slice(i - 3, i)}${res}`;
  		  }
  		  return `${val.slice(0, i)}${res}`
  		}

  		// CHECK FUNCTIONS
  		// ===============

  		function checkBounds (buf, offset, byteLength) {
  		  validateNumber(offset, 'offset');
  		  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
  		    boundsError(offset, buf.length - (byteLength + 1));
  		  }
  		}

  		function checkIntBI (value, min, max, buf, offset, byteLength) {
  		  if (value > max || value < min) {
  		    const n = typeof min === 'bigint' ? 'n' : '';
  		    let range;
  		    {
  		      if (min === 0 || min === BigInt(0)) {
  		        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
  		      } else {
  		        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +
  		                `${(byteLength + 1) * 8 - 1}${n}`;
  		      }
  		    }
  		    throw new errors.ERR_OUT_OF_RANGE('value', range, value)
  		  }
  		  checkBounds(buf, offset, byteLength);
  		}

  		function validateNumber (value, name) {
  		  if (typeof value !== 'number') {
  		    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)
  		  }
  		}

  		function boundsError (value, length, type) {
  		  if (Math.floor(value) !== value) {
  		    validateNumber(value, type);
  		    throw new errors.ERR_OUT_OF_RANGE('offset', 'an integer', value)
  		  }

  		  if (length < 0) {
  		    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()
  		  }

  		  throw new errors.ERR_OUT_OF_RANGE('offset',
  		                                    `>= ${0} and <= ${length}`,
  		                                    value)
  		}

  		// HELPER FUNCTIONS
  		// ================

  		const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

  		function base64clean (str) {
  		  // Node takes equal signs as end of the Base64 encoding
  		  str = str.split('=')[0];
  		  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  		  str = str.trim().replace(INVALID_BASE64_RE, '');
  		  // Node converts strings with length < 2 to ''
  		  if (str.length < 2) return ''
  		  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  		  while (str.length % 4 !== 0) {
  		    str = str + '=';
  		  }
  		  return str
  		}

  		function utf8ToBytes (string, units) {
  		  units = units || Infinity;
  		  let codePoint;
  		  const length = string.length;
  		  let leadSurrogate = null;
  		  const bytes = [];

  		  for (let i = 0; i < length; ++i) {
  		    codePoint = string.charCodeAt(i);

  		    // is surrogate component
  		    if (codePoint > 0xD7FF && codePoint < 0xE000) {
  		      // last char was a lead
  		      if (!leadSurrogate) {
  		        // no lead yet
  		        if (codePoint > 0xDBFF) {
  		          // unexpected trail
  		          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
  		          continue
  		        } else if (i + 1 === length) {
  		          // unpaired lead
  		          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
  		          continue
  		        }

  		        // valid lead
  		        leadSurrogate = codePoint;

  		        continue
  		      }

  		      // 2 leads in a row
  		      if (codePoint < 0xDC00) {
  		        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
  		        leadSurrogate = codePoint;
  		        continue
  		      }

  		      // valid surrogate pair
  		      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
  		    } else if (leadSurrogate) {
  		      // valid bmp char, but last char was a lead
  		      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
  		    }

  		    leadSurrogate = null;

  		    // encode utf8
  		    if (codePoint < 0x80) {
  		      if ((units -= 1) < 0) break
  		      bytes.push(codePoint);
  		    } else if (codePoint < 0x800) {
  		      if ((units -= 2) < 0) break
  		      bytes.push(
  		        codePoint >> 0x6 | 0xC0,
  		        codePoint & 0x3F | 0x80
  		      );
  		    } else if (codePoint < 0x10000) {
  		      if ((units -= 3) < 0) break
  		      bytes.push(
  		        codePoint >> 0xC | 0xE0,
  		        codePoint >> 0x6 & 0x3F | 0x80,
  		        codePoint & 0x3F | 0x80
  		      );
  		    } else if (codePoint < 0x110000) {
  		      if ((units -= 4) < 0) break
  		      bytes.push(
  		        codePoint >> 0x12 | 0xF0,
  		        codePoint >> 0xC & 0x3F | 0x80,
  		        codePoint >> 0x6 & 0x3F | 0x80,
  		        codePoint & 0x3F | 0x80
  		      );
  		    } else {
  		      throw new Error('Invalid code point')
  		    }
  		  }

  		  return bytes
  		}

  		function asciiToBytes (str) {
  		  const byteArray = [];
  		  for (let i = 0; i < str.length; ++i) {
  		    // Node's code seems to be doing this and not & 0x7F..
  		    byteArray.push(str.charCodeAt(i) & 0xFF);
  		  }
  		  return byteArray
  		}

  		function utf16leToBytes (str, units) {
  		  let c, hi, lo;
  		  const byteArray = [];
  		  for (let i = 0; i < str.length; ++i) {
  		    if ((units -= 2) < 0) break

  		    c = str.charCodeAt(i);
  		    hi = c >> 8;
  		    lo = c % 256;
  		    byteArray.push(lo);
  		    byteArray.push(hi);
  		  }

  		  return byteArray
  		}

  		function base64ToBytes (str) {
  		  return base64.toByteArray(base64clean(str))
  		}

  		function blitBuffer (src, dst, offset, length) {
  		  let i;
  		  for (i = 0; i < length; ++i) {
  		    if ((i + offset >= dst.length) || (i >= src.length)) break
  		    dst[i + offset] = src[i];
  		  }
  		  return i
  		}

  		// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
  		// the `instanceof` check but they should be treated as of that type.
  		// See: https://github.com/feross/buffer/issues/166
  		function isInstance (obj, type) {
  		  return obj instanceof type ||
  		    (obj != null && obj.constructor != null && obj.constructor.name != null &&
  		      obj.constructor.name === type.name)
  		}
  		function numberIsNaN (obj) {
  		  // For IE11 support
  		  return obj !== obj // eslint-disable-line no-self-compare
  		}

  		// Create lookup table for `toString('hex')`
  		// See: https://github.com/feross/buffer/issues/219
  		const hexSliceLookupTable = (function () {
  		  const alphabet = '0123456789abcdef';
  		  const table = new Array(256);
  		  for (let i = 0; i < 16; ++i) {
  		    const i16 = i * 16;
  		    for (let j = 0; j < 16; ++j) {
  		      table[i16 + j] = alphabet[i] + alphabet[j];
  		    }
  		  }
  		  return table
  		})();

  		// Return not function with Error if BigInt not supported
  		function defineBigIntMethod (fn) {
  		  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn
  		}

  		function BufferBigIntNotDefined () {
  		  throw new Error('BigInt not supported')
  		} 
  	} (buffer));
  	return buffer;
  }

  var bufferExports = requireBuffer();

  // this will be executed in browser environment so we can use window.crypto
  /* eslint-disable n/no-unsupported-features/node-builtins */

  const CipherAlgorithm = {
      Aes128Ctr: "AES-128-CTR",
      Aes128Cbc: "AES-128-CBC",
  };

  /**
   * @param {string} algorithm
   * @param {Uint8Array} key
   * @param {Uint8Array} iv
   * @param {Uint8Array} data
   * @returns {Promise<Uint8Array>}
   */
  async function createCipheriv(algorithm, key, iv, data) {
      let algorithm_;

      switch (algorithm.toUpperCase()) {
          case CipherAlgorithm.Aes128Ctr:
              algorithm_ = {
                  name: "AES-CTR",
                  counter: iv,
                  length: 128,
              };
              break;
          case CipherAlgorithm.Aes128Cbc:
              algorithm_ = {
                  name: "AES-CBC",
                  iv: iv,
              };
              break;
          default:
              throw new Error(
                  "(BUG) non-exhaustive switch statement for CipherAlgorithm",
              );
      }

      const key_ = await window.crypto.subtle.importKey(
          "raw",
          key,
          algorithm_.name,
          false,
          ["encrypt"],
      );

      return new Uint8Array(
          // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#return_value
          /** @type {ArrayBuffer} */ (
              // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
              await window.crypto.subtle.encrypt(algorithm_, key_, data)
          ),
      );
  }

  /**
   * @param {string} algorithm
   * @param {Uint8Array} key
   * @param {Uint8Array} iv
   * @param {Uint8Array} data
   * @returns {Promise<Uint8Array>}
   */
  async function createDecipheriv(algorithm, key, iv, data) {
      let algorithm_;

      switch (algorithm.toUpperCase()) {
          case CipherAlgorithm.Aes128Ctr:
              algorithm_ = {
                  name: "AES-CTR",
                  counter: iv,
                  length: 128,
              };
              break;
          case CipherAlgorithm.Aes128Cbc:
              algorithm_ = {
                  name: "AES-CBC",
                  iv,
              };
              break;
          default:
              throw new Error(
                  "(BUG) non-exhaustive switch statement for CipherAlgorithm",
              );
      }

      const key_ = await window.crypto.subtle.importKey(
          "raw",
          key,
          algorithm_.name,
          false,
          ["decrypt"],
      );
      let decrypted;
      try {
          decrypted = await window.crypto.subtle.decrypt(algorithm_, key_, data);
      } catch (error) {
          const message =
              // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
              error != null && /** @type {Error} */ (error).message != null
                  ? // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                    /** @type {Error} */ (error).message
                  : "";

          throw new Error(`Unable to decrypt: ${message}`);
      }
      return new Uint8Array(
          // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#return_value
          /** @type {ArrayBuffer} */ (
              // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
              decrypted
          ),
      );
  }

  /**
   * @param {string} passphrase
   * @param {string} iv
   * @returns {Promise<Uint8Array>}
   */
  async function messageDigest(passphrase, iv) {
      const pass = encode$2(passphrase);
      const sliced = decode$6(iv).slice(0, 8);
      const result = SparkMD5.ArrayBuffer.hash(
          // @ts-ignore
          bufferExports.Buffer.concat([bufferExports.Buffer.from(pass), bufferExports.Buffer.from(sliced)]),
      );

      return Promise.resolve(decode$6(result));
  }

  // this will be executed in browser environment so we can use window.crypto
  /* eslint-disable n/no-unsupported-features/node-builtins */

  /**
   * @typedef {import("./hmac.js").HashAlgorithm} HashAlgorithm
   */

  /**
   * @param {HashAlgorithm} algorithm
   * @param {Uint8Array | string} password
   * @param {Uint8Array | string} salt
   * @param {number} iterations
   * @param {number} length
   * @returns {Promise<Uint8Array>}
   */
  async function deriveKey(algorithm, password, salt, iterations, length) {
      const pass =
          typeof password === "string"
              ? // Valid ASCII is also valid UTF-8 so encoding the password as UTF-8
                // should be fine if only valid ASCII characters are used in the password
                encode$2(password)
              : password;

      const nacl = typeof salt === "string" ? encode$2(salt) : salt;

      try {
          const key = await window.crypto.subtle.importKey(
              "raw",
              pass,
              {
                  name: "PBKDF2",
                  hash: algorithm,
              },
              false,
              ["deriveBits"],
          );

          return new Uint8Array(
              await window.crypto.subtle.deriveBits(
                  {
                      name: "PBKDF2",
                      hash: algorithm,
                      salt: nacl,
                      iterations,
                  },
                  key,
                  length << 3,
              ),
          );
      } catch {
          throw new Error("(BUG) Non-Exhaustive switch statement for algorithms");
      }
  }

  const HMAC_SHA256 = "hmac-sha256";

  /**
   * @typedef {object} KeystoreKdfParams
   * @property {number} dkLen
   * @property {string} salt
   * @property {number} c
   * @property {string} prf
   */

  /**
   * @typedef {object} KeystoreCipherParams
   * @property {string} iv
   */

  /**
   * @typedef {object} KeystoreCrypto
   * @property {string} ciphertext
   * @property {KeystoreCipherParams} cipherparams
   * @property {string} cipher
   * @property {string} kdf
   * @property {KeystoreKdfParams} kdfparams
   * @property {string} mac
   */

  /**
   * @typedef {object} Keystore
   * @property {number} version
   * @property {KeystoreCrypto} crypto
   */

  /**
   * @param {Uint8Array} privateKey
   * @param {string} passphrase
   * @returns {Promise<Uint8Array>}
   */
  async function createKeystore(privateKey, passphrase) {
      // all values taken from https://github.com/ethereumjs/ethereumjs-wallet/blob/de3a92e752673ada1d78f95cf80bc56ae1f59775/src/index.ts#L25
      const dkLen = 32;
      const c = 262144;
      const saltLen = 32;
      const salt = await bytesAsync(saltLen);

      const key = await deriveKey(
          HashAlgorithm.Sha256,
          passphrase,
          salt,
          c,
          dkLen,
      );

      const iv = await bytesAsync(16);

      // AES-128-CTR with the first half of the derived key and a random IV
      const cipherText = await createCipheriv(
          CipherAlgorithm.Aes128Ctr,
          key.slice(0, 16),
          iv,
          privateKey,
      );

      const mac = await hash(
          HashAlgorithm.Sha384,
          key.slice(16),
          cipherText,
      );

      /**
       * @type {Keystore}
       */
      const keystore = {
          version: 1,
          crypto: {
              ciphertext: encode$3(cipherText),
              cipherparams: { iv: encode$3(iv) },
              cipher: CipherAlgorithm.Aes128Ctr,
              kdf: "pbkdf2",
              kdfparams: {
                  dkLen,
                  salt: encode$3(salt),
                  c,
                  prf: HMAC_SHA256,
              },
              mac: encode$3(mac),
          },
      };

      return encode$2(JSON.stringify(keystore));
  }

  /**
   * @param {Uint8Array} keystoreBytes
   * @param {string} passphrase
   * @returns {Promise<Uint8Array>}
   */
  async function loadKeystore(keystoreBytes, passphrase) {
      /**
       * @type {Keystore}
       */
      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
      const keystore = JSON.parse(decode$5(keystoreBytes));

      if (keystore.version !== 1) {
          throw new BadKeyError(
              `unsupported keystore version: ${keystore.version}`,
          );
      }

      const {
          ciphertext,
          cipherparams: { iv },
          cipher,
          kdf,
          kdfparams: { dkLen, salt, c, prf },
          mac,
      } = keystore.crypto;

      if (kdf !== "pbkdf2") {
          throw new BadKeyError(`unsupported key derivation function:" + ${kdf}`);
      }

      if (prf !== HMAC_SHA256) {
          throw new BadKeyError(
              `unsupported key derivation hash function: ${prf}`,
          );
      }

      const saltBytes = decode$6(salt);
      const ivBytes = decode$6(iv);
      const cipherBytes = decode$6(ciphertext);

      const key = await deriveKey(
          HashAlgorithm.Sha256,
          passphrase,
          saltBytes,
          c,
          dkLen,
      );

      const macHex = decode$6(mac);
      const verifyHmac = await hash(
          HashAlgorithm.Sha384,
          key.slice(16),
          cipherBytes,
      );

      // compare that these two Uint8Arrays are equivalent
      if (!macHex.every((b, i) => b === verifyHmac[i])) {
          throw new BadKeyError("HMAC mismatch; passphrase is incorrect");
      }

      return createDecipheriv(
          cipher,
          key.slice(0, 16),
          ivBytes,
          cipherBytes,
      );
  }

  /**
   * @typedef {object} AsnSeq
   * @property {AsnType[]} seq
   */

  /**
   * @typedef {object} AsnInt
   * @property {number} int
   */

  /**
   * @typedef {object} AsnBytes
   * @property {Uint8Array} bytes
   */

  /**
   * @typedef {object} AsnIdent
   * @property {string} ident
   */

  /**
   * @typedef {{}} AsnNull
   */

  /**
   * @typedef {AsnSeq | AsnInt | AsnBytes | AsnIdent | AsnNull} AsnType
   */

  /**
   * Note: may throw weird errors on malformed input. Catch and rethrow with, e.g. `BadKeyError`.
   *@param {Uint8Array} data
   *@returns {AsnType}
   */
  function decode$4(data) {
      return decodeIncremental(data)[0];
  }

  /**
   * @param {Uint8Array} bytes
   * @returns {[AsnType, Uint8Array]}
   */
  function decodeIncremental(bytes) {
      // slice off the initial tag byte, `decodeLength` returns a slice of the remaining data
      const [len, rem] = decodeLength(bytes.subarray(1));
      const data = rem.subarray(0, len);
      const tail = rem.subarray(len);

      switch (bytes[0]) {
          case 2:
              return [{ int: decodeInt(data) }, tail];
          case 4: // must always be primitive form in DER; for OCTET STRING this is literal bytes
              return [{ bytes: data }, tail];
          case 5: // empty
              return [{}, tail];
          case 6:
              return [{ ident: decodeObjectIdent(data) }, tail];
          case 48:
              return [{ seq: decodeSeq(data) }, tail];
          default:
              throw new Error(`unsupported DER type tag: ${bytes[0]}`);
      }
  }

  /**
   * @param {Uint8Array} seqBytes
   * @returns {AsnType[]}
   */
  function decodeSeq(seqBytes) {
      let data = seqBytes;

      const seq = [];

      while (data.length !== 0) {
          const [decoded, remaining] = decodeIncremental(data);
          seq.push(decoded);
          data = remaining;
      }

      return seq;
  }

  /**
   * @param {Uint8Array} idBytes
   * @returns {string}
   */
  function decodeObjectIdent(idBytes) {
      const id = [
          // first octet is 40 * value1 + value2
          Math.floor(idBytes[0] / 40),
          idBytes[0] % 40,
      ];

      // each following ID component is big-endian base128 where the MSB is set if another byte
      // follows for the same value
      let val = 0;

      for (const byte of idBytes.subarray(1)) {
          // shift the entire value left by 7 bits
          val *= 128;

          if (byte < 128) {
              // no more octets follow for this value, finish it off
              val += byte;
              id.push(val);
              val = 0;
          } else {
              // zero the MSB
              val += byte & 127;
          }
      }

      return id.join(".");
  }

  /**
   * @param {Uint8Array} lenBytes
   * @returns {[number, Uint8Array]}
   */
  function decodeLength(lenBytes) {
      if (lenBytes[0] < 128) {
          // definite, short form
          return [lenBytes[0], lenBytes.subarray(1)];
      }

      const numBytes = lenBytes[0] - 128;

      const intBytes = lenBytes.subarray(1, numBytes + 1);
      const rem = lenBytes.subarray(numBytes + 1);

      return [decodeInt(intBytes), rem];
  }

  /**
   * @param {Uint8Array} intBytes
   * @returns {number}
   */
  function decodeInt(intBytes) {
      const len = intBytes.length;
      if (len === 1) {
          return intBytes[0];
      }

      let view = new DataView(
          intBytes.buffer,
          intBytes.byteOffset,
          intBytes.byteLength,
      );

      if (len === 2) return view.getUint16(0, false);

      if (len === 3) {
          // prefix a zero byte and we'll treat it as a 32-bit int
          const data = Uint8Array.of(0, ...intBytes);
          view = new DataView(data.buffer, data.byteOffset, data.byteLength);
      }

      if (len > 4) {
          // this probably means a bug in the decoding as this would mean a >4GB structure
          throw new Error(`unsupported DER integer length of ${len} bytes`);
      }

      return view.getUint32(0, false);
  }

  class AlgorithmIdentifier {
      /**
       * @param {import("../encoding/der.js").AsnType} asn
       */
      constructor(asn) {
          if ("seq" in asn && asn.seq.length >= 1 && "ident" in asn.seq[0]) {
              /**
               * @type {string}
               */
              this.algIdent = asn.seq[0].ident;

              /**
               * @type {import("../encoding/der.js").AsnType | undefined}
               */
              this.parameters = asn.seq[1];
          } else {
              throw new Error(
                  `error parsing AlgorithmIdentifier from ${JSON.stringify(asn)}`,
              );
          }
      }

      /**
       * @returns {string}
       */
      toString() {
          return JSON.stringify(this);
      }
  }

  class PBES2Params {
      /**
       * @param {import("../encoding/der.js").AsnType} asn
       */
      constructor(asn) {
          if ("seq" in asn && asn.seq.length === 2) {
              /**
               * @type {AlgorithmIdentifier}
               */
              this.kdf = new AlgorithmIdentifier(asn.seq[0]);

              /**
               * @type {AlgorithmIdentifier}
               */
              this.encScheme = new AlgorithmIdentifier(asn.seq[1]);
          } else {
              throw new Error(
                  `error parsing PBES2Params from ${JSON.stringify(asn)}`,
              );
          }
      }
  }

  class PBKDF2Params {
      /**
       * @param {import("../encoding/der.js").AsnType} asn
       */
      constructor(asn) {
          if (
              "seq" in asn &&
              asn.seq.length >= 2 &&
              "bytes" in asn.seq[0] &&
              "int" in asn.seq[1]
          ) {
              /**
               * @type {Uint8Array}
               */
              this.salt = asn.seq[0].bytes;

              /**
               * @type {number}
               */
              this.iterCount = asn.seq[1]["int"];

              if (asn.seq.length > 2) {
                  if ("seq" in asn.seq[2]) {
                      this.prf = new AlgorithmIdentifier(asn.seq[2]);
                      return;
                  } else if ("int" in asn.seq[2]) {
                      /**
                       * @type {number | undefined}
                       */
                      this.keyLength = asn.seq[2]["int"];
                  }

                  if (asn.seq.length === 4) {
                      /**
                       * @type {AlgorithmIdentifier | undefined}
                       */
                      this.prf = new AlgorithmIdentifier(asn.seq[3]);
                  }

                  return;
              }
          }

          throw new Error(
              `error parsing PBKDF2Params from ${JSON.stringify(asn)}`,
          );
      }
  }

  class PrivateKeyInfo {
      /**
       * @param {import("../encoding/der.js").AsnType} asn
       */
      constructor(asn) {
          if ("seq" in asn && asn.seq.length === 3) {
              if ("int" in asn.seq[0] && asn.seq[0]["int"] === 0) {
                  /**
                   * @type {number}
                   */
                  this.version = 0;
              } else {
                  throw new Error(
                      `expected version = 0, got ${JSON.stringify(asn.seq[0])}`,
                  );
              }

              /**
               * @type {AlgorithmIdentifier}
               */
              this.algId = new AlgorithmIdentifier(asn.seq[1]);

              if ("bytes" in asn.seq[2]) {
                  /**
                   * @type {Uint8Array}
                   */
                  this.privateKey = asn.seq[2].bytes;
              } else {
                  throw new Error(
                      `expected octet string as 3rd element, got ${JSON.stringify(
                        asn.seq[2],
                    )}`,
                  );
              }

              return;
          }

          throw new Error(
              `error parsing PrivateKeyInfo from ${JSON.stringify(asn)}`,
          );
      }

      /**
       * @param {Uint8Array} encoded
       * @returns {PrivateKeyInfo}
       */
      static parse(encoded) {
          return new PrivateKeyInfo(decode$4(encoded));
      }
  }

  class EncryptedPrivateKeyInfo {
      /**
       * @param {import("../encoding/der.js").AsnType} asn
       */
      constructor(asn) {
          if ("seq" in asn && asn.seq.length === 2 && "bytes" in asn.seq[1]) {
              /**
               * @type {AlgorithmIdentifier}
               */
              this.algId = new AlgorithmIdentifier(asn.seq[0]);

              /**
               * @type {Uint8Array}
               */
              this.data = asn.seq[1].bytes;
              return;
          }

          throw new Error(
              `error parsing EncryptedPrivateKeyInfo from ${JSON.stringify(asn)}`,
          );
      }

      /**
       * @param {Uint8Array} encoded
       * @returns {EncryptedPrivateKeyInfo}
       */
      static parse(encoded) {
          return new EncryptedPrivateKeyInfo(decode$4(encoded));
      }

      /**
       * @param {string} passphrase
       * @returns {Promise<PrivateKeyInfo>}
       */
      async decrypt(passphrase) {
          if (
              this.algId.algIdent !== "1.2.840.113549.1.5.13" ||
              !this.algId.parameters
          ) {
              // PBES2
              throw new Error(
                  `unsupported key encryption algorithm: ${this.algId.toString()}`,
              );
          }

          const pbes2Params = new PBES2Params(this.algId.parameters);

          if (
              pbes2Params.kdf.algIdent !== "1.2.840.113549.1.5.12" ||
              !pbes2Params.kdf.parameters
          ) {
              // PBKDF2
              throw new Error(
                  `unsupported key derivation function: ${pbes2Params.kdf.toString()}`,
              );
          }

          const pbkdf2Params = new PBKDF2Params(pbes2Params.kdf.parameters);

          if (!pbkdf2Params.prf) {
              throw new Error("unsupported PRF HMAC-SHA-1");
          } else if (pbkdf2Params.prf.algIdent !== "1.2.840.113549.2.9") {
              // HMAC-SHA-256
              throw new Error(`unsupported PRF ${pbkdf2Params.prf.toString()}`);
          }

          if (pbes2Params.encScheme.algIdent !== "2.16.840.1.101.3.4.1.2") {
              // AES-128-CBC
              throw new Error(
                  `unsupported encryption scheme: ${pbes2Params.encScheme.toString()}`,
              );
          }

          if (
              !pbes2Params.encScheme.parameters ||
              !("bytes" in pbes2Params.encScheme.parameters)
          ) {
              throw new Error(
                  "expected IV as bytes for AES-128-CBC, " +
                      `got: ${JSON.stringify(pbes2Params.encScheme.parameters)}`,
              );
          }

          const keyLen = pbkdf2Params.keyLength || 16;
          const iv = pbes2Params.encScheme.parameters.bytes;

          const key = await deriveKey(
              HashAlgorithm.Sha256,
              passphrase,
              pbkdf2Params.salt,
              pbkdf2Params.iterCount,
              keyLen,
          );

          const decrypted = await createDecipheriv(
              CipherAlgorithm.Aes128Cbc,
              key,
              iv,
              this.data,
          );

          return PrivateKeyInfo.parse(decrypted);
      }
  }

  /**
   * @param {string} text
   * @returns {Uint8Array}
   */
  function decode$3(text) {
      return Uint8Array.from(bufferExports.Buffer.from(text, "base64"));
  }

  var build = {};

  /*!
   * MIT License
   * 
   * Copyright (c) 2017-2024 Peculiar Ventures, LLC
   * 
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   * 
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   * 
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   * 
   */

  var hasRequiredBuild;

  function requireBuild () {
  	if (hasRequiredBuild) return build;
  	hasRequiredBuild = 1;

  	const ARRAY_BUFFER_NAME = "[object ArrayBuffer]";
  	class BufferSourceConverter {
  	    static isArrayBuffer(data) {
  	        return Object.prototype.toString.call(data) === ARRAY_BUFFER_NAME;
  	    }
  	    static toArrayBuffer(data) {
  	        if (this.isArrayBuffer(data)) {
  	            return data;
  	        }
  	        if (data.byteLength === data.buffer.byteLength) {
  	            return data.buffer;
  	        }
  	        if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {
  	            return data.buffer;
  	        }
  	        return this.toUint8Array(data.buffer)
  	            .slice(data.byteOffset, data.byteOffset + data.byteLength)
  	            .buffer;
  	    }
  	    static toUint8Array(data) {
  	        return this.toView(data, Uint8Array);
  	    }
  	    static toView(data, type) {
  	        if (data.constructor === type) {
  	            return data;
  	        }
  	        if (this.isArrayBuffer(data)) {
  	            return new type(data);
  	        }
  	        if (this.isArrayBufferView(data)) {
  	            return new type(data.buffer, data.byteOffset, data.byteLength);
  	        }
  	        throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'");
  	    }
  	    static isBufferSource(data) {
  	        return this.isArrayBufferView(data)
  	            || this.isArrayBuffer(data);
  	    }
  	    static isArrayBufferView(data) {
  	        return ArrayBuffer.isView(data)
  	            || (data && this.isArrayBuffer(data.buffer));
  	    }
  	    static isEqual(a, b) {
  	        const aView = BufferSourceConverter.toUint8Array(a);
  	        const bView = BufferSourceConverter.toUint8Array(b);
  	        if (aView.length !== bView.byteLength) {
  	            return false;
  	        }
  	        for (let i = 0; i < aView.length; i++) {
  	            if (aView[i] !== bView[i]) {
  	                return false;
  	            }
  	        }
  	        return true;
  	    }
  	    static concat(...args) {
  	        let buffers;
  	        if (Array.isArray(args[0]) && !(args[1] instanceof Function)) {
  	            buffers = args[0];
  	        }
  	        else if (Array.isArray(args[0]) && args[1] instanceof Function) {
  	            buffers = args[0];
  	        }
  	        else {
  	            if (args[args.length - 1] instanceof Function) {
  	                buffers = args.slice(0, args.length - 1);
  	            }
  	            else {
  	                buffers = args;
  	            }
  	        }
  	        let size = 0;
  	        for (const buffer of buffers) {
  	            size += buffer.byteLength;
  	        }
  	        const res = new Uint8Array(size);
  	        let offset = 0;
  	        for (const buffer of buffers) {
  	            const view = this.toUint8Array(buffer);
  	            res.set(view, offset);
  	            offset += view.length;
  	        }
  	        if (args[args.length - 1] instanceof Function) {
  	            return this.toView(res, args[args.length - 1]);
  	        }
  	        return res.buffer;
  	    }
  	}

  	const STRING_TYPE = "string";
  	const HEX_REGEX = /^[0-9a-f\s]+$/i;
  	const BASE64_REGEX = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
  	const BASE64URL_REGEX = /^[a-zA-Z0-9-_]+$/;
  	class Utf8Converter {
  	    static fromString(text) {
  	        const s = unescape(encodeURIComponent(text));
  	        const uintArray = new Uint8Array(s.length);
  	        for (let i = 0; i < s.length; i++) {
  	            uintArray[i] = s.charCodeAt(i);
  	        }
  	        return uintArray.buffer;
  	    }
  	    static toString(buffer) {
  	        const buf = BufferSourceConverter.toUint8Array(buffer);
  	        let encodedString = "";
  	        for (let i = 0; i < buf.length; i++) {
  	            encodedString += String.fromCharCode(buf[i]);
  	        }
  	        const decodedString = decodeURIComponent(escape(encodedString));
  	        return decodedString;
  	    }
  	}
  	class Utf16Converter {
  	    static toString(buffer, littleEndian = false) {
  	        const arrayBuffer = BufferSourceConverter.toArrayBuffer(buffer);
  	        const dataView = new DataView(arrayBuffer);
  	        let res = "";
  	        for (let i = 0; i < arrayBuffer.byteLength; i += 2) {
  	            const code = dataView.getUint16(i, littleEndian);
  	            res += String.fromCharCode(code);
  	        }
  	        return res;
  	    }
  	    static fromString(text, littleEndian = false) {
  	        const res = new ArrayBuffer(text.length * 2);
  	        const dataView = new DataView(res);
  	        for (let i = 0; i < text.length; i++) {
  	            dataView.setUint16(i * 2, text.charCodeAt(i), littleEndian);
  	        }
  	        return res;
  	    }
  	}
  	class Convert {
  	    static isHex(data) {
  	        return typeof data === STRING_TYPE
  	            && HEX_REGEX.test(data);
  	    }
  	    static isBase64(data) {
  	        return typeof data === STRING_TYPE
  	            && BASE64_REGEX.test(data);
  	    }
  	    static isBase64Url(data) {
  	        return typeof data === STRING_TYPE
  	            && BASE64URL_REGEX.test(data);
  	    }
  	    static ToString(buffer, enc = "utf8") {
  	        const buf = BufferSourceConverter.toUint8Array(buffer);
  	        switch (enc.toLowerCase()) {
  	            case "utf8":
  	                return this.ToUtf8String(buf);
  	            case "binary":
  	                return this.ToBinary(buf);
  	            case "hex":
  	                return this.ToHex(buf);
  	            case "base64":
  	                return this.ToBase64(buf);
  	            case "base64url":
  	                return this.ToBase64Url(buf);
  	            case "utf16le":
  	                return Utf16Converter.toString(buf, true);
  	            case "utf16":
  	            case "utf16be":
  	                return Utf16Converter.toString(buf);
  	            default:
  	                throw new Error(`Unknown type of encoding '${enc}'`);
  	        }
  	    }
  	    static FromString(str, enc = "utf8") {
  	        if (!str) {
  	            return new ArrayBuffer(0);
  	        }
  	        switch (enc.toLowerCase()) {
  	            case "utf8":
  	                return this.FromUtf8String(str);
  	            case "binary":
  	                return this.FromBinary(str);
  	            case "hex":
  	                return this.FromHex(str);
  	            case "base64":
  	                return this.FromBase64(str);
  	            case "base64url":
  	                return this.FromBase64Url(str);
  	            case "utf16le":
  	                return Utf16Converter.fromString(str, true);
  	            case "utf16":
  	            case "utf16be":
  	                return Utf16Converter.fromString(str);
  	            default:
  	                throw new Error(`Unknown type of encoding '${enc}'`);
  	        }
  	    }
  	    static ToBase64(buffer) {
  	        const buf = BufferSourceConverter.toUint8Array(buffer);
  	        if (typeof btoa !== "undefined") {
  	            const binary = this.ToString(buf, "binary");
  	            return btoa(binary);
  	        }
  	        else {
  	            return Buffer.from(buf).toString("base64");
  	        }
  	    }
  	    static FromBase64(base64) {
  	        const formatted = this.formatString(base64);
  	        if (!formatted) {
  	            return new ArrayBuffer(0);
  	        }
  	        if (!Convert.isBase64(formatted)) {
  	            throw new TypeError("Argument 'base64Text' is not Base64 encoded");
  	        }
  	        if (typeof atob !== "undefined") {
  	            return this.FromBinary(atob(formatted));
  	        }
  	        else {
  	            return new Uint8Array(Buffer.from(formatted, "base64")).buffer;
  	        }
  	    }
  	    static FromBase64Url(base64url) {
  	        const formatted = this.formatString(base64url);
  	        if (!formatted) {
  	            return new ArrayBuffer(0);
  	        }
  	        if (!Convert.isBase64Url(formatted)) {
  	            throw new TypeError("Argument 'base64url' is not Base64Url encoded");
  	        }
  	        return this.FromBase64(this.Base64Padding(formatted.replace(/\-/g, "+").replace(/\_/g, "/")));
  	    }
  	    static ToBase64Url(data) {
  	        return this.ToBase64(data).replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
  	    }
  	    static FromUtf8String(text, encoding = Convert.DEFAULT_UTF8_ENCODING) {
  	        switch (encoding) {
  	            case "ascii":
  	                return this.FromBinary(text);
  	            case "utf8":
  	                return Utf8Converter.fromString(text);
  	            case "utf16":
  	            case "utf16be":
  	                return Utf16Converter.fromString(text);
  	            case "utf16le":
  	            case "usc2":
  	                return Utf16Converter.fromString(text, true);
  	            default:
  	                throw new Error(`Unknown type of encoding '${encoding}'`);
  	        }
  	    }
  	    static ToUtf8String(buffer, encoding = Convert.DEFAULT_UTF8_ENCODING) {
  	        switch (encoding) {
  	            case "ascii":
  	                return this.ToBinary(buffer);
  	            case "utf8":
  	                return Utf8Converter.toString(buffer);
  	            case "utf16":
  	            case "utf16be":
  	                return Utf16Converter.toString(buffer);
  	            case "utf16le":
  	            case "usc2":
  	                return Utf16Converter.toString(buffer, true);
  	            default:
  	                throw new Error(`Unknown type of encoding '${encoding}'`);
  	        }
  	    }
  	    static FromBinary(text) {
  	        const stringLength = text.length;
  	        const resultView = new Uint8Array(stringLength);
  	        for (let i = 0; i < stringLength; i++) {
  	            resultView[i] = text.charCodeAt(i);
  	        }
  	        return resultView.buffer;
  	    }
  	    static ToBinary(buffer) {
  	        const buf = BufferSourceConverter.toUint8Array(buffer);
  	        let res = "";
  	        for (let i = 0; i < buf.length; i++) {
  	            res += String.fromCharCode(buf[i]);
  	        }
  	        return res;
  	    }
  	    static ToHex(buffer) {
  	        const buf = BufferSourceConverter.toUint8Array(buffer);
  	        let result = "";
  	        const len = buf.length;
  	        for (let i = 0; i < len; i++) {
  	            const byte = buf[i];
  	            if (byte < 16) {
  	                result += "0";
  	            }
  	            result += byte.toString(16);
  	        }
  	        return result;
  	    }
  	    static FromHex(hexString) {
  	        let formatted = this.formatString(hexString);
  	        if (!formatted) {
  	            return new ArrayBuffer(0);
  	        }
  	        if (!Convert.isHex(formatted)) {
  	            throw new TypeError("Argument 'hexString' is not HEX encoded");
  	        }
  	        if (formatted.length % 2) {
  	            formatted = `0${formatted}`;
  	        }
  	        const res = new Uint8Array(formatted.length / 2);
  	        for (let i = 0; i < formatted.length; i = i + 2) {
  	            const c = formatted.slice(i, i + 2);
  	            res[i / 2] = parseInt(c, 16);
  	        }
  	        return res.buffer;
  	    }
  	    static ToUtf16String(buffer, littleEndian = false) {
  	        return Utf16Converter.toString(buffer, littleEndian);
  	    }
  	    static FromUtf16String(text, littleEndian = false) {
  	        return Utf16Converter.fromString(text, littleEndian);
  	    }
  	    static Base64Padding(base64) {
  	        const padCount = 4 - (base64.length % 4);
  	        if (padCount < 4) {
  	            for (let i = 0; i < padCount; i++) {
  	                base64 += "=";
  	            }
  	        }
  	        return base64;
  	    }
  	    static formatString(data) {
  	        return (data === null || data === void 0 ? void 0 : data.replace(/[\n\r\t ]/g, "")) || "";
  	    }
  	}
  	Convert.DEFAULT_UTF8_ENCODING = "utf8";

  	function assign(target, ...sources) {
  	    const res = arguments[0];
  	    for (let i = 1; i < arguments.length; i++) {
  	        const obj = arguments[i];
  	        for (const prop in obj) {
  	            res[prop] = obj[prop];
  	        }
  	    }
  	    return res;
  	}
  	function combine(...buf) {
  	    const totalByteLength = buf.map((item) => item.byteLength).reduce((prev, cur) => prev + cur);
  	    const res = new Uint8Array(totalByteLength);
  	    let currentPos = 0;
  	    buf.map((item) => new Uint8Array(item)).forEach((arr) => {
  	        for (const item2 of arr) {
  	            res[currentPos++] = item2;
  	        }
  	    });
  	    return res.buffer;
  	}
  	function isEqual(bytes1, bytes2) {
  	    if (!(bytes1 && bytes2)) {
  	        return false;
  	    }
  	    if (bytes1.byteLength !== bytes2.byteLength) {
  	        return false;
  	    }
  	    const b1 = new Uint8Array(bytes1);
  	    const b2 = new Uint8Array(bytes2);
  	    for (let i = 0; i < bytes1.byteLength; i++) {
  	        if (b1[i] !== b2[i]) {
  	            return false;
  	        }
  	    }
  	    return true;
  	}

  	build.BufferSourceConverter = BufferSourceConverter;
  	build.Convert = Convert;
  	build.assign = assign;
  	build.combine = combine;
  	build.isEqual = isEqual;
  	return build;
  }

  var buildExports = requireBuild();

  /*!
   Copyright (c) Peculiar Ventures, LLC
  */

  function utilFromBase(inputBuffer, inputBase) {
      let result = 0;
      if (inputBuffer.length === 1) {
          return inputBuffer[0];
      }
      for (let i = (inputBuffer.length - 1); i >= 0; i--) {
          result += inputBuffer[(inputBuffer.length - 1) - i] * Math.pow(2, inputBase * i);
      }
      return result;
  }
  function utilToBase(value, base, reserved = (-1)) {
      const internalReserved = reserved;
      let internalValue = value;
      let result = 0;
      let biggest = Math.pow(2, base);
      for (let i = 1; i < 8; i++) {
          if (value < biggest) {
              let retBuf;
              if (internalReserved < 0) {
                  retBuf = new ArrayBuffer(i);
                  result = i;
              }
              else {
                  if (internalReserved < i) {
                      return (new ArrayBuffer(0));
                  }
                  retBuf = new ArrayBuffer(internalReserved);
                  result = internalReserved;
              }
              const retView = new Uint8Array(retBuf);
              for (let j = (i - 1); j >= 0; j--) {
                  const basis = Math.pow(2, j * base);
                  retView[result - j - 1] = Math.floor(internalValue / basis);
                  internalValue -= (retView[result - j - 1]) * basis;
              }
              return retBuf;
          }
          biggest *= Math.pow(2, base);
      }
      return new ArrayBuffer(0);
  }
  function utilConcatView(...views) {
      let outputLength = 0;
      let prevLength = 0;
      for (const view of views) {
          outputLength += view.length;
      }
      const retBuf = new ArrayBuffer(outputLength);
      const retView = new Uint8Array(retBuf);
      for (const view of views) {
          retView.set(view, prevLength);
          prevLength += view.length;
      }
      return retView;
  }
  function utilDecodeTC() {
      const buf = new Uint8Array(this.valueHex);
      if (this.valueHex.byteLength >= 2) {
          const condition1 = (buf[0] === 0xFF) && (buf[1] & 0x80);
          const condition2 = (buf[0] === 0x00) && ((buf[1] & 0x80) === 0x00);
          if (condition1 || condition2) {
              this.warnings.push("Needlessly long format");
          }
      }
      const bigIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
      const bigIntView = new Uint8Array(bigIntBuffer);
      for (let i = 0; i < this.valueHex.byteLength; i++) {
          bigIntView[i] = 0;
      }
      bigIntView[0] = (buf[0] & 0x80);
      const bigInt = utilFromBase(bigIntView, 8);
      const smallIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
      const smallIntView = new Uint8Array(smallIntBuffer);
      for (let j = 0; j < this.valueHex.byteLength; j++) {
          smallIntView[j] = buf[j];
      }
      smallIntView[0] &= 0x7F;
      const smallInt = utilFromBase(smallIntView, 8);
      return (smallInt - bigInt);
  }
  function utilEncodeTC(value) {
      const modValue = (value < 0) ? (value * (-1)) : value;
      let bigInt = 128;
      for (let i = 1; i < 8; i++) {
          if (modValue <= bigInt) {
              if (value < 0) {
                  const smallInt = bigInt - modValue;
                  const retBuf = utilToBase(smallInt, 8, i);
                  const retView = new Uint8Array(retBuf);
                  retView[0] |= 0x80;
                  return retBuf;
              }
              let retBuf = utilToBase(modValue, 8, i);
              let retView = new Uint8Array(retBuf);
              if (retView[0] & 0x80) {
                  const tempBuf = retBuf.slice(0);
                  const tempView = new Uint8Array(tempBuf);
                  retBuf = new ArrayBuffer(retBuf.byteLength + 1);
                  retView = new Uint8Array(retBuf);
                  for (let k = 0; k < tempBuf.byteLength; k++) {
                      retView[k + 1] = tempView[k];
                  }
                  retView[0] = 0x00;
              }
              return retBuf;
          }
          bigInt *= Math.pow(2, 8);
      }
      return (new ArrayBuffer(0));
  }
  function isEqualBuffer(inputBuffer1, inputBuffer2) {
      if (inputBuffer1.byteLength !== inputBuffer2.byteLength) {
          return false;
      }
      const view1 = new Uint8Array(inputBuffer1);
      const view2 = new Uint8Array(inputBuffer2);
      for (let i = 0; i < view1.length; i++) {
          if (view1[i] !== view2[i]) {
              return false;
          }
      }
      return true;
  }
  function padNumber(inputNumber, fullLength) {
      const str = inputNumber.toString(10);
      if (fullLength < str.length) {
          return "";
      }
      const dif = fullLength - str.length;
      const padding = new Array(dif);
      for (let i = 0; i < dif; i++) {
          padding[i] = "0";
      }
      const paddingString = padding.join("");
      return paddingString.concat(str);
  }

  /*!
   * Copyright (c) 2014, GMO GlobalSign
   * Copyright (c) 2015-2022, Peculiar Ventures
   * All rights reserved.
   * 
   * Author 2014-2019, Yury Strozhevsky
   * 
   * Redistribution and use in source and binary forms, with or without modification,
   * are permitted provided that the following conditions are met:
   * 
   * * Redistributions of source code must retain the above copyright notice, this
   *   list of conditions and the following disclaimer.
   * 
   * * Redistributions in binary form must reproduce the above copyright notice, this
   *   list of conditions and the following disclaimer in the documentation and/or
   *   other materials provided with the distribution.
   * 
   * * Neither the name of the copyright holder nor the names of its
   *   contributors may be used to endorse or promote products derived from
   *   this software without specific prior written permission.
   * 
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
   * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
   * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
   * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
   * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
   * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
   * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   * 
   */


  function assertBigInt() {
      if (typeof BigInt === "undefined") {
          throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.");
      }
  }
  function concat$1(buffers) {
      let outputLength = 0;
      let prevLength = 0;
      for (let i = 0; i < buffers.length; i++) {
          const buffer = buffers[i];
          outputLength += buffer.byteLength;
      }
      const retView = new Uint8Array(outputLength);
      for (let i = 0; i < buffers.length; i++) {
          const buffer = buffers[i];
          retView.set(new Uint8Array(buffer), prevLength);
          prevLength += buffer.byteLength;
      }
      return retView.buffer;
  }
  function checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) {
      if (!(inputBuffer instanceof Uint8Array)) {
          baseBlock.error = "Wrong parameter: inputBuffer must be 'Uint8Array'";
          return false;
      }
      if (!inputBuffer.byteLength) {
          baseBlock.error = "Wrong parameter: inputBuffer has zero length";
          return false;
      }
      if (inputOffset < 0) {
          baseBlock.error = "Wrong parameter: inputOffset less than zero";
          return false;
      }
      if (inputLength < 0) {
          baseBlock.error = "Wrong parameter: inputLength less than zero";
          return false;
      }
      if ((inputBuffer.byteLength - inputOffset - inputLength) < 0) {
          baseBlock.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
          return false;
      }
      return true;
  }

  class ViewWriter {
      constructor() {
          this.items = [];
      }
      write(buf) {
          this.items.push(buf);
      }
      final() {
          return concat$1(this.items);
      }
  }

  const powers2 = [new Uint8Array([1])];
  const digitsString = "0123456789";
  const EMPTY_STRING = "";
  const EMPTY_BUFFER = new ArrayBuffer(0);
  const EMPTY_VIEW = new Uint8Array(0);
  const END_OF_CONTENT_NAME = "EndOfContent";
  const OCTET_STRING_NAME = "OCTET STRING";
  const BIT_STRING_NAME = "BIT STRING";

  function HexBlock(BaseClass) {
      var _a;
      return _a = class Some extends BaseClass {
              get valueHex() {
                  return this.valueHexView.slice().buffer;
              }
              set valueHex(value) {
                  this.valueHexView = new Uint8Array(value);
              }
              constructor(...args) {
                  var _b;
                  super(...args);
                  const params = args[0] || {};
                  this.isHexOnly = (_b = params.isHexOnly) !== null && _b !== void 0 ? _b : false;
                  this.valueHexView = params.valueHex ? buildExports.BufferSourceConverter.toUint8Array(params.valueHex) : EMPTY_VIEW;
              }
              fromBER(inputBuffer, inputOffset, inputLength) {
                  const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;
                  if (!checkBufferParams(this, view, inputOffset, inputLength)) {
                      return -1;
                  }
                  const endLength = inputOffset + inputLength;
                  this.valueHexView = view.subarray(inputOffset, endLength);
                  if (!this.valueHexView.length) {
                      this.warnings.push("Zero buffer length");
                      return inputOffset;
                  }
                  this.blockLength = inputLength;
                  return endLength;
              }
              toBER(sizeOnly = false) {
                  if (!this.isHexOnly) {
                      this.error = "Flag 'isHexOnly' is not set, abort";
                      return EMPTY_BUFFER;
                  }
                  if (sizeOnly) {
                      return new ArrayBuffer(this.valueHexView.byteLength);
                  }
                  return (this.valueHexView.byteLength === this.valueHexView.buffer.byteLength)
                      ? this.valueHexView.buffer
                      : this.valueHexView.slice().buffer;
              }
              toJSON() {
                  return {
                      ...super.toJSON(),
                      isHexOnly: this.isHexOnly,
                      valueHex: buildExports.Convert.ToHex(this.valueHexView),
                  };
              }
          },
          _a.NAME = "hexBlock",
          _a;
  }

  class LocalBaseBlock {
      static blockName() {
          return this.NAME;
      }
      get valueBeforeDecode() {
          return this.valueBeforeDecodeView.slice().buffer;
      }
      set valueBeforeDecode(value) {
          this.valueBeforeDecodeView = new Uint8Array(value);
      }
      constructor({ blockLength = 0, error = EMPTY_STRING, warnings = [], valueBeforeDecode = EMPTY_VIEW, } = {}) {
          this.blockLength = blockLength;
          this.error = error;
          this.warnings = warnings;
          this.valueBeforeDecodeView = buildExports.BufferSourceConverter.toUint8Array(valueBeforeDecode);
      }
      toJSON() {
          return {
              blockName: this.constructor.NAME,
              blockLength: this.blockLength,
              error: this.error,
              warnings: this.warnings,
              valueBeforeDecode: buildExports.Convert.ToHex(this.valueBeforeDecodeView),
          };
      }
  }
  LocalBaseBlock.NAME = "baseBlock";

  class ValueBlock extends LocalBaseBlock {
      fromBER(_inputBuffer, _inputOffset, _inputLength) {
          throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
      }
      toBER(_sizeOnly, _writer) {
          throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
      }
  }
  ValueBlock.NAME = "valueBlock";

  class LocalIdentificationBlock extends HexBlock(LocalBaseBlock) {
      constructor({ idBlock = {} } = {}) {
          var _a, _b, _c, _d;
          super();
          if (idBlock) {
              this.isHexOnly = (_a = idBlock.isHexOnly) !== null && _a !== void 0 ? _a : false;
              this.valueHexView = idBlock.valueHex
                  ? buildExports.BufferSourceConverter.toUint8Array(idBlock.valueHex)
                  : EMPTY_VIEW;
              this.tagClass = (_b = idBlock.tagClass) !== null && _b !== void 0 ? _b : -1;
              this.tagNumber = (_c = idBlock.tagNumber) !== null && _c !== void 0 ? _c : -1;
              this.isConstructed = (_d = idBlock.isConstructed) !== null && _d !== void 0 ? _d : false;
          }
          else {
              this.tagClass = -1;
              this.tagNumber = -1;
              this.isConstructed = false;
          }
      }
      toBER(sizeOnly = false) {
          let firstOctet = 0;
          switch (this.tagClass) {
              case 1:
                  firstOctet |= 0x00;
                  break;
              case 2:
                  firstOctet |= 0x40;
                  break;
              case 3:
                  firstOctet |= 0x80;
                  break;
              case 4:
                  firstOctet |= 0xC0;
                  break;
              default:
                  this.error = "Unknown tag class";
                  return EMPTY_BUFFER;
          }
          if (this.isConstructed)
              firstOctet |= 0x20;
          if (this.tagNumber < 31 && !this.isHexOnly) {
              const retView = new Uint8Array(1);
              if (!sizeOnly) {
                  let number = this.tagNumber;
                  number &= 0x1F;
                  firstOctet |= number;
                  retView[0] = firstOctet;
              }
              return retView.buffer;
          }
          if (!this.isHexOnly) {
              const encodedBuf = utilToBase(this.tagNumber, 7);
              const encodedView = new Uint8Array(encodedBuf);
              const size = encodedBuf.byteLength;
              const retView = new Uint8Array(size + 1);
              retView[0] = (firstOctet | 0x1F);
              if (!sizeOnly) {
                  for (let i = 0; i < (size - 1); i++)
                      retView[i + 1] = encodedView[i] | 0x80;
                  retView[size] = encodedView[size - 1];
              }
              return retView.buffer;
          }
          const retView = new Uint8Array(this.valueHexView.byteLength + 1);
          retView[0] = (firstOctet | 0x1F);
          if (!sizeOnly) {
              const curView = this.valueHexView;
              for (let i = 0; i < (curView.length - 1); i++)
                  retView[i + 1] = curView[i] | 0x80;
              retView[this.valueHexView.byteLength] = curView[curView.length - 1];
          }
          return retView.buffer;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
          const inputView = buildExports.BufferSourceConverter.toUint8Array(inputBuffer);
          if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
              return -1;
          }
          const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
          if (intBuffer.length === 0) {
              this.error = "Zero buffer length";
              return -1;
          }
          const tagClassMask = intBuffer[0] & 0xC0;
          switch (tagClassMask) {
              case 0x00:
                  this.tagClass = (1);
                  break;
              case 0x40:
                  this.tagClass = (2);
                  break;
              case 0x80:
                  this.tagClass = (3);
                  break;
              case 0xC0:
                  this.tagClass = (4);
                  break;
              default:
                  this.error = "Unknown tag class";
                  return -1;
          }
          this.isConstructed = (intBuffer[0] & 0x20) === 0x20;
          this.isHexOnly = false;
          const tagNumberMask = intBuffer[0] & 0x1F;
          if (tagNumberMask !== 0x1F) {
              this.tagNumber = (tagNumberMask);
              this.blockLength = 1;
          }
          else {
              let count = 1;
              let intTagNumberBuffer = this.valueHexView = new Uint8Array(255);
              let tagNumberBufferMaxLength = 255;
              while (intBuffer[count] & 0x80) {
                  intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F;
                  count++;
                  if (count >= intBuffer.length) {
                      this.error = "End of input reached before message was fully decoded";
                      return -1;
                  }
                  if (count === tagNumberBufferMaxLength) {
                      tagNumberBufferMaxLength += 255;
                      const tempBufferView = new Uint8Array(tagNumberBufferMaxLength);
                      for (let i = 0; i < intTagNumberBuffer.length; i++)
                          tempBufferView[i] = intTagNumberBuffer[i];
                      intTagNumberBuffer = this.valueHexView = new Uint8Array(tagNumberBufferMaxLength);
                  }
              }
              this.blockLength = (count + 1);
              intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F;
              const tempBufferView = new Uint8Array(count);
              for (let i = 0; i < count; i++)
                  tempBufferView[i] = intTagNumberBuffer[i];
              intTagNumberBuffer = this.valueHexView = new Uint8Array(count);
              intTagNumberBuffer.set(tempBufferView);
              if (this.blockLength <= 9)
                  this.tagNumber = utilFromBase(intTagNumberBuffer, 7);
              else {
                  this.isHexOnly = true;
                  this.warnings.push("Tag too long, represented as hex-coded");
              }
          }
          if (((this.tagClass === 1))
              && (this.isConstructed)) {
              switch (this.tagNumber) {
                  case 1:
                  case 2:
                  case 5:
                  case 6:
                  case 9:
                  case 13:
                  case 14:
                  case 23:
                  case 24:
                  case 31:
                  case 32:
                  case 33:
                  case 34:
                      this.error = "Constructed encoding used for primitive type";
                      return -1;
              }
          }
          return (inputOffset + this.blockLength);
      }
      toJSON() {
          return {
              ...super.toJSON(),
              tagClass: this.tagClass,
              tagNumber: this.tagNumber,
              isConstructed: this.isConstructed,
          };
      }
  }
  LocalIdentificationBlock.NAME = "identificationBlock";

  class LocalLengthBlock extends LocalBaseBlock {
      constructor({ lenBlock = {} } = {}) {
          var _a, _b, _c;
          super();
          this.isIndefiniteForm = (_a = lenBlock.isIndefiniteForm) !== null && _a !== void 0 ? _a : false;
          this.longFormUsed = (_b = lenBlock.longFormUsed) !== null && _b !== void 0 ? _b : false;
          this.length = (_c = lenBlock.length) !== null && _c !== void 0 ? _c : 0;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
          const view = buildExports.BufferSourceConverter.toUint8Array(inputBuffer);
          if (!checkBufferParams(this, view, inputOffset, inputLength)) {
              return -1;
          }
          const intBuffer = view.subarray(inputOffset, inputOffset + inputLength);
          if (intBuffer.length === 0) {
              this.error = "Zero buffer length";
              return -1;
          }
          if (intBuffer[0] === 0xFF) {
              this.error = "Length block 0xFF is reserved by standard";
              return -1;
          }
          this.isIndefiniteForm = intBuffer[0] === 0x80;
          if (this.isIndefiniteForm) {
              this.blockLength = 1;
              return (inputOffset + this.blockLength);
          }
          this.longFormUsed = !!(intBuffer[0] & 0x80);
          if (this.longFormUsed === false) {
              this.length = (intBuffer[0]);
              this.blockLength = 1;
              return (inputOffset + this.blockLength);
          }
          const count = intBuffer[0] & 0x7F;
          if (count > 8) {
              this.error = "Too big integer";
              return -1;
          }
          if ((count + 1) > intBuffer.length) {
              this.error = "End of input reached before message was fully decoded";
              return -1;
          }
          const lenOffset = inputOffset + 1;
          const lengthBufferView = view.subarray(lenOffset, lenOffset + count);
          if (lengthBufferView[count - 1] === 0x00)
              this.warnings.push("Needlessly long encoded length");
          this.length = utilFromBase(lengthBufferView, 8);
          if (this.longFormUsed && (this.length <= 127))
              this.warnings.push("Unnecessary usage of long length form");
          this.blockLength = count + 1;
          return (inputOffset + this.blockLength);
      }
      toBER(sizeOnly = false) {
          let retBuf;
          let retView;
          if (this.length > 127)
              this.longFormUsed = true;
          if (this.isIndefiniteForm) {
              retBuf = new ArrayBuffer(1);
              if (sizeOnly === false) {
                  retView = new Uint8Array(retBuf);
                  retView[0] = 0x80;
              }
              return retBuf;
          }
          if (this.longFormUsed) {
              const encodedBuf = utilToBase(this.length, 8);
              if (encodedBuf.byteLength > 127) {
                  this.error = "Too big length";
                  return (EMPTY_BUFFER);
              }
              retBuf = new ArrayBuffer(encodedBuf.byteLength + 1);
              if (sizeOnly)
                  return retBuf;
              const encodedView = new Uint8Array(encodedBuf);
              retView = new Uint8Array(retBuf);
              retView[0] = encodedBuf.byteLength | 0x80;
              for (let i = 0; i < encodedBuf.byteLength; i++)
                  retView[i + 1] = encodedView[i];
              return retBuf;
          }
          retBuf = new ArrayBuffer(1);
          if (sizeOnly === false) {
              retView = new Uint8Array(retBuf);
              retView[0] = this.length;
          }
          return retBuf;
      }
      toJSON() {
          return {
              ...super.toJSON(),
              isIndefiniteForm: this.isIndefiniteForm,
              longFormUsed: this.longFormUsed,
              length: this.length,
          };
      }
  }
  LocalLengthBlock.NAME = "lengthBlock";

  const typeStore = {};

  class BaseBlock extends LocalBaseBlock {
      constructor({ name = EMPTY_STRING, optional = false, primitiveSchema, ...parameters } = {}, valueBlockType) {
          super(parameters);
          this.name = name;
          this.optional = optional;
          if (primitiveSchema) {
              this.primitiveSchema = primitiveSchema;
          }
          this.idBlock = new LocalIdentificationBlock(parameters);
          this.lenBlock = new LocalLengthBlock(parameters);
          this.valueBlock = valueBlockType ? new valueBlockType(parameters) : new ValueBlock(parameters);
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
          const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm)
              ? inputLength
              : this.lenBlock.length);
          if (resultOffset === -1) {
              this.error = this.valueBlock.error;
              return resultOffset;
          }
          if (!this.idBlock.error.length)
              this.blockLength += this.idBlock.blockLength;
          if (!this.lenBlock.error.length)
              this.blockLength += this.lenBlock.blockLength;
          if (!this.valueBlock.error.length)
              this.blockLength += this.valueBlock.blockLength;
          return resultOffset;
      }
      toBER(sizeOnly, writer) {
          const _writer = writer || new ViewWriter();
          if (!writer) {
              prepareIndefiniteForm(this);
          }
          const idBlockBuf = this.idBlock.toBER(sizeOnly);
          _writer.write(idBlockBuf);
          if (this.lenBlock.isIndefiniteForm) {
              _writer.write(new Uint8Array([0x80]).buffer);
              this.valueBlock.toBER(sizeOnly, _writer);
              _writer.write(new ArrayBuffer(2));
          }
          else {
              const valueBlockBuf = this.valueBlock.toBER(sizeOnly);
              this.lenBlock.length = valueBlockBuf.byteLength;
              const lenBlockBuf = this.lenBlock.toBER(sizeOnly);
              _writer.write(lenBlockBuf);
              _writer.write(valueBlockBuf);
          }
          if (!writer) {
              return _writer.final();
          }
          return EMPTY_BUFFER;
      }
      toJSON() {
          const object = {
              ...super.toJSON(),
              idBlock: this.idBlock.toJSON(),
              lenBlock: this.lenBlock.toJSON(),
              valueBlock: this.valueBlock.toJSON(),
              name: this.name,
              optional: this.optional,
          };
          if (this.primitiveSchema)
              object.primitiveSchema = this.primitiveSchema.toJSON();
          return object;
      }
      toString(encoding = "ascii") {
          if (encoding === "ascii") {
              return this.onAsciiEncoding();
          }
          return buildExports.Convert.ToHex(this.toBER());
      }
      onAsciiEncoding() {
          const name = this.constructor.NAME;
          const value = buildExports.Convert.ToHex(this.valueBlock.valueBeforeDecodeView);
          return `${name} : ${value}`;
      }
      isEqual(other) {
          if (this === other) {
              return true;
          }
          if (!(other instanceof this.constructor)) {
              return false;
          }
          const thisRaw = this.toBER();
          const otherRaw = other.toBER();
          return isEqualBuffer(thisRaw, otherRaw);
      }
  }
  BaseBlock.NAME = "BaseBlock";
  function prepareIndefiniteForm(baseBlock) {
      var _a;
      if (baseBlock instanceof typeStore.Constructed) {
          for (const value of baseBlock.valueBlock.value) {
              if (prepareIndefiniteForm(value)) {
                  baseBlock.lenBlock.isIndefiniteForm = true;
              }
          }
      }
      return !!((_a = baseBlock.lenBlock) === null || _a === void 0 ? void 0 : _a.isIndefiniteForm);
  }

  class BaseStringBlock extends BaseBlock {
      getValue() {
          return this.valueBlock.value;
      }
      setValue(value) {
          this.valueBlock.value = value;
      }
      constructor({ value = EMPTY_STRING, ...parameters } = {}, stringValueBlockType) {
          super(parameters, stringValueBlockType);
          if (value) {
              this.fromString(value);
          }
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
          const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm)
              ? inputLength
              : this.lenBlock.length);
          if (resultOffset === -1) {
              this.error = this.valueBlock.error;
              return resultOffset;
          }
          this.fromBuffer(this.valueBlock.valueHexView);
          if (!this.idBlock.error.length)
              this.blockLength += this.idBlock.blockLength;
          if (!this.lenBlock.error.length)
              this.blockLength += this.lenBlock.blockLength;
          if (!this.valueBlock.error.length)
              this.blockLength += this.valueBlock.blockLength;
          return resultOffset;
      }
      onAsciiEncoding() {
          return `${this.constructor.NAME} : '${this.valueBlock.value}'`;
      }
  }
  BaseStringBlock.NAME = "BaseStringBlock";

  class LocalPrimitiveValueBlock extends HexBlock(ValueBlock) {
      constructor({ isHexOnly = true, ...parameters } = {}) {
          super(parameters);
          this.isHexOnly = isHexOnly;
      }
  }
  LocalPrimitiveValueBlock.NAME = "PrimitiveValueBlock";

  var _a$w;
  class Primitive extends BaseBlock {
      constructor(parameters = {}) {
          super(parameters, LocalPrimitiveValueBlock);
          this.idBlock.isConstructed = false;
      }
  }
  _a$w = Primitive;
  (() => {
      typeStore.Primitive = _a$w;
  })();
  Primitive.NAME = "PRIMITIVE";

  function localChangeType(inputObject, newType) {
      if (inputObject instanceof newType) {
          return inputObject;
      }
      const newObject = new newType();
      newObject.idBlock = inputObject.idBlock;
      newObject.lenBlock = inputObject.lenBlock;
      newObject.warnings = inputObject.warnings;
      newObject.valueBeforeDecodeView = inputObject.valueBeforeDecodeView;
      return newObject;
  }
  function localFromBER(inputBuffer, inputOffset = 0, inputLength = inputBuffer.length) {
      const incomingOffset = inputOffset;
      let returnObject = new BaseBlock({}, ValueBlock);
      const baseBlock = new LocalBaseBlock();
      if (!checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength)) {
          returnObject.error = baseBlock.error;
          return {
              offset: -1,
              result: returnObject,
          };
      }
      const intBuffer = inputBuffer.subarray(inputOffset, inputOffset + inputLength);
      if (!intBuffer.length) {
          returnObject.error = "Zero buffer length";
          return {
              offset: -1,
              result: returnObject,
          };
      }
      let resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);
      if (returnObject.idBlock.warnings.length) {
          returnObject.warnings.concat(returnObject.idBlock.warnings);
      }
      if (resultOffset === -1) {
          returnObject.error = returnObject.idBlock.error;
          return {
              offset: -1,
              result: returnObject,
          };
      }
      inputOffset = resultOffset;
      inputLength -= returnObject.idBlock.blockLength;
      resultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);
      if (returnObject.lenBlock.warnings.length) {
          returnObject.warnings.concat(returnObject.lenBlock.warnings);
      }
      if (resultOffset === -1) {
          returnObject.error = returnObject.lenBlock.error;
          return {
              offset: -1,
              result: returnObject,
          };
      }
      inputOffset = resultOffset;
      inputLength -= returnObject.lenBlock.blockLength;
      if (!returnObject.idBlock.isConstructed
          && returnObject.lenBlock.isIndefiniteForm) {
          returnObject.error = "Indefinite length form used for primitive encoding form";
          return {
              offset: -1,
              result: returnObject,
          };
      }
      let newASN1Type = BaseBlock;
      switch (returnObject.idBlock.tagClass) {
          case 1:
              if ((returnObject.idBlock.tagNumber >= 37)
                  && (returnObject.idBlock.isHexOnly === false)) {
                  returnObject.error = "UNIVERSAL 37 and upper tags are reserved by ASN.1 standard";
                  return {
                      offset: -1,
                      result: returnObject,
                  };
              }
              switch (returnObject.idBlock.tagNumber) {
                  case 0:
                      if ((returnObject.idBlock.isConstructed)
                          && (returnObject.lenBlock.length > 0)) {
                          returnObject.error = "Type [UNIVERSAL 0] is reserved";
                          return {
                              offset: -1,
                              result: returnObject,
                          };
                      }
                      newASN1Type = typeStore.EndOfContent;
                      break;
                  case 1:
                      newASN1Type = typeStore.Boolean;
                      break;
                  case 2:
                      newASN1Type = typeStore.Integer;
                      break;
                  case 3:
                      newASN1Type = typeStore.BitString;
                      break;
                  case 4:
                      newASN1Type = typeStore.OctetString;
                      break;
                  case 5:
                      newASN1Type = typeStore.Null;
                      break;
                  case 6:
                      newASN1Type = typeStore.ObjectIdentifier;
                      break;
                  case 10:
                      newASN1Type = typeStore.Enumerated;
                      break;
                  case 12:
                      newASN1Type = typeStore.Utf8String;
                      break;
                  case 13:
                      newASN1Type = typeStore.RelativeObjectIdentifier;
                      break;
                  case 14:
                      newASN1Type = typeStore.TIME;
                      break;
                  case 15:
                      returnObject.error = "[UNIVERSAL 15] is reserved by ASN.1 standard";
                      return {
                          offset: -1,
                          result: returnObject,
                      };
                  case 16:
                      newASN1Type = typeStore.Sequence;
                      break;
                  case 17:
                      newASN1Type = typeStore.Set;
                      break;
                  case 18:
                      newASN1Type = typeStore.NumericString;
                      break;
                  case 19:
                      newASN1Type = typeStore.PrintableString;
                      break;
                  case 20:
                      newASN1Type = typeStore.TeletexString;
                      break;
                  case 21:
                      newASN1Type = typeStore.VideotexString;
                      break;
                  case 22:
                      newASN1Type = typeStore.IA5String;
                      break;
                  case 23:
                      newASN1Type = typeStore.UTCTime;
                      break;
                  case 24:
                      newASN1Type = typeStore.GeneralizedTime;
                      break;
                  case 25:
                      newASN1Type = typeStore.GraphicString;
                      break;
                  case 26:
                      newASN1Type = typeStore.VisibleString;
                      break;
                  case 27:
                      newASN1Type = typeStore.GeneralString;
                      break;
                  case 28:
                      newASN1Type = typeStore.UniversalString;
                      break;
                  case 29:
                      newASN1Type = typeStore.CharacterString;
                      break;
                  case 30:
                      newASN1Type = typeStore.BmpString;
                      break;
                  case 31:
                      newASN1Type = typeStore.DATE;
                      break;
                  case 32:
                      newASN1Type = typeStore.TimeOfDay;
                      break;
                  case 33:
                      newASN1Type = typeStore.DateTime;
                      break;
                  case 34:
                      newASN1Type = typeStore.Duration;
                      break;
                  default: {
                      const newObject = returnObject.idBlock.isConstructed
                          ? new typeStore.Constructed()
                          : new typeStore.Primitive();
                      newObject.idBlock = returnObject.idBlock;
                      newObject.lenBlock = returnObject.lenBlock;
                      newObject.warnings = returnObject.warnings;
                      returnObject = newObject;
                  }
              }
              break;
          case 2:
          case 3:
          case 4:
          default: {
              newASN1Type = returnObject.idBlock.isConstructed
                  ? typeStore.Constructed
                  : typeStore.Primitive;
          }
      }
      returnObject = localChangeType(returnObject, newASN1Type);
      resultOffset = returnObject.fromBER(inputBuffer, inputOffset, returnObject.lenBlock.isIndefiniteForm ? inputLength : returnObject.lenBlock.length);
      returnObject.valueBeforeDecodeView = inputBuffer.subarray(incomingOffset, incomingOffset + returnObject.blockLength);
      return {
          offset: resultOffset,
          result: returnObject,
      };
  }
  function fromBER(inputBuffer) {
      if (!inputBuffer.byteLength) {
          const result = new BaseBlock({}, ValueBlock);
          result.error = "Input buffer has zero length";
          return {
              offset: -1,
              result,
          };
      }
      return localFromBER(buildExports.BufferSourceConverter.toUint8Array(inputBuffer).slice(), 0, inputBuffer.byteLength);
  }

  function checkLen(indefiniteLength, length) {
      if (indefiniteLength) {
          return 1;
      }
      return length;
  }
  class LocalConstructedValueBlock extends ValueBlock {
      constructor({ value = [], isIndefiniteForm = false, ...parameters } = {}) {
          super(parameters);
          this.value = value;
          this.isIndefiniteForm = isIndefiniteForm;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
          const view = buildExports.BufferSourceConverter.toUint8Array(inputBuffer);
          if (!checkBufferParams(this, view, inputOffset, inputLength)) {
              return -1;
          }
          this.valueBeforeDecodeView = view.subarray(inputOffset, inputOffset + inputLength);
          if (this.valueBeforeDecodeView.length === 0) {
              this.warnings.push("Zero buffer length");
              return inputOffset;
          }
          let currentOffset = inputOffset;
          while (checkLen(this.isIndefiniteForm, inputLength) > 0) {
              const returnObject = localFromBER(view, currentOffset, inputLength);
              if (returnObject.offset === -1) {
                  this.error = returnObject.result.error;
                  this.warnings.concat(returnObject.result.warnings);
                  return -1;
              }
              currentOffset = returnObject.offset;
              this.blockLength += returnObject.result.blockLength;
              inputLength -= returnObject.result.blockLength;
              this.value.push(returnObject.result);
              if (this.isIndefiniteForm && returnObject.result.constructor.NAME === END_OF_CONTENT_NAME) {
                  break;
              }
          }
          if (this.isIndefiniteForm) {
              if (this.value[this.value.length - 1].constructor.NAME === END_OF_CONTENT_NAME) {
                  this.value.pop();
              }
              else {
                  this.warnings.push("No EndOfContent block encoded");
              }
          }
          return currentOffset;
      }
      toBER(sizeOnly, writer) {
          const _writer = writer || new ViewWriter();
          for (let i = 0; i < this.value.length; i++) {
              this.value[i].toBER(sizeOnly, _writer);
          }
          if (!writer) {
              return _writer.final();
          }
          return EMPTY_BUFFER;
      }
      toJSON() {
          const object = {
              ...super.toJSON(),
              isIndefiniteForm: this.isIndefiniteForm,
              value: [],
          };
          for (const value of this.value) {
              object.value.push(value.toJSON());
          }
          return object;
      }
  }
  LocalConstructedValueBlock.NAME = "ConstructedValueBlock";

  var _a$v;
  class Constructed extends BaseBlock {
      constructor(parameters = {}) {
          super(parameters, LocalConstructedValueBlock);
          this.idBlock.isConstructed = true;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
          this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
          const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm) ? inputLength : this.lenBlock.length);
          if (resultOffset === -1) {
              this.error = this.valueBlock.error;
              return resultOffset;
          }
          if (!this.idBlock.error.length)
              this.blockLength += this.idBlock.blockLength;
          if (!this.lenBlock.error.length)
              this.blockLength += this.lenBlock.blockLength;
          if (!this.valueBlock.error.length)
              this.blockLength += this.valueBlock.blockLength;
          return resultOffset;
      }
      onAsciiEncoding() {
          const values = [];
          for (const value of this.valueBlock.value) {
              values.push(value.toString("ascii").split("\n").map((o) => `  ${o}`).join("\n"));
          }
          const blockName = this.idBlock.tagClass === 3
              ? `[${this.idBlock.tagNumber}]`
              : this.constructor.NAME;
          return values.length
              ? `${blockName} :\n${values.join("\n")}`
              : `${blockName} :`;
      }
  }
  _a$v = Constructed;
  (() => {
      typeStore.Constructed = _a$v;
  })();
  Constructed.NAME = "CONSTRUCTED";

  class LocalEndOfContentValueBlock extends ValueBlock {
      fromBER(inputBuffer, inputOffset, _inputLength) {
          return inputOffset;
      }
      toBER(_sizeOnly) {
          return EMPTY_BUFFER;
      }
  }
  LocalEndOfContentValueBlock.override = "EndOfContentValueBlock";

  var _a$u;
  class EndOfContent extends BaseBlock {
      constructor(parameters = {}) {
          super(parameters, LocalEndOfContentValueBlock);
          this.idBlock.tagClass = 1;
          this.idBlock.tagNumber = 0;
      }
  }
  _a$u = EndOfContent;
  (() => {
      typeStore.EndOfContent = _a$u;
  })();
  EndOfContent.NAME = END_OF_CONTENT_NAME;

  var _a$t;
  class Null extends BaseBlock {
      constructor(parameters = {}) {
          super(parameters, ValueBlock);
          this.idBlock.tagClass = 1;
          this.idBlock.tagNumber = 5;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
          if (this.lenBlock.length > 0)
              this.warnings.push("Non-zero length of value block for Null type");
          if (!this.idBlock.error.length)
              this.blockLength += this.idBlock.blockLength;
          if (!this.lenBlock.error.length)
              this.blockLength += this.lenBlock.blockLength;
          this.blockLength += inputLength;
          if ((inputOffset + inputLength) > inputBuffer.byteLength) {
              this.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
              return -1;
          }
          return (inputOffset + inputLength);
      }
      toBER(sizeOnly, writer) {
          const retBuf = new ArrayBuffer(2);
          if (!sizeOnly) {
              const retView = new Uint8Array(retBuf);
              retView[0] = 0x05;
              retView[1] = 0x00;
          }
          if (writer) {
              writer.write(retBuf);
          }
          return retBuf;
      }
      onAsciiEncoding() {
          return `${this.constructor.NAME}`;
      }
  }
  _a$t = Null;
  (() => {
      typeStore.Null = _a$t;
  })();
  Null.NAME = "NULL";

  class LocalBooleanValueBlock extends HexBlock(ValueBlock) {
      get value() {
          for (const octet of this.valueHexView) {
              if (octet > 0) {
                  return true;
              }
          }
          return false;
      }
      set value(value) {
          this.valueHexView[0] = value ? 0xFF : 0x00;
      }
      constructor({ value, ...parameters } = {}) {
          super(parameters);
          if (parameters.valueHex) {
              this.valueHexView = buildExports.BufferSourceConverter.toUint8Array(parameters.valueHex);
          }
          else {
              this.valueHexView = new Uint8Array(1);
          }
          if (value) {
              this.value = value;
          }
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
          const inputView = buildExports.BufferSourceConverter.toUint8Array(inputBuffer);
          if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
              return -1;
          }
          this.valueHexView = inputView.subarray(inputOffset, inputOffset + inputLength);
          if (inputLength > 1)
              this.warnings.push("Boolean value encoded in more then 1 octet");
          this.isHexOnly = true;
          utilDecodeTC.call(this);
          this.blockLength = inputLength;
          return (inputOffset + inputLength);
      }
      toBER() {
          return this.valueHexView.slice();
      }
      toJSON() {
          return {
              ...super.toJSON(),
              value: this.value,
          };
      }
  }
  LocalBooleanValueBlock.NAME = "BooleanValueBlock";

  var _a$s;
  let Boolean$1 = class Boolean extends BaseBlock {
      getValue() {
          return this.valueBlock.value;
      }
      setValue(value) {
          this.valueBlock.value = value;
      }
      constructor(parameters = {}) {
          super(parameters, LocalBooleanValueBlock);
          this.idBlock.tagClass = 1;
          this.idBlock.tagNumber = 1;
      }
      onAsciiEncoding() {
          return `${this.constructor.NAME} : ${this.getValue}`;
      }
  };
  _a$s = Boolean$1;
  (() => {
      typeStore.Boolean = _a$s;
  })();
  Boolean$1.NAME = "BOOLEAN";

  class LocalOctetStringValueBlock extends HexBlock(LocalConstructedValueBlock) {
      constructor({ isConstructed = false, ...parameters } = {}) {
          super(parameters);
          this.isConstructed = isConstructed;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
          let resultOffset = 0;
          if (this.isConstructed) {
              this.isHexOnly = false;
              resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
              if (resultOffset === -1)
                  return resultOffset;
              for (let i = 0; i < this.value.length; i++) {
                  const currentBlockName = this.value[i].constructor.NAME;
                  if (currentBlockName === END_OF_CONTENT_NAME) {
                      if (this.isIndefiniteForm)
                          break;
                      else {
                          this.error = "EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only";
                          return -1;
                      }
                  }
                  if (currentBlockName !== OCTET_STRING_NAME) {
                      this.error = "OCTET STRING may consists of OCTET STRINGs only";
                      return -1;
                  }
              }
          }
          else {
              this.isHexOnly = true;
              resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
              this.blockLength = inputLength;
          }
          return resultOffset;
      }
      toBER(sizeOnly, writer) {
          if (this.isConstructed)
              return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);
          return sizeOnly
              ? new ArrayBuffer(this.valueHexView.byteLength)
              : this.valueHexView.slice().buffer;
      }
      toJSON() {
          return {
              ...super.toJSON(),
              isConstructed: this.isConstructed,
          };
      }
  }
  LocalOctetStringValueBlock.NAME = "OctetStringValueBlock";

  var _a$r;
  class OctetString extends BaseBlock {
      constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}) {
          var _b, _c;
          (_b = parameters.isConstructed) !== null && _b !== void 0 ? _b : (parameters.isConstructed = !!((_c = parameters.value) === null || _c === void 0 ? void 0 : _c.length));
          super({
              idBlock: {
                  isConstructed: parameters.isConstructed,
                  ...idBlock,
              },
              lenBlock: {
                  ...lenBlock,
                  isIndefiniteForm: !!parameters.isIndefiniteForm,
              },
              ...parameters,
          }, LocalOctetStringValueBlock);
          this.idBlock.tagClass = 1;
          this.idBlock.tagNumber = 4;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
          this.valueBlock.isConstructed = this.idBlock.isConstructed;
          this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
          if (inputLength === 0) {
              if (this.idBlock.error.length === 0)
                  this.blockLength += this.idBlock.blockLength;
              if (this.lenBlock.error.length === 0)
                  this.blockLength += this.lenBlock.blockLength;
              return inputOffset;
          }
          if (!this.valueBlock.isConstructed) {
              const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;
              const buf = view.subarray(inputOffset, inputOffset + inputLength);
              try {
                  if (buf.byteLength) {
                      const asn = localFromBER(buf, 0, buf.byteLength);
                      if (asn.offset !== -1 && asn.offset === inputLength) {
                          this.valueBlock.value = [asn.result];
                      }
                  }
              }
              catch {
              }
          }
          return super.fromBER(inputBuffer, inputOffset, inputLength);
      }
      onAsciiEncoding() {
          if (this.valueBlock.isConstructed || (this.valueBlock.value && this.valueBlock.value.length)) {
              return Constructed.prototype.onAsciiEncoding.call(this);
          }
          const name = this.constructor.NAME;
          const value = buildExports.Convert.ToHex(this.valueBlock.valueHexView);
          return `${name} : ${value}`;
      }
      getValue() {
          if (!this.idBlock.isConstructed) {
              return this.valueBlock.valueHexView.slice().buffer;
          }
          const array = [];
          for (const content of this.valueBlock.value) {
              if (content instanceof _a$r) {
                  array.push(content.valueBlock.valueHexView);
              }
          }
          return buildExports.BufferSourceConverter.concat(array);
      }
  }
  _a$r = OctetString;
  (() => {
      typeStore.OctetString = _a$r;
  })();
  OctetString.NAME = OCTET_STRING_NAME;

  class LocalBitStringValueBlock extends HexBlock(LocalConstructedValueBlock) {
      constructor({ unusedBits = 0, isConstructed = false, ...parameters } = {}) {
          super(parameters);
          this.unusedBits = unusedBits;
          this.isConstructed = isConstructed;
          this.blockLength = this.valueHexView.byteLength;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
          if (!inputLength) {
              return inputOffset;
          }
          let resultOffset = -1;
          if (this.isConstructed) {
              resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
              if (resultOffset === -1)
                  return resultOffset;
              for (const value of this.value) {
                  const currentBlockName = value.constructor.NAME;
                  if (currentBlockName === END_OF_CONTENT_NAME) {
                      if (this.isIndefiniteForm)
                          break;
                      else {
                          this.error = "EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only";
                          return -1;
                      }
                  }
                  if (currentBlockName !== BIT_STRING_NAME) {
                      this.error = "BIT STRING may consists of BIT STRINGs only";
                      return -1;
                  }
                  const valueBlock = value.valueBlock;
                  if ((this.unusedBits > 0) && (valueBlock.unusedBits > 0)) {
                      this.error = "Using of \"unused bits\" inside constructive BIT STRING allowed for least one only";
                      return -1;
                  }
                  this.unusedBits = valueBlock.unusedBits;
              }
              return resultOffset;
          }
          const inputView = buildExports.BufferSourceConverter.toUint8Array(inputBuffer);
          if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
              return -1;
          }
          const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
          this.unusedBits = intBuffer[0];
          if (this.unusedBits > 7) {
              this.error = "Unused bits for BitString must be in range 0-7";
              return -1;
          }
          if (!this.unusedBits) {
              const buf = intBuffer.subarray(1);
              try {
                  if (buf.byteLength) {
                      const asn = localFromBER(buf, 0, buf.byteLength);
                      if (asn.offset !== -1 && asn.offset === (inputLength - 1)) {
                          this.value = [asn.result];
                      }
                  }
              }
              catch {
              }
          }
          this.valueHexView = intBuffer.subarray(1);
          this.blockLength = intBuffer.length;
          return (inputOffset + inputLength);
      }
      toBER(sizeOnly, writer) {
          if (this.isConstructed) {
              return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);
          }
          if (sizeOnly) {
              return new ArrayBuffer(this.valueHexView.byteLength + 1);
          }
          if (!this.valueHexView.byteLength) {
              return EMPTY_BUFFER;
          }
          const retView = new Uint8Array(this.valueHexView.length + 1);
          retView[0] = this.unusedBits;
          retView.set(this.valueHexView, 1);
          return retView.buffer;
      }
      toJSON() {
          return {
              ...super.toJSON(),
              unusedBits: this.unusedBits,
              isConstructed: this.isConstructed,
          };
      }
  }
  LocalBitStringValueBlock.NAME = "BitStringValueBlock";

  var _a$q;
  class BitString extends BaseBlock {
      constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}) {
          var _b, _c;
          (_b = parameters.isConstructed) !== null && _b !== void 0 ? _b : (parameters.isConstructed = !!((_c = parameters.value) === null || _c === void 0 ? void 0 : _c.length));
          super({
              idBlock: {
                  isConstructed: parameters.isConstructed,
                  ...idBlock,
              },
              lenBlock: {
                  ...lenBlock,
                  isIndefiniteForm: !!parameters.isIndefiniteForm,
              },
              ...parameters,
          }, LocalBitStringValueBlock);
          this.idBlock.tagClass = 1;
          this.idBlock.tagNumber = 3;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
          this.valueBlock.isConstructed = this.idBlock.isConstructed;
          this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
          return super.fromBER(inputBuffer, inputOffset, inputLength);
      }
      onAsciiEncoding() {
          if (this.valueBlock.isConstructed || (this.valueBlock.value && this.valueBlock.value.length)) {
              return Constructed.prototype.onAsciiEncoding.call(this);
          }
          else {
              const bits = [];
              const valueHex = this.valueBlock.valueHexView;
              for (const byte of valueHex) {
                  bits.push(byte.toString(2).padStart(8, "0"));
              }
              const bitsStr = bits.join("");
              const name = this.constructor.NAME;
              const value = bitsStr.substring(0, bitsStr.length - this.valueBlock.unusedBits);
              return `${name} : ${value}`;
          }
      }
  }
  _a$q = BitString;
  (() => {
      typeStore.BitString = _a$q;
  })();
  BitString.NAME = BIT_STRING_NAME;

  var _a$p;
  function viewAdd(first, second) {
      const c = new Uint8Array([0]);
      const firstView = new Uint8Array(first);
      const secondView = new Uint8Array(second);
      let firstViewCopy = firstView.slice(0);
      const firstViewCopyLength = firstViewCopy.length - 1;
      const secondViewCopy = secondView.slice(0);
      const secondViewCopyLength = secondViewCopy.length - 1;
      let value = 0;
      const max = (secondViewCopyLength < firstViewCopyLength) ? firstViewCopyLength : secondViewCopyLength;
      let counter = 0;
      for (let i = max; i >= 0; i--, counter++) {
          switch (true) {
              case (counter < secondViewCopy.length):
                  value = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c[0];
                  break;
              default:
                  value = firstViewCopy[firstViewCopyLength - counter] + c[0];
          }
          c[0] = value / 10;
          switch (true) {
              case (counter >= firstViewCopy.length):
                  firstViewCopy = utilConcatView(new Uint8Array([value % 10]), firstViewCopy);
                  break;
              default:
                  firstViewCopy[firstViewCopyLength - counter] = value % 10;
          }
      }
      if (c[0] > 0)
          firstViewCopy = utilConcatView(c, firstViewCopy);
      return firstViewCopy;
  }
  function power2(n) {
      if (n >= powers2.length) {
          for (let p = powers2.length; p <= n; p++) {
              const c = new Uint8Array([0]);
              let digits = (powers2[p - 1]).slice(0);
              for (let i = (digits.length - 1); i >= 0; i--) {
                  const newValue = new Uint8Array([(digits[i] << 1) + c[0]]);
                  c[0] = newValue[0] / 10;
                  digits[i] = newValue[0] % 10;
              }
              if (c[0] > 0)
                  digits = utilConcatView(c, digits);
              powers2.push(digits);
          }
      }
      return powers2[n];
  }
  function viewSub(first, second) {
      let b = 0;
      const firstView = new Uint8Array(first);
      const secondView = new Uint8Array(second);
      const firstViewCopy = firstView.slice(0);
      const firstViewCopyLength = firstViewCopy.length - 1;
      const secondViewCopy = secondView.slice(0);
      const secondViewCopyLength = secondViewCopy.length - 1;
      let value;
      let counter = 0;
      for (let i = secondViewCopyLength; i >= 0; i--, counter++) {
          value = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b;
          switch (true) {
              case (value < 0):
                  b = 1;
                  firstViewCopy[firstViewCopyLength - counter] = value + 10;
                  break;
              default:
                  b = 0;
                  firstViewCopy[firstViewCopyLength - counter] = value;
          }
      }
      if (b > 0) {
          for (let i = (firstViewCopyLength - secondViewCopyLength + 1); i >= 0; i--, counter++) {
              value = firstViewCopy[firstViewCopyLength - counter] - b;
              if (value < 0) {
                  b = 1;
                  firstViewCopy[firstViewCopyLength - counter] = value + 10;
              }
              else {
                  b = 0;
                  firstViewCopy[firstViewCopyLength - counter] = value;
                  break;
              }
          }
      }
      return firstViewCopy.slice();
  }
  class LocalIntegerValueBlock extends HexBlock(ValueBlock) {
      setValueHex() {
          if (this.valueHexView.length >= 4) {
              this.warnings.push("Too big Integer for decoding, hex only");
              this.isHexOnly = true;
              this._valueDec = 0;
          }
          else {
              this.isHexOnly = false;
              if (this.valueHexView.length > 0) {
                  this._valueDec = utilDecodeTC.call(this);
              }
          }
      }
      constructor({ value, ...parameters } = {}) {
          super(parameters);
          this._valueDec = 0;
          if (parameters.valueHex) {
              this.setValueHex();
          }
          if (value !== undefined) {
              this.valueDec = value;
          }
      }
      set valueDec(v) {
          this._valueDec = v;
          this.isHexOnly = false;
          this.valueHexView = new Uint8Array(utilEncodeTC(v));
      }
      get valueDec() {
          return this._valueDec;
      }
      fromDER(inputBuffer, inputOffset, inputLength, expectedLength = 0) {
          const offset = this.fromBER(inputBuffer, inputOffset, inputLength);
          if (offset === -1)
              return offset;
          const view = this.valueHexView;
          if ((view[0] === 0x00) && ((view[1] & 0x80) !== 0)) {
              this.valueHexView = view.subarray(1);
          }
          else {
              if (expectedLength !== 0) {
                  if (view.length < expectedLength) {
                      if ((expectedLength - view.length) > 1)
                          expectedLength = view.length + 1;
                      this.valueHexView = view.subarray(expectedLength - view.length);
                  }
              }
          }
          return offset;
      }
      toDER(sizeOnly = false) {
          const view = this.valueHexView;
          switch (true) {
              case ((view[0] & 0x80) !== 0):
                  {
                      const updatedView = new Uint8Array(this.valueHexView.length + 1);
                      updatedView[0] = 0x00;
                      updatedView.set(view, 1);
                      this.valueHexView = updatedView;
                  }
                  break;
              case ((view[0] === 0x00) && ((view[1] & 0x80) === 0)):
                  {
                      this.valueHexView = this.valueHexView.subarray(1);
                  }
                  break;
          }
          return this.toBER(sizeOnly);
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
          const resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
          if (resultOffset === -1) {
              return resultOffset;
          }
          this.setValueHex();
          return resultOffset;
      }
      toBER(sizeOnly) {
          return sizeOnly
              ? new ArrayBuffer(this.valueHexView.length)
              : this.valueHexView.slice().buffer;
      }
      toJSON() {
          return {
              ...super.toJSON(),
              valueDec: this.valueDec,
          };
      }
      toString() {
          const firstBit = (this.valueHexView.length * 8) - 1;
          let digits = new Uint8Array((this.valueHexView.length * 8) / 3);
          let bitNumber = 0;
          let currentByte;
          const asn1View = this.valueHexView;
          let result = "";
          let flag = false;
          for (let byteNumber = (asn1View.byteLength - 1); byteNumber >= 0; byteNumber--) {
              currentByte = asn1View[byteNumber];
              for (let i = 0; i < 8; i++) {
                  if ((currentByte & 1) === 1) {
                      switch (bitNumber) {
                          case firstBit:
                              digits = viewSub(power2(bitNumber), digits);
                              result = "-";
                              break;
                          default:
                              digits = viewAdd(digits, power2(bitNumber));
                      }
                  }
                  bitNumber++;
                  currentByte >>= 1;
              }
          }
          for (let i = 0; i < digits.length; i++) {
              if (digits[i])
                  flag = true;
              if (flag)
                  result += digitsString.charAt(digits[i]);
          }
          if (flag === false)
              result += digitsString.charAt(0);
          return result;
      }
  }
  _a$p = LocalIntegerValueBlock;
  LocalIntegerValueBlock.NAME = "IntegerValueBlock";
  (() => {
      Object.defineProperty(_a$p.prototype, "valueHex", {
          set: function (v) {
              this.valueHexView = new Uint8Array(v);
              this.setValueHex();
          },
          get: function () {
              return this.valueHexView.slice().buffer;
          },
      });
  })();

  var _a$o;
  class Integer extends BaseBlock {
      constructor(parameters = {}) {
          super(parameters, LocalIntegerValueBlock);
          this.idBlock.tagClass = 1;
          this.idBlock.tagNumber = 2;
      }
      toBigInt() {
          assertBigInt();
          return BigInt(this.valueBlock.toString());
      }
      static fromBigInt(value) {
          assertBigInt();
          const bigIntValue = BigInt(value);
          const writer = new ViewWriter();
          const hex = bigIntValue.toString(16).replace(/^-/, "");
          const view = new Uint8Array(buildExports.Convert.FromHex(hex));
          if (bigIntValue < 0) {
              const first = new Uint8Array(view.length + (view[0] & 0x80 ? 1 : 0));
              first[0] |= 0x80;
              const firstInt = BigInt(`0x${buildExports.Convert.ToHex(first)}`);
              const secondInt = firstInt + bigIntValue;
              const second = buildExports.BufferSourceConverter.toUint8Array(buildExports.Convert.FromHex(secondInt.toString(16)));
              second[0] |= 0x80;
              writer.write(second);
          }
          else {
              if (view[0] & 0x80) {
                  writer.write(new Uint8Array([0]));
              }
              writer.write(view);
          }
          const res = new _a$o({ valueHex: writer.final() });
          return res;
      }
      convertToDER() {
          const integer = new _a$o({ valueHex: this.valueBlock.valueHexView });
          integer.valueBlock.toDER();
          return integer;
      }
      convertFromDER() {
          return new _a$o({
              valueHex: this.valueBlock.valueHexView[0] === 0
                  ? this.valueBlock.valueHexView.subarray(1)
                  : this.valueBlock.valueHexView,
          });
      }
      onAsciiEncoding() {
          return `${this.constructor.NAME} : ${this.valueBlock.toString()}`;
      }
  }
  _a$o = Integer;
  (() => {
      typeStore.Integer = _a$o;
  })();
  Integer.NAME = "INTEGER";

  var _a$n;
  class Enumerated extends Integer {
      constructor(parameters = {}) {
          super(parameters);
          this.idBlock.tagClass = 1;
          this.idBlock.tagNumber = 10;
      }
  }
  _a$n = Enumerated;
  (() => {
      typeStore.Enumerated = _a$n;
  })();
  Enumerated.NAME = "ENUMERATED";

  class LocalSidValueBlock extends HexBlock(ValueBlock) {
      constructor({ valueDec = -1, isFirstSid = false, ...parameters } = {}) {
          super(parameters);
          this.valueDec = valueDec;
          this.isFirstSid = isFirstSid;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
          if (!inputLength) {
              return inputOffset;
          }
          const inputView = buildExports.BufferSourceConverter.toUint8Array(inputBuffer);
          if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
              return -1;
          }
          const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
          this.valueHexView = new Uint8Array(inputLength);
          for (let i = 0; i < inputLength; i++) {
              this.valueHexView[i] = intBuffer[i] & 0x7F;
              this.blockLength++;
              if ((intBuffer[i] & 0x80) === 0x00)
                  break;
          }
          const tempView = new Uint8Array(this.blockLength);
          for (let i = 0; i < this.blockLength; i++) {
              tempView[i] = this.valueHexView[i];
          }
          this.valueHexView = tempView;
          if ((intBuffer[this.blockLength - 1] & 0x80) !== 0x00) {
              this.error = "End of input reached before message was fully decoded";
              return -1;
          }
          if (this.valueHexView[0] === 0x00)
              this.warnings.push("Needlessly long format of SID encoding");
          if (this.blockLength <= 8)
              this.valueDec = utilFromBase(this.valueHexView, 7);
          else {
              this.isHexOnly = true;
              this.warnings.push("Too big SID for decoding, hex only");
          }
          return (inputOffset + this.blockLength);
      }
      set valueBigInt(value) {
          assertBigInt();
          let bits = BigInt(value).toString(2);
          while (bits.length % 7) {
              bits = "0" + bits;
          }
          const bytes = new Uint8Array(bits.length / 7);
          for (let i = 0; i < bytes.length; i++) {
              bytes[i] = parseInt(bits.slice(i * 7, i * 7 + 7), 2) + (i + 1 < bytes.length ? 0x80 : 0);
          }
          this.fromBER(bytes.buffer, 0, bytes.length);
      }
      toBER(sizeOnly) {
          if (this.isHexOnly) {
              if (sizeOnly)
                  return (new ArrayBuffer(this.valueHexView.byteLength));
              const curView = this.valueHexView;
              const retView = new Uint8Array(this.blockLength);
              for (let i = 0; i < (this.blockLength - 1); i++)
                  retView[i] = curView[i] | 0x80;
              retView[this.blockLength - 1] = curView[this.blockLength - 1];
              return retView.buffer;
          }
          const encodedBuf = utilToBase(this.valueDec, 7);
          if (encodedBuf.byteLength === 0) {
              this.error = "Error during encoding SID value";
              return EMPTY_BUFFER;
          }
          const retView = new Uint8Array(encodedBuf.byteLength);
          if (!sizeOnly) {
              const encodedView = new Uint8Array(encodedBuf);
              const len = encodedBuf.byteLength - 1;
              for (let i = 0; i < len; i++)
                  retView[i] = encodedView[i] | 0x80;
              retView[len] = encodedView[len];
          }
          return retView;
      }
      toString() {
          let result = "";
          if (this.isHexOnly)
              result = buildExports.Convert.ToHex(this.valueHexView);
          else {
              if (this.isFirstSid) {
                  let sidValue = this.valueDec;
                  if (this.valueDec <= 39)
                      result = "0.";
                  else {
                      if (this.valueDec <= 79) {
                          result = "1.";
                          sidValue -= 40;
                      }
                      else {
                          result = "2.";
                          sidValue -= 80;
                      }
                  }
                  result += sidValue.toString();
              }
              else
                  result = this.valueDec.toString();
          }
          return result;
      }
      toJSON() {
          return {
              ...super.toJSON(),
              valueDec: this.valueDec,
              isFirstSid: this.isFirstSid,
          };
      }
  }
  LocalSidValueBlock.NAME = "sidBlock";

  class LocalObjectIdentifierValueBlock extends ValueBlock {
      constructor({ value = EMPTY_STRING, ...parameters } = {}) {
          super(parameters);
          this.value = [];
          if (value) {
              this.fromString(value);
          }
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
          let resultOffset = inputOffset;
          while (inputLength > 0) {
              const sidBlock = new LocalSidValueBlock();
              resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
              if (resultOffset === -1) {
                  this.blockLength = 0;
                  this.error = sidBlock.error;
                  return resultOffset;
              }
              if (this.value.length === 0)
                  sidBlock.isFirstSid = true;
              this.blockLength += sidBlock.blockLength;
              inputLength -= sidBlock.blockLength;
              this.value.push(sidBlock);
          }
          return resultOffset;
      }
      toBER(sizeOnly) {
          const retBuffers = [];
          for (let i = 0; i < this.value.length; i++) {
              const valueBuf = this.value[i].toBER(sizeOnly);
              if (valueBuf.byteLength === 0) {
                  this.error = this.value[i].error;
                  return EMPTY_BUFFER;
              }
              retBuffers.push(valueBuf);
          }
          return concat$1(retBuffers);
      }
      fromString(string) {
          this.value = [];
          let pos1 = 0;
          let pos2 = 0;
          let sid = "";
          let flag = false;
          do {
              pos2 = string.indexOf(".", pos1);
              if (pos2 === -1)
                  sid = string.substring(pos1);
              else
                  sid = string.substring(pos1, pos2);
              pos1 = pos2 + 1;
              if (flag) {
                  const sidBlock = this.value[0];
                  let plus = 0;
                  switch (sidBlock.valueDec) {
                      case 0:
                          break;
                      case 1:
                          plus = 40;
                          break;
                      case 2:
                          plus = 80;
                          break;
                      default:
                          this.value = [];
                          return;
                  }
                  const parsedSID = parseInt(sid, 10);
                  if (isNaN(parsedSID))
                      return;
                  sidBlock.valueDec = parsedSID + plus;
                  flag = false;
              }
              else {
                  const sidBlock = new LocalSidValueBlock();
                  if (sid > Number.MAX_SAFE_INTEGER) {
                      assertBigInt();
                      const sidValue = BigInt(sid);
                      sidBlock.valueBigInt = sidValue;
                  }
                  else {
                      sidBlock.valueDec = parseInt(sid, 10);
                      if (isNaN(sidBlock.valueDec))
                          return;
                  }
                  if (!this.value.length) {
                      sidBlock.isFirstSid = true;
                      flag = true;
                  }
                  this.value.push(sidBlock);
              }
          } while (pos2 !== -1);
      }
      toString() {
          let result = "";
          let isHexOnly = false;
          for (let i = 0; i < this.value.length; i++) {
              isHexOnly = this.value[i].isHexOnly;
              let sidStr = this.value[i].toString();
              if (i !== 0)
                  result = `${result}.`;
              if (isHexOnly) {
                  sidStr = `{${sidStr}}`;
                  if (this.value[i].isFirstSid)
                      result = `2.{${sidStr} - 80}`;
                  else
                      result += sidStr;
              }
              else
                  result += sidStr;
          }
          return result;
      }
      toJSON() {
          const object = {
              ...super.toJSON(),
              value: this.toString(),
              sidArray: [],
          };
          for (let i = 0; i < this.value.length; i++) {
              object.sidArray.push(this.value[i].toJSON());
          }
          return object;
      }
  }
  LocalObjectIdentifierValueBlock.NAME = "ObjectIdentifierValueBlock";

  var _a$m;
  class ObjectIdentifier extends BaseBlock {
      getValue() {
          return this.valueBlock.toString();
      }
      setValue(value) {
          this.valueBlock.fromString(value);
      }
      constructor(parameters = {}) {
          super(parameters, LocalObjectIdentifierValueBlock);
          this.idBlock.tagClass = 1;
          this.idBlock.tagNumber = 6;
      }
      onAsciiEncoding() {
          return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;
      }
      toJSON() {
          return {
              ...super.toJSON(),
              value: this.getValue(),
          };
      }
  }
  _a$m = ObjectIdentifier;
  (() => {
      typeStore.ObjectIdentifier = _a$m;
  })();
  ObjectIdentifier.NAME = "OBJECT IDENTIFIER";

  class LocalRelativeSidValueBlock extends HexBlock(LocalBaseBlock) {
      constructor({ valueDec = 0, ...parameters } = {}) {
          super(parameters);
          this.valueDec = valueDec;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
          if (inputLength === 0)
              return inputOffset;
          const inputView = buildExports.BufferSourceConverter.toUint8Array(inputBuffer);
          if (!checkBufferParams(this, inputView, inputOffset, inputLength))
              return -1;
          const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
          this.valueHexView = new Uint8Array(inputLength);
          for (let i = 0; i < inputLength; i++) {
              this.valueHexView[i] = intBuffer[i] & 0x7F;
              this.blockLength++;
              if ((intBuffer[i] & 0x80) === 0x00)
                  break;
          }
          const tempView = new Uint8Array(this.blockLength);
          for (let i = 0; i < this.blockLength; i++)
              tempView[i] = this.valueHexView[i];
          this.valueHexView = tempView;
          if ((intBuffer[this.blockLength - 1] & 0x80) !== 0x00) {
              this.error = "End of input reached before message was fully decoded";
              return -1;
          }
          if (this.valueHexView[0] === 0x00)
              this.warnings.push("Needlessly long format of SID encoding");
          if (this.blockLength <= 8)
              this.valueDec = utilFromBase(this.valueHexView, 7);
          else {
              this.isHexOnly = true;
              this.warnings.push("Too big SID for decoding, hex only");
          }
          return (inputOffset + this.blockLength);
      }
      toBER(sizeOnly) {
          if (this.isHexOnly) {
              if (sizeOnly)
                  return (new ArrayBuffer(this.valueHexView.byteLength));
              const curView = this.valueHexView;
              const retView = new Uint8Array(this.blockLength);
              for (let i = 0; i < (this.blockLength - 1); i++)
                  retView[i] = curView[i] | 0x80;
              retView[this.blockLength - 1] = curView[this.blockLength - 1];
              return retView.buffer;
          }
          const encodedBuf = utilToBase(this.valueDec, 7);
          if (encodedBuf.byteLength === 0) {
              this.error = "Error during encoding SID value";
              return EMPTY_BUFFER;
          }
          const retView = new Uint8Array(encodedBuf.byteLength);
          if (!sizeOnly) {
              const encodedView = new Uint8Array(encodedBuf);
              const len = encodedBuf.byteLength - 1;
              for (let i = 0; i < len; i++)
                  retView[i] = encodedView[i] | 0x80;
              retView[len] = encodedView[len];
          }
          return retView.buffer;
      }
      toString() {
          let result = "";
          if (this.isHexOnly)
              result = buildExports.Convert.ToHex(this.valueHexView);
          else {
              result = this.valueDec.toString();
          }
          return result;
      }
      toJSON() {
          return {
              ...super.toJSON(),
              valueDec: this.valueDec,
          };
      }
  }
  LocalRelativeSidValueBlock.NAME = "relativeSidBlock";

  class LocalRelativeObjectIdentifierValueBlock extends ValueBlock {
      constructor({ value = EMPTY_STRING, ...parameters } = {}) {
          super(parameters);
          this.value = [];
          if (value) {
              this.fromString(value);
          }
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
          let resultOffset = inputOffset;
          while (inputLength > 0) {
              const sidBlock = new LocalRelativeSidValueBlock();
              resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
              if (resultOffset === -1) {
                  this.blockLength = 0;
                  this.error = sidBlock.error;
                  return resultOffset;
              }
              this.blockLength += sidBlock.blockLength;
              inputLength -= sidBlock.blockLength;
              this.value.push(sidBlock);
          }
          return resultOffset;
      }
      toBER(sizeOnly, _writer) {
          const retBuffers = [];
          for (let i = 0; i < this.value.length; i++) {
              const valueBuf = this.value[i].toBER(sizeOnly);
              if (valueBuf.byteLength === 0) {
                  this.error = this.value[i].error;
                  return EMPTY_BUFFER;
              }
              retBuffers.push(valueBuf);
          }
          return concat$1(retBuffers);
      }
      fromString(string) {
          this.value = [];
          let pos1 = 0;
          let pos2 = 0;
          let sid = "";
          do {
              pos2 = string.indexOf(".", pos1);
              if (pos2 === -1)
                  sid = string.substring(pos1);
              else
                  sid = string.substring(pos1, pos2);
              pos1 = pos2 + 1;
              const sidBlock = new LocalRelativeSidValueBlock();
              sidBlock.valueDec = parseInt(sid, 10);
              if (isNaN(sidBlock.valueDec))
                  return true;
              this.value.push(sidBlock);
          } while (pos2 !== -1);
          return true;
      }
      toString() {
          let result = "";
          let isHexOnly = false;
          for (let i = 0; i < this.value.length; i++) {
              isHexOnly = this.value[i].isHexOnly;
              let sidStr = this.value[i].toString();
              if (i !== 0)
                  result = `${result}.`;
              if (isHexOnly) {
                  sidStr = `{${sidStr}}`;
                  result += sidStr;
              }
              else
                  result += sidStr;
          }
          return result;
      }
      toJSON() {
          const object = {
              ...super.toJSON(),
              value: this.toString(),
              sidArray: [],
          };
          for (let i = 0; i < this.value.length; i++)
              object.sidArray.push(this.value[i].toJSON());
          return object;
      }
  }
  LocalRelativeObjectIdentifierValueBlock.NAME = "RelativeObjectIdentifierValueBlock";

  var _a$l;
  class RelativeObjectIdentifier extends BaseBlock {
      getValue() {
          return this.valueBlock.toString();
      }
      setValue(value) {
          this.valueBlock.fromString(value);
      }
      constructor(parameters = {}) {
          super(parameters, LocalRelativeObjectIdentifierValueBlock);
          this.idBlock.tagClass = 1;
          this.idBlock.tagNumber = 13;
      }
      onAsciiEncoding() {
          return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;
      }
      toJSON() {
          return {
              ...super.toJSON(),
              value: this.getValue(),
          };
      }
  }
  _a$l = RelativeObjectIdentifier;
  (() => {
      typeStore.RelativeObjectIdentifier = _a$l;
  })();
  RelativeObjectIdentifier.NAME = "RelativeObjectIdentifier";

  var _a$k;
  class Sequence extends Constructed {
      constructor(parameters = {}) {
          super(parameters);
          this.idBlock.tagClass = 1;
          this.idBlock.tagNumber = 16;
      }
  }
  _a$k = Sequence;
  (() => {
      typeStore.Sequence = _a$k;
  })();
  Sequence.NAME = "SEQUENCE";

  var _a$j;
  let Set$1 = class Set extends Constructed {
      constructor(parameters = {}) {
          super(parameters);
          this.idBlock.tagClass = 1;
          this.idBlock.tagNumber = 17;
      }
  };
  _a$j = Set$1;
  (() => {
      typeStore.Set = _a$j;
  })();
  Set$1.NAME = "SET";

  class LocalStringValueBlock extends HexBlock(ValueBlock) {
      constructor({ ...parameters } = {}) {
          super(parameters);
          this.isHexOnly = true;
          this.value = EMPTY_STRING;
      }
      toJSON() {
          return {
              ...super.toJSON(),
              value: this.value,
          };
      }
  }
  LocalStringValueBlock.NAME = "StringValueBlock";

  class LocalSimpleStringValueBlock extends LocalStringValueBlock {
  }
  LocalSimpleStringValueBlock.NAME = "SimpleStringValueBlock";

  class LocalSimpleStringBlock extends BaseStringBlock {
      constructor({ ...parameters } = {}) {
          super(parameters, LocalSimpleStringValueBlock);
      }
      fromBuffer(inputBuffer) {
          this.valueBlock.value = String.fromCharCode.apply(null, buildExports.BufferSourceConverter.toUint8Array(inputBuffer));
      }
      fromString(inputString) {
          const strLen = inputString.length;
          const view = this.valueBlock.valueHexView = new Uint8Array(strLen);
          for (let i = 0; i < strLen; i++)
              view[i] = inputString.charCodeAt(i);
          this.valueBlock.value = inputString;
      }
  }
  LocalSimpleStringBlock.NAME = "SIMPLE STRING";

  class LocalUtf8StringValueBlock extends LocalSimpleStringBlock {
      fromBuffer(inputBuffer) {
          this.valueBlock.valueHexView = buildExports.BufferSourceConverter.toUint8Array(inputBuffer);
          try {
              this.valueBlock.value = buildExports.Convert.ToUtf8String(inputBuffer);
          }
          catch (ex) {
              this.warnings.push(`Error during "decodeURIComponent": ${ex}, using raw string`);
              this.valueBlock.value = buildExports.Convert.ToBinary(inputBuffer);
          }
      }
      fromString(inputString) {
          this.valueBlock.valueHexView = new Uint8Array(buildExports.Convert.FromUtf8String(inputString));
          this.valueBlock.value = inputString;
      }
  }
  LocalUtf8StringValueBlock.NAME = "Utf8StringValueBlock";

  var _a$i;
  class Utf8String extends LocalUtf8StringValueBlock {
      constructor(parameters = {}) {
          super(parameters);
          this.idBlock.tagClass = 1;
          this.idBlock.tagNumber = 12;
      }
  }
  _a$i = Utf8String;
  (() => {
      typeStore.Utf8String = _a$i;
  })();
  Utf8String.NAME = "UTF8String";

  class LocalBmpStringValueBlock extends LocalSimpleStringBlock {
      fromBuffer(inputBuffer) {
          this.valueBlock.value = buildExports.Convert.ToUtf16String(inputBuffer);
          this.valueBlock.valueHexView = buildExports.BufferSourceConverter.toUint8Array(inputBuffer);
      }
      fromString(inputString) {
          this.valueBlock.value = inputString;
          this.valueBlock.valueHexView = new Uint8Array(buildExports.Convert.FromUtf16String(inputString));
      }
  }
  LocalBmpStringValueBlock.NAME = "BmpStringValueBlock";

  var _a$h;
  class BmpString extends LocalBmpStringValueBlock {
      constructor({ ...parameters } = {}) {
          super(parameters);
          this.idBlock.tagClass = 1;
          this.idBlock.tagNumber = 30;
      }
  }
  _a$h = BmpString;
  (() => {
      typeStore.BmpString = _a$h;
  })();
  BmpString.NAME = "BMPString";

  class LocalUniversalStringValueBlock extends LocalSimpleStringBlock {
      fromBuffer(inputBuffer) {
          const copyBuffer = ArrayBuffer.isView(inputBuffer) ? inputBuffer.slice().buffer : inputBuffer.slice(0);
          const valueView = new Uint8Array(copyBuffer);
          for (let i = 0; i < valueView.length; i += 4) {
              valueView[i] = valueView[i + 3];
              valueView[i + 1] = valueView[i + 2];
              valueView[i + 2] = 0x00;
              valueView[i + 3] = 0x00;
          }
          this.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));
      }
      fromString(inputString) {
          const strLength = inputString.length;
          const valueHexView = this.valueBlock.valueHexView = new Uint8Array(strLength * 4);
          for (let i = 0; i < strLength; i++) {
              const codeBuf = utilToBase(inputString.charCodeAt(i), 8);
              const codeView = new Uint8Array(codeBuf);
              if (codeView.length > 4)
                  continue;
              const dif = 4 - codeView.length;
              for (let j = (codeView.length - 1); j >= 0; j--)
                  valueHexView[i * 4 + j + dif] = codeView[j];
          }
          this.valueBlock.value = inputString;
      }
  }
  LocalUniversalStringValueBlock.NAME = "UniversalStringValueBlock";

  var _a$g;
  class UniversalString extends LocalUniversalStringValueBlock {
      constructor({ ...parameters } = {}) {
          super(parameters);
          this.idBlock.tagClass = 1;
          this.idBlock.tagNumber = 28;
      }
  }
  _a$g = UniversalString;
  (() => {
      typeStore.UniversalString = _a$g;
  })();
  UniversalString.NAME = "UniversalString";

  var _a$f;
  class NumericString extends LocalSimpleStringBlock {
      constructor(parameters = {}) {
          super(parameters);
          this.idBlock.tagClass = 1;
          this.idBlock.tagNumber = 18;
      }
  }
  _a$f = NumericString;
  (() => {
      typeStore.NumericString = _a$f;
  })();
  NumericString.NAME = "NumericString";

  var _a$e;
  class PrintableString extends LocalSimpleStringBlock {
      constructor(parameters = {}) {
          super(parameters);
          this.idBlock.tagClass = 1;
          this.idBlock.tagNumber = 19;
      }
  }
  _a$e = PrintableString;
  (() => {
      typeStore.PrintableString = _a$e;
  })();
  PrintableString.NAME = "PrintableString";

  var _a$d;
  class TeletexString extends LocalSimpleStringBlock {
      constructor(parameters = {}) {
          super(parameters);
          this.idBlock.tagClass = 1;
          this.idBlock.tagNumber = 20;
      }
  }
  _a$d = TeletexString;
  (() => {
      typeStore.TeletexString = _a$d;
  })();
  TeletexString.NAME = "TeletexString";

  var _a$c;
  class VideotexString extends LocalSimpleStringBlock {
      constructor(parameters = {}) {
          super(parameters);
          this.idBlock.tagClass = 1;
          this.idBlock.tagNumber = 21;
      }
  }
  _a$c = VideotexString;
  (() => {
      typeStore.VideotexString = _a$c;
  })();
  VideotexString.NAME = "VideotexString";

  var _a$b;
  class IA5String extends LocalSimpleStringBlock {
      constructor(parameters = {}) {
          super(parameters);
          this.idBlock.tagClass = 1;
          this.idBlock.tagNumber = 22;
      }
  }
  _a$b = IA5String;
  (() => {
      typeStore.IA5String = _a$b;
  })();
  IA5String.NAME = "IA5String";

  var _a$a;
  class GraphicString extends LocalSimpleStringBlock {
      constructor(parameters = {}) {
          super(parameters);
          this.idBlock.tagClass = 1;
          this.idBlock.tagNumber = 25;
      }
  }
  _a$a = GraphicString;
  (() => {
      typeStore.GraphicString = _a$a;
  })();
  GraphicString.NAME = "GraphicString";

  var _a$9;
  class VisibleString extends LocalSimpleStringBlock {
      constructor(parameters = {}) {
          super(parameters);
          this.idBlock.tagClass = 1;
          this.idBlock.tagNumber = 26;
      }
  }
  _a$9 = VisibleString;
  (() => {
      typeStore.VisibleString = _a$9;
  })();
  VisibleString.NAME = "VisibleString";

  var _a$8;
  class GeneralString extends LocalSimpleStringBlock {
      constructor(parameters = {}) {
          super(parameters);
          this.idBlock.tagClass = 1;
          this.idBlock.tagNumber = 27;
      }
  }
  _a$8 = GeneralString;
  (() => {
      typeStore.GeneralString = _a$8;
  })();
  GeneralString.NAME = "GeneralString";

  var _a$7;
  class CharacterString extends LocalSimpleStringBlock {
      constructor(parameters = {}) {
          super(parameters);
          this.idBlock.tagClass = 1;
          this.idBlock.tagNumber = 29;
      }
  }
  _a$7 = CharacterString;
  (() => {
      typeStore.CharacterString = _a$7;
  })();
  CharacterString.NAME = "CharacterString";

  var _a$6;
  class UTCTime extends VisibleString {
      constructor({ value, valueDate, ...parameters } = {}) {
          super(parameters);
          this.year = 0;
          this.month = 0;
          this.day = 0;
          this.hour = 0;
          this.minute = 0;
          this.second = 0;
          if (value) {
              this.fromString(value);
              this.valueBlock.valueHexView = new Uint8Array(value.length);
              for (let i = 0; i < value.length; i++)
                  this.valueBlock.valueHexView[i] = value.charCodeAt(i);
          }
          if (valueDate) {
              this.fromDate(valueDate);
              this.valueBlock.valueHexView = new Uint8Array(this.toBuffer());
          }
          this.idBlock.tagClass = 1;
          this.idBlock.tagNumber = 23;
      }
      fromBuffer(inputBuffer) {
          this.fromString(String.fromCharCode.apply(null, buildExports.BufferSourceConverter.toUint8Array(inputBuffer)));
      }
      toBuffer() {
          const str = this.toString();
          const buffer = new ArrayBuffer(str.length);
          const view = new Uint8Array(buffer);
          for (let i = 0; i < str.length; i++)
              view[i] = str.charCodeAt(i);
          return buffer;
      }
      fromDate(inputDate) {
          this.year = inputDate.getUTCFullYear();
          this.month = inputDate.getUTCMonth() + 1;
          this.day = inputDate.getUTCDate();
          this.hour = inputDate.getUTCHours();
          this.minute = inputDate.getUTCMinutes();
          this.second = inputDate.getUTCSeconds();
      }
      toDate() {
          return (new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second)));
      }
      fromString(inputString) {
          const parser = /(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/ig;
          const parserArray = parser.exec(inputString);
          if (parserArray === null) {
              this.error = "Wrong input string for conversion";
              return;
          }
          const year = parseInt(parserArray[1], 10);
          if (year >= 50)
              this.year = 1900 + year;
          else
              this.year = 2000 + year;
          this.month = parseInt(parserArray[2], 10);
          this.day = parseInt(parserArray[3], 10);
          this.hour = parseInt(parserArray[4], 10);
          this.minute = parseInt(parserArray[5], 10);
          this.second = parseInt(parserArray[6], 10);
      }
      toString(encoding = "iso") {
          if (encoding === "iso") {
              const outputArray = new Array(7);
              outputArray[0] = padNumber(((this.year < 2000) ? (this.year - 1900) : (this.year - 2000)), 2);
              outputArray[1] = padNumber(this.month, 2);
              outputArray[2] = padNumber(this.day, 2);
              outputArray[3] = padNumber(this.hour, 2);
              outputArray[4] = padNumber(this.minute, 2);
              outputArray[5] = padNumber(this.second, 2);
              outputArray[6] = "Z";
              return outputArray.join("");
          }
          return super.toString(encoding);
      }
      onAsciiEncoding() {
          return `${this.constructor.NAME} : ${this.toDate().toISOString()}`;
      }
      toJSON() {
          return {
              ...super.toJSON(),
              year: this.year,
              month: this.month,
              day: this.day,
              hour: this.hour,
              minute: this.minute,
              second: this.second,
          };
      }
  }
  _a$6 = UTCTime;
  (() => {
      typeStore.UTCTime = _a$6;
  })();
  UTCTime.NAME = "UTCTime";

  var _a$5;
  class GeneralizedTime extends UTCTime {
      constructor(parameters = {}) {
          var _b;
          super(parameters);
          (_b = this.millisecond) !== null && _b !== void 0 ? _b : (this.millisecond = 0);
          this.idBlock.tagClass = 1;
          this.idBlock.tagNumber = 24;
      }
      fromDate(inputDate) {
          super.fromDate(inputDate);
          this.millisecond = inputDate.getUTCMilliseconds();
      }
      toDate() {
          const utcDate = Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond);
          return (new Date(utcDate));
      }
      fromString(inputString) {
          let isUTC = false;
          let timeString = "";
          let dateTimeString = "";
          let fractionPart = 0;
          let parser;
          let hourDifference = 0;
          let minuteDifference = 0;
          if (inputString[inputString.length - 1] === "Z") {
              timeString = inputString.substring(0, inputString.length - 1);
              isUTC = true;
          }
          else {
              const number = new Number(inputString[inputString.length - 1]);
              if (isNaN(number.valueOf()))
                  throw new Error("Wrong input string for conversion");
              timeString = inputString;
          }
          if (isUTC) {
              if (timeString.indexOf("+") !== -1)
                  throw new Error("Wrong input string for conversion");
              if (timeString.indexOf("-") !== -1)
                  throw new Error("Wrong input string for conversion");
          }
          else {
              let multiplier = 1;
              let differencePosition = timeString.indexOf("+");
              let differenceString = "";
              if (differencePosition === -1) {
                  differencePosition = timeString.indexOf("-");
                  multiplier = -1;
              }
              if (differencePosition !== -1) {
                  differenceString = timeString.substring(differencePosition + 1);
                  timeString = timeString.substring(0, differencePosition);
                  if ((differenceString.length !== 2) && (differenceString.length !== 4))
                      throw new Error("Wrong input string for conversion");
                  let number = parseInt(differenceString.substring(0, 2), 10);
                  if (isNaN(number.valueOf()))
                      throw new Error("Wrong input string for conversion");
                  hourDifference = multiplier * number;
                  if (differenceString.length === 4) {
                      number = parseInt(differenceString.substring(2, 4), 10);
                      if (isNaN(number.valueOf()))
                          throw new Error("Wrong input string for conversion");
                      minuteDifference = multiplier * number;
                  }
              }
          }
          let fractionPointPosition = timeString.indexOf(".");
          if (fractionPointPosition === -1)
              fractionPointPosition = timeString.indexOf(",");
          if (fractionPointPosition !== -1) {
              const fractionPartCheck = new Number(`0${timeString.substring(fractionPointPosition)}`);
              if (isNaN(fractionPartCheck.valueOf()))
                  throw new Error("Wrong input string for conversion");
              fractionPart = fractionPartCheck.valueOf();
              dateTimeString = timeString.substring(0, fractionPointPosition);
          }
          else
              dateTimeString = timeString;
          switch (true) {
              case (dateTimeString.length === 8):
                  parser = /(\d{4})(\d{2})(\d{2})/ig;
                  if (fractionPointPosition !== -1)
                      throw new Error("Wrong input string for conversion");
                  break;
              case (dateTimeString.length === 10):
                  parser = /(\d{4})(\d{2})(\d{2})(\d{2})/ig;
                  if (fractionPointPosition !== -1) {
                      let fractionResult = 60 * fractionPart;
                      this.minute = Math.floor(fractionResult);
                      fractionResult = 60 * (fractionResult - this.minute);
                      this.second = Math.floor(fractionResult);
                      fractionResult = 1000 * (fractionResult - this.second);
                      this.millisecond = Math.floor(fractionResult);
                  }
                  break;
              case (dateTimeString.length === 12):
                  parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
                  if (fractionPointPosition !== -1) {
                      let fractionResult = 60 * fractionPart;
                      this.second = Math.floor(fractionResult);
                      fractionResult = 1000 * (fractionResult - this.second);
                      this.millisecond = Math.floor(fractionResult);
                  }
                  break;
              case (dateTimeString.length === 14):
                  parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
                  if (fractionPointPosition !== -1) {
                      const fractionResult = 1000 * fractionPart;
                      this.millisecond = Math.floor(fractionResult);
                  }
                  break;
              default:
                  throw new Error("Wrong input string for conversion");
          }
          const parserArray = parser.exec(dateTimeString);
          if (parserArray === null)
              throw new Error("Wrong input string for conversion");
          for (let j = 1; j < parserArray.length; j++) {
              switch (j) {
                  case 1:
                      this.year = parseInt(parserArray[j], 10);
                      break;
                  case 2:
                      this.month = parseInt(parserArray[j], 10);
                      break;
                  case 3:
                      this.day = parseInt(parserArray[j], 10);
                      break;
                  case 4:
                      this.hour = parseInt(parserArray[j], 10) + hourDifference;
                      break;
                  case 5:
                      this.minute = parseInt(parserArray[j], 10) + minuteDifference;
                      break;
                  case 6:
                      this.second = parseInt(parserArray[j], 10);
                      break;
                  default:
                      throw new Error("Wrong input string for conversion");
              }
          }
          if (isUTC === false) {
              const tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
              this.year = tempDate.getUTCFullYear();
              this.month = tempDate.getUTCMonth();
              this.day = tempDate.getUTCDay();
              this.hour = tempDate.getUTCHours();
              this.minute = tempDate.getUTCMinutes();
              this.second = tempDate.getUTCSeconds();
              this.millisecond = tempDate.getUTCMilliseconds();
          }
      }
      toString(encoding = "iso") {
          if (encoding === "iso") {
              const outputArray = [];
              outputArray.push(padNumber(this.year, 4));
              outputArray.push(padNumber(this.month, 2));
              outputArray.push(padNumber(this.day, 2));
              outputArray.push(padNumber(this.hour, 2));
              outputArray.push(padNumber(this.minute, 2));
              outputArray.push(padNumber(this.second, 2));
              if (this.millisecond !== 0) {
                  outputArray.push(".");
                  outputArray.push(padNumber(this.millisecond, 3));
              }
              outputArray.push("Z");
              return outputArray.join("");
          }
          return super.toString(encoding);
      }
      toJSON() {
          return {
              ...super.toJSON(),
              millisecond: this.millisecond,
          };
      }
  }
  _a$5 = GeneralizedTime;
  (() => {
      typeStore.GeneralizedTime = _a$5;
  })();
  GeneralizedTime.NAME = "GeneralizedTime";

  var _a$4;
  class DATE extends Utf8String {
      constructor(parameters = {}) {
          super(parameters);
          this.idBlock.tagClass = 1;
          this.idBlock.tagNumber = 31;
      }
  }
  _a$4 = DATE;
  (() => {
      typeStore.DATE = _a$4;
  })();
  DATE.NAME = "DATE";

  var _a$3;
  class TimeOfDay extends Utf8String {
      constructor(parameters = {}) {
          super(parameters);
          this.idBlock.tagClass = 1;
          this.idBlock.tagNumber = 32;
      }
  }
  _a$3 = TimeOfDay;
  (() => {
      typeStore.TimeOfDay = _a$3;
  })();
  TimeOfDay.NAME = "TimeOfDay";

  var _a$2;
  class DateTime extends Utf8String {
      constructor(parameters = {}) {
          super(parameters);
          this.idBlock.tagClass = 1;
          this.idBlock.tagNumber = 33;
      }
  }
  _a$2 = DateTime;
  (() => {
      typeStore.DateTime = _a$2;
  })();
  DateTime.NAME = "DateTime";

  var _a$1;
  let Duration$1 = class Duration extends Utf8String {
      constructor(parameters = {}) {
          super(parameters);
          this.idBlock.tagClass = 1;
          this.idBlock.tagNumber = 34;
      }
  };
  _a$1 = Duration$1;
  (() => {
      typeStore.Duration = _a$1;
  })();
  Duration$1.NAME = "Duration";

  var _a;
  class TIME extends Utf8String {
      constructor(parameters = {}) {
          super(parameters);
          this.idBlock.tagClass = 1;
          this.idBlock.tagNumber = 14;
      }
  }
  _a = TIME;
  (() => {
      typeStore.TIME = _a;
  })();
  TIME.NAME = "TIME";

  var pem = {exports: {}};

  /**
   * Node.js module for Forge.
   *
   * @author Dave Longley
   *
   * Copyright 2011-2016 Digital Bazaar, Inc.
   */

  var forge;
  var hasRequiredForge;

  function requireForge () {
  	if (hasRequiredForge) return forge;
  	hasRequiredForge = 1;
  	forge = {
  	  // default options
  	  options: {
  	    usePureJavaScript: false
  	  }
  	};
  	return forge;
  }

  var util = {exports: {}};

  /**
   * Base-N/Base-X encoding/decoding functions.
   *
   * Original implementation from base-x:
   * https://github.com/cryptocoinjs/base-x
   *
   * Which is MIT licensed:
   *
   * The MIT License (MIT)
   *
   * Copyright base-x contributors (c) 2016
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
   * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
   * DEALINGS IN THE SOFTWARE.
   */

  var baseN;
  var hasRequiredBaseN;

  function requireBaseN () {
  	if (hasRequiredBaseN) return baseN;
  	hasRequiredBaseN = 1;
  	var api = {};
  	baseN = api;

  	// baseN alphabet indexes
  	var _reverseAlphabets = {};

  	/**
  	 * BaseN-encodes a Uint8Array using the given alphabet.
  	 *
  	 * @param input the Uint8Array to encode.
  	 * @param maxline the maximum number of encoded characters per line to use,
  	 *          defaults to none.
  	 *
  	 * @return the baseN-encoded output string.
  	 */
  	api.encode = function(input, alphabet, maxline) {
  	  if(typeof alphabet !== 'string') {
  	    throw new TypeError('"alphabet" must be a string.');
  	  }
  	  if(maxline !== undefined && typeof maxline !== 'number') {
  	    throw new TypeError('"maxline" must be a number.');
  	  }

  	  var output = '';

  	  if(!(input instanceof Uint8Array)) {
  	    // assume forge byte buffer
  	    output = _encodeWithByteBuffer(input, alphabet);
  	  } else {
  	    var i = 0;
  	    var base = alphabet.length;
  	    var first = alphabet.charAt(0);
  	    var digits = [0];
  	    for(i = 0; i < input.length; ++i) {
  	      for(var j = 0, carry = input[i]; j < digits.length; ++j) {
  	        carry += digits[j] << 8;
  	        digits[j] = carry % base;
  	        carry = (carry / base) | 0;
  	      }

  	      while(carry > 0) {
  	        digits.push(carry % base);
  	        carry = (carry / base) | 0;
  	      }
  	    }

  	    // deal with leading zeros
  	    for(i = 0; input[i] === 0 && i < input.length - 1; ++i) {
  	      output += first;
  	    }
  	    // convert digits to a string
  	    for(i = digits.length - 1; i >= 0; --i) {
  	      output += alphabet[digits[i]];
  	    }
  	  }

  	  if(maxline) {
  	    var regex = new RegExp('.{1,' + maxline + '}', 'g');
  	    output = output.match(regex).join('\r\n');
  	  }

  	  return output;
  	};

  	/**
  	 * Decodes a baseN-encoded (using the given alphabet) string to a
  	 * Uint8Array.
  	 *
  	 * @param input the baseN-encoded input string.
  	 *
  	 * @return the Uint8Array.
  	 */
  	api.decode = function(input, alphabet) {
  	  if(typeof input !== 'string') {
  	    throw new TypeError('"input" must be a string.');
  	  }
  	  if(typeof alphabet !== 'string') {
  	    throw new TypeError('"alphabet" must be a string.');
  	  }

  	  var table = _reverseAlphabets[alphabet];
  	  if(!table) {
  	    // compute reverse alphabet
  	    table = _reverseAlphabets[alphabet] = [];
  	    for(var i = 0; i < alphabet.length; ++i) {
  	      table[alphabet.charCodeAt(i)] = i;
  	    }
  	  }

  	  // remove whitespace characters
  	  input = input.replace(/\s/g, '');

  	  var base = alphabet.length;
  	  var first = alphabet.charAt(0);
  	  var bytes = [0];
  	  for(var i = 0; i < input.length; i++) {
  	    var value = table[input.charCodeAt(i)];
  	    if(value === undefined) {
  	      return;
  	    }

  	    for(var j = 0, carry = value; j < bytes.length; ++j) {
  	      carry += bytes[j] * base;
  	      bytes[j] = carry & 0xff;
  	      carry >>= 8;
  	    }

  	    while(carry > 0) {
  	      bytes.push(carry & 0xff);
  	      carry >>= 8;
  	    }
  	  }

  	  // deal with leading zeros
  	  for(var k = 0; input[k] === first && k < input.length - 1; ++k) {
  	    bytes.push(0);
  	  }

  	  if(typeof Buffer !== 'undefined') {
  	    return Buffer.from(bytes.reverse());
  	  }

  	  return new Uint8Array(bytes.reverse());
  	};

  	function _encodeWithByteBuffer(input, alphabet) {
  	  var i = 0;
  	  var base = alphabet.length;
  	  var first = alphabet.charAt(0);
  	  var digits = [0];
  	  for(i = 0; i < input.length(); ++i) {
  	    for(var j = 0, carry = input.at(i); j < digits.length; ++j) {
  	      carry += digits[j] << 8;
  	      digits[j] = carry % base;
  	      carry = (carry / base) | 0;
  	    }

  	    while(carry > 0) {
  	      digits.push(carry % base);
  	      carry = (carry / base) | 0;
  	    }
  	  }

  	  var output = '';

  	  // deal with leading zeros
  	  for(i = 0; input.at(i) === 0 && i < input.length() - 1; ++i) {
  	    output += first;
  	  }
  	  // convert digits to a string
  	  for(i = digits.length - 1; i >= 0; --i) {
  	    output += alphabet[digits[i]];
  	  }

  	  return output;
  	}
  	return baseN;
  }

  /**
   * Utility functions for web applications.
   *
   * @author Dave Longley
   *
   * Copyright (c) 2010-2018 Digital Bazaar, Inc.
   */

  var hasRequiredUtil;

  function requireUtil () {
  	if (hasRequiredUtil) return util.exports;
  	hasRequiredUtil = 1;
  	var forge = requireForge();
  	var baseN = requireBaseN();

  	/* Utilities API */
  	var util$1 = util.exports = forge.util = forge.util || {};

  	// define setImmediate and nextTick
  	(function() {
  	  // use native nextTick (unless we're in webpack)
  	  // webpack (or better node-libs-browser polyfill) sets process.browser.
  	  // this way we can detect webpack properly
  	  if(typeof process !== 'undefined' && process.nextTick && !process.browser) {
  	    util$1.nextTick = process.nextTick;
  	    if(typeof setImmediate === 'function') {
  	      util$1.setImmediate = setImmediate;
  	    } else {
  	      // polyfill setImmediate with nextTick, older versions of node
  	      // (those w/o setImmediate) won't totally starve IO
  	      util$1.setImmediate = util$1.nextTick;
  	    }
  	    return;
  	  }

  	  // polyfill nextTick with native setImmediate
  	  if(typeof setImmediate === 'function') {
  	    util$1.setImmediate = function() { return setImmediate.apply(undefined, arguments); };
  	    util$1.nextTick = function(callback) {
  	      return setImmediate(callback);
  	    };
  	    return;
  	  }

  	  /* Note: A polyfill upgrade pattern is used here to allow combining
  	  polyfills. For example, MutationObserver is fast, but blocks UI updates,
  	  so it needs to allow UI updates periodically, so it falls back on
  	  postMessage or setTimeout. */

  	  // polyfill with setTimeout
  	  util$1.setImmediate = function(callback) {
  	    setTimeout(callback, 0);
  	  };

  	  // upgrade polyfill to use postMessage
  	  if(typeof window !== 'undefined' &&
  	    typeof window.postMessage === 'function') {
  	    var msg = 'forge.setImmediate';
  	    var callbacks = [];
  	    util$1.setImmediate = function(callback) {
  	      callbacks.push(callback);
  	      // only send message when one hasn't been sent in
  	      // the current turn of the event loop
  	      if(callbacks.length === 1) {
  	        window.postMessage(msg, '*');
  	      }
  	    };
  	    function handler(event) {
  	      if(event.source === window && event.data === msg) {
  	        event.stopPropagation();
  	        var copy = callbacks.slice();
  	        callbacks.length = 0;
  	        copy.forEach(function(callback) {
  	          callback();
  	        });
  	      }
  	    }
  	    window.addEventListener('message', handler, true);
  	  }

  	  // upgrade polyfill to use MutationObserver
  	  if(typeof MutationObserver !== 'undefined') {
  	    // polyfill with MutationObserver
  	    var now = Date.now();
  	    var attr = true;
  	    var div = document.createElement('div');
  	    var callbacks = [];
  	    new MutationObserver(function() {
  	      var copy = callbacks.slice();
  	      callbacks.length = 0;
  	      copy.forEach(function(callback) {
  	        callback();
  	      });
  	    }).observe(div, {attributes: true});
  	    var oldSetImmediate = util$1.setImmediate;
  	    util$1.setImmediate = function(callback) {
  	      if(Date.now() - now > 15) {
  	        now = Date.now();
  	        oldSetImmediate(callback);
  	      } else {
  	        callbacks.push(callback);
  	        // only trigger observer when it hasn't been triggered in
  	        // the current turn of the event loop
  	        if(callbacks.length === 1) {
  	          div.setAttribute('a', attr = !attr);
  	        }
  	      }
  	    };
  	  }

  	  util$1.nextTick = util$1.setImmediate;
  	})();

  	// check if running under Node.js
  	util$1.isNodejs =
  	  typeof process !== 'undefined' && process.versions && process.versions.node;


  	// 'self' will also work in Web Workers (instance of WorkerGlobalScope) while
  	// it will point to `window` in the main thread.
  	// To remain compatible with older browsers, we fall back to 'window' if 'self'
  	// is not available.
  	util$1.globalScope = (function() {
  	  if(util$1.isNodejs) {
  	    return commonjsGlobal;
  	  }

  	  return typeof self === 'undefined' ? window : self;
  	})();

  	// define isArray
  	util$1.isArray = Array.isArray || function(x) {
  	  return Object.prototype.toString.call(x) === '[object Array]';
  	};

  	// define isArrayBuffer
  	util$1.isArrayBuffer = function(x) {
  	  return typeof ArrayBuffer !== 'undefined' && x instanceof ArrayBuffer;
  	};

  	// define isArrayBufferView
  	util$1.isArrayBufferView = function(x) {
  	  return x && util$1.isArrayBuffer(x.buffer) && x.byteLength !== undefined;
  	};

  	/**
  	 * Ensure a bits param is 8, 16, 24, or 32. Used to validate input for
  	 * algorithms where bit manipulation, JavaScript limitations, and/or algorithm
  	 * design only allow for byte operations of a limited size.
  	 *
  	 * @param n number of bits.
  	 *
  	 * Throw Error if n invalid.
  	 */
  	function _checkBitsParam(n) {
  	  if(!(n === 8 || n === 16 || n === 24 || n === 32)) {
  	    throw new Error('Only 8, 16, 24, or 32 bits supported: ' + n);
  	  }
  	}

  	// TODO: set ByteBuffer to best available backing
  	util$1.ByteBuffer = ByteStringBuffer;

  	/** Buffer w/BinaryString backing */

  	/**
  	 * Constructor for a binary string backed byte buffer.
  	 *
  	 * @param [b] the bytes to wrap (either encoded as string, one byte per
  	 *          character, or as an ArrayBuffer or Typed Array).
  	 */
  	function ByteStringBuffer(b) {
  	  // TODO: update to match DataBuffer API

  	  // the data in this buffer
  	  this.data = '';
  	  // the pointer for reading from this buffer
  	  this.read = 0;

  	  if(typeof b === 'string') {
  	    this.data = b;
  	  } else if(util$1.isArrayBuffer(b) || util$1.isArrayBufferView(b)) {
  	    if(typeof Buffer !== 'undefined' && b instanceof Buffer) {
  	      this.data = b.toString('binary');
  	    } else {
  	      // convert native buffer to forge buffer
  	      // FIXME: support native buffers internally instead
  	      var arr = new Uint8Array(b);
  	      try {
  	        this.data = String.fromCharCode.apply(null, arr);
  	      } catch(e) {
  	        for(var i = 0; i < arr.length; ++i) {
  	          this.putByte(arr[i]);
  	        }
  	      }
  	    }
  	  } else if(b instanceof ByteStringBuffer ||
  	    (typeof b === 'object' && typeof b.data === 'string' &&
  	    typeof b.read === 'number')) {
  	    // copy existing buffer
  	    this.data = b.data;
  	    this.read = b.read;
  	  }

  	  // used for v8 optimization
  	  this._constructedStringLength = 0;
  	}
  	util$1.ByteStringBuffer = ByteStringBuffer;

  	/* Note: This is an optimization for V8-based browsers. When V8 concatenates
  	  a string, the strings are only joined logically using a "cons string" or
  	  "constructed/concatenated string". These containers keep references to one
  	  another and can result in very large memory usage. For example, if a 2MB
  	  string is constructed by concatenating 4 bytes together at a time, the
  	  memory usage will be ~44MB; so ~22x increase. The strings are only joined
  	  together when an operation requiring their joining takes place, such as
  	  substr(). This function is called when adding data to this buffer to ensure
  	  these types of strings are periodically joined to reduce the memory
  	  footprint. */
  	var _MAX_CONSTRUCTED_STRING_LENGTH = 4096;
  	util$1.ByteStringBuffer.prototype._optimizeConstructedString = function(x) {
  	  this._constructedStringLength += x;
  	  if(this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH) {
  	    // this substr() should cause the constructed string to join
  	    this.data.substr(0, 1);
  	    this._constructedStringLength = 0;
  	  }
  	};

  	/**
  	 * Gets the number of bytes in this buffer.
  	 *
  	 * @return the number of bytes in this buffer.
  	 */
  	util$1.ByteStringBuffer.prototype.length = function() {
  	  return this.data.length - this.read;
  	};

  	/**
  	 * Gets whether or not this buffer is empty.
  	 *
  	 * @return true if this buffer is empty, false if not.
  	 */
  	util$1.ByteStringBuffer.prototype.isEmpty = function() {
  	  return this.length() <= 0;
  	};

  	/**
  	 * Puts a byte in this buffer.
  	 *
  	 * @param b the byte to put.
  	 *
  	 * @return this buffer.
  	 */
  	util$1.ByteStringBuffer.prototype.putByte = function(b) {
  	  return this.putBytes(String.fromCharCode(b));
  	};

  	/**
  	 * Puts a byte in this buffer N times.
  	 *
  	 * @param b the byte to put.
  	 * @param n the number of bytes of value b to put.
  	 *
  	 * @return this buffer.
  	 */
  	util$1.ByteStringBuffer.prototype.fillWithByte = function(b, n) {
  	  b = String.fromCharCode(b);
  	  var d = this.data;
  	  while(n > 0) {
  	    if(n & 1) {
  	      d += b;
  	    }
  	    n >>>= 1;
  	    if(n > 0) {
  	      b += b;
  	    }
  	  }
  	  this.data = d;
  	  this._optimizeConstructedString(n);
  	  return this;
  	};

  	/**
  	 * Puts bytes in this buffer.
  	 *
  	 * @param bytes the bytes (as a binary encoded string) to put.
  	 *
  	 * @return this buffer.
  	 */
  	util$1.ByteStringBuffer.prototype.putBytes = function(bytes) {
  	  this.data += bytes;
  	  this._optimizeConstructedString(bytes.length);
  	  return this;
  	};

  	/**
  	 * Puts a UTF-16 encoded string into this buffer.
  	 *
  	 * @param str the string to put.
  	 *
  	 * @return this buffer.
  	 */
  	util$1.ByteStringBuffer.prototype.putString = function(str) {
  	  return this.putBytes(util$1.encodeUtf8(str));
  	};

  	/**
  	 * Puts a 16-bit integer in this buffer in big-endian order.
  	 *
  	 * @param i the 16-bit integer.
  	 *
  	 * @return this buffer.
  	 */
  	util$1.ByteStringBuffer.prototype.putInt16 = function(i) {
  	  return this.putBytes(
  	    String.fromCharCode(i >> 8 & 0xFF) +
  	    String.fromCharCode(i & 0xFF));
  	};

  	/**
  	 * Puts a 24-bit integer in this buffer in big-endian order.
  	 *
  	 * @param i the 24-bit integer.
  	 *
  	 * @return this buffer.
  	 */
  	util$1.ByteStringBuffer.prototype.putInt24 = function(i) {
  	  return this.putBytes(
  	    String.fromCharCode(i >> 16 & 0xFF) +
  	    String.fromCharCode(i >> 8 & 0xFF) +
  	    String.fromCharCode(i & 0xFF));
  	};

  	/**
  	 * Puts a 32-bit integer in this buffer in big-endian order.
  	 *
  	 * @param i the 32-bit integer.
  	 *
  	 * @return this buffer.
  	 */
  	util$1.ByteStringBuffer.prototype.putInt32 = function(i) {
  	  return this.putBytes(
  	    String.fromCharCode(i >> 24 & 0xFF) +
  	    String.fromCharCode(i >> 16 & 0xFF) +
  	    String.fromCharCode(i >> 8 & 0xFF) +
  	    String.fromCharCode(i & 0xFF));
  	};

  	/**
  	 * Puts a 16-bit integer in this buffer in little-endian order.
  	 *
  	 * @param i the 16-bit integer.
  	 *
  	 * @return this buffer.
  	 */
  	util$1.ByteStringBuffer.prototype.putInt16Le = function(i) {
  	  return this.putBytes(
  	    String.fromCharCode(i & 0xFF) +
  	    String.fromCharCode(i >> 8 & 0xFF));
  	};

  	/**
  	 * Puts a 24-bit integer in this buffer in little-endian order.
  	 *
  	 * @param i the 24-bit integer.
  	 *
  	 * @return this buffer.
  	 */
  	util$1.ByteStringBuffer.prototype.putInt24Le = function(i) {
  	  return this.putBytes(
  	    String.fromCharCode(i & 0xFF) +
  	    String.fromCharCode(i >> 8 & 0xFF) +
  	    String.fromCharCode(i >> 16 & 0xFF));
  	};

  	/**
  	 * Puts a 32-bit integer in this buffer in little-endian order.
  	 *
  	 * @param i the 32-bit integer.
  	 *
  	 * @return this buffer.
  	 */
  	util$1.ByteStringBuffer.prototype.putInt32Le = function(i) {
  	  return this.putBytes(
  	    String.fromCharCode(i & 0xFF) +
  	    String.fromCharCode(i >> 8 & 0xFF) +
  	    String.fromCharCode(i >> 16 & 0xFF) +
  	    String.fromCharCode(i >> 24 & 0xFF));
  	};

  	/**
  	 * Puts an n-bit integer in this buffer in big-endian order.
  	 *
  	 * @param i the n-bit integer.
  	 * @param n the number of bits in the integer (8, 16, 24, or 32).
  	 *
  	 * @return this buffer.
  	 */
  	util$1.ByteStringBuffer.prototype.putInt = function(i, n) {
  	  _checkBitsParam(n);
  	  var bytes = '';
  	  do {
  	    n -= 8;
  	    bytes += String.fromCharCode((i >> n) & 0xFF);
  	  } while(n > 0);
  	  return this.putBytes(bytes);
  	};

  	/**
  	 * Puts a signed n-bit integer in this buffer in big-endian order. Two's
  	 * complement representation is used.
  	 *
  	 * @param i the n-bit integer.
  	 * @param n the number of bits in the integer (8, 16, 24, or 32).
  	 *
  	 * @return this buffer.
  	 */
  	util$1.ByteStringBuffer.prototype.putSignedInt = function(i, n) {
  	  // putInt checks n
  	  if(i < 0) {
  	    i += 2 << (n - 1);
  	  }
  	  return this.putInt(i, n);
  	};

  	/**
  	 * Puts the given buffer into this buffer.
  	 *
  	 * @param buffer the buffer to put into this one.
  	 *
  	 * @return this buffer.
  	 */
  	util$1.ByteStringBuffer.prototype.putBuffer = function(buffer) {
  	  return this.putBytes(buffer.getBytes());
  	};

  	/**
  	 * Gets a byte from this buffer and advances the read pointer by 1.
  	 *
  	 * @return the byte.
  	 */
  	util$1.ByteStringBuffer.prototype.getByte = function() {
  	  return this.data.charCodeAt(this.read++);
  	};

  	/**
  	 * Gets a uint16 from this buffer in big-endian order and advances the read
  	 * pointer by 2.
  	 *
  	 * @return the uint16.
  	 */
  	util$1.ByteStringBuffer.prototype.getInt16 = function() {
  	  var rval = (
  	    this.data.charCodeAt(this.read) << 8 ^
  	    this.data.charCodeAt(this.read + 1));
  	  this.read += 2;
  	  return rval;
  	};

  	/**
  	 * Gets a uint24 from this buffer in big-endian order and advances the read
  	 * pointer by 3.
  	 *
  	 * @return the uint24.
  	 */
  	util$1.ByteStringBuffer.prototype.getInt24 = function() {
  	  var rval = (
  	    this.data.charCodeAt(this.read) << 16 ^
  	    this.data.charCodeAt(this.read + 1) << 8 ^
  	    this.data.charCodeAt(this.read + 2));
  	  this.read += 3;
  	  return rval;
  	};

  	/**
  	 * Gets a uint32 from this buffer in big-endian order and advances the read
  	 * pointer by 4.
  	 *
  	 * @return the word.
  	 */
  	util$1.ByteStringBuffer.prototype.getInt32 = function() {
  	  var rval = (
  	    this.data.charCodeAt(this.read) << 24 ^
  	    this.data.charCodeAt(this.read + 1) << 16 ^
  	    this.data.charCodeAt(this.read + 2) << 8 ^
  	    this.data.charCodeAt(this.read + 3));
  	  this.read += 4;
  	  return rval;
  	};

  	/**
  	 * Gets a uint16 from this buffer in little-endian order and advances the read
  	 * pointer by 2.
  	 *
  	 * @return the uint16.
  	 */
  	util$1.ByteStringBuffer.prototype.getInt16Le = function() {
  	  var rval = (
  	    this.data.charCodeAt(this.read) ^
  	    this.data.charCodeAt(this.read + 1) << 8);
  	  this.read += 2;
  	  return rval;
  	};

  	/**
  	 * Gets a uint24 from this buffer in little-endian order and advances the read
  	 * pointer by 3.
  	 *
  	 * @return the uint24.
  	 */
  	util$1.ByteStringBuffer.prototype.getInt24Le = function() {
  	  var rval = (
  	    this.data.charCodeAt(this.read) ^
  	    this.data.charCodeAt(this.read + 1) << 8 ^
  	    this.data.charCodeAt(this.read + 2) << 16);
  	  this.read += 3;
  	  return rval;
  	};

  	/**
  	 * Gets a uint32 from this buffer in little-endian order and advances the read
  	 * pointer by 4.
  	 *
  	 * @return the word.
  	 */
  	util$1.ByteStringBuffer.prototype.getInt32Le = function() {
  	  var rval = (
  	    this.data.charCodeAt(this.read) ^
  	    this.data.charCodeAt(this.read + 1) << 8 ^
  	    this.data.charCodeAt(this.read + 2) << 16 ^
  	    this.data.charCodeAt(this.read + 3) << 24);
  	  this.read += 4;
  	  return rval;
  	};

  	/**
  	 * Gets an n-bit integer from this buffer in big-endian order and advances the
  	 * read pointer by ceil(n/8).
  	 *
  	 * @param n the number of bits in the integer (8, 16, 24, or 32).
  	 *
  	 * @return the integer.
  	 */
  	util$1.ByteStringBuffer.prototype.getInt = function(n) {
  	  _checkBitsParam(n);
  	  var rval = 0;
  	  do {
  	    // TODO: Use (rval * 0x100) if adding support for 33 to 53 bits.
  	    rval = (rval << 8) + this.data.charCodeAt(this.read++);
  	    n -= 8;
  	  } while(n > 0);
  	  return rval;
  	};

  	/**
  	 * Gets a signed n-bit integer from this buffer in big-endian order, using
  	 * two's complement, and advances the read pointer by n/8.
  	 *
  	 * @param n the number of bits in the integer (8, 16, 24, or 32).
  	 *
  	 * @return the integer.
  	 */
  	util$1.ByteStringBuffer.prototype.getSignedInt = function(n) {
  	  // getInt checks n
  	  var x = this.getInt(n);
  	  var max = 2 << (n - 2);
  	  if(x >= max) {
  	    x -= max << 1;
  	  }
  	  return x;
  	};

  	/**
  	 * Reads bytes out as a binary encoded string and clears them from the
  	 * buffer. Note that the resulting string is binary encoded (in node.js this
  	 * encoding is referred to as `binary`, it is *not* `utf8`).
  	 *
  	 * @param count the number of bytes to read, undefined or null for all.
  	 *
  	 * @return a binary encoded string of bytes.
  	 */
  	util$1.ByteStringBuffer.prototype.getBytes = function(count) {
  	  var rval;
  	  if(count) {
  	    // read count bytes
  	    count = Math.min(this.length(), count);
  	    rval = this.data.slice(this.read, this.read + count);
  	    this.read += count;
  	  } else if(count === 0) {
  	    rval = '';
  	  } else {
  	    // read all bytes, optimize to only copy when needed
  	    rval = (this.read === 0) ? this.data : this.data.slice(this.read);
  	    this.clear();
  	  }
  	  return rval;
  	};

  	/**
  	 * Gets a binary encoded string of the bytes from this buffer without
  	 * modifying the read pointer.
  	 *
  	 * @param count the number of bytes to get, omit to get all.
  	 *
  	 * @return a string full of binary encoded characters.
  	 */
  	util$1.ByteStringBuffer.prototype.bytes = function(count) {
  	  return (typeof(count) === 'undefined' ?
  	    this.data.slice(this.read) :
  	    this.data.slice(this.read, this.read + count));
  	};

  	/**
  	 * Gets a byte at the given index without modifying the read pointer.
  	 *
  	 * @param i the byte index.
  	 *
  	 * @return the byte.
  	 */
  	util$1.ByteStringBuffer.prototype.at = function(i) {
  	  return this.data.charCodeAt(this.read + i);
  	};

  	/**
  	 * Puts a byte at the given index without modifying the read pointer.
  	 *
  	 * @param i the byte index.
  	 * @param b the byte to put.
  	 *
  	 * @return this buffer.
  	 */
  	util$1.ByteStringBuffer.prototype.setAt = function(i, b) {
  	  this.data = this.data.substr(0, this.read + i) +
  	    String.fromCharCode(b) +
  	    this.data.substr(this.read + i + 1);
  	  return this;
  	};

  	/**
  	 * Gets the last byte without modifying the read pointer.
  	 *
  	 * @return the last byte.
  	 */
  	util$1.ByteStringBuffer.prototype.last = function() {
  	  return this.data.charCodeAt(this.data.length - 1);
  	};

  	/**
  	 * Creates a copy of this buffer.
  	 *
  	 * @return the copy.
  	 */
  	util$1.ByteStringBuffer.prototype.copy = function() {
  	  var c = util$1.createBuffer(this.data);
  	  c.read = this.read;
  	  return c;
  	};

  	/**
  	 * Compacts this buffer.
  	 *
  	 * @return this buffer.
  	 */
  	util$1.ByteStringBuffer.prototype.compact = function() {
  	  if(this.read > 0) {
  	    this.data = this.data.slice(this.read);
  	    this.read = 0;
  	  }
  	  return this;
  	};

  	/**
  	 * Clears this buffer.
  	 *
  	 * @return this buffer.
  	 */
  	util$1.ByteStringBuffer.prototype.clear = function() {
  	  this.data = '';
  	  this.read = 0;
  	  return this;
  	};

  	/**
  	 * Shortens this buffer by triming bytes off of the end of this buffer.
  	 *
  	 * @param count the number of bytes to trim off.
  	 *
  	 * @return this buffer.
  	 */
  	util$1.ByteStringBuffer.prototype.truncate = function(count) {
  	  var len = Math.max(0, this.length() - count);
  	  this.data = this.data.substr(this.read, len);
  	  this.read = 0;
  	  return this;
  	};

  	/**
  	 * Converts this buffer to a hexadecimal string.
  	 *
  	 * @return a hexadecimal string.
  	 */
  	util$1.ByteStringBuffer.prototype.toHex = function() {
  	  var rval = '';
  	  for(var i = this.read; i < this.data.length; ++i) {
  	    var b = this.data.charCodeAt(i);
  	    if(b < 16) {
  	      rval += '0';
  	    }
  	    rval += b.toString(16);
  	  }
  	  return rval;
  	};

  	/**
  	 * Converts this buffer to a UTF-16 string (standard JavaScript string).
  	 *
  	 * @return a UTF-16 string.
  	 */
  	util$1.ByteStringBuffer.prototype.toString = function() {
  	  return util$1.decodeUtf8(this.bytes());
  	};

  	/** End Buffer w/BinaryString backing */

  	/** Buffer w/UInt8Array backing */

  	/**
  	 * FIXME: Experimental. Do not use yet.
  	 *
  	 * Constructor for an ArrayBuffer-backed byte buffer.
  	 *
  	 * The buffer may be constructed from a string, an ArrayBuffer, DataView, or a
  	 * TypedArray.
  	 *
  	 * If a string is given, its encoding should be provided as an option,
  	 * otherwise it will default to 'binary'. A 'binary' string is encoded such
  	 * that each character is one byte in length and size.
  	 *
  	 * If an ArrayBuffer, DataView, or TypedArray is given, it will be used
  	 * *directly* without any copying. Note that, if a write to the buffer requires
  	 * more space, the buffer will allocate a new backing ArrayBuffer to
  	 * accommodate. The starting read and write offsets for the buffer may be
  	 * given as options.
  	 *
  	 * @param [b] the initial bytes for this buffer.
  	 * @param options the options to use:
  	 *          [readOffset] the starting read offset to use (default: 0).
  	 *          [writeOffset] the starting write offset to use (default: the
  	 *            length of the first parameter).
  	 *          [growSize] the minimum amount, in bytes, to grow the buffer by to
  	 *            accommodate writes (default: 1024).
  	 *          [encoding] the encoding ('binary', 'utf8', 'utf16', 'hex') for the
  	 *            first parameter, if it is a string (default: 'binary').
  	 */
  	function DataBuffer(b, options) {
  	  // default options
  	  options = options || {};

  	  // pointers for read from/write to buffer
  	  this.read = options.readOffset || 0;
  	  this.growSize = options.growSize || 1024;

  	  var isArrayBuffer = util$1.isArrayBuffer(b);
  	  var isArrayBufferView = util$1.isArrayBufferView(b);
  	  if(isArrayBuffer || isArrayBufferView) {
  	    // use ArrayBuffer directly
  	    if(isArrayBuffer) {
  	      this.data = new DataView(b);
  	    } else {
  	      // TODO: adjust read/write offset based on the type of view
  	      // or specify that this must be done in the options ... that the
  	      // offsets are byte-based
  	      this.data = new DataView(b.buffer, b.byteOffset, b.byteLength);
  	    }
  	    this.write = ('writeOffset' in options ?
  	      options.writeOffset : this.data.byteLength);
  	    return;
  	  }

  	  // initialize to empty array buffer and add any given bytes using putBytes
  	  this.data = new DataView(new ArrayBuffer(0));
  	  this.write = 0;

  	  if(b !== null && b !== undefined) {
  	    this.putBytes(b);
  	  }

  	  if('writeOffset' in options) {
  	    this.write = options.writeOffset;
  	  }
  	}
  	util$1.DataBuffer = DataBuffer;

  	/**
  	 * Gets the number of bytes in this buffer.
  	 *
  	 * @return the number of bytes in this buffer.
  	 */
  	util$1.DataBuffer.prototype.length = function() {
  	  return this.write - this.read;
  	};

  	/**
  	 * Gets whether or not this buffer is empty.
  	 *
  	 * @return true if this buffer is empty, false if not.
  	 */
  	util$1.DataBuffer.prototype.isEmpty = function() {
  	  return this.length() <= 0;
  	};

  	/**
  	 * Ensures this buffer has enough empty space to accommodate the given number
  	 * of bytes. An optional parameter may be given that indicates a minimum
  	 * amount to grow the buffer if necessary. If the parameter is not given,
  	 * the buffer will be grown by some previously-specified default amount
  	 * or heuristic.
  	 *
  	 * @param amount the number of bytes to accommodate.
  	 * @param [growSize] the minimum amount, in bytes, to grow the buffer by if
  	 *          necessary.
  	 */
  	util$1.DataBuffer.prototype.accommodate = function(amount, growSize) {
  	  if(this.length() >= amount) {
  	    return this;
  	  }
  	  growSize = Math.max(growSize || this.growSize, amount);

  	  // grow buffer
  	  var src = new Uint8Array(
  	    this.data.buffer, this.data.byteOffset, this.data.byteLength);
  	  var dst = new Uint8Array(this.length() + growSize);
  	  dst.set(src);
  	  this.data = new DataView(dst.buffer);

  	  return this;
  	};

  	/**
  	 * Puts a byte in this buffer.
  	 *
  	 * @param b the byte to put.
  	 *
  	 * @return this buffer.
  	 */
  	util$1.DataBuffer.prototype.putByte = function(b) {
  	  this.accommodate(1);
  	  this.data.setUint8(this.write++, b);
  	  return this;
  	};

  	/**
  	 * Puts a byte in this buffer N times.
  	 *
  	 * @param b the byte to put.
  	 * @param n the number of bytes of value b to put.
  	 *
  	 * @return this buffer.
  	 */
  	util$1.DataBuffer.prototype.fillWithByte = function(b, n) {
  	  this.accommodate(n);
  	  for(var i = 0; i < n; ++i) {
  	    this.data.setUint8(b);
  	  }
  	  return this;
  	};

  	/**
  	 * Puts bytes in this buffer. The bytes may be given as a string, an
  	 * ArrayBuffer, a DataView, or a TypedArray.
  	 *
  	 * @param bytes the bytes to put.
  	 * @param [encoding] the encoding for the first parameter ('binary', 'utf8',
  	 *          'utf16', 'hex'), if it is a string (default: 'binary').
  	 *
  	 * @return this buffer.
  	 */
  	util$1.DataBuffer.prototype.putBytes = function(bytes, encoding) {
  	  if(util$1.isArrayBufferView(bytes)) {
  	    var src = new Uint8Array(bytes.buffer, bytes.byteOffset, bytes.byteLength);
  	    var len = src.byteLength - src.byteOffset;
  	    this.accommodate(len);
  	    var dst = new Uint8Array(this.data.buffer, this.write);
  	    dst.set(src);
  	    this.write += len;
  	    return this;
  	  }

  	  if(util$1.isArrayBuffer(bytes)) {
  	    var src = new Uint8Array(bytes);
  	    this.accommodate(src.byteLength);
  	    var dst = new Uint8Array(this.data.buffer);
  	    dst.set(src, this.write);
  	    this.write += src.byteLength;
  	    return this;
  	  }

  	  // bytes is a util.DataBuffer or equivalent
  	  if(bytes instanceof util$1.DataBuffer ||
  	    (typeof bytes === 'object' &&
  	    typeof bytes.read === 'number' && typeof bytes.write === 'number' &&
  	    util$1.isArrayBufferView(bytes.data))) {
  	    var src = new Uint8Array(bytes.data.byteLength, bytes.read, bytes.length());
  	    this.accommodate(src.byteLength);
  	    var dst = new Uint8Array(bytes.data.byteLength, this.write);
  	    dst.set(src);
  	    this.write += src.byteLength;
  	    return this;
  	  }

  	  if(bytes instanceof util$1.ByteStringBuffer) {
  	    // copy binary string and process as the same as a string parameter below
  	    bytes = bytes.data;
  	    encoding = 'binary';
  	  }

  	  // string conversion
  	  encoding = encoding || 'binary';
  	  if(typeof bytes === 'string') {
  	    var view;

  	    // decode from string
  	    if(encoding === 'hex') {
  	      this.accommodate(Math.ceil(bytes.length / 2));
  	      view = new Uint8Array(this.data.buffer, this.write);
  	      this.write += util$1.binary.hex.decode(bytes, view, this.write);
  	      return this;
  	    }
  	    if(encoding === 'base64') {
  	      this.accommodate(Math.ceil(bytes.length / 4) * 3);
  	      view = new Uint8Array(this.data.buffer, this.write);
  	      this.write += util$1.binary.base64.decode(bytes, view, this.write);
  	      return this;
  	    }

  	    // encode text as UTF-8 bytes
  	    if(encoding === 'utf8') {
  	      // encode as UTF-8 then decode string as raw binary
  	      bytes = util$1.encodeUtf8(bytes);
  	      encoding = 'binary';
  	    }

  	    // decode string as raw binary
  	    if(encoding === 'binary' || encoding === 'raw') {
  	      // one byte per character
  	      this.accommodate(bytes.length);
  	      view = new Uint8Array(this.data.buffer, this.write);
  	      this.write += util$1.binary.raw.decode(view);
  	      return this;
  	    }

  	    // encode text as UTF-16 bytes
  	    if(encoding === 'utf16') {
  	      // two bytes per character
  	      this.accommodate(bytes.length * 2);
  	      view = new Uint16Array(this.data.buffer, this.write);
  	      this.write += util$1.text.utf16.encode(view);
  	      return this;
  	    }

  	    throw new Error('Invalid encoding: ' + encoding);
  	  }

  	  throw Error('Invalid parameter: ' + bytes);
  	};

  	/**
  	 * Puts the given buffer into this buffer.
  	 *
  	 * @param buffer the buffer to put into this one.
  	 *
  	 * @return this buffer.
  	 */
  	util$1.DataBuffer.prototype.putBuffer = function(buffer) {
  	  this.putBytes(buffer);
  	  buffer.clear();
  	  return this;
  	};

  	/**
  	 * Puts a string into this buffer.
  	 *
  	 * @param str the string to put.
  	 * @param [encoding] the encoding for the string (default: 'utf16').
  	 *
  	 * @return this buffer.
  	 */
  	util$1.DataBuffer.prototype.putString = function(str) {
  	  return this.putBytes(str, 'utf16');
  	};

  	/**
  	 * Puts a 16-bit integer in this buffer in big-endian order.
  	 *
  	 * @param i the 16-bit integer.
  	 *
  	 * @return this buffer.
  	 */
  	util$1.DataBuffer.prototype.putInt16 = function(i) {
  	  this.accommodate(2);
  	  this.data.setInt16(this.write, i);
  	  this.write += 2;
  	  return this;
  	};

  	/**
  	 * Puts a 24-bit integer in this buffer in big-endian order.
  	 *
  	 * @param i the 24-bit integer.
  	 *
  	 * @return this buffer.
  	 */
  	util$1.DataBuffer.prototype.putInt24 = function(i) {
  	  this.accommodate(3);
  	  this.data.setInt16(this.write, i >> 8 & 0xFFFF);
  	  this.data.setInt8(this.write, i >> 16 & 0xFF);
  	  this.write += 3;
  	  return this;
  	};

  	/**
  	 * Puts a 32-bit integer in this buffer in big-endian order.
  	 *
  	 * @param i the 32-bit integer.
  	 *
  	 * @return this buffer.
  	 */
  	util$1.DataBuffer.prototype.putInt32 = function(i) {
  	  this.accommodate(4);
  	  this.data.setInt32(this.write, i);
  	  this.write += 4;
  	  return this;
  	};

  	/**
  	 * Puts a 16-bit integer in this buffer in little-endian order.
  	 *
  	 * @param i the 16-bit integer.
  	 *
  	 * @return this buffer.
  	 */
  	util$1.DataBuffer.prototype.putInt16Le = function(i) {
  	  this.accommodate(2);
  	  this.data.setInt16(this.write, i, true);
  	  this.write += 2;
  	  return this;
  	};

  	/**
  	 * Puts a 24-bit integer in this buffer in little-endian order.
  	 *
  	 * @param i the 24-bit integer.
  	 *
  	 * @return this buffer.
  	 */
  	util$1.DataBuffer.prototype.putInt24Le = function(i) {
  	  this.accommodate(3);
  	  this.data.setInt8(this.write, i >> 16 & 0xFF);
  	  this.data.setInt16(this.write, i >> 8 & 0xFFFF, true);
  	  this.write += 3;
  	  return this;
  	};

  	/**
  	 * Puts a 32-bit integer in this buffer in little-endian order.
  	 *
  	 * @param i the 32-bit integer.
  	 *
  	 * @return this buffer.
  	 */
  	util$1.DataBuffer.prototype.putInt32Le = function(i) {
  	  this.accommodate(4);
  	  this.data.setInt32(this.write, i, true);
  	  this.write += 4;
  	  return this;
  	};

  	/**
  	 * Puts an n-bit integer in this buffer in big-endian order.
  	 *
  	 * @param i the n-bit integer.
  	 * @param n the number of bits in the integer (8, 16, 24, or 32).
  	 *
  	 * @return this buffer.
  	 */
  	util$1.DataBuffer.prototype.putInt = function(i, n) {
  	  _checkBitsParam(n);
  	  this.accommodate(n / 8);
  	  do {
  	    n -= 8;
  	    this.data.setInt8(this.write++, (i >> n) & 0xFF);
  	  } while(n > 0);
  	  return this;
  	};

  	/**
  	 * Puts a signed n-bit integer in this buffer in big-endian order. Two's
  	 * complement representation is used.
  	 *
  	 * @param i the n-bit integer.
  	 * @param n the number of bits in the integer.
  	 *
  	 * @return this buffer.
  	 */
  	util$1.DataBuffer.prototype.putSignedInt = function(i, n) {
  	  _checkBitsParam(n);
  	  this.accommodate(n / 8);
  	  if(i < 0) {
  	    i += 2 << (n - 1);
  	  }
  	  return this.putInt(i, n);
  	};

  	/**
  	 * Gets a byte from this buffer and advances the read pointer by 1.
  	 *
  	 * @return the byte.
  	 */
  	util$1.DataBuffer.prototype.getByte = function() {
  	  return this.data.getInt8(this.read++);
  	};

  	/**
  	 * Gets a uint16 from this buffer in big-endian order and advances the read
  	 * pointer by 2.
  	 *
  	 * @return the uint16.
  	 */
  	util$1.DataBuffer.prototype.getInt16 = function() {
  	  var rval = this.data.getInt16(this.read);
  	  this.read += 2;
  	  return rval;
  	};

  	/**
  	 * Gets a uint24 from this buffer in big-endian order and advances the read
  	 * pointer by 3.
  	 *
  	 * @return the uint24.
  	 */
  	util$1.DataBuffer.prototype.getInt24 = function() {
  	  var rval = (
  	    this.data.getInt16(this.read) << 8 ^
  	    this.data.getInt8(this.read + 2));
  	  this.read += 3;
  	  return rval;
  	};

  	/**
  	 * Gets a uint32 from this buffer in big-endian order and advances the read
  	 * pointer by 4.
  	 *
  	 * @return the word.
  	 */
  	util$1.DataBuffer.prototype.getInt32 = function() {
  	  var rval = this.data.getInt32(this.read);
  	  this.read += 4;
  	  return rval;
  	};

  	/**
  	 * Gets a uint16 from this buffer in little-endian order and advances the read
  	 * pointer by 2.
  	 *
  	 * @return the uint16.
  	 */
  	util$1.DataBuffer.prototype.getInt16Le = function() {
  	  var rval = this.data.getInt16(this.read, true);
  	  this.read += 2;
  	  return rval;
  	};

  	/**
  	 * Gets a uint24 from this buffer in little-endian order and advances the read
  	 * pointer by 3.
  	 *
  	 * @return the uint24.
  	 */
  	util$1.DataBuffer.prototype.getInt24Le = function() {
  	  var rval = (
  	    this.data.getInt8(this.read) ^
  	    this.data.getInt16(this.read + 1, true) << 8);
  	  this.read += 3;
  	  return rval;
  	};

  	/**
  	 * Gets a uint32 from this buffer in little-endian order and advances the read
  	 * pointer by 4.
  	 *
  	 * @return the word.
  	 */
  	util$1.DataBuffer.prototype.getInt32Le = function() {
  	  var rval = this.data.getInt32(this.read, true);
  	  this.read += 4;
  	  return rval;
  	};

  	/**
  	 * Gets an n-bit integer from this buffer in big-endian order and advances the
  	 * read pointer by n/8.
  	 *
  	 * @param n the number of bits in the integer (8, 16, 24, or 32).
  	 *
  	 * @return the integer.
  	 */
  	util$1.DataBuffer.prototype.getInt = function(n) {
  	  _checkBitsParam(n);
  	  var rval = 0;
  	  do {
  	    // TODO: Use (rval * 0x100) if adding support for 33 to 53 bits.
  	    rval = (rval << 8) + this.data.getInt8(this.read++);
  	    n -= 8;
  	  } while(n > 0);
  	  return rval;
  	};

  	/**
  	 * Gets a signed n-bit integer from this buffer in big-endian order, using
  	 * two's complement, and advances the read pointer by n/8.
  	 *
  	 * @param n the number of bits in the integer (8, 16, 24, or 32).
  	 *
  	 * @return the integer.
  	 */
  	util$1.DataBuffer.prototype.getSignedInt = function(n) {
  	  // getInt checks n
  	  var x = this.getInt(n);
  	  var max = 2 << (n - 2);
  	  if(x >= max) {
  	    x -= max << 1;
  	  }
  	  return x;
  	};

  	/**
  	 * Reads bytes out as a binary encoded string and clears them from the
  	 * buffer.
  	 *
  	 * @param count the number of bytes to read, undefined or null for all.
  	 *
  	 * @return a binary encoded string of bytes.
  	 */
  	util$1.DataBuffer.prototype.getBytes = function(count) {
  	  // TODO: deprecate this method, it is poorly named and
  	  // this.toString('binary') replaces it
  	  // add a toTypedArray()/toArrayBuffer() function
  	  var rval;
  	  if(count) {
  	    // read count bytes
  	    count = Math.min(this.length(), count);
  	    rval = this.data.slice(this.read, this.read + count);
  	    this.read += count;
  	  } else if(count === 0) {
  	    rval = '';
  	  } else {
  	    // read all bytes, optimize to only copy when needed
  	    rval = (this.read === 0) ? this.data : this.data.slice(this.read);
  	    this.clear();
  	  }
  	  return rval;
  	};

  	/**
  	 * Gets a binary encoded string of the bytes from this buffer without
  	 * modifying the read pointer.
  	 *
  	 * @param count the number of bytes to get, omit to get all.
  	 *
  	 * @return a string full of binary encoded characters.
  	 */
  	util$1.DataBuffer.prototype.bytes = function(count) {
  	  // TODO: deprecate this method, it is poorly named, add "getString()"
  	  return (typeof(count) === 'undefined' ?
  	    this.data.slice(this.read) :
  	    this.data.slice(this.read, this.read + count));
  	};

  	/**
  	 * Gets a byte at the given index without modifying the read pointer.
  	 *
  	 * @param i the byte index.
  	 *
  	 * @return the byte.
  	 */
  	util$1.DataBuffer.prototype.at = function(i) {
  	  return this.data.getUint8(this.read + i);
  	};

  	/**
  	 * Puts a byte at the given index without modifying the read pointer.
  	 *
  	 * @param i the byte index.
  	 * @param b the byte to put.
  	 *
  	 * @return this buffer.
  	 */
  	util$1.DataBuffer.prototype.setAt = function(i, b) {
  	  this.data.setUint8(i, b);
  	  return this;
  	};

  	/**
  	 * Gets the last byte without modifying the read pointer.
  	 *
  	 * @return the last byte.
  	 */
  	util$1.DataBuffer.prototype.last = function() {
  	  return this.data.getUint8(this.write - 1);
  	};

  	/**
  	 * Creates a copy of this buffer.
  	 *
  	 * @return the copy.
  	 */
  	util$1.DataBuffer.prototype.copy = function() {
  	  return new util$1.DataBuffer(this);
  	};

  	/**
  	 * Compacts this buffer.
  	 *
  	 * @return this buffer.
  	 */
  	util$1.DataBuffer.prototype.compact = function() {
  	  if(this.read > 0) {
  	    var src = new Uint8Array(this.data.buffer, this.read);
  	    var dst = new Uint8Array(src.byteLength);
  	    dst.set(src);
  	    this.data = new DataView(dst);
  	    this.write -= this.read;
  	    this.read = 0;
  	  }
  	  return this;
  	};

  	/**
  	 * Clears this buffer.
  	 *
  	 * @return this buffer.
  	 */
  	util$1.DataBuffer.prototype.clear = function() {
  	  this.data = new DataView(new ArrayBuffer(0));
  	  this.read = this.write = 0;
  	  return this;
  	};

  	/**
  	 * Shortens this buffer by triming bytes off of the end of this buffer.
  	 *
  	 * @param count the number of bytes to trim off.
  	 *
  	 * @return this buffer.
  	 */
  	util$1.DataBuffer.prototype.truncate = function(count) {
  	  this.write = Math.max(0, this.length() - count);
  	  this.read = Math.min(this.read, this.write);
  	  return this;
  	};

  	/**
  	 * Converts this buffer to a hexadecimal string.
  	 *
  	 * @return a hexadecimal string.
  	 */
  	util$1.DataBuffer.prototype.toHex = function() {
  	  var rval = '';
  	  for(var i = this.read; i < this.data.byteLength; ++i) {
  	    var b = this.data.getUint8(i);
  	    if(b < 16) {
  	      rval += '0';
  	    }
  	    rval += b.toString(16);
  	  }
  	  return rval;
  	};

  	/**
  	 * Converts this buffer to a string, using the given encoding. If no
  	 * encoding is given, 'utf8' (UTF-8) is used.
  	 *
  	 * @param [encoding] the encoding to use: 'binary', 'utf8', 'utf16', 'hex',
  	 *          'base64' (default: 'utf8').
  	 *
  	 * @return a string representation of the bytes in this buffer.
  	 */
  	util$1.DataBuffer.prototype.toString = function(encoding) {
  	  var view = new Uint8Array(this.data, this.read, this.length());
  	  encoding = encoding || 'utf8';

  	  // encode to string
  	  if(encoding === 'binary' || encoding === 'raw') {
  	    return util$1.binary.raw.encode(view);
  	  }
  	  if(encoding === 'hex') {
  	    return util$1.binary.hex.encode(view);
  	  }
  	  if(encoding === 'base64') {
  	    return util$1.binary.base64.encode(view);
  	  }

  	  // decode to text
  	  if(encoding === 'utf8') {
  	    return util$1.text.utf8.decode(view);
  	  }
  	  if(encoding === 'utf16') {
  	    return util$1.text.utf16.decode(view);
  	  }

  	  throw new Error('Invalid encoding: ' + encoding);
  	};

  	/** End Buffer w/UInt8Array backing */

  	/**
  	 * Creates a buffer that stores bytes. A value may be given to populate the
  	 * buffer with data. This value can either be string of encoded bytes or a
  	 * regular string of characters. When passing a string of binary encoded
  	 * bytes, the encoding `raw` should be given. This is also the default. When
  	 * passing a string of characters, the encoding `utf8` should be given.
  	 *
  	 * @param [input] a string with encoded bytes to store in the buffer.
  	 * @param [encoding] (default: 'raw', other: 'utf8').
  	 */
  	util$1.createBuffer = function(input, encoding) {
  	  // TODO: deprecate, use new ByteBuffer() instead
  	  encoding = encoding || 'raw';
  	  if(input !== undefined && encoding === 'utf8') {
  	    input = util$1.encodeUtf8(input);
  	  }
  	  return new util$1.ByteBuffer(input);
  	};

  	/**
  	 * Fills a string with a particular value. If you want the string to be a byte
  	 * string, pass in String.fromCharCode(theByte).
  	 *
  	 * @param c the character to fill the string with, use String.fromCharCode
  	 *          to fill the string with a byte value.
  	 * @param n the number of characters of value c to fill with.
  	 *
  	 * @return the filled string.
  	 */
  	util$1.fillString = function(c, n) {
  	  var s = '';
  	  while(n > 0) {
  	    if(n & 1) {
  	      s += c;
  	    }
  	    n >>>= 1;
  	    if(n > 0) {
  	      c += c;
  	    }
  	  }
  	  return s;
  	};

  	/**
  	 * Performs a per byte XOR between two byte strings and returns the result as a
  	 * string of bytes.
  	 *
  	 * @param s1 first string of bytes.
  	 * @param s2 second string of bytes.
  	 * @param n the number of bytes to XOR.
  	 *
  	 * @return the XOR'd result.
  	 */
  	util$1.xorBytes = function(s1, s2, n) {
  	  var s3 = '';
  	  var b = '';
  	  var t = '';
  	  var i = 0;
  	  var c = 0;
  	  for(; n > 0; --n, ++i) {
  	    b = s1.charCodeAt(i) ^ s2.charCodeAt(i);
  	    if(c >= 10) {
  	      s3 += t;
  	      t = '';
  	      c = 0;
  	    }
  	    t += String.fromCharCode(b);
  	    ++c;
  	  }
  	  s3 += t;
  	  return s3;
  	};

  	/**
  	 * Converts a hex string into a 'binary' encoded string of bytes.
  	 *
  	 * @param hex the hexadecimal string to convert.
  	 *
  	 * @return the binary-encoded string of bytes.
  	 */
  	util$1.hexToBytes = function(hex) {
  	  // TODO: deprecate: "Deprecated. Use util.binary.hex.decode instead."
  	  var rval = '';
  	  var i = 0;
  	  if(hex.length & 1 == 1) {
  	    // odd number of characters, convert first character alone
  	    i = 1;
  	    rval += String.fromCharCode(parseInt(hex[0], 16));
  	  }
  	  // convert 2 characters (1 byte) at a time
  	  for(; i < hex.length; i += 2) {
  	    rval += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
  	  }
  	  return rval;
  	};

  	/**
  	 * Converts a 'binary' encoded string of bytes to hex.
  	 *
  	 * @param bytes the byte string to convert.
  	 *
  	 * @return the string of hexadecimal characters.
  	 */
  	util$1.bytesToHex = function(bytes) {
  	  // TODO: deprecate: "Deprecated. Use util.binary.hex.encode instead."
  	  return util$1.createBuffer(bytes).toHex();
  	};

  	/**
  	 * Converts an 32-bit integer to 4-big-endian byte string.
  	 *
  	 * @param i the integer.
  	 *
  	 * @return the byte string.
  	 */
  	util$1.int32ToBytes = function(i) {
  	  return (
  	    String.fromCharCode(i >> 24 & 0xFF) +
  	    String.fromCharCode(i >> 16 & 0xFF) +
  	    String.fromCharCode(i >> 8 & 0xFF) +
  	    String.fromCharCode(i & 0xFF));
  	};

  	// base64 characters, reverse mapping
  	var _base64 =
  	  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
  	var _base64Idx = [
  	/*43 -43 = 0*/
  	/*'+',  1,  2,  3,'/' */
  	   62, -1, -1, -1, 63,

  	/*'0','1','2','3','4','5','6','7','8','9' */
  	   52, 53, 54, 55, 56, 57, 58, 59, 60, 61,

  	/*15, 16, 17,'=', 19, 20, 21 */
  	  -1, -1, -1, 64, -1, -1, -1,

  	/*65 - 43 = 22*/
  	/*'A','B','C','D','E','F','G','H','I','J','K','L','M', */
  	   0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12,

  	/*'N','O','P','Q','R','S','T','U','V','W','X','Y','Z' */
  	   13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,

  	/*91 - 43 = 48 */
  	/*48, 49, 50, 51, 52, 53 */
  	  -1, -1, -1, -1, -1, -1,

  	/*97 - 43 = 54*/
  	/*'a','b','c','d','e','f','g','h','i','j','k','l','m' */
  	   26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,

  	/*'n','o','p','q','r','s','t','u','v','w','x','y','z' */
  	   39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51
  	];

  	// base58 characters (Bitcoin alphabet)
  	var _base58 = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';

  	/**
  	 * Base64 encodes a 'binary' encoded string of bytes.
  	 *
  	 * @param input the binary encoded string of bytes to base64-encode.
  	 * @param maxline the maximum number of encoded characters per line to use,
  	 *          defaults to none.
  	 *
  	 * @return the base64-encoded output.
  	 */
  	util$1.encode64 = function(input, maxline) {
  	  // TODO: deprecate: "Deprecated. Use util.binary.base64.encode instead."
  	  var line = '';
  	  var output = '';
  	  var chr1, chr2, chr3;
  	  var i = 0;
  	  while(i < input.length) {
  	    chr1 = input.charCodeAt(i++);
  	    chr2 = input.charCodeAt(i++);
  	    chr3 = input.charCodeAt(i++);

  	    // encode 4 character group
  	    line += _base64.charAt(chr1 >> 2);
  	    line += _base64.charAt(((chr1 & 3) << 4) | (chr2 >> 4));
  	    if(isNaN(chr2)) {
  	      line += '==';
  	    } else {
  	      line += _base64.charAt(((chr2 & 15) << 2) | (chr3 >> 6));
  	      line += isNaN(chr3) ? '=' : _base64.charAt(chr3 & 63);
  	    }

  	    if(maxline && line.length > maxline) {
  	      output += line.substr(0, maxline) + '\r\n';
  	      line = line.substr(maxline);
  	    }
  	  }
  	  output += line;
  	  return output;
  	};

  	/**
  	 * Base64 decodes a string into a 'binary' encoded string of bytes.
  	 *
  	 * @param input the base64-encoded input.
  	 *
  	 * @return the binary encoded string.
  	 */
  	util$1.decode64 = function(input) {
  	  // TODO: deprecate: "Deprecated. Use util.binary.base64.decode instead."

  	  // remove all non-base64 characters
  	  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');

  	  var output = '';
  	  var enc1, enc2, enc3, enc4;
  	  var i = 0;

  	  while(i < input.length) {
  	    enc1 = _base64Idx[input.charCodeAt(i++) - 43];
  	    enc2 = _base64Idx[input.charCodeAt(i++) - 43];
  	    enc3 = _base64Idx[input.charCodeAt(i++) - 43];
  	    enc4 = _base64Idx[input.charCodeAt(i++) - 43];

  	    output += String.fromCharCode((enc1 << 2) | (enc2 >> 4));
  	    if(enc3 !== 64) {
  	      // decoded at least 2 bytes
  	      output += String.fromCharCode(((enc2 & 15) << 4) | (enc3 >> 2));
  	      if(enc4 !== 64) {
  	        // decoded 3 bytes
  	        output += String.fromCharCode(((enc3 & 3) << 6) | enc4);
  	      }
  	    }
  	  }

  	  return output;
  	};

  	/**
  	 * Encodes the given string of characters (a standard JavaScript
  	 * string) as a binary encoded string where the bytes represent
  	 * a UTF-8 encoded string of characters. Non-ASCII characters will be
  	 * encoded as multiple bytes according to UTF-8.
  	 *
  	 * @param str a standard string of characters to encode.
  	 *
  	 * @return the binary encoded string.
  	 */
  	util$1.encodeUtf8 = function(str) {
  	  return unescape(encodeURIComponent(str));
  	};

  	/**
  	 * Decodes a binary encoded string that contains bytes that
  	 * represent a UTF-8 encoded string of characters -- into a
  	 * string of characters (a standard JavaScript string).
  	 *
  	 * @param str the binary encoded string to decode.
  	 *
  	 * @return the resulting standard string of characters.
  	 */
  	util$1.decodeUtf8 = function(str) {
  	  return decodeURIComponent(escape(str));
  	};

  	// binary encoding/decoding tools
  	// FIXME: Experimental. Do not use yet.
  	util$1.binary = {
  	  raw: {},
  	  hex: {},
  	  base64: {},
  	  base58: {},
  	  baseN : {
  	    encode: baseN.encode,
  	    decode: baseN.decode
  	  }
  	};

  	/**
  	 * Encodes a Uint8Array as a binary-encoded string. This encoding uses
  	 * a value between 0 and 255 for each character.
  	 *
  	 * @param bytes the Uint8Array to encode.
  	 *
  	 * @return the binary-encoded string.
  	 */
  	util$1.binary.raw.encode = function(bytes) {
  	  return String.fromCharCode.apply(null, bytes);
  	};

  	/**
  	 * Decodes a binary-encoded string to a Uint8Array. This encoding uses
  	 * a value between 0 and 255 for each character.
  	 *
  	 * @param str the binary-encoded string to decode.
  	 * @param [output] an optional Uint8Array to write the output to; if it
  	 *          is too small, an exception will be thrown.
  	 * @param [offset] the start offset for writing to the output (default: 0).
  	 *
  	 * @return the Uint8Array or the number of bytes written if output was given.
  	 */
  	util$1.binary.raw.decode = function(str, output, offset) {
  	  var out = output;
  	  if(!out) {
  	    out = new Uint8Array(str.length);
  	  }
  	  offset = offset || 0;
  	  var j = offset;
  	  for(var i = 0; i < str.length; ++i) {
  	    out[j++] = str.charCodeAt(i);
  	  }
  	  return output ? (j - offset) : out;
  	};

  	/**
  	 * Encodes a 'binary' string, ArrayBuffer, DataView, TypedArray, or
  	 * ByteBuffer as a string of hexadecimal characters.
  	 *
  	 * @param bytes the bytes to convert.
  	 *
  	 * @return the string of hexadecimal characters.
  	 */
  	util$1.binary.hex.encode = util$1.bytesToHex;

  	/**
  	 * Decodes a hex-encoded string to a Uint8Array.
  	 *
  	 * @param hex the hexadecimal string to convert.
  	 * @param [output] an optional Uint8Array to write the output to; if it
  	 *          is too small, an exception will be thrown.
  	 * @param [offset] the start offset for writing to the output (default: 0).
  	 *
  	 * @return the Uint8Array or the number of bytes written if output was given.
  	 */
  	util$1.binary.hex.decode = function(hex, output, offset) {
  	  var out = output;
  	  if(!out) {
  	    out = new Uint8Array(Math.ceil(hex.length / 2));
  	  }
  	  offset = offset || 0;
  	  var i = 0, j = offset;
  	  if(hex.length & 1) {
  	    // odd number of characters, convert first character alone
  	    i = 1;
  	    out[j++] = parseInt(hex[0], 16);
  	  }
  	  // convert 2 characters (1 byte) at a time
  	  for(; i < hex.length; i += 2) {
  	    out[j++] = parseInt(hex.substr(i, 2), 16);
  	  }
  	  return output ? (j - offset) : out;
  	};

  	/**
  	 * Base64-encodes a Uint8Array.
  	 *
  	 * @param input the Uint8Array to encode.
  	 * @param maxline the maximum number of encoded characters per line to use,
  	 *          defaults to none.
  	 *
  	 * @return the base64-encoded output string.
  	 */
  	util$1.binary.base64.encode = function(input, maxline) {
  	  var line = '';
  	  var output = '';
  	  var chr1, chr2, chr3;
  	  var i = 0;
  	  while(i < input.byteLength) {
  	    chr1 = input[i++];
  	    chr2 = input[i++];
  	    chr3 = input[i++];

  	    // encode 4 character group
  	    line += _base64.charAt(chr1 >> 2);
  	    line += _base64.charAt(((chr1 & 3) << 4) | (chr2 >> 4));
  	    if(isNaN(chr2)) {
  	      line += '==';
  	    } else {
  	      line += _base64.charAt(((chr2 & 15) << 2) | (chr3 >> 6));
  	      line += isNaN(chr3) ? '=' : _base64.charAt(chr3 & 63);
  	    }

  	    if(maxline && line.length > maxline) {
  	      output += line.substr(0, maxline) + '\r\n';
  	      line = line.substr(maxline);
  	    }
  	  }
  	  output += line;
  	  return output;
  	};

  	/**
  	 * Decodes a base64-encoded string to a Uint8Array.
  	 *
  	 * @param input the base64-encoded input string.
  	 * @param [output] an optional Uint8Array to write the output to; if it
  	 *          is too small, an exception will be thrown.
  	 * @param [offset] the start offset for writing to the output (default: 0).
  	 *
  	 * @return the Uint8Array or the number of bytes written if output was given.
  	 */
  	util$1.binary.base64.decode = function(input, output, offset) {
  	  var out = output;
  	  if(!out) {
  	    out = new Uint8Array(Math.ceil(input.length / 4) * 3);
  	  }

  	  // remove all non-base64 characters
  	  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');

  	  offset = offset || 0;
  	  var enc1, enc2, enc3, enc4;
  	  var i = 0, j = offset;

  	  while(i < input.length) {
  	    enc1 = _base64Idx[input.charCodeAt(i++) - 43];
  	    enc2 = _base64Idx[input.charCodeAt(i++) - 43];
  	    enc3 = _base64Idx[input.charCodeAt(i++) - 43];
  	    enc4 = _base64Idx[input.charCodeAt(i++) - 43];

  	    out[j++] = (enc1 << 2) | (enc2 >> 4);
  	    if(enc3 !== 64) {
  	      // decoded at least 2 bytes
  	      out[j++] = ((enc2 & 15) << 4) | (enc3 >> 2);
  	      if(enc4 !== 64) {
  	        // decoded 3 bytes
  	        out[j++] = ((enc3 & 3) << 6) | enc4;
  	      }
  	    }
  	  }

  	  // make sure result is the exact decoded length
  	  return output ? (j - offset) : out.subarray(0, j);
  	};

  	// add support for base58 encoding/decoding with Bitcoin alphabet
  	util$1.binary.base58.encode = function(input, maxline) {
  	  return util$1.binary.baseN.encode(input, _base58, maxline);
  	};
  	util$1.binary.base58.decode = function(input, maxline) {
  	  return util$1.binary.baseN.decode(input, _base58, maxline);
  	};

  	// text encoding/decoding tools
  	// FIXME: Experimental. Do not use yet.
  	util$1.text = {
  	  utf8: {},
  	  utf16: {}
  	};

  	/**
  	 * Encodes the given string as UTF-8 in a Uint8Array.
  	 *
  	 * @param str the string to encode.
  	 * @param [output] an optional Uint8Array to write the output to; if it
  	 *          is too small, an exception will be thrown.
  	 * @param [offset] the start offset for writing to the output (default: 0).
  	 *
  	 * @return the Uint8Array or the number of bytes written if output was given.
  	 */
  	util$1.text.utf8.encode = function(str, output, offset) {
  	  str = util$1.encodeUtf8(str);
  	  var out = output;
  	  if(!out) {
  	    out = new Uint8Array(str.length);
  	  }
  	  offset = offset || 0;
  	  var j = offset;
  	  for(var i = 0; i < str.length; ++i) {
  	    out[j++] = str.charCodeAt(i);
  	  }
  	  return output ? (j - offset) : out;
  	};

  	/**
  	 * Decodes the UTF-8 contents from a Uint8Array.
  	 *
  	 * @param bytes the Uint8Array to decode.
  	 *
  	 * @return the resulting string.
  	 */
  	util$1.text.utf8.decode = function(bytes) {
  	  return util$1.decodeUtf8(String.fromCharCode.apply(null, bytes));
  	};

  	/**
  	 * Encodes the given string as UTF-16 in a Uint8Array.
  	 *
  	 * @param str the string to encode.
  	 * @param [output] an optional Uint8Array to write the output to; if it
  	 *          is too small, an exception will be thrown.
  	 * @param [offset] the start offset for writing to the output (default: 0).
  	 *
  	 * @return the Uint8Array or the number of bytes written if output was given.
  	 */
  	util$1.text.utf16.encode = function(str, output, offset) {
  	  var out = output;
  	  if(!out) {
  	    out = new Uint8Array(str.length * 2);
  	  }
  	  var view = new Uint16Array(out.buffer);
  	  offset = offset || 0;
  	  var j = offset;
  	  var k = offset;
  	  for(var i = 0; i < str.length; ++i) {
  	    view[k++] = str.charCodeAt(i);
  	    j += 2;
  	  }
  	  return output ? (j - offset) : out;
  	};

  	/**
  	 * Decodes the UTF-16 contents from a Uint8Array.
  	 *
  	 * @param bytes the Uint8Array to decode.
  	 *
  	 * @return the resulting string.
  	 */
  	util$1.text.utf16.decode = function(bytes) {
  	  return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));
  	};

  	/**
  	 * Deflates the given data using a flash interface.
  	 *
  	 * @param api the flash interface.
  	 * @param bytes the data.
  	 * @param raw true to return only raw deflate data, false to include zlib
  	 *          header and trailer.
  	 *
  	 * @return the deflated data as a string.
  	 */
  	util$1.deflate = function(api, bytes, raw) {
  	  bytes = util$1.decode64(api.deflate(util$1.encode64(bytes)).rval);

  	  // strip zlib header and trailer if necessary
  	  if(raw) {
  	    // zlib header is 2 bytes (CMF,FLG) where FLG indicates that
  	    // there is a 4-byte DICT (alder-32) block before the data if
  	    // its 5th bit is set
  	    var start = 2;
  	    var flg = bytes.charCodeAt(1);
  	    if(flg & 0x20) {
  	      start = 6;
  	    }
  	    // zlib trailer is 4 bytes of adler-32
  	    bytes = bytes.substring(start, bytes.length - 4);
  	  }

  	  return bytes;
  	};

  	/**
  	 * Inflates the given data using a flash interface.
  	 *
  	 * @param api the flash interface.
  	 * @param bytes the data.
  	 * @param raw true if the incoming data has no zlib header or trailer and is
  	 *          raw DEFLATE data.
  	 *
  	 * @return the inflated data as a string, null on error.
  	 */
  	util$1.inflate = function(api, bytes, raw) {
  	  // TODO: add zlib header and trailer if necessary/possible
  	  var rval = api.inflate(util$1.encode64(bytes)).rval;
  	  return (rval === null) ? null : util$1.decode64(rval);
  	};

  	/**
  	 * Sets a storage object.
  	 *
  	 * @param api the storage interface.
  	 * @param id the storage ID to use.
  	 * @param obj the storage object, null to remove.
  	 */
  	var _setStorageObject = function(api, id, obj) {
  	  if(!api) {
  	    throw new Error('WebStorage not available.');
  	  }

  	  var rval;
  	  if(obj === null) {
  	    rval = api.removeItem(id);
  	  } else {
  	    // json-encode and base64-encode object
  	    obj = util$1.encode64(JSON.stringify(obj));
  	    rval = api.setItem(id, obj);
  	  }

  	  // handle potential flash error
  	  if(typeof(rval) !== 'undefined' && rval.rval !== true) {
  	    var error = new Error(rval.error.message);
  	    error.id = rval.error.id;
  	    error.name = rval.error.name;
  	    throw error;
  	  }
  	};

  	/**
  	 * Gets a storage object.
  	 *
  	 * @param api the storage interface.
  	 * @param id the storage ID to use.
  	 *
  	 * @return the storage object entry or null if none exists.
  	 */
  	var _getStorageObject = function(api, id) {
  	  if(!api) {
  	    throw new Error('WebStorage not available.');
  	  }

  	  // get the existing entry
  	  var rval = api.getItem(id);

  	  /* Note: We check api.init because we can't do (api == localStorage)
  	    on IE because of "Class doesn't support Automation" exception. Only
  	    the flash api has an init method so this works too, but we need a
  	    better solution in the future. */

  	  // flash returns item wrapped in an object, handle special case
  	  if(api.init) {
  	    if(rval.rval === null) {
  	      if(rval.error) {
  	        var error = new Error(rval.error.message);
  	        error.id = rval.error.id;
  	        error.name = rval.error.name;
  	        throw error;
  	      }
  	      // no error, but also no item
  	      rval = null;
  	    } else {
  	      rval = rval.rval;
  	    }
  	  }

  	  // handle decoding
  	  if(rval !== null) {
  	    // base64-decode and json-decode data
  	    rval = JSON.parse(util$1.decode64(rval));
  	  }

  	  return rval;
  	};

  	/**
  	 * Stores an item in local storage.
  	 *
  	 * @param api the storage interface.
  	 * @param id the storage ID to use.
  	 * @param key the key for the item.
  	 * @param data the data for the item (any javascript object/primitive).
  	 */
  	var _setItem = function(api, id, key, data) {
  	  // get storage object
  	  var obj = _getStorageObject(api, id);
  	  if(obj === null) {
  	    // create a new storage object
  	    obj = {};
  	  }
  	  // update key
  	  obj[key] = data;

  	  // set storage object
  	  _setStorageObject(api, id, obj);
  	};

  	/**
  	 * Gets an item from local storage.
  	 *
  	 * @param api the storage interface.
  	 * @param id the storage ID to use.
  	 * @param key the key for the item.
  	 *
  	 * @return the item.
  	 */
  	var _getItem = function(api, id, key) {
  	  // get storage object
  	  var rval = _getStorageObject(api, id);
  	  if(rval !== null) {
  	    // return data at key
  	    rval = (key in rval) ? rval[key] : null;
  	  }

  	  return rval;
  	};

  	/**
  	 * Removes an item from local storage.
  	 *
  	 * @param api the storage interface.
  	 * @param id the storage ID to use.
  	 * @param key the key for the item.
  	 */
  	var _removeItem = function(api, id, key) {
  	  // get storage object
  	  var obj = _getStorageObject(api, id);
  	  if(obj !== null && key in obj) {
  	    // remove key
  	    delete obj[key];

  	    // see if entry has no keys remaining
  	    var empty = true;
  	    for(var prop in obj) {
  	      empty = false;
  	      break;
  	    }
  	    if(empty) {
  	      // remove entry entirely if no keys are left
  	      obj = null;
  	    }

  	    // set storage object
  	    _setStorageObject(api, id, obj);
  	  }
  	};

  	/**
  	 * Clears the local disk storage identified by the given ID.
  	 *
  	 * @param api the storage interface.
  	 * @param id the storage ID to use.
  	 */
  	var _clearItems = function(api, id) {
  	  _setStorageObject(api, id, null);
  	};

  	/**
  	 * Calls a storage function.
  	 *
  	 * @param func the function to call.
  	 * @param args the arguments for the function.
  	 * @param location the location argument.
  	 *
  	 * @return the return value from the function.
  	 */
  	var _callStorageFunction = function(func, args, location) {
  	  var rval = null;

  	  // default storage types
  	  if(typeof(location) === 'undefined') {
  	    location = ['web', 'flash'];
  	  }

  	  // apply storage types in order of preference
  	  var type;
  	  var done = false;
  	  var exception = null;
  	  for(var idx in location) {
  	    type = location[idx];
  	    try {
  	      if(type === 'flash' || type === 'both') {
  	        if(args[0] === null) {
  	          throw new Error('Flash local storage not available.');
  	        }
  	        rval = func.apply(this, args);
  	        done = (type === 'flash');
  	      }
  	      if(type === 'web' || type === 'both') {
  	        args[0] = localStorage;
  	        rval = func.apply(this, args);
  	        done = true;
  	      }
  	    } catch(ex) {
  	      exception = ex;
  	    }
  	    if(done) {
  	      break;
  	    }
  	  }

  	  if(!done) {
  	    throw exception;
  	  }

  	  return rval;
  	};

  	/**
  	 * Stores an item on local disk.
  	 *
  	 * The available types of local storage include 'flash', 'web', and 'both'.
  	 *
  	 * The type 'flash' refers to flash local storage (SharedObject). In order
  	 * to use flash local storage, the 'api' parameter must be valid. The type
  	 * 'web' refers to WebStorage, if supported by the browser. The type 'both'
  	 * refers to storing using both 'flash' and 'web', not just one or the
  	 * other.
  	 *
  	 * The location array should list the storage types to use in order of
  	 * preference:
  	 *
  	 * ['flash']: flash only storage
  	 * ['web']: web only storage
  	 * ['both']: try to store in both
  	 * ['flash','web']: store in flash first, but if not available, 'web'
  	 * ['web','flash']: store in web first, but if not available, 'flash'
  	 *
  	 * The location array defaults to: ['web', 'flash']
  	 *
  	 * @param api the flash interface, null to use only WebStorage.
  	 * @param id the storage ID to use.
  	 * @param key the key for the item.
  	 * @param data the data for the item (any javascript object/primitive).
  	 * @param location an array with the preferred types of storage to use.
  	 */
  	util$1.setItem = function(api, id, key, data, location) {
  	  _callStorageFunction(_setItem, arguments, location);
  	};

  	/**
  	 * Gets an item on local disk.
  	 *
  	 * Set setItem() for details on storage types.
  	 *
  	 * @param api the flash interface, null to use only WebStorage.
  	 * @param id the storage ID to use.
  	 * @param key the key for the item.
  	 * @param location an array with the preferred types of storage to use.
  	 *
  	 * @return the item.
  	 */
  	util$1.getItem = function(api, id, key, location) {
  	  return _callStorageFunction(_getItem, arguments, location);
  	};

  	/**
  	 * Removes an item on local disk.
  	 *
  	 * Set setItem() for details on storage types.
  	 *
  	 * @param api the flash interface.
  	 * @param id the storage ID to use.
  	 * @param key the key for the item.
  	 * @param location an array with the preferred types of storage to use.
  	 */
  	util$1.removeItem = function(api, id, key, location) {
  	  _callStorageFunction(_removeItem, arguments, location);
  	};

  	/**
  	 * Clears the local disk storage identified by the given ID.
  	 *
  	 * Set setItem() for details on storage types.
  	 *
  	 * @param api the flash interface if flash is available.
  	 * @param id the storage ID to use.
  	 * @param location an array with the preferred types of storage to use.
  	 */
  	util$1.clearItems = function(api, id, location) {
  	  _callStorageFunction(_clearItems, arguments, location);
  	};

  	/**
  	 * Check if an object is empty.
  	 *
  	 * Taken from:
  	 * http://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object-from-json/679937#679937
  	 *
  	 * @param object the object to check.
  	 */
  	util$1.isEmpty = function(obj) {
  	  for(var prop in obj) {
  	    if(obj.hasOwnProperty(prop)) {
  	      return false;
  	    }
  	  }
  	  return true;
  	};

  	/**
  	 * Format with simple printf-style interpolation.
  	 *
  	 * %%: literal '%'
  	 * %s,%o: convert next argument into a string.
  	 *
  	 * @param format the string to format.
  	 * @param ... arguments to interpolate into the format string.
  	 */
  	util$1.format = function(format) {
  	  var re = /%./g;
  	  // current match
  	  var match;
  	  // current part
  	  var part;
  	  // current arg index
  	  var argi = 0;
  	  // collected parts to recombine later
  	  var parts = [];
  	  // last index found
  	  var last = 0;
  	  // loop while matches remain
  	  while((match = re.exec(format))) {
  	    part = format.substring(last, re.lastIndex - 2);
  	    // don't add empty strings (ie, parts between %s%s)
  	    if(part.length > 0) {
  	      parts.push(part);
  	    }
  	    last = re.lastIndex;
  	    // switch on % code
  	    var code = match[0][1];
  	    switch(code) {
  	    case 's':
  	    case 'o':
  	      // check if enough arguments were given
  	      if(argi < arguments.length) {
  	        parts.push(arguments[argi++ + 1]);
  	      } else {
  	        parts.push('<?>');
  	      }
  	      break;
  	    // FIXME: do proper formating for numbers, etc
  	    //case 'f':
  	    //case 'd':
  	    case '%':
  	      parts.push('%');
  	      break;
  	    default:
  	      parts.push('<%' + code + '?>');
  	    }
  	  }
  	  // add trailing part of format string
  	  parts.push(format.substring(last));
  	  return parts.join('');
  	};

  	/**
  	 * Formats a number.
  	 *
  	 * http://snipplr.com/view/5945/javascript-numberformat--ported-from-php/
  	 */
  	util$1.formatNumber = function(number, decimals, dec_point, thousands_sep) {
  	  // http://kevin.vanzonneveld.net
  	  // +   original by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)
  	  // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
  	  // +     bugfix by: Michael White (http://crestidg.com)
  	  // +     bugfix by: Benjamin Lupton
  	  // +     bugfix by: Allan Jensen (http://www.winternet.no)
  	  // +    revised by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)
  	  // *     example 1: number_format(1234.5678, 2, '.', '');
  	  // *     returns 1: 1234.57

  	  var n = number, c = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;
  	  var d = dec_point === undefined ? ',' : dec_point;
  	  var t = thousands_sep === undefined ?
  	   '.' : thousands_sep, s = n < 0 ? '-' : '';
  	  var i = parseInt((n = Math.abs(+n || 0).toFixed(c)), 10) + '';
  	  var j = (i.length > 3) ? i.length % 3 : 0;
  	  return s + (j ? i.substr(0, j) + t : '') +
  	    i.substr(j).replace(/(\d{3})(?=\d)/g, '$1' + t) +
  	    (c ? d + Math.abs(n - i).toFixed(c).slice(2) : '');
  	};

  	/**
  	 * Formats a byte size.
  	 *
  	 * http://snipplr.com/view/5949/format-humanize-file-byte-size-presentation-in-javascript/
  	 */
  	util$1.formatSize = function(size) {
  	  if(size >= 1073741824) {
  	    size = util$1.formatNumber(size / 1073741824, 2, '.', '') + ' GiB';
  	  } else if(size >= 1048576) {
  	    size = util$1.formatNumber(size / 1048576, 2, '.', '') + ' MiB';
  	  } else if(size >= 1024) {
  	    size = util$1.formatNumber(size / 1024, 0) + ' KiB';
  	  } else {
  	    size = util$1.formatNumber(size, 0) + ' bytes';
  	  }
  	  return size;
  	};

  	/**
  	 * Converts an IPv4 or IPv6 string representation into bytes (in network order).
  	 *
  	 * @param ip the IPv4 or IPv6 address to convert.
  	 *
  	 * @return the 4-byte IPv6 or 16-byte IPv6 address or null if the address can't
  	 *         be parsed.
  	 */
  	util$1.bytesFromIP = function(ip) {
  	  if(ip.indexOf('.') !== -1) {
  	    return util$1.bytesFromIPv4(ip);
  	  }
  	  if(ip.indexOf(':') !== -1) {
  	    return util$1.bytesFromIPv6(ip);
  	  }
  	  return null;
  	};

  	/**
  	 * Converts an IPv4 string representation into bytes (in network order).
  	 *
  	 * @param ip the IPv4 address to convert.
  	 *
  	 * @return the 4-byte address or null if the address can't be parsed.
  	 */
  	util$1.bytesFromIPv4 = function(ip) {
  	  ip = ip.split('.');
  	  if(ip.length !== 4) {
  	    return null;
  	  }
  	  var b = util$1.createBuffer();
  	  for(var i = 0; i < ip.length; ++i) {
  	    var num = parseInt(ip[i], 10);
  	    if(isNaN(num)) {
  	      return null;
  	    }
  	    b.putByte(num);
  	  }
  	  return b.getBytes();
  	};

  	/**
  	 * Converts an IPv6 string representation into bytes (in network order).
  	 *
  	 * @param ip the IPv6 address to convert.
  	 *
  	 * @return the 16-byte address or null if the address can't be parsed.
  	 */
  	util$1.bytesFromIPv6 = function(ip) {
  	  var blanks = 0;
  	  ip = ip.split(':').filter(function(e) {
  	    if(e.length === 0) ++blanks;
  	    return true;
  	  });
  	  var zeros = (8 - ip.length + blanks) * 2;
  	  var b = util$1.createBuffer();
  	  for(var i = 0; i < 8; ++i) {
  	    if(!ip[i] || ip[i].length === 0) {
  	      b.fillWithByte(0, zeros);
  	      zeros = 0;
  	      continue;
  	    }
  	    var bytes = util$1.hexToBytes(ip[i]);
  	    if(bytes.length < 2) {
  	      b.putByte(0);
  	    }
  	    b.putBytes(bytes);
  	  }
  	  return b.getBytes();
  	};

  	/**
  	 * Converts 4-bytes into an IPv4 string representation or 16-bytes into
  	 * an IPv6 string representation. The bytes must be in network order.
  	 *
  	 * @param bytes the bytes to convert.
  	 *
  	 * @return the IPv4 or IPv6 string representation if 4 or 16 bytes,
  	 *         respectively, are given, otherwise null.
  	 */
  	util$1.bytesToIP = function(bytes) {
  	  if(bytes.length === 4) {
  	    return util$1.bytesToIPv4(bytes);
  	  }
  	  if(bytes.length === 16) {
  	    return util$1.bytesToIPv6(bytes);
  	  }
  	  return null;
  	};

  	/**
  	 * Converts 4-bytes into an IPv4 string representation. The bytes must be
  	 * in network order.
  	 *
  	 * @param bytes the bytes to convert.
  	 *
  	 * @return the IPv4 string representation or null for an invalid # of bytes.
  	 */
  	util$1.bytesToIPv4 = function(bytes) {
  	  if(bytes.length !== 4) {
  	    return null;
  	  }
  	  var ip = [];
  	  for(var i = 0; i < bytes.length; ++i) {
  	    ip.push(bytes.charCodeAt(i));
  	  }
  	  return ip.join('.');
  	};

  	/**
  	 * Converts 16-bytes into an IPv16 string representation. The bytes must be
  	 * in network order.
  	 *
  	 * @param bytes the bytes to convert.
  	 *
  	 * @return the IPv16 string representation or null for an invalid # of bytes.
  	 */
  	util$1.bytesToIPv6 = function(bytes) {
  	  if(bytes.length !== 16) {
  	    return null;
  	  }
  	  var ip = [];
  	  var zeroGroups = [];
  	  var zeroMaxGroup = 0;
  	  for(var i = 0; i < bytes.length; i += 2) {
  	    var hex = util$1.bytesToHex(bytes[i] + bytes[i + 1]);
  	    // canonicalize zero representation
  	    while(hex[0] === '0' && hex !== '0') {
  	      hex = hex.substr(1);
  	    }
  	    if(hex === '0') {
  	      var last = zeroGroups[zeroGroups.length - 1];
  	      var idx = ip.length;
  	      if(!last || idx !== last.end + 1) {
  	        zeroGroups.push({start: idx, end: idx});
  	      } else {
  	        last.end = idx;
  	        if((last.end - last.start) >
  	          (zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start)) {
  	          zeroMaxGroup = zeroGroups.length - 1;
  	        }
  	      }
  	    }
  	    ip.push(hex);
  	  }
  	  if(zeroGroups.length > 0) {
  	    var group = zeroGroups[zeroMaxGroup];
  	    // only shorten group of length > 0
  	    if(group.end - group.start > 0) {
  	      ip.splice(group.start, group.end - group.start + 1, '');
  	      if(group.start === 0) {
  	        ip.unshift('');
  	      }
  	      if(group.end === 7) {
  	        ip.push('');
  	      }
  	    }
  	  }
  	  return ip.join(':');
  	};

  	/**
  	 * Estimates the number of processes that can be run concurrently. If
  	 * creating Web Workers, keep in mind that the main JavaScript process needs
  	 * its own core.
  	 *
  	 * @param options the options to use:
  	 *          update true to force an update (not use the cached value).
  	 * @param callback(err, max) called once the operation completes.
  	 */
  	util$1.estimateCores = function(options, callback) {
  	  if(typeof options === 'function') {
  	    callback = options;
  	    options = {};
  	  }
  	  options = options || {};
  	  if('cores' in util$1 && !options.update) {
  	    return callback(null, util$1.cores);
  	  }
  	  if(typeof navigator !== 'undefined' &&
  	    'hardwareConcurrency' in navigator &&
  	    navigator.hardwareConcurrency > 0) {
  	    util$1.cores = navigator.hardwareConcurrency;
  	    return callback(null, util$1.cores);
  	  }
  	  if(typeof Worker === 'undefined') {
  	    // workers not available
  	    util$1.cores = 1;
  	    return callback(null, util$1.cores);
  	  }
  	  if(typeof Blob === 'undefined') {
  	    // can't estimate, default to 2
  	    util$1.cores = 2;
  	    return callback(null, util$1.cores);
  	  }

  	  // create worker concurrency estimation code as blob
  	  var blobUrl = URL.createObjectURL(new Blob(['(',
  	    function() {
  	      self.addEventListener('message', function(e) {
  	        // run worker for 4 ms
  	        var st = Date.now();
  	        var et = st + 4;
  	        self.postMessage({st: st, et: et});
  	      });
  	    }.toString(),
  	  ')()'], {type: 'application/javascript'}));

  	  // take 5 samples using 16 workers
  	  sample([], 5, 16);

  	  function sample(max, samples, numWorkers) {
  	    if(samples === 0) {
  	      // get overlap average
  	      var avg = Math.floor(max.reduce(function(avg, x) {
  	        return avg + x;
  	      }, 0) / max.length);
  	      util$1.cores = Math.max(1, avg);
  	      URL.revokeObjectURL(blobUrl);
  	      return callback(null, util$1.cores);
  	    }
  	    map(numWorkers, function(err, results) {
  	      max.push(reduce(numWorkers, results));
  	      sample(max, samples - 1, numWorkers);
  	    });
  	  }

  	  function map(numWorkers, callback) {
  	    var workers = [];
  	    var results = [];
  	    for(var i = 0; i < numWorkers; ++i) {
  	      var worker = new Worker(blobUrl);
  	      worker.addEventListener('message', function(e) {
  	        results.push(e.data);
  	        if(results.length === numWorkers) {
  	          for(var i = 0; i < numWorkers; ++i) {
  	            workers[i].terminate();
  	          }
  	          callback(null, results);
  	        }
  	      });
  	      workers.push(worker);
  	    }
  	    for(var i = 0; i < numWorkers; ++i) {
  	      workers[i].postMessage(i);
  	    }
  	  }

  	  function reduce(numWorkers, results) {
  	    // find overlapping time windows
  	    var overlaps = [];
  	    for(var n = 0; n < numWorkers; ++n) {
  	      var r1 = results[n];
  	      var overlap = overlaps[n] = [];
  	      for(var i = 0; i < numWorkers; ++i) {
  	        if(n === i) {
  	          continue;
  	        }
  	        var r2 = results[i];
  	        if((r1.st > r2.st && r1.st < r2.et) ||
  	          (r2.st > r1.st && r2.st < r1.et)) {
  	          overlap.push(i);
  	        }
  	      }
  	    }
  	    // get maximum overlaps ... don't include overlapping worker itself
  	    // as the main JS process was also being scheduled during the work and
  	    // would have to be subtracted from the estimate anyway
  	    return overlaps.reduce(function(max, overlap) {
  	      return Math.max(max, overlap.length);
  	    }, 0);
  	  }
  	};
  	return util.exports;
  }

  /**
   * Javascript implementation of basic PEM (Privacy Enhanced Mail) algorithms.
   *
   * See: RFC 1421.
   *
   * @author Dave Longley
   *
   * Copyright (c) 2013-2014 Digital Bazaar, Inc.
   *
   * A Forge PEM object has the following fields:
   *
   * type: identifies the type of message (eg: "RSA PRIVATE KEY").
   *
   * procType: identifies the type of processing performed on the message,
   *   it has two subfields: version and type, eg: 4,ENCRYPTED.
   *
   * contentDomain: identifies the type of content in the message, typically
   *   only uses the value: "RFC822".
   *
   * dekInfo: identifies the message encryption algorithm and mode and includes
   *   any parameters for the algorithm, it has two subfields: algorithm and
   *   parameters, eg: DES-CBC,F8143EDE5960C597.
   *
   * headers: contains all other PEM encapsulated headers -- where order is
   *   significant (for pairing data like recipient ID + key info).
   *
   * body: the binary-encoded body.
   */

  var hasRequiredPem;

  function requirePem () {
  	if (hasRequiredPem) return pem.exports;
  	hasRequiredPem = 1;
  	var forge = requireForge();
  	requireUtil();

  	// shortcut for pem API
  	var pem$1 = pem.exports = forge.pem = forge.pem || {};

  	/**
  	 * Encodes (serializes) the given PEM object.
  	 *
  	 * @param msg the PEM message object to encode.
  	 * @param options the options to use:
  	 *          maxline the maximum characters per line for the body, (default: 64).
  	 *
  	 * @return the PEM-formatted string.
  	 */
  	pem$1.encode = function(msg, options) {
  	  options = options || {};
  	  var rval = '-----BEGIN ' + msg.type + '-----\r\n';

  	  // encode special headers
  	  var header;
  	  if(msg.procType) {
  	    header = {
  	      name: 'Proc-Type',
  	      values: [String(msg.procType.version), msg.procType.type]
  	    };
  	    rval += foldHeader(header);
  	  }
  	  if(msg.contentDomain) {
  	    header = {name: 'Content-Domain', values: [msg.contentDomain]};
  	    rval += foldHeader(header);
  	  }
  	  if(msg.dekInfo) {
  	    header = {name: 'DEK-Info', values: [msg.dekInfo.algorithm]};
  	    if(msg.dekInfo.parameters) {
  	      header.values.push(msg.dekInfo.parameters);
  	    }
  	    rval += foldHeader(header);
  	  }

  	  if(msg.headers) {
  	    // encode all other headers
  	    for(var i = 0; i < msg.headers.length; ++i) {
  	      rval += foldHeader(msg.headers[i]);
  	    }
  	  }

  	  // terminate header
  	  if(msg.procType) {
  	    rval += '\r\n';
  	  }

  	  // add body
  	  rval += forge.util.encode64(msg.body, options.maxline || 64) + '\r\n';

  	  rval += '-----END ' + msg.type + '-----\r\n';
  	  return rval;
  	};

  	/**
  	 * Decodes (deserializes) all PEM messages found in the given string.
  	 *
  	 * @param str the PEM-formatted string to decode.
  	 *
  	 * @return the PEM message objects in an array.
  	 */
  	pem$1.decode = function(str) {
  	  var rval = [];

  	  // split string into PEM messages (be lenient w/EOF on BEGIN line)
  	  var rMessage = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g;
  	  var rHeader = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/;
  	  var rCRLF = /\r?\n/;
  	  var match;
  	  while(true) {
  	    match = rMessage.exec(str);
  	    if(!match) {
  	      break;
  	    }

  	    // accept "NEW CERTIFICATE REQUEST" as "CERTIFICATE REQUEST"
  	    // https://datatracker.ietf.org/doc/html/rfc7468#section-7
  	    var type = match[1];
  	    if(type === 'NEW CERTIFICATE REQUEST') {
  	      type = 'CERTIFICATE REQUEST';
  	    }

  	    var msg = {
  	      type: type,
  	      procType: null,
  	      contentDomain: null,
  	      dekInfo: null,
  	      headers: [],
  	      body: forge.util.decode64(match[3])
  	    };
  	    rval.push(msg);

  	    // no headers
  	    if(!match[2]) {
  	      continue;
  	    }

  	    // parse headers
  	    var lines = match[2].split(rCRLF);
  	    var li = 0;
  	    while(match && li < lines.length) {
  	      // get line, trim any rhs whitespace
  	      var line = lines[li].replace(/\s+$/, '');

  	      // RFC2822 unfold any following folded lines
  	      for(var nl = li + 1; nl < lines.length; ++nl) {
  	        var next = lines[nl];
  	        if(!/\s/.test(next[0])) {
  	          break;
  	        }
  	        line += next;
  	        li = nl;
  	      }

  	      // parse header
  	      match = line.match(rHeader);
  	      if(match) {
  	        var header = {name: match[1], values: []};
  	        var values = match[2].split(',');
  	        for(var vi = 0; vi < values.length; ++vi) {
  	          header.values.push(ltrim(values[vi]));
  	        }

  	        // Proc-Type must be the first header
  	        if(!msg.procType) {
  	          if(header.name !== 'Proc-Type') {
  	            throw new Error('Invalid PEM formatted message. The first ' +
  	              'encapsulated header must be "Proc-Type".');
  	          } else if(header.values.length !== 2) {
  	            throw new Error('Invalid PEM formatted message. The "Proc-Type" ' +
  	              'header must have two subfields.');
  	          }
  	          msg.procType = {version: values[0], type: values[1]};
  	        } else if(!msg.contentDomain && header.name === 'Content-Domain') {
  	          // special-case Content-Domain
  	          msg.contentDomain = values[0] || '';
  	        } else if(!msg.dekInfo && header.name === 'DEK-Info') {
  	          // special-case DEK-Info
  	          if(header.values.length === 0) {
  	            throw new Error('Invalid PEM formatted message. The "DEK-Info" ' +
  	              'header must have at least one subfield.');
  	          }
  	          msg.dekInfo = {algorithm: values[0], parameters: values[1] || null};
  	        } else {
  	          msg.headers.push(header);
  	        }
  	      }

  	      ++li;
  	    }

  	    if(msg.procType === 'ENCRYPTED' && !msg.dekInfo) {
  	      throw new Error('Invalid PEM formatted message. The "DEK-Info" ' +
  	        'header must be present if "Proc-Type" is "ENCRYPTED".');
  	    }
  	  }

  	  if(rval.length === 0) {
  	    throw new Error('Invalid PEM formatted message.');
  	  }

  	  return rval;
  	};

  	function foldHeader(header) {
  	  var rval = header.name + ': ';

  	  // ensure values with CRLF are folded
  	  var values = [];
  	  var insertSpace = function(match, $1) {
  	    return ' ' + $1;
  	  };
  	  for(var i = 0; i < header.values.length; ++i) {
  	    values.push(header.values[i].replace(/^(\S+\r\n)/, insertSpace));
  	  }
  	  rval += values.join(',') + '\r\n';

  	  // do folding
  	  var length = 0;
  	  var candidate = -1;
  	  for(var i = 0; i < rval.length; ++i, ++length) {
  	    if(length > 65 && candidate !== -1) {
  	      var insert = rval[candidate];
  	      if(insert === ',') {
  	        ++candidate;
  	        rval = rval.substr(0, candidate) + '\r\n ' + rval.substr(candidate);
  	      } else {
  	        rval = rval.substr(0, candidate) +
  	          '\r\n' + insert + rval.substr(candidate + 1);
  	      }
  	      length = (i - candidate - 1);
  	      candidate = -1;
  	      ++i;
  	    } else if(rval[i] === ' ' || rval[i] === '\t' || rval[i] === ',') {
  	      candidate = i;
  	    }
  	  }

  	  return rval;
  	}

  	function ltrim(str) {
  	  return str.replace(/^\s+/, '');
  	}
  	return pem.exports;
  }

  var pemExports = requirePem();
  var pemForge = /*@__PURE__*/getDefaultExportFromCjs(pemExports);

  const ID_ED25519 = "1.3.101.112";

  /**
   * @param {string} pem
   * @param {string} [passphrase]
   * @returns {Promise<Ed25519PrivateKey | EcdsaPrivateKey | Uint8Array>}
   */
  async function readPemED25519(pem, passphrase) {
      const pemKeyData = pem.replace(
          /-----BEGIN (.*)-----|-----END (.*)-----|\n|\r/g,
          "",
      );

      const key = decode$3(pemKeyData);
      if (passphrase) {
          let encrypted;

          try {
              encrypted = EncryptedPrivateKeyInfo.parse(key);
          } catch (error) {
              const message =
                  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                  error != null && /** @type {Error} */ (error).message != null
                      ? // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                        /** @type {Error} */ (error).message
                      : "";

              throw new BadKeyError(
                  `failed to parse encrypted private key: ${message}`,
              );
          }

          const decrypted = await encrypted.decrypt(passphrase);

          let privateKey = null;

          if (decrypted.algId.algIdent === ID_ED25519) {
              privateKey = Ed25519PrivateKey;
          } else {
              throw new BadKeyError(
                  `unknown private key algorithm ${decrypted.algId.toString()}`,
              );
          }

          const keyData = decode$4(decrypted.privateKey);

          if (!("bytes" in keyData)) {
              throw new BadKeyError(
                  `expected ASN bytes, got ${JSON.stringify(keyData)}`,
              );
          }

          return privateKey.fromBytes(keyData.bytes);
      }

      return key.subarray(16);
  }

  /**
   * @param {string} pem
   * @param {string} [passphrase]
   * @returns {Promise<Ed25519PrivateKey | EcdsaPrivateKey | Uint8Array>}
   */
  async function readPemECDSA(pem, passphrase) {
      const pemKeyData = pem.replace(
          /-----BEGIN (.*)-----|-----END (.*)-----|\n|\r/g,
          "",
      );
      const key = decode$3(pemKeyData);

      if (passphrase) {
          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call
          const decodedPem = pemForge.decode(pem)[0];
          /** @type {string} */
          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-assignment
          const ivString = decodedPem.dekInfo.parameters;
          const iv = decode$6(ivString);
          const pemLines = pem.split("\n");
          const key = await messageDigest(passphrase, ivString);
          const dataToDecrypt = bufferExports.Buffer.from(
              pemLines.slice(4, pemLines.length - 1).join(""),
              "base64",
          );
          const keyDerBytes = await createDecipheriv(
              CipherAlgorithm.Aes128Cbc,
              key,
              iv,
              dataToDecrypt,
          );

          return EcdsaPrivateKey.fromBytesDer(keyDerBytes);
      } else {
          const asnData = fromBER(key);
          const parsedKey = asnData.result;

          // @ts-ignore
          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-return
          return parsedKey.valueBlock.value[1].valueBlock.valueHexView;
      }
  }

  /**
   * @param {string} pem
   * @param {string} [passphrase]
   * @returns {Promise<Ed25519PrivateKey | EcdsaPrivateKey | Uint8Array>}
   */
  async function read(pem, passphrase) {
      // If not then it is ED25519 type
      const isEcdsa = pem.includes("BEGIN EC PRIVATE KEY") ? true : false;
      if (isEcdsa) {
          return readPemECDSA(pem, passphrase);
      } else {
          return readPemED25519(pem, passphrase);
      }
  }

  /**
   * @param {Uint8Array} seed
   * @param {number} index
   * @returns {Promise<Uint8Array>}
   */
  function legacy(seed, index) {
      const password = new Uint8Array(seed.length + 8);
      password.set(seed, 0);

      const view = new DataView(
          password.buffer,
          password.byteOffset,
          password.byteLength,
      );

      if (index === 0xffffffffff) {
          view.setInt32(seed.length + 0, 0xff);
          view.setInt32(seed.length + 4, -1); // 0xffffffff
      } else {
          view.setInt32(seed.length + 0, index < 0 ? -1 : 0);
          view.setInt32(seed.length + 4, index);
      }

      const salt = Uint8Array.from([0xff]);
      return deriveKey(
          HashAlgorithm.Sha512,
          password,
          salt,
          2048,
          32,
      );
  }

  /**
   * @typedef {import("./PrivateKey.js").default} PrivateKey
   * @typedef {import("./Ed25519PrivateKey.js").default} Ed25519PrivateKey
   * @typedef {import("./EcdsaPrivateKey.js").default} EcdsaPrivateKey
   * @typedef {import("./Mnemonic.js").default} Mnemonic
   */

  const CACHE$1 = {
      /** @type {((key: Ed25519PrivateKey | EcdsaPrivateKey) => PrivateKey) | null} */
      privateKeyConstructor: null,

      /** @type {((bytes: Uint8Array) => PrivateKey) | null} */
      privateKeyFromBytes: null,

      /** @type {((words: string) => Mnemonic) | null} */
      mnemonicFromString: null,
  };

  /**
   * @typedef {object} ProtoSignaturePair
   * @property {(Uint8Array | null)=} pubKeyPrefix
   * @property {(Uint8Array | null)=} ed25519
   * @property {(Uint8Array | null)=} ECDSASecp256k1
   */

  /**
   * @typedef {object} ProtoSigMap
   * @property {(ProtoSignaturePair[] | null)=} sigPair
   */

  /**
   * @typedef {object} ProtoSignedTransaction
   * @property {(Uint8Array | null)=} bodyBytes
   * @property {(ProtoSigMap | null)=} sigMap
   */

  /**
   * @typedef {object} Transaction
   * @property {() => boolean} isFrozen
   * @property {ProtoSignedTransaction[]} _signedTransactions
   * @property {Set<string>} _signerPublicKeys
   * @property {(publicKey: PublicKey, signature: Uint8Array) => Transaction} addSignature
   * @property {() => void} _requireFrozen
   * @property {() => Transaction} freeze
   */

  /**
   * @typedef {import("./Mnemonic.js").default} Mnemonic
   */

  /**
   * A private key on the Hedera network.
   */
  let PrivateKey$1 = class PrivateKey extends Key$1 {
      /**
       * @hideconstructor
       * @internal
       * @param {Ed25519PrivateKey | EcdsaPrivateKey} key
       */
      constructor(key) {
          super();

          /**
           * @type {Ed25519PrivateKey | EcdsaPrivateKey}
           * @readonly
           * @private
           */
          this._key = key;
      }

      /**
       * @returns {string}
       */
      get _type() {
          return this._key._type;
      }

      /**
       * @returns {Uint8Array | null}
       */
      get _chainCode() {
          return this._key._chainCode;
      }

      /**
       * Generate a random Ed25519 private key.
       * @returns {PrivateKey}
       */
      static generateED25519() {
          return new PrivateKey(Ed25519PrivateKey.generate());
      }

      /**
       * Generate a random EDSA private key.
       * @returns {PrivateKey}
       */
      static generateECDSA() {
          return new PrivateKey(EcdsaPrivateKey.generate());
      }

      /**
       * Depredated - Use `generateED25519()` instead
       * Generate a random Ed25519 private key.
       * @returns {PrivateKey}
       */
      static generate() {
          return PrivateKey.generateED25519();
      }

      /**
       * Depredated - Use `generateED25519Async()` instead
       * Generate a random Ed25519 private key.
       * @returns {Promise<PrivateKey>}
       */
      static async generateAsync() {
          return PrivateKey.generateED25519Async();
      }

      /**
       * Generate a random Ed25519 private key.
       * @returns {Promise<PrivateKey>}
       */
      static async generateED25519Async() {
          return new PrivateKey(await Ed25519PrivateKey.generateAsync());
      }

      /**
       * Generate a random ECDSA private key.
       * @returns {Promise<PrivateKey>}
       */
      static async generateECDSAAsync() {
          return new PrivateKey(await EcdsaPrivateKey.generateAsync());
      }

      /**
       * Construct a private key from bytes. Requires DER header.
       * @param {Uint8Array} data
       * @returns {PrivateKey}
       */
      static fromBytes(data) {
          let message;

          if (data.length == 32) {
              console.warn(
                  "WARNING: Consider using fromStringECDSA() or fromStringED25519() on a HEX-encoded string and fromStringDer() on a HEX-encoded string with DER prefix instead.",
              );
          }

          try {
              return new PrivateKey(Ed25519PrivateKey.fromBytes(data));
          } catch (error) {
              message =
                  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                  error != null && /** @type {Error} */ (error).message != null
                      ? // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                        /** @type {Error} */ (error).message
                      : "";
          }

          try {
              return new PrivateKey(EcdsaPrivateKey.fromBytes(data));
          } catch (error) {
              message =
                  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                  error != null && /** @type {Error} */ (error).message != null
                      ? // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                        /** @type {Error} */ (error).message
                      : "";
          }

          throw new BadKeyError(
              `private key cannot be decoded from bytes: ${message}`,
          );
      }

      /**
       * Construct a ECDSA private key from bytes.
       * @param {Uint8Array} data
       * @returns {PrivateKey}
       */
      static fromBytesECDSA(data) {
          return new PrivateKey(EcdsaPrivateKey.fromBytes(data));
      }

      /**
       * Construct a ED25519 private key from bytes.
       * @param {Uint8Array} data
       * @returns {PrivateKey}
       */
      static fromBytesED25519(data) {
          return new PrivateKey(Ed25519PrivateKey.fromBytes(data));
      }

      /**
       * Construct a private key from a hex-encoded string. Requires DER header.
       * @param {string} text
       * @returns {PrivateKey}
       */
      static fromString(text) {
          return PrivateKey.fromBytes(decode$6(text));
      }

      /**
       * Construct a ECDSA private key from a hex-encoded string.
       * @param {string} text
       * @returns {PrivateKey}
       */
      static fromStringECDSA(text) {
          return PrivateKey.fromBytesECDSA(decode$6(text));
      }

      /**
       * Construct a Ed25519 private key from a hex-encoded string.
       * @param {string} text
       * @returns {PrivateKey}
       */
      static fromStringED25519(text) {
          return PrivateKey.fromBytesED25519(decode$6(text));
      }

      /**
       * Construct a Ed25519 private key from a Uint8Array seed.
       * @param {Uint8Array} seed
       * @returns {Promise<PrivateKey>}
       */
      static async fromSeedED25519(seed) {
          const ed25519Key = await Ed25519PrivateKey.fromSeed(seed);
          return new PrivateKey(ed25519Key);
      }

      /**
       * Construct a ECDSA private key from a Uint8Array seed.
       * @param {Uint8Array} seed
       * @returns {Promise<PrivateKey>}
       */
      static async fromSeedECDSAsecp256k1(seed) {
          const ecdsaKey = await EcdsaPrivateKey.fromSeed(seed);
          return new PrivateKey(ecdsaKey);
      }

      /**
       * @deprecated - Use `Mnemonic.from[Words|String]().toStandard[Ed25519|ECDSAsecp256k1]PrivateKey()` instead
       *
       * Recover a private key from a mnemonic phrase (and optionally a password).
       * @param {Mnemonic | string} mnemonic
       * @param {string} [passphrase]
       * @returns {Promise<PrivateKey>}
       */
      static async fromMnemonic(mnemonic, passphrase = "") {
          if (CACHE$1.mnemonicFromString == null) {
              throw new Error("Mnemonic not found in cache");
          }

          return (
              (
                  typeof mnemonic === "string"
                      ? CACHE$1.mnemonicFromString(mnemonic)
                      : mnemonic
              )
                  // eslint-disable-next-line deprecation/deprecation
                  .toEd25519PrivateKey(passphrase)
          );
      }

      /**
       * Recover a private key from a keystore, previously created by `.toKeystore()`.
       *
       * This key will _not_ support child key derivation.
       * @param {Uint8Array} data
       * @param {string} [passphrase]
       * @returns {Promise<PrivateKey>}
       * @throws {BadKeyError} If the passphrase is incorrect or the hash fails to validate.
       */
      static async fromKeystore(data, passphrase = "") {
          return PrivateKey.fromBytes(await loadKeystore(data, passphrase));
      }

      /**
       * Recover a private key from a pem string; the private key may be encrypted.
       *
       * This method assumes the .pem file has been converted to a string already.
       *
       * If `passphrase` is not null or empty, this looks for the first `ENCRYPTED PRIVATE KEY`
       * section and uses `passphrase` to decrypt it; otherwise, it looks for the first `PRIVATE KEY`
       * section and decodes that as a DER-encoded  private key.
       * @param {string} data
       * @param {string} [passphrase]
       * @returns {Promise<PrivateKey>}
       */
      static async fromPem(data, passphrase = "") {
          const pem = await read(data, passphrase);

          if (
              pem instanceof Ed25519PrivateKey ||
              pem instanceof EcdsaPrivateKey
          ) {
              return new PrivateKey(pem);
          }

          const isEcdsa = data.includes("BEGIN EC PRIVATE KEY") ? true : false;
          if (isEcdsa) {
              return new PrivateKey(EcdsaPrivateKey.fromBytes(pem));
          } else {
              return new PrivateKey(Ed25519PrivateKey.fromBytes(pem));
          }
      }

      /**
       * Derive a new private key at the given wallet index.
       *
       * Only currently supported for keys created with from mnemonics; other keys will throw
       * an error.
       *
       * You can check if a key supports derivation with `.supportsDerivation()`
       * @param {number} index
       * @returns {Promise<PrivateKey>}
       * @throws If this key does not support derivation.
       */
      async derive(index) {
          if (this._key._chainCode == null) {
              throw new Error("this private key does not support key derivation");
          }

          if (this._key instanceof Ed25519PrivateKey) {
              const { keyData, chainCode } = await derive(
                  this.toBytesRaw(),
                  this._key._chainCode,
                  index,
              );

              return new PrivateKey(new Ed25519PrivateKey(keyData, chainCode));
          } else {
              const { keyData, chainCode } = await derive$1(
                  this.toBytesRaw(),
                  this._key._chainCode,
                  index,
              );

              return new PrivateKey(
                  new EcdsaPrivateKey(fromBytes(keyData), chainCode),
              );
          }
      }

      /**
       * @param {number} index
       * @returns {Promise<PrivateKey>}
       * @throws If this key does not support derivation.
       */
      async legacyDerive(index) {
          const keyBytes = await legacy(
              this.toBytesRaw().subarray(0, 32),
              index,
          );

          /** @type {new (bytes: Uint8Array) => Ed25519PrivateKey | EcdsaPrivateKey} */
          const constructor = /** @type {any} */ (this._key.constructor);

          // eslint-disable-next-line @typescript-eslint/no-unsafe-call
          return new PrivateKey(new constructor(keyBytes));
      }

      /**
       * Get the public key associated with this private key.
       *
       * The public key can be freely given and used by other parties to verify
       * the signatures generated by this private key.
       * @returns {PublicKey}
       */
      get publicKey() {
          return new PublicKey$1(this._key.publicKey);
      }

      /**
       * Sign a message with this private key.
       * @param {Uint8Array} bytes
       * @returns {Uint8Array} - The signature bytes without the message
       */
      sign(bytes) {
          return this._key.sign(bytes);
      }

      /**
       * @param {Transaction} transaction
       * @returns {Uint8Array}
       */
      signTransaction(transaction) {
          if (!transaction.isFrozen()) {
              transaction.freeze();
          }

          if (transaction._signedTransactions.length != 1) {
              throw new Error(
                  "`PrivateKey.signTransaction()` requires `Transaction` to have a single node `AccountId` set",
              );
          }

          const tx = /** @type {ProtoSignedTransaction} */ (
              transaction._signedTransactions[0]
          );

          const publicKeyHex = encode$3(this.publicKey.toBytesRaw());

          if (tx.sigMap == null) {
              tx.sigMap = {};
          }

          if (tx.sigMap.sigPair == null) {
              tx.sigMap.sigPair = [];
          }

          for (const sigPair of tx.sigMap.sigPair) {
              if (
                  sigPair.pubKeyPrefix != null &&
                  encode$3(sigPair.pubKeyPrefix) === publicKeyHex
              ) {
                  switch (this._type) {
                      case "ED25519":
                          return /** @type {Uint8Array} */ (sigPair.ed25519);
                      case "secp256k1":
                          return /** @type {Uint8Array} */ (
                              sigPair.ECDSASecp256k1
                          );
                  }
              }
          }

          const siganture = this.sign(
              tx.bodyBytes != null ? tx.bodyBytes : new Uint8Array(),
          );

          /** @type {ProtoSignaturePair} */
          const protoSignature = {
              pubKeyPrefix: this.publicKey.toBytesRaw(),
          };

          switch (this._type) {
              case "ED25519":
                  protoSignature.ed25519 = siganture;
                  break;
              case "secp256k1":
                  protoSignature.ECDSASecp256k1 = siganture;
                  break;
          }

          tx.sigMap.sigPair.push(protoSignature);
          transaction._signerPublicKeys.add(publicKeyHex);

          return siganture;
      }

      /**
       * Check if `derive` can be called on this private key.
       *
       * This is only the case if the key was created from a mnemonic.
       * @returns {boolean}
       */
      isDerivable() {
          return this._key._chainCode != null;
      }

      /**
       * @returns {Uint8Array}
       */
      toBytes() {
          if (this._key instanceof Ed25519PrivateKey) {
              return this.toBytesRaw();
          } else {
              return this.toBytesDer();
          }
      }

      /**
       * @returns {Uint8Array}
       */
      toBytesDer() {
          return this._key.toBytesDer();
      }

      /**
       * @returns {Uint8Array}
       */
      toBytesRaw() {
          return this._key.toBytesRaw();
      }

      /**
       * @returns {string}
       */
      toString() {
          return this.toStringDer();
      }

      /**
       * @returns {string}
       */
      toStringDer() {
          return encode$3(this.toBytesDer());
      }

      /**
       * @returns {string}
       */
      toStringRaw() {
          return encode$3(this.toBytesRaw());
      }

      /**
       * Create a keystore with a given passphrase.
       *
       * The key can be recovered later with `fromKeystore()`.
       *
       * Note that this will not retain the ancillary data used for
       * deriving child keys, thus `.derive()` on the restored key will
       * throw even if this instance supports derivation.
       * @param {string} [passphrase]
       * @returns {Promise<Uint8Array>}
       */
      toKeystore(passphrase = "") {
          return createKeystore(this.toBytesRaw(), passphrase);
      }

      /**
       * Recover the recovery ID used in the signature for the given message.
       *
       * **Note:** This method only works for ECDSA secp256k1 keys.
       * @param {Uint8Array} r - 32-byte `r` component of the signature
       * @param {Uint8Array} s - 32-byte `s` component of the signature
       * @param {Uint8Array} message - The original (unhashed) message
       * @returns {number} Recovery ID (03), or -1 if not found or not applicable
       */
      getRecoveryId(r, s, message) {
          if (!(this._key instanceof EcdsaPrivateKey)) {
              throw new Error("Invalid key type, must be ECDSA secp256k1.");
          }

          if (r.length !== 32 || s.length !== 32) {
              throw new Error("Invalid signature components.");
          }

          const signature = new Uint8Array(64);

          signature.set(r, 0);
          signature.set(s, 32);

          return this._key.getRecoveryId(signature, message);
      }
  };

  CACHE$1.privateKeyConstructor = (key) => new PrivateKey$1(key);
  CACHE$1.privateKeyFromBytes = (bytes) => PrivateKey$1.fromBytes(bytes);

  /**
   * Possible statuses for {@link Mnemonic#validate()}.
   * @readonly
   * @enum {string}
   */
  const BadMnemonicReason = Object.freeze({
      /**
       * The mnemonic did not have a supported number of words (12 or 24 for regular and 22 for legacy).
       */
      BadLength: "BadLength",

      /**
       * The mnemonic contained words which were not found in the word list.
       */
      UnknownWords: "UnknownWords",

      /**
       * The checksum encoded in the mnemonic did not match the checksum we just calculated for
       * that mnemonic.
       *
       * 24-word mnemonics have an 8-bit checksum that is appended to the 32 bytes of source entropy
       * after being calculated from it, before being encoded into words.
       *
       * This could happen if two or more of the words were entered out of the original order or
       * replaced with another from the standard word list (as this is only returned if all the words
       * exist in the word list).
       */
      ChecksumMismatch: "ChecksumMismatch",
  });

  /** @typedef {import("./Mnemonic.js").default} Mnemonic */

  class BadMnemonicError extends Error {
      /**
       * @param {Mnemonic} mnemonic
       * @param {string} reason
       * @param {number[]} unknownWordIndices
       * @hideconstructor
       */
      constructor(mnemonic, reason, unknownWordIndices) {
          let reasonMessage;

          switch (reason) {
              case BadMnemonicReason.BadLength:
                  reasonMessage = "mnemonic is of an unexpected number of words";
                  break;

              case BadMnemonicReason.ChecksumMismatch:
                  reasonMessage =
                      "checksum byte in mnemonic did not match the rest of the mnemonic";
                  break;

              case BadMnemonicReason.UnknownWords:
                  reasonMessage =
                      "mnemonic contained words that are not in the standard word list";
                  break;

              default:
                  throw new Error(
                      `unexpected value ${reason.toString()} for 'reason'`,
                  );
          }

          super(`invalid mnemonic: ${reasonMessage}`);

          if (typeof Error.captureStackTrace !== "undefined") {
              Error.captureStackTrace(this, BadMnemonicError);
          }

          this.name = "BadMnemonicError";

          /** The reason for which the mnemonic failed validation. */
          this.reason = reason;

          /** The mnemonic that failed validation. */
          this.mnemonic = mnemonic;

          /**
           * The indices in the mnemonic that were not found in the BIP-39
           * standard English word list.
           */
          this.unknownWordIndices = unknownWordIndices;
      }
  }

  var legacyWords = [
      "aback",
      "abbey",
      "abbot",
      "abide",
      "ablaze",
      "able",
      "aboard",
      "abode",
      "abort",
      "abound",
      "about",
      "above",
      "abroad",
      "abrupt",
      "absent",
      "absorb",
      "absurd",
      "abuse",
      "accent",
      "accept",
      "access",
      "accord",
      "accuse",
      "ace",
      "ache",
      "aching",
      "acid",
      "acidic",
      "acorn",
      "acre",
      "across",
      "act",
      "action",
      "active",
      "actor",
      "actual",
      "acute",
      "adam",
      "adapt",
      "add",
      "added",
      "addict",
      "adept",
      "adhere",
      "adjust",
      "admire",
      "admit",
      "adobe",
      "adopt",
      "adrift",
      "adult",
      "adverb",
      "advice",
      "aerial",
      "afar",
      "affair",
      "affect",
      "afford",
      "afghan",
      "afield",
      "afloat",
      "afraid",
      "afresh",
      "after",
      "again",
      "age",
      "agency",
      "agenda",
      "agent",
      "aghast",
      "agile",
      "ago",
      "agony",
      "agree",
      "agreed",
      "ahead",
      "aid",
      "aide",
      "aim",
      "air",
      "airman",
      "airy",
      "akin",
      "alarm",
      "alaska",
      "albeit",
      "album",
      "ale",
      "alert",
      "alibi",
      "alice",
      "alien",
      "alight",
      "align",
      "alike",
      "alive",
      "alkali",
      "all",
      "alley",
      "allied",
      "allow",
      "alloy",
      "ally",
      "almond",
      "almost",
      "aloft",
      "alone",
      "along",
      "aloof",
      "aloud",
      "alpha",
      "alpine",
      "also",
      "altar",
      "alter",
      "always",
      "amaze",
      "amazon",
      "amber",
      "ambush",
      "amen",
      "amend",
      "amid",
      "amidst",
      "amiss",
      "among",
      "amount",
      "ample",
      "amuse",
      "anchor",
      "and",
      "andrew",
      "anew",
      "angel",
      "anger",
      "angle",
      "angry",
      "animal",
      "ankle",
      "annoy",
      "annual",
      "answer",
      "anthem",
      "any",
      "anyhow",
      "anyway",
      "apart",
      "apathy",
      "apex",
      "apiece",
      "appeal",
      "appear",
      "apple",
      "apply",
      "april",
      "apron",
      "arab",
      "arcade",
      "arcane",
      "arch",
      "arctic",
      "ardent",
      "are",
      "area",
      "argue",
      "arid",
      "arise",
      "ark",
      "arm",
      "armful",
      "army",
      "aroma",
      "around",
      "arouse",
      "array",
      "arrest",
      "arrive",
      "arrow",
      "arson",
      "art",
      "artery",
      "artful",
      "artist",
      "ascent",
      "ash",
      "ashen",
      "ashore",
      "aside",
      "ask",
      "asleep",
      "aspect",
      "assay",
      "assent",
      "assert",
      "assess",
      "asset",
      "assign",
      "assist",
      "assume",
      "assure",
      "asthma",
      "astute",
      "asylum",
      "ate",
      "athens",
      "atlas",
      "atom",
      "atomic",
      "attach",
      "attack",
      "attain",
      "attend",
      "attic",
      "auburn",
      "audio",
      "audit",
      "august",
      "aunt",
      "auntie",
      "aura",
      "austin",
      "author",
      "auto",
      "autumn",
      "avail",
      "avenge",
      "avenue",
      "avert",
      "avid",
      "avoid",
      "await",
      "awake",
      "awaken",
      "award",
      "aware",
      "awash",
      "away",
      "awful",
      "awhile",
      "axe",
      "axes",
      "axiom",
      "axis",
      "axle",
      "aye",
      "babe",
      "baby",
      "bach",
      "back",
      "backup",
      "bacon",
      "bad",
      "badge",
      "badly",
      "bag",
      "baggy",
      "bail",
      "bait",
      "bake",
      "baker",
      "bakery",
      "bald",
      "ball",
      "ballad",
      "ballet",
      "ballot",
      "baltic",
      "bamboo",
      "ban",
      "banal",
      "banana",
      "band",
      "bang",
      "bank",
      "bar",
      "barber",
      "bare",
      "barely",
      "barge",
      "bark",
      "barley",
      "barn",
      "baron",
      "barrel",
      "barren",
      "basalt",
      "base",
      "basic",
      "basil",
      "basin",
      "basis",
      "basket",
      "bass",
      "bat",
      "batch",
      "bath",
      "baton",
      "battle",
      "bay",
      "beach",
      "beacon",
      "beak",
      "beam",
      "bean",
      "bear",
      "beard",
      "beast",
      "beat",
      "beauty",
      "become",
      "bed",
      "beech",
      "beef",
      "beefy",
      "beep",
      "beer",
      "beet",
      "beetle",
      "before",
      "beg",
      "beggar",
      "begin",
      "behalf",
      "behave",
      "behind",
      "beige",
      "being",
      "belief",
      "bell",
      "belly",
      "belong",
      "below",
      "belt",
      "bench",
      "bend",
      "benign",
      "bent",
      "berlin",
      "berry",
      "berth",
      "beset",
      "beside",
      "best",
      "bestow",
      "bet",
      "beta",
      "betray",
      "better",
      "beware",
      "beyond",
      "bias",
      "biceps",
      "bicker",
      "bid",
      "big",
      "bigger",
      "bike",
      "bile",
      "bill",
      "bin",
      "binary",
      "bind",
      "biopsy",
      "birch",
      "bird",
      "birdie",
      "birth",
      "bishop",
      "bit",
      "bitch",
      "bite",
      "bitter",
      "black",
      "blade",
      "blame",
      "bland",
      "blast",
      "blaze",
      "bleak",
      "blend",
      "bless",
      "blew",
      "blind",
      "blink",
      "blip",
      "bliss",
      "blitz",
      "block",
      "blond",
      "blood",
      "bloody",
      "bloom",
      "blot",
      "blouse",
      "blow",
      "blue",
      "bluff",
      "blunt",
      "blur",
      "blush",
      "boar",
      "board",
      "boast",
      "boat",
      "bob",
      "bodily",
      "body",
      "bogus",
      "boil",
      "bold",
      "bolt",
      "bomb",
      "bombay",
      "bond",
      "bone",
      "bonn",
      "bonnet",
      "bonus",
      "bony",
      "book",
      "boom",
      "boost",
      "boot",
      "booth",
      "booze",
      "border",
      "bore",
      "borrow",
      "bosom",
      "boss",
      "boston",
      "both",
      "bother",
      "bottle",
      "bottom",
      "bought",
      "bounce",
      "bound",
      "bounty",
      "bout",
      "bovine",
      "bow",
      "bowel",
      "bowl",
      "box",
      "boy",
      "boyish",
      "brace",
      "brain",
      "brainy",
      "brake",
      "bran",
      "branch",
      "brand",
      "brandy",
      "brass",
      "brave",
      "bravo",
      "brazil",
      "breach",
      "bread",
      "break",
      "breast",
      "breath",
      "bred",
      "breed",
      "breeze",
      "brew",
      "bribe",
      "brick",
      "bride",
      "bridge",
      "brief",
      "bright",
      "brim",
      "brine",
      "bring",
      "brink",
      "brisk",
      "broad",
      "broke",
      "broken",
      "bronze",
      "brook",
      "broom",
      "brown",
      "bruise",
      "brush",
      "brutal",
      "brute",
      "bubble",
      "buck",
      "bucket",
      "buckle",
      "budget",
      "buffet",
      "buggy",
      "build",
      "bulb",
      "bulge",
      "bulk",
      "bulky",
      "bull",
      "bullet",
      "bully",
      "bump",
      "bumpy",
      "bunch",
      "bundle",
      "bunk",
      "bunny",
      "burden",
      "bureau",
      "burial",
      "buried",
      "burly",
      "burn",
      "burnt",
      "burrow",
      "burst",
      "bury",
      "bus",
      "bush",
      "bust",
      "bustle",
      "busy",
      "but",
      "butler",
      "butt",
      "butter",
      "button",
      "buy",
      "buyer",
      "buzz",
      "bye",
      "byte",
      "cab",
      "cabin",
      "cable",
      "cache",
      "cactus",
      "caesar",
      "cage",
      "cairo",
      "cajun",
      "cajole",
      "cake",
      "calf",
      "call",
      "caller",
      "calm",
      "calmly",
      "came",
      "camel",
      "camera",
      "camp",
      "campus",
      "can",
      "canada",
      "canal",
      "canary",
      "cancel",
      "cancer",
      "candid",
      "candle",
      "candy",
      "cane",
      "canine",
      "canoe",
      "canopy",
      "canvas",
      "canyon",
      "cap",
      "cape",
      "car",
      "carbon",
      "card",
      "care",
      "career",
      "caress",
      "cargo",
      "carl",
      "carnal",
      "carol",
      "carp",
      "carpet",
      "carrot",
      "carry",
      "cart",
      "cartel",
      "case",
      "cash",
      "cask",
      "cast",
      "castle",
      "casual",
      "cat",
      "catch",
      "cater",
      "cattle",
      "caught",
      "causal",
      "cause",
      "cave",
      "cease",
      "celery",
      "cell",
      "cellar",
      "celtic",
      "cement",
      "censor",
      "census",
      "cent",
      "cereal",
      "chain",
      "chair",
      "chalk",
      "chalky",
      "champ",
      "chance",
      "change",
      "chant",
      "chaos",
      "chap",
      "chapel",
      "charge",
      "charm",
      "chart",
      "chase",
      "chat",
      "cheap",
      "cheat",
      "check",
      "cheek",
      "cheeky",
      "cheer",
      "cheery",
      "cheese",
      "chef",
      "cheque",
      "cherry",
      "chess",
      "chest",
      "chew",
      "chic",
      "chick",
      "chief",
      "child",
      "chile",
      "chill",
      "chilly",
      "chin",
      "china",
      "chip",
      "choice",
      "choir",
      "choose",
      "chop",
      "choppy",
      "chord",
      "chorus",
      "chose",
      "chosen",
      "chris",
      "chrome",
      "chunk",
      "chunky",
      "church",
      "cider",
      "cigar",
      "cinema",
      "circa",
      "circle",
      "circus",
      "cite",
      "city",
      "civic",
      "civil",
      "clad",
      "claim",
      "clammy",
      "clan",
      "clap",
      "clash",
      "clasp",
      "class",
      "clause",
      "claw",
      "clay",
      "clean",
      "clear",
      "clergy",
      "clerk",
      "clever",
      "click",
      "client",
      "cliff",
      "climax",
      "climb",
      "clinch",
      "cling",
      "clinic",
      "clip",
      "cloak",
      "clock",
      "clone",
      "close",
      "closer",
      "closet",
      "cloth",
      "cloud",
      "cloudy",
      "clout",
      "clown",
      "club",
      "clue",
      "clumsy",
      "clung",
      "clutch",
      "coach",
      "coal",
      "coarse",
      "coast",
      "coat",
      "coax",
      "cobalt",
      "cobra",
      "coca",
      "cock",
      "cocoa",
      "code",
      "coffee",
      "coffin",
      "cohort",
      "coil",
      "coin",
      "coke",
      "cold",
      "collar",
      "colon",
      "colony",
      "colt",
      "column",
      "comb",
      "combat",
      "come",
      "comedy",
      "comic",
      "commit",
      "common",
      "compel",
      "comply",
      "concur",
      "cone",
      "confer",
      "congo",
      "consul",
      "convex",
      "convey",
      "convoy",
      "cook",
      "cool",
      "cope",
      "copper",
      "copy",
      "coral",
      "cord",
      "core",
      "cork",
      "corn",
      "corner",
      "corps",
      "corpse",
      "corpus",
      "cortex",
      "cosmic",
      "cosmos",
      "cost",
      "costly",
      "cotton",
      "couch",
      "cough",
      "could",
      "count",
      "county",
      "coup",
      "couple",
      "coupon",
      "course",
      "court",
      "cousin",
      "cove",
      "cover",
      "covert",
      "cow",
      "coward",
      "cowboy",
      "cozy",
      "crab",
      "crack",
      "cradle",
      "craft",
      "crafty",
      "crag",
      "crane",
      "crash",
      "crate",
      "crater",
      "crawl",
      "crazy",
      "creak",
      "cream",
      "creamy",
      "create",
      "credit",
      "creed",
      "creek",
      "creep",
      "creepy",
      "crept",
      "crest",
      "crew",
      "cried",
      "crime",
      "crisis",
      "crisp",
      "critic",
      "crook",
      "crop",
      "cross",
      "crow",
      "crowd",
      "crown",
      "crude",
      "cruel",
      "cruise",
      "crunch",
      "crush",
      "crust",
      "crux",
      "cry",
      "crypt",
      "cuba",
      "cube",
      "cubic",
      "cuckoo",
      "cuff",
      "cult",
      "cup",
      "curb",
      "cure",
      "curfew",
      "curl",
      "curry",
      "curse",
      "cursor",
      "curve",
      "cuss",
      "custom",
      "cut",
      "cute",
      "cycle",
      "cyclic",
      "cynic",
      "czech",
      "dad",
      "daddy",
      "dagger",
      "daily",
      "dairy",
      "daisy",
      "dale",
      "dam",
      "damage",
      "damp",
      "dampen",
      "dance",
      "danger",
      "danish",
      "dare",
      "dark",
      "darken",
      "darn",
      "dart",
      "dash",
      "data",
      "date",
      "david",
      "dawn",
      "day",
      "dead",
      "deadly",
      "deaf",
      "deal",
      "dealer",
      "dean",
      "dear",
      "death",
      "debate",
      "debit",
      "debris",
      "debt",
      "debtor",
      "decade",
      "decay",
      "decent",
      "decide",
      "deck",
      "decor",
      "decree",
      "deduce",
      "deed",
      "deep",
      "deeply",
      "deer",
      "defeat",
      "defect",
      "defend",
      "defer",
      "define",
      "defy",
      "degree",
      "deity",
      "delay",
      "delete",
      "delhi",
      "delta",
      "demand",
      "demise",
      "demo",
      "demure",
      "denial",
      "denote",
      "dense",
      "dental",
      "deny",
      "depart",
      "depend",
      "depict",
      "deploy",
      "depot",
      "depth",
      "deputy",
      "derive",
      "desert",
      "design",
      "desire",
      "desist",
      "desk",
      "detail",
      "detect",
      "deter",
      "detest",
      "detour",
      "device",
      "devise",
      "devoid",
      "devote",
      "devour",
      "dial",
      "diana",
      "diary",
      "dice",
      "dictum",
      "did",
      "die",
      "diesel",
      "diet",
      "differ",
      "dig",
      "digest",
      "digit",
      "dine",
      "dinghy",
      "dinner",
      "diode",
      "dip",
      "dire",
      "direct",
      "dirt",
      "dirty",
      "disc",
      "disco",
      "dish",
      "disk",
      "dismal",
      "dispel",
      "ditch",
      "dive",
      "divert",
      "divide",
      "divine",
      "dizzy",
      "docile",
      "dock",
      "doctor",
      "dog",
      "dogma",
      "dole",
      "doll",
      "dollar",
      "dolly",
      "domain",
      "dome",
      "domino",
      "donate",
      "done",
      "donkey",
      "donor",
      "doom",
      "door",
      "dorsal",
      "dose",
      "dot",
      "double",
      "doubt",
      "dough",
      "dour",
      "dove",
      "down",
      "dozen",
      "draft",
      "drag",
      "dragon",
      "drain",
      "drama",
      "drank",
      "draw",
      "drawer",
      "dread",
      "dream",
      "dreary",
      "dress",
      "drew",
      "dried",
      "drift",
      "drill",
      "drink",
      "drip",
      "drive",
      "driver",
      "drop",
      "drove",
      "drown",
      "drug",
      "drum",
      "drunk",
      "dry",
      "dual",
      "duck",
      "duct",
      "due",
      "duel",
      "duet",
      "duke",
      "dull",
      "duly",
      "dumb",
      "dummy",
      "dump",
      "dune",
      "dung",
      "duress",
      "during",
      "dusk",
      "dust",
      "dusty",
      "dutch",
      "duty",
      "dwarf",
      "dwell",
      "dyer",
      "dying",
      "dynamo",
      "each",
      "eager",
      "eagle",
      "ear",
      "earl",
      "early",
      "earn",
      "earth",
      "ease",
      "easel",
      "easily",
      "east",
      "easter",
      "easy",
      "eat",
      "eaten",
      "eater",
      "echo",
      "eddy",
      "eden",
      "edge",
      "edible",
      "edict",
      "edit",
      "editor",
      "eel",
      "eerie",
      "eerily",
      "effect",
      "effort",
      "egg",
      "ego",
      "eight",
      "eighth",
      "eighty",
      "either",
      "elbow",
      "elder",
      "eldest",
      "elect",
      "eleven",
      "elicit",
      "elite",
      "else",
      "elude",
      "elves",
      "embark",
      "emblem",
      "embryo",
      "emerge",
      "emit",
      "empire",
      "employ",
      "empty",
      "enable",
      "enamel",
      "end",
      "endure",
      "enemy",
      "energy",
      "engage",
      "engine",
      "enjoy",
      "enlist",
      "enough",
      "ensure",
      "entail",
      "enter",
      "entire",
      "entry",
      "envoy",
      "envy",
      "enzyme",
      "epic",
      "epoch",
      "equal",
      "equate",
      "equip",
      "equity",
      "era",
      "erect",
      "eric",
      "erode",
      "erotic",
      "errant",
      "error",
      "escape",
      "escort",
      "essay",
      "essex",
      "estate",
      "esteem",
      "ethic",
      "ethnic",
      "europe",
      "evade",
      "eve",
      "even",
      "event",
      "ever",
      "every",
      "evict",
      "evil",
      "evoke",
      "evolve",
      "exact",
      "exam",
      "exceed",
      "excel",
      "except",
      "excess",
      "excise",
      "excite",
      "excuse",
      "exempt",
      "exert",
      "exile",
      "exist",
      "exit",
      "exodus",
      "exotic",
      "expand",
      "expect",
      "expert",
      "expire",
      "export",
      "expose",
      "extend",
      "extra",
      "eye",
      "eyed",
      "fabric",
      "face",
      "facial",
      "fact",
      "factor",
      "fade",
      "fail",
      "faint",
      "fair",
      "fairly",
      "fairy",
      "faith",
      "fake",
      "falcon",
      "fall",
      "false",
      "falter",
      "fame",
      "family",
      "famine",
      "famous",
      "fan",
      "fancy",
      "far",
      "farce",
      "fare",
      "farm",
      "farmer",
      "fast",
      "fasten",
      "faster",
      "fat",
      "fatal",
      "fate",
      "father",
      "fatty",
      "fault",
      "faulty",
      "fauna",
      "fear",
      "feast",
      "feat",
      "fed",
      "fee",
      "feeble",
      "feed",
      "feel",
      "feet",
      "fell",
      "fellow",
      "felt",
      "female",
      "fence",
      "fend",
      "ferry",
      "fetal",
      "fetch",
      "feudal",
      "fever",
      "few",
      "fewer",
      "fiasco",
      "fiddle",
      "field",
      "fiend",
      "fierce",
      "fiery",
      "fifth",
      "fifty",
      "fig",
      "fight",
      "figure",
      "file",
      "fill",
      "filled",
      "filler",
      "film",
      "filter",
      "filth",
      "filthy",
      "final",
      "finale",
      "find",
      "fine",
      "finery",
      "finger",
      "finish",
      "finite",
      "fire",
      "firm",
      "firmly",
      "first",
      "fiscal",
      "fish",
      "fisher",
      "fist",
      "fit",
      "fitful",
      "five",
      "fix",
      "flag",
      "flair",
      "flak",
      "flame",
      "flank",
      "flap",
      "flare",
      "flash",
      "flask",
      "flat",
      "flavor",
      "flaw",
      "fled",
      "flee",
      "fleece",
      "fleet",
      "flesh",
      "fleshy",
      "flew",
      "flick",
      "flight",
      "flimsy",
      "flint",
      "flirt",
      "float",
      "flock",
      "flood",
      "floor",
      "floppy",
      "flora",
      "floral",
      "flour",
      "flow",
      "flower",
      "fluent",
      "fluffy",
      "fluid",
      "flung",
      "flurry",
      "flush",
      "flute",
      "flux",
      "fly",
      "flyer",
      "foal",
      "foam",
      "focal",
      "focus",
      "fog",
      "foil",
      "fold",
      "folk",
      "follow",
      "folly",
      "fond",
      "fondly",
      "font",
      "food",
      "fool",
      "foot",
      "for",
      "forbid",
      "force",
      "ford",
      "forest",
      "forge",
      "forget",
      "fork",
      "form",
      "formal",
      "format",
      "former",
      "fort",
      "forth",
      "forty",
      "forum",
      "fossil",
      "foster",
      "foul",
      "found",
      "four",
      "fourth",
      "fox",
      "foyer",
      "frail",
      "frame",
      "franc",
      "france",
      "frank",
      "fraud",
      "fred",
      "free",
      "freed",
      "freely",
      "freeze",
      "french",
      "frenzy",
      "fresh",
      "friar",
      "friday",
      "fridge",
      "fried",
      "friend",
      "fright",
      "fringe",
      "frock",
      "frog",
      "from",
      "front",
      "frost",
      "frosty",
      "frown",
      "frozen",
      "frugal",
      "fruit",
      "fry",
      "fudge",
      "fuel",
      "full",
      "fully",
      "fumes",
      "fun",
      "fund",
      "funny",
      "fur",
      "furry",
      "fury",
      "fuse",
      "fusion",
      "fuss",
      "fussy",
      "futile",
      "future",
      "fuzzy",
      "gadget",
      "gain",
      "gala",
      "galaxy",
      "gale",
      "gall",
      "galley",
      "gallon",
      "gallop",
      "gamble",
      "game",
      "gamma",
      "gandhi",
      "gang",
      "gap",
      "garage",
      "garden",
      "garlic",
      "gas",
      "gasp",
      "gate",
      "gather",
      "gauge",
      "gaunt",
      "gave",
      "gaze",
      "gear",
      "geese",
      "gem",
      "gemini",
      "gender",
      "gene",
      "geneva",
      "genial",
      "genius",
      "genre",
      "gentle",
      "gently",
      "gentry",
      "genus",
      "george",
      "germ",
      "get",
      "ghetto",
      "ghost",
      "giant",
      "gift",
      "giggle",
      "gill",
      "gilt",
      "ginger",
      "girl",
      "give",
      "given",
      "glad",
      "glade",
      "glance",
      "gland",
      "glare",
      "glass",
      "glassy",
      "gleam",
      "glee",
      "glide",
      "global",
      "globe",
      "gloom",
      "gloomy",
      "gloria",
      "glory",
      "gloss",
      "glossy",
      "glove",
      "glow",
      "glue",
      "gnat",
      "gnu",
      "goal",
      "goat",
      "gold",
      "golden",
      "golf",
      "gone",
      "gong",
      "goo",
      "good",
      "goose",
      "gore",
      "gorge",
      "gory",
      "gosh",
      "gospel",
      "gossip",
      "got",
      "gothic",
      "govern",
      "gown",
      "grab",
      "grace",
      "grade",
      "grail",
      "grain",
      "grand",
      "grant",
      "grape",
      "graph",
      "grasp",
      "grass",
      "grassy",
      "grate",
      "grave",
      "gravel",
      "gravy",
      "grease",
      "greasy",
      "great",
      "greece",
      "greed",
      "greedy",
      "greek",
      "green",
      "greet",
      "grew",
      "grey",
      "grid",
      "grief",
      "grill",
      "grim",
      "grin",
      "grind",
      "grip",
      "grit",
      "gritty",
      "groan",
      "groin",
      "groom",
      "groove",
      "gross",
      "ground",
      "group",
      "grove",
      "grow",
      "grown",
      "growth",
      "grudge",
      "grunt",
      "guard",
      "guess",
      "guest",
      "guide",
      "guild",
      "guilt",
      "guilty",
      "guise",
      "guitar",
      "gulf",
      "gully",
      "gun",
      "gunman",
      "guru",
      "gut",
      "guy",
      "gypsy",
      "habit",
      "hack",
      "had",
      "hail",
      "hair",
      "hairy",
      "haiti",
      "hale",
      "half",
      "hall",
      "halt",
      "hamlet",
      "hammer",
      "hand",
      "handle",
      "handy",
      "hang",
      "hangar",
      "hanoi",
      "happen",
      "happy",
      "harass",
      "harbor",
      "hard",
      "harder",
      "hardly",
      "hare",
      "harem",
      "harm",
      "harp",
      "harry",
      "harsh",
      "has",
      "hash",
      "hassle",
      "haste",
      "hasten",
      "hasty",
      "hat",
      "hatch",
      "hate",
      "haul",
      "haunt",
      "havana",
      "have",
      "haven",
      "havoc",
      "hawaii",
      "hawk",
      "hay",
      "hazard",
      "haze",
      "hazel",
      "hazy",
      "head",
      "heal",
      "health",
      "heap",
      "hear",
      "heard",
      "heart",
      "hearth",
      "hearty",
      "heat",
      "heater",
      "heaven",
      "heavy",
      "hebrew",
      "heck",
      "hectic",
      "hedge",
      "heel",
      "hefty",
      "height",
      "heir",
      "held",
      "helium",
      "helix",
      "hell",
      "hello",
      "helm",
      "helmet",
      "help",
      "hemp",
      "hence",
      "henry",
      "her",
      "herald",
      "herb",
      "herd",
      "here",
      "hereby",
      "hermes",
      "hernia",
      "hero",
      "heroic",
      "heroin",
      "hey",
      "heyday",
      "hick",
      "hidden",
      "hide",
      "high",
      "higher",
      "highly",
      "hill",
      "him",
      "hind",
      "hinder",
      "hint",
      "hippie",
      "hire",
      "his",
      "hiss",
      "hit",
      "hive",
      "hoard",
      "hoarse",
      "hobby",
      "hockey",
      "hold",
      "holder",
      "hole",
      "hollow",
      "holly",
      "holy",
      "home",
      "honest",
      "honey",
      "hood",
      "hook",
      "hope",
      "horn",
      "horrid",
      "horror",
      "horse",
      "hose",
      "host",
      "hot",
      "hotel",
      "hound",
      "hour",
      "house",
      "hover",
      "how",
      "huge",
      "hull",
      "human",
      "humane",
      "humble",
      "humid",
      "hung",
      "hunger",
      "hungry",
      "hunt",
      "hurdle",
      "hurl",
      "hurry",
      "hurt",
      "hush",
      "hut",
      "hybrid",
      "hymn",
      "hyphen",
      "ice",
      "icing",
      "icon",
      "idaho",
      "idea",
      "ideal",
      "idiom",
      "idiot",
      "idle",
      "idly",
      "idol",
      "ignite",
      "ignore",
      "ill",
      "image",
      "immune",
      "impact",
      "imply",
      "import",
      "impose",
      "inca",
      "incest",
      "inch",
      "income",
      "incur",
      "indeed",
      "index",
      "india",
      "indian",
      "indoor",
      "induce",
      "inept",
      "inert",
      "infant",
      "infect",
      "infer",
      "influx",
      "inform",
      "inject",
      "injure",
      "injury",
      "ink",
      "inlaid",
      "inland",
      "inlet",
      "inmate",
      "inn",
      "innate",
      "inner",
      "input",
      "insane",
      "insect",
      "insert",
      "inset",
      "inside",
      "insist",
      "insult",
      "insure",
      "intact",
      "intake",
      "intend",
      "inter",
      "into",
      "invade",
      "invent",
      "invest",
      "invite",
      "invoke",
      "inward",
      "iowa",
      "iran",
      "iraq",
      "irish",
      "iron",
      "ironic",
      "irony",
      "isaac",
      "isabel",
      "island",
      "isle",
      "israel",
      "issue",
      "italy",
      "itch",
      "item",
      "itself",
      "ivan",
      "ivory",
      "jack",
      "jacket",
      "jacob",
      "jade",
      "jaguar",
      "jail",
      "james",
      "jane",
      "japan",
      "jargon",
      "java",
      "jaw",
      "jazz",
      "jeep",
      "jelly",
      "jerky",
      "jest",
      "jet",
      "jewel",
      "jewish",
      "jim",
      "job",
      "jock",
      "jockey",
      "joe",
      "john",
      "join",
      "joint",
      "joke",
      "jolly",
      "jolt",
      "jordan",
      "joseph",
      "joy",
      "joyful",
      "joyous",
      "judge",
      "judy",
      "juice",
      "juicy",
      "july",
      "jumble",
      "jumbo",
      "jump",
      "june",
      "jungle",
      "junior",
      "junk",
      "junta",
      "jury",
      "just",
      "kansas",
      "karate",
      "karl",
      "keel",
      "keen",
      "keep",
      "keeper",
      "kenya",
      "kept",
      "kernel",
      "kettle",
      "key",
      "khaki",
      "kick",
      "kid",
      "kidnap",
      "kidney",
      "kill",
      "killer",
      "kin",
      "kind",
      "kindly",
      "king",
      "kiss",
      "kite",
      "kitten",
      "knack",
      "knee",
      "kneel",
      "knew",
      "knife",
      "knight",
      "knit",
      "knob",
      "knock",
      "knot",
      "know",
      "known",
      "koran",
      "korea",
      "kuwait",
      "label",
      "lace",
      "lack",
      "lad",
      "ladder",
      "laden",
      "lady",
      "lagoon",
      "laity",
      "lake",
      "lamb",
      "lame",
      "lamp",
      "lance",
      "land",
      "lane",
      "lap",
      "lapse",
      "large",
      "larval",
      "laser",
      "last",
      "latch",
      "late",
      "lately",
      "latent",
      "later",
      "latest",
      "latin",
      "latter",
      "laugh",
      "launch",
      "lava",
      "lavish",
      "law",
      "lawful",
      "lawn",
      "lawyer",
      "lay",
      "layer",
      "layman",
      "lazy",
      "lead",
      "leader",
      "leaf",
      "leafy",
      "league",
      "leak",
      "leaky",
      "lean",
      "leap",
      "learn",
      "lease",
      "leash",
      "least",
      "leave",
      "led",
      "ledge",
      "left",
      "leg",
      "legacy",
      "legal",
      "legend",
      "legion",
      "lemon",
      "lend",
      "length",
      "lens",
      "lent",
      "leo",
      "leper",
      "lesion",
      "less",
      "lessen",
      "lesser",
      "lesson",
      "lest",
      "let",
      "lethal",
      "letter",
      "level",
      "lever",
      "levy",
      "lewis",
      "liable",
      "liar",
      "libel",
      "libya",
      "lice",
      "lick",
      "lid",
      "lie",
      "lied",
      "lier",
      "life",
      "lift",
      "light",
      "like",
      "likely",
      "limb",
      "lime",
      "limit",
      "limp",
      "line",
      "linear",
      "linen",
      "linger",
      "link",
      "lint",
      "lion",
      "lip",
      "liquid",
      "liquor",
      "list",
      "listen",
      "lit",
      "live",
      "lively",
      "liver",
      "liz",
      "lizard",
      "load",
      "loaf",
      "loan",
      "lobby",
      "lobe",
      "local",
      "locate",
      "lock",
      "locus",
      "lodge",
      "loft",
      "lofty",
      "log",
      "logic",
      "logo",
      "london",
      "lone",
      "lonely",
      "long",
      "longer",
      "look",
      "loop",
      "loose",
      "loosen",
      "loot",
      "lord",
      "lorry",
      "lose",
      "loss",
      "lost",
      "lot",
      "lotion",
      "lotus",
      "loud",
      "loudly",
      "lounge",
      "lousy",
      "love",
      "lovely",
      "lover",
      "low",
      "lower",
      "lowest",
      "loyal",
      "lucid",
      "luck",
      "lucky",
      "lucy",
      "lull",
      "lump",
      "lumpy",
      "lunacy",
      "lunar",
      "lunch",
      "lung",
      "lure",
      "lurid",
      "lush",
      "lust",
      "lute",
      "luther",
      "luxury",
      "lying",
      "lymph",
      "lynch",
      "lyric",
      "macho",
      "macro",
      "mad",
      "madam",
      "made",
      "mafia",
      "magic",
      "magma",
      "magnet",
      "magnum",
      "magpie",
      "maid",
      "maiden",
      "mail",
      "main",
      "mainly",
      "major",
      "make",
      "maker",
      "male",
      "malice",
      "mall",
      "malt",
      "mammal",
      "manage",
      "mane",
      "mania",
      "manic",
      "manner",
      "manor",
      "mantle",
      "manual",
      "manure",
      "many",
      "map",
      "maple",
      "marble",
      "march",
      "mare",
      "margin",
      "maria",
      "marina",
      "mark",
      "market",
      "marry",
      "mars",
      "marsh",
      "martin",
      "martyr",
      "mary",
      "mask",
      "mason",
      "mass",
      "mast",
      "master",
      "mat",
      "match",
      "mate",
      "matrix",
      "matter",
      "mature",
      "maxim",
      "may",
      "maybe",
      "mayor",
      "maze",
      "mead",
      "meadow",
      "meal",
      "mean",
      "meant",
      "meat",
      "medal",
      "media",
      "median",
      "medic",
      "medium",
      "meet",
      "mellow",
      "melody",
      "melon",
      "melt",
      "member",
      "memo",
      "memory",
      "menace",
      "mend",
      "mental",
      "mentor",
      "menu",
      "mercy",
      "mere",
      "merely",
      "merge",
      "merger",
      "merit",
      "merry",
      "mesh",
      "mess",
      "messy",
      "met",
      "metal",
      "meter",
      "method",
      "methyl",
      "metric",
      "metro",
      "mexico",
      "miami",
      "mickey",
      "mid",
      "midday",
      "middle",
      "midst",
      "midway",
      "might",
      "mighty",
      "mild",
      "mildew",
      "mile",
      "milk",
      "milky",
      "mill",
      "mimic",
      "mince",
      "mind",
      "mine",
      "mini",
      "mink",
      "minor",
      "mint",
      "minus",
      "minute",
      "mire",
      "mirror",
      "mirth",
      "misery",
      "miss",
      "mist",
      "misty",
      "mite",
      "mix",
      "moan",
      "moat",
      "mob",
      "mobile",
      "mock",
      "mode",
      "model",
      "modem",
      "modern",
      "modest",
      "modify",
      "module",
      "moist",
      "molar",
      "mold",
      "mole",
      "molten",
      "moment",
      "monday",
      "money",
      "monk",
      "monkey",
      "month",
      "mood",
      "moody",
      "moon",
      "moor",
      "moral",
      "morale",
      "morbid",
      "more",
      "morgue",
      "mortal",
      "mortar",
      "mosaic",
      "moscow",
      "moses",
      "mosque",
      "moss",
      "most",
      "mostly",
      "moth",
      "mother",
      "motion",
      "motive",
      "motor",
      "mount",
      "mourn",
      "mouse",
      "mouth",
      "move",
      "movie",
      "mrs",
      "much",
      "muck",
      "mucus",
      "mud",
      "muddle",
      "muddy",
      "mule",
      "mummy",
      "munich",
      "murder",
      "murky",
      "murmur",
      "muscle",
      "museum",
      "music",
      "mussel",
      "must",
      "mutant",
      "mute",
      "mutiny",
      "mutter",
      "mutton",
      "mutual",
      "muzzle",
      "myopic",
      "myriad",
      "myself",
      "mystic",
      "myth",
      "nadir",
      "nail",
      "naked",
      "name",
      "namely",
      "nape",
      "napkin",
      "naples",
      "narrow",
      "nasal",
      "nasty",
      "nathan",
      "nation",
      "native",
      "nature",
      "nausea",
      "naval",
      "nave",
      "navy",
      "near",
      "nearer",
      "nearly",
      "neat",
      "neatly",
      "neck",
      "need",
      "needle",
      "needy",
      "negate",
      "neon",
      "nepal",
      "nephew",
      "nerve",
      "nest",
      "net",
      "neural",
      "never",
      "newly",
      "next",
      "nice",
      "nicely",
      "niche",
      "nickel",
      "niece",
      "night",
      "nile",
      "nimble",
      "nine",
      "ninety",
      "ninth",
      "nobel",
      "noble",
      "nobody",
      "node",
      "noise",
      "noisy",
      "none",
      "noon",
      "nor",
      "norm",
      "normal",
      "north",
      "norway",
      "nose",
      "nosy",
      "not",
      "note",
      "notice",
      "notify",
      "notion",
      "noun",
      "novel",
      "novice",
      "now",
      "nozzle",
      "null",
      "numb",
      "number",
      "nurse",
      "nut",
      "nylon",
      "nymph",
      "oak",
      "oar",
      "oasis",
      "oath",
      "obese",
      "obey",
      "object",
      "oblige",
      "oboe",
      "obtain",
      "obtuse",
      "occult",
      "occupy",
      "occur",
      "ocean",
      "octave",
      "odd",
      "off",
      "offend",
      "offer",
      "office",
      "offset",
      "often",
      "ohio",
      "oil",
      "oily",
      "okay",
      "old",
      "older",
      "oldest",
      "olive",
      "omega",
      "omen",
      "omit",
      "once",
      "one",
      "onion",
      "only",
      "onset",
      "onto",
      "onus",
      "onward",
      "opaque",
      "open",
      "openly",
      "opera",
      "opium",
      "oppose",
      "optic",
      "option",
      "oracle",
      "oral",
      "orange",
      "orbit",
      "orchid",
      "ordeal",
      "order",
      "organ",
      "orgasm",
      "orient",
      "origin",
      "ornate",
      "orphan",
      "oscar",
      "other",
      "otter",
      "ought",
      "ounce",
      "our",
      "out",
      "outer",
      "output",
      "outset",
      "oval",
      "oven",
      "over",
      "overt",
      "owe",
      "owing",
      "owl",
      "own",
      "owner",
      "oxford",
      "oxide",
      "oxygen",
      "oyster",
      "ozone",
      "pace",
      "pack",
      "packet",
      "pact",
      "pad",
      "paddle",
      "paddy",
      "pagan",
      "page",
      "paid",
      "pain",
      "paint",
      "pair",
      "palace",
      "pale",
      "palm",
      "pan",
      "panama",
      "panel",
      "panic",
      "papa",
      "papal",
      "paper",
      "parade",
      "parcel",
      "pardon",
      "parent",
      "paris",
      "parish",
      "park",
      "parody",
      "parrot",
      "part",
      "partly",
      "party",
      "pascal",
      "pass",
      "past",
      "paste",
      "pastel",
      "pastor",
      "pastry",
      "pat",
      "patch",
      "patent",
      "path",
      "patio",
      "patrol",
      "patron",
      "paul",
      "pause",
      "pave",
      "paw",
      "pawn",
      "pay",
      "peace",
      "peach",
      "peak",
      "pear",
      "pearl",
      "pedal",
      "peel",
      "peer",
      "peking",
      "pelvic",
      "pelvis",
      "pen",
      "penal",
      "pence",
      "pencil",
      "penny",
      "people",
      "pepper",
      "per",
      "perch",
      "peril",
      "period",
      "perish",
      "permit",
      "person",
      "peru",
      "pest",
      "pet",
      "peter",
      "petite",
      "petrol",
      "petty",
      "phase",
      "philip",
      "phone",
      "photo",
      "phrase",
      "piano",
      "pick",
      "picket",
      "picnic",
      "pie",
      "piece",
      "pier",
      "pierce",
      "piety",
      "pig",
      "pigeon",
      "piggy",
      "pike",
      "pile",
      "pill",
      "pillar",
      "pillow",
      "pilot",
      "pin",
      "pinch",
      "pine",
      "pink",
      "pint",
      "pious",
      "pipe",
      "pirate",
      "piss",
      "pistol",
      "piston",
      "pit",
      "pitch",
      "pity",
      "pivot",
      "pixel",
      "pizza",
      "place",
      "placid",
      "plague",
      "plain",
      "plan",
      "plane",
      "planet",
      "plank",
      "plant",
      "plasma",
      "plate",
      "play",
      "player",
      "plea",
      "plead",
      "please",
      "pledge",
      "plenty",
      "plight",
      "plot",
      "plough",
      "ploy",
      "plug",
      "plum",
      "plump",
      "plunge",
      "plural",
      "plus",
      "plush",
      "pocket",
      "poem",
      "poet",
      "poetic",
      "poetry",
      "point",
      "poison",
      "poland",
      "polar",
      "pole",
      "police",
      "policy",
      "polish",
      "polite",
      "poll",
      "pollen",
      "polo",
      "pond",
      "ponder",
      "pony",
      "pool",
      "poor",
      "poorly",
      "pop",
      "poppy",
      "pore",
      "pork",
      "port",
      "portal",
      "pose",
      "posh",
      "post",
      "postal",
      "pot",
      "potato",
      "potent",
      "pouch",
      "pound",
      "pour",
      "powder",
      "power",
      "praise",
      "pray",
      "prayer",
      "preach",
      "prefer",
      "prefix",
      "press",
      "pretty",
      "price",
      "pride",
      "priest",
      "primal",
      "prime",
      "prince",
      "print",
      "prior",
      "prism",
      "prison",
      "privy",
      "prize",
      "probe",
      "profit",
      "prompt",
      "prone",
      "proof",
      "propel",
      "proper",
      "prose",
      "proton",
      "proud",
      "prove",
      "proven",
      "proxy",
      "prune",
      "pry",
      "psalm",
      "pseudo",
      "psyche",
      "pub",
      "public",
      "puff",
      "pull",
      "pulp",
      "pulpit",
      "pulsar",
      "pulse",
      "pump",
      "punch",
      "punish",
      "punk",
      "pupil",
      "puppet",
      "puppy",
      "pure",
      "purely",
      "purge",
      "purify",
      "purple",
      "purse",
      "pursue",
      "push",
      "pushy",
      "put",
      "putt",
      "puzzle",
      "quaint",
      "quake",
      "quarry",
      "quart",
      "quartz",
      "quebec",
      "queen",
      "queer",
      "query",
      "quest",
      "queue",
      "quick",
      "quid",
      "quiet",
      "quilt",
      "quirk",
      "quit",
      "quite",
      "quiver",
      "quiz",
      "quota",
      "quote",
      "rabbit",
      "race",
      "racial",
      "racism",
      "rack",
      "racket",
      "radar",
      "radio",
      "radish",
      "radius",
      "raffle",
      "raft",
      "rage",
      "raid",
      "rail",
      "rain",
      "rainy",
      "raise",
      "rake",
      "rally",
      "ramp",
      "random",
      "range",
      "rank",
      "ransom",
      "rape",
      "rapid",
      "rare",
      "rarely",
      "rarity",
      "rash",
      "rat",
      "rate",
      "rather",
      "ratify",
      "ratio",
      "rattle",
      "rave",
      "raven",
      "raw",
      "ray",
      "razor",
      "reach",
      "react",
      "read",
      "reader",
      "ready",
      "real",
      "really",
      "realm",
      "reap",
      "rear",
      "reason",
      "rebel",
      "recall",
      "recent",
      "recess",
      "recipe",
      "reckon",
      "record",
      "recoup",
      "rector",
      "red",
      "redeem",
      "redo",
      "reduce",
      "reed",
      "reef",
      "reek",
      "refer",
      "reform",
      "refuge",
      "refuse",
      "regal",
      "regard",
      "regent",
      "regime",
      "region",
      "regret",
      "reign",
      "reject",
      "relate",
      "relax",
      "relay",
      "relic",
      "relief",
      "relish",
      "rely",
      "remain",
      "remark",
      "remedy",
      "remind",
      "remit",
      "remote",
      "remove",
      "renal",
      "render",
      "rent",
      "rental",
      "repair",
      "repeal",
      "repeat",
      "repent",
      "reply",
      "report",
      "rescue",
      "resent",
      "reside",
      "resign",
      "resin",
      "resist",
      "resort",
      "rest",
      "result",
      "resume",
      "retail",
      "retain",
      "retina",
      "retire",
      "return",
      "reveal",
      "review",
      "revise",
      "revive",
      "revolt",
      "reward",
      "rex",
      "rhine",
      "rhino",
      "rhyme",
      "rhythm",
      "ribbon",
      "rice",
      "rich",
      "rick",
      "rid",
      "ride",
      "rider",
      "ridge",
      "rife",
      "rifle",
      "rift",
      "right",
      "rigid",
      "rile",
      "rim",
      "ring",
      "rinse",
      "riot",
      "ripe",
      "ripen",
      "ripple",
      "rise",
      "risk",
      "risky",
      "rite",
      "ritual",
      "ritz",
      "rival",
      "river",
      "road",
      "roar",
      "roast",
      "rob",
      "robe",
      "robert",
      "robin",
      "robot",
      "robust",
      "rock",
      "rocket",
      "rocky",
      "rod",
      "rode",
      "rodent",
      "rogue",
      "role",
      "roll",
      "roman",
      "rome",
      "roof",
      "room",
      "root",
      "rope",
      "rose",
      "rosy",
      "rot",
      "rotate",
      "rotor",
      "rotten",
      "rouge",
      "rough",
      "round",
      "route",
      "rover",
      "row",
      "royal",
      "rub",
      "rubber",
      "rubble",
      "ruby",
      "rudder",
      "rude",
      "rug",
      "rugby",
      "ruin",
      "rule",
      "ruler",
      "rumble",
      "rump",
      "run",
      "rune",
      "rung",
      "runway",
      "rural",
      "rush",
      "russia",
      "rust",
      "rustic",
      "rusty",
      "sack",
      "sacred",
      "sad",
      "saddle",
      "sadism",
      "sadly",
      "safari",
      "safe",
      "safely",
      "safer",
      "safety",
      "saga",
      "sage",
      "sahara",
      "said",
      "sail",
      "sailor",
      "saint",
      "sake",
      "salad",
      "salary",
      "sale",
      "saline",
      "saliva",
      "salmon",
      "saloon",
      "salt",
      "salty",
      "salute",
      "sam",
      "same",
      "sample",
      "sand",
      "sandy",
      "sane",
      "sash",
      "satin",
      "satire",
      "saturn",
      "sauce",
      "saucer",
      "saudi",
      "sauna",
      "savage",
      "save",
      "saw",
      "say",
      "scale",
      "scalp",
      "scan",
      "scant",
      "scar",
      "scarce",
      "scare",
      "scarf",
      "scary",
      "scene",
      "scenic",
      "scent",
      "school",
      "scold",
      "scope",
      "score",
      "scorn",
      "scotch",
      "scott",
      "scout",
      "scrap",
      "scrape",
      "scream",
      "screen",
      "screw",
      "script",
      "scroll",
      "scrub",
      "scum",
      "sea",
      "seal",
      "seam",
      "seaman",
      "search",
      "season",
      "seat",
      "second",
      "secret",
      "sect",
      "sector",
      "secure",
      "see",
      "seed",
      "seeing",
      "seek",
      "seem",
      "seize",
      "seldom",
      "select",
      "self",
      "sell",
      "seller",
      "semi",
      "senate",
      "send",
      "senile",
      "senior",
      "sense",
      "sensor",
      "sent",
      "sentry",
      "seoul",
      "sequel",
      "serene",
      "serial",
      "series",
      "sermon",
      "serum",
      "serve",
      "server",
      "set",
      "settle",
      "seven",
      "severe",
      "sew",
      "sewage",
      "shabby",
      "shade",
      "shadow",
      "shady",
      "shaft",
      "shaggy",
      "shah",
      "shake",
      "shaky",
      "shall",
      "sham",
      "shame",
      "shape",
      "share",
      "shark",
      "sharp",
      "shawl",
      "she",
      "shear",
      "sheen",
      "sheep",
      "sheer",
      "sheet",
      "shelf",
      "shell",
      "sherry",
      "shield",
      "shift",
      "shine",
      "shiny",
      "ship",
      "shire",
      "shirk",
      "shirt",
      "shiver",
      "shock",
      "shoe",
      "shook",
      "shoot",
      "shop",
      "shore",
      "short",
      "shot",
      "should",
      "shout",
      "show",
      "shower",
      "shrank",
      "shrewd",
      "shrill",
      "shrimp",
      "shrine",
      "shrink",
      "shrub",
      "shrug",
      "shut",
      "shy",
      "shyly",
      "sick",
      "side",
      "siege",
      "sigh",
      "sight",
      "sigma",
      "sign",
      "signal",
      "silent",
      "silk",
      "silken",
      "silky",
      "sill",
      "silly",
      "silo",
      "silver",
      "simple",
      "simply",
      "since",
      "sinful",
      "sing",
      "singer",
      "single",
      "sink",
      "sir",
      "sire",
      "siren",
      "sister",
      "sit",
      "site",
      "sitter",
      "six",
      "sixth",
      "sixty",
      "size",
      "sketch",
      "skill",
      "skin",
      "skinny",
      "skip",
      "skirt",
      "skull",
      "sky",
      "slab",
      "slack",
      "slain",
      "slam",
      "slang",
      "slap",
      "slat",
      "slate",
      "slave",
      "sleek",
      "sleep",
      "sleepy",
      "sleeve",
      "slice",
      "slick",
      "slid",
      "slide",
      "slight",
      "slim",
      "slimy",
      "sling",
      "slip",
      "slit",
      "slogan",
      "slope",
      "sloppy",
      "slot",
      "slow",
      "slowly",
      "slug",
      "slum",
      "slump",
      "smack",
      "small",
      "smart",
      "smash",
      "smear",
      "smell",
      "smelly",
      "smelt",
      "smile",
      "smite",
      "smoke",
      "smoky",
      "smooth",
      "smug",
      "snack",
      "snail",
      "snake",
      "snap",
      "snatch",
      "sneak",
      "snow",
      "snowy",
      "snug",
      "soak",
      "soap",
      "sober",
      "soccer",
      "social",
      "sock",
      "socket",
      "socks",
      "soda",
      "sodden",
      "sodium",
      "sofa",
      "soft",
      "soften",
      "softly",
      "soggy",
      "soil",
      "solar",
      "sold",
      "sole",
      "solely",
      "solemn",
      "solid",
      "solo",
      "solve",
      "some",
      "son",
      "sonar",
      "sonata",
      "song",
      "sonic",
      "sony",
      "soon",
      "sooner",
      "soot",
      "soothe",
      "sordid",
      "sore",
      "sorrow",
      "sorry",
      "sort",
      "soul",
      "sound",
      "soup",
      "sour",
      "source",
      "soviet",
      "sow",
      "space",
      "spade",
      "spain",
      "span",
      "spare",
      "spark",
      "sparse",
      "spasm",
      "spat",
      "spate",
      "speak",
      "spear",
      "speech",
      "speed",
      "speedy",
      "spell",
      "spend",
      "sphere",
      "spice",
      "spicy",
      "spider",
      "spiky",
      "spill",
      "spin",
      "spinal",
      "spine",
      "spiral",
      "spirit",
      "spit",
      "spite",
      "splash",
      "split",
      "spoil",
      "spoke",
      "sponge",
      "spoon",
      "sport",
      "spot",
      "spouse",
      "spray",
      "spread",
      "spree",
      "spring",
      "sprint",
      "spur",
      "squad",
      "square",
      "squash",
      "squat",
      "squid",
      "stab",
      "stable",
      "stack",
      "staff",
      "stage",
      "stain",
      "stair",
      "stairs",
      "stake",
      "stale",
      "stall",
      "stamp",
      "stance",
      "stand",
      "staple",
      "star",
      "starch",
      "stare",
      "stark",
      "start",
      "starve",
      "state",
      "static",
      "statue",
      "status",
      "stay",
      "stead",
      "steady",
      "steak",
      "steal",
      "steam",
      "steel",
      "steep",
      "steer",
      "stem",
      "stench",
      "step",
      "stereo",
      "stern",
      "stew",
      "stick",
      "sticky",
      "stiff",
      "stifle",
      "stigma",
      "still",
      "sting",
      "stint",
      "stir",
      "stitch",
      "stock",
      "stocky",
      "stone",
      "stony",
      "stool",
      "stop",
      "store",
      "storm",
      "stormy",
      "story",
      "stout",
      "stove",
      "stow",
      "strain",
      "strait",
      "strand",
      "strap",
      "strata",
      "straw",
      "stray",
      "streak",
      "stream",
      "street",
      "stress",
      "strict",
      "stride",
      "strife",
      "strike",
      "string",
      "strip",
      "stripe",
      "strive",
      "stroke",
      "stroll",
      "strong",
      "stud",
      "studio",
      "study",
      "stuff",
      "stuffy",
      "stunt",
      "stupid",
      "sturdy",
      "style",
      "submit",
      "subtle",
      "subtly",
      "suburb",
      "such",
      "sudden",
      "sue",
      "suez",
      "suffer",
      "sugar",
      "suit",
      "suite",
      "suitor",
      "sullen",
      "sultan",
      "sum",
      "summer",
      "summit",
      "summon",
      "sun",
      "sunday",
      "sunny",
      "sunset",
      "super",
      "superb",
      "supper",
      "supple",
      "supply",
      "sure",
      "surely",
      "surf",
      "surge",
      "survey",
      "suture",
      "swamp",
      "swan",
      "swap",
      "swarm",
      "sway",
      "swear",
      "sweat",
      "sweaty",
      "sweden",
      "sweep",
      "sweet",
      "swell",
      "swift",
      "swim",
      "swine",
      "swing",
      "swirl",
      "swiss",
      "switch",
      "sword",
      "swore",
      "sydney",
      "symbol",
      "synod",
      "syntax",
      "syria",
      "syrup",
      "system",
      "table",
      "tablet",
      "taboo",
      "tacit",
      "tackle",
      "tact",
      "tactic",
      "tail",
      "tailor",
      "taiwan",
      "take",
      "tale",
      "talent",
      "talk",
      "tall",
      "tally",
      "tame",
      "tampa",
      "tan",
      "tandem",
      "tangle",
      "tank",
      "tap",
      "tape",
      "target",
      "tariff",
      "tarp",
      "tart",
      "tarzan",
      "task",
      "taste",
      "tasty",
      "tattoo",
      "taurus",
      "taut",
      "tavern",
      "tax",
      "taxi",
      "tea",
      "teach",
      "teak",
      "team",
      "tear",
      "tease",
      "tech",
      "teeth",
      "tell",
      "temper",
      "temple",
      "tempo",
      "tempt",
      "ten",
      "tenant",
      "tend",
      "tender",
      "tendon",
      "tennis",
      "tenor",
      "tense",
      "tent",
      "tenth",
      "tenure",
      "teresa",
      "term",
      "terror",
      "terse",
      "test",
      "texas",
      "text",
      "thank",
      "thaw",
      "them",
      "theme",
      "thence",
      "theory",
      "there",
      "these",
      "thesis",
      "they",
      "thick",
      "thief",
      "thigh",
      "thin",
      "thing",
      "think",
      "third",
      "thirst",
      "thirty",
      "this",
      "thomas",
      "thorn",
      "those",
      "though",
      "thread",
      "threat",
      "three",
      "thrill",
      "thrive",
      "throat",
      "throne",
      "throng",
      "throw",
      "thrust",
      "thud",
      "thug",
      "thumb",
      "thus",
      "thyme",
      "tibet",
      "tick",
      "ticket",
      "tidal",
      "tide",
      "tidy",
      "tie",
      "tier",
      "tiger",
      "tight",
      "tile",
      "till",
      "tilt",
      "timber",
      "time",
      "timid",
      "tin",
      "tiny",
      "tip",
      "tire",
      "tissue",
      "title",
      "toad",
      "toast",
      "today",
      "toe",
      "toilet",
      "token",
      "tokyo",
      "told",
      "toll",
      "tom",
      "tomato",
      "tomb",
      "tonal",
      "tone",
      "tongue",
      "tonic",
      "too",
      "took",
      "tool",
      "tooth",
      "top",
      "topaz",
      "topic",
      "torch",
      "torque",
      "torso",
      "tort",
      "toss",
      "total",
      "touch",
      "tough",
      "tour",
      "toward",
      "towel",
      "tower",
      "town",
      "toxic",
      "toxin",
      "toy",
      "trace",
      "track",
      "tract",
      "trade",
      "tragic",
      "trail",
      "train",
      "trait",
      "tram",
      "trance",
      "trap",
      "trauma",
      "travel",
      "tray",
      "tread",
      "treat",
      "treaty",
      "treble",
      "tree",
      "trek",
      "tremor",
      "trench",
      "trend",
      "trendy",
      "trial",
      "tribal",
      "tribe",
      "trick",
      "tricky",
      "tried",
      "trifle",
      "trim",
      "trio",
      "trip",
      "triple",
      "troop",
      "trophy",
      "trot",
      "trough",
      "trout",
      "truce",
      "truck",
      "true",
      "truly",
      "trunk",
      "trust",
      "truth",
      "try",
      "tube",
      "tumble",
      "tuna",
      "tundra",
      "tune",
      "tunic",
      "tunnel",
      "turban",
      "turf",
      "turk",
      "turkey",
      "turn",
      "turtle",
      "tutor",
      "tweed",
      "twelve",
      "twenty",
      "twice",
      "twin",
      "twist",
      "two",
      "tycoon",
      "tying",
      "type",
      "tyrant",
      "ugly",
      "ulcer",
      "ultra",
      "umpire",
      "unable",
      "uncle",
      "under",
      "uneasy",
      "unfair",
      "unify",
      "union",
      "unique",
      "unit",
      "unite",
      "unity",
      "unlike",
      "unrest",
      "unruly",
      "until",
      "update",
      "upheld",
      "uphill",
      "uphold",
      "upon",
      "upper",
      "uproar",
      "upset",
      "upshot",
      "uptake",
      "upturn",
      "upward",
      "urban",
      "urge",
      "urgent",
      "urging",
      "urine",
      "usable",
      "usage",
      "use",
      "useful",
      "user",
      "usual",
      "utmost",
      "utter",
      "vacant",
      "vacuum",
      "vague",
      "vain",
      "valet",
      "valid",
      "valley",
      "value",
      "valve",
      "van",
      "vanish",
      "vanity",
      "vary",
      "vase",
      "vast",
      "vat",
      "vault",
      "vector",
      "veil",
      "vein",
      "velvet",
      "vendor",
      "veneer",
      "venice",
      "venom",
      "vent",
      "venue",
      "venus",
      "verb",
      "verbal",
      "verge",
      "verify",
      "verity",
      "verse",
      "versus",
      "very",
      "vessel",
      "vest",
      "vet",
      "veto",
      "via",
      "viable",
      "vicar",
      "vice",
      "victim",
      "victor",
      "video",
      "vienna",
      "view",
      "vigil",
      "viking",
      "vile",
      "villa",
      "vine",
      "vinyl",
      "viola",
      "violet",
      "violin",
      "viral",
      "virgo",
      "virtue",
      "virus",
      "visa",
      "vision",
      "visit",
      "visual",
      "vital",
      "vivid",
      "vocal",
      "vodka",
      "vogue",
      "voice",
      "void",
      "volley",
      "volume",
      "vote",
      "vowel",
      "voyage",
      "vulgar",
      "wade",
      "wage",
      "waist",
      "wait",
      "waiter",
      "wake",
      "walk",
      "walker",
      "wall",
      "wallet",
      "walnut",
      "wander",
      "want",
      "war",
      "warden",
      "warm",
      "warmth",
      "warn",
      "warp",
      "warsaw",
      "wary",
      "was",
      "wash",
      "wasp",
      "waste",
      "watch",
      "water",
      "watery",
      "wave",
      "wax",
      "way",
      "weak",
      "weaken",
      "wealth",
      "weapon",
      "wear",
      "weary",
      "weave",
      "wedge",
      "wee",
      "weed",
      "week",
      "weekly",
      "weep",
      "weigh",
      "weight",
      "weird",
      "well",
      "were",
      "west",
      "wet",
      "whale",
      "wharf",
      "what",
      "wheat",
      "wheel",
      "when",
      "whence",
      "where",
      "which",
      "whiff",
      "while",
      "whim",
      "whip",
      "whisky",
      "white",
      "who",
      "whole",
      "wholly",
      "whom",
      "whose",
      "why",
      "wicked",
      "wide",
      "widely",
      "widen",
      "wider",
      "widow",
      "width",
      "wife",
      "wig",
      "wild",
      "wildly",
      "will",
      "willow",
      "wily",
      "win",
      "wind",
      "window",
      "windy",
      "wine",
      "wing",
      "wink",
      "winner",
      "winter",
      "wipe",
      "wire",
      "wisdom",
      "wise",
      "wish",
      "wit",
      "witch",
      "with",
      "within",
      "witty",
      "wizard",
      "woke",
      "wolf",
      "wolves",
      "woman",
      "womb",
      "won",
      "wonder",
      "wood",
      "wooden",
      "woods",
      "woody",
      "wool",
      "word",
      "work",
      "worker",
      "world",
      "worm",
      "worry",
      "worse",
      "worst",
      "worth",
      "worthy",
      "would",
      "wound",
      "wrap",
      "wrath",
      "wreath",
      "wreck",
      "wring",
      "wrist",
      "writ",
      "write",
      "writer",
      "wrong",
      "xerox",
      "yacht",
      "yale",
      "yard",
      "yarn",
      "yeah",
      "year",
      "yeard",
      "yeast",
      "yellow",
      "yet",
      "yield",
      "yogurt",
      "yolk",
      "you",
      "young",
      "your",
      "youth",
      "zaire",
      "zeal",
      "zebra",
      "zenith",
      "zero",
      "zeus",
      "zigzag",
      "zinc",
      "zombie",
      "zone",
  ];

  var bip39Words = [
      "abandon",
      "ability",
      "able",
      "about",
      "above",
      "absent",
      "absorb",
      "abstract",
      "absurd",
      "abuse",
      "access",
      "accident",
      "account",
      "accuse",
      "achieve",
      "acid",
      "acoustic",
      "acquire",
      "across",
      "act",
      "action",
      "actor",
      "actress",
      "actual",
      "adapt",
      "add",
      "addict",
      "address",
      "adjust",
      "admit",
      "adult",
      "advance",
      "advice",
      "aerobic",
      "affair",
      "afford",
      "afraid",
      "again",
      "age",
      "agent",
      "agree",
      "ahead",
      "aim",
      "air",
      "airport",
      "aisle",
      "alarm",
      "album",
      "alcohol",
      "alert",
      "alien",
      "all",
      "alley",
      "allow",
      "almost",
      "alone",
      "alpha",
      "already",
      "also",
      "alter",
      "always",
      "amateur",
      "amazing",
      "among",
      "amount",
      "amused",
      "analyst",
      "anchor",
      "ancient",
      "anger",
      "angle",
      "angry",
      "animal",
      "ankle",
      "announce",
      "annual",
      "another",
      "answer",
      "antenna",
      "antique",
      "anxiety",
      "any",
      "apart",
      "apology",
      "appear",
      "apple",
      "approve",
      "april",
      "arch",
      "arctic",
      "area",
      "arena",
      "argue",
      "arm",
      "armed",
      "armor",
      "army",
      "around",
      "arrange",
      "arrest",
      "arrive",
      "arrow",
      "art",
      "artefact",
      "artist",
      "artwork",
      "ask",
      "aspect",
      "assault",
      "asset",
      "assist",
      "assume",
      "asthma",
      "athlete",
      "atom",
      "attack",
      "attend",
      "attitude",
      "attract",
      "auction",
      "audit",
      "august",
      "aunt",
      "author",
      "auto",
      "autumn",
      "average",
      "avocado",
      "avoid",
      "awake",
      "aware",
      "away",
      "awesome",
      "awful",
      "awkward",
      "axis",
      "baby",
      "bachelor",
      "bacon",
      "badge",
      "bag",
      "balance",
      "balcony",
      "ball",
      "bamboo",
      "banana",
      "banner",
      "bar",
      "barely",
      "bargain",
      "barrel",
      "base",
      "basic",
      "basket",
      "battle",
      "beach",
      "bean",
      "beauty",
      "because",
      "become",
      "beef",
      "before",
      "begin",
      "behave",
      "behind",
      "believe",
      "below",
      "belt",
      "bench",
      "benefit",
      "best",
      "betray",
      "better",
      "between",
      "beyond",
      "bicycle",
      "bid",
      "bike",
      "bind",
      "biology",
      "bird",
      "birth",
      "bitter",
      "black",
      "blade",
      "blame",
      "blanket",
      "blast",
      "bleak",
      "bless",
      "blind",
      "blood",
      "blossom",
      "blouse",
      "blue",
      "blur",
      "blush",
      "board",
      "boat",
      "body",
      "boil",
      "bomb",
      "bone",
      "bonus",
      "book",
      "boost",
      "border",
      "boring",
      "borrow",
      "boss",
      "bottom",
      "bounce",
      "box",
      "boy",
      "bracket",
      "brain",
      "brand",
      "brass",
      "brave",
      "bread",
      "breeze",
      "brick",
      "bridge",
      "brief",
      "bright",
      "bring",
      "brisk",
      "broccoli",
      "broken",
      "bronze",
      "broom",
      "brother",
      "brown",
      "brush",
      "bubble",
      "buddy",
      "budget",
      "buffalo",
      "build",
      "bulb",
      "bulk",
      "bullet",
      "bundle",
      "bunker",
      "burden",
      "burger",
      "burst",
      "bus",
      "business",
      "busy",
      "butter",
      "buyer",
      "buzz",
      "cabbage",
      "cabin",
      "cable",
      "cactus",
      "cage",
      "cake",
      "call",
      "calm",
      "camera",
      "camp",
      "can",
      "canal",
      "cancel",
      "candy",
      "cannon",
      "canoe",
      "canvas",
      "canyon",
      "capable",
      "capital",
      "captain",
      "car",
      "carbon",
      "card",
      "cargo",
      "carpet",
      "carry",
      "cart",
      "case",
      "cash",
      "casino",
      "castle",
      "casual",
      "cat",
      "catalog",
      "catch",
      "category",
      "cattle",
      "caught",
      "cause",
      "caution",
      "cave",
      "ceiling",
      "celery",
      "cement",
      "census",
      "century",
      "cereal",
      "certain",
      "chair",
      "chalk",
      "champion",
      "change",
      "chaos",
      "chapter",
      "charge",
      "chase",
      "chat",
      "cheap",
      "check",
      "cheese",
      "chef",
      "cherry",
      "chest",
      "chicken",
      "chief",
      "child",
      "chimney",
      "choice",
      "choose",
      "chronic",
      "chuckle",
      "chunk",
      "churn",
      "cigar",
      "cinnamon",
      "circle",
      "citizen",
      "city",
      "civil",
      "claim",
      "clap",
      "clarify",
      "claw",
      "clay",
      "clean",
      "clerk",
      "clever",
      "click",
      "client",
      "cliff",
      "climb",
      "clinic",
      "clip",
      "clock",
      "clog",
      "close",
      "cloth",
      "cloud",
      "clown",
      "club",
      "clump",
      "cluster",
      "clutch",
      "coach",
      "coast",
      "coconut",
      "code",
      "coffee",
      "coil",
      "coin",
      "collect",
      "color",
      "column",
      "combine",
      "come",
      "comfort",
      "comic",
      "common",
      "company",
      "concert",
      "conduct",
      "confirm",
      "congress",
      "connect",
      "consider",
      "control",
      "convince",
      "cook",
      "cool",
      "copper",
      "copy",
      "coral",
      "core",
      "corn",
      "correct",
      "cost",
      "cotton",
      "couch",
      "country",
      "couple",
      "course",
      "cousin",
      "cover",
      "coyote",
      "crack",
      "cradle",
      "craft",
      "cram",
      "crane",
      "crash",
      "crater",
      "crawl",
      "crazy",
      "cream",
      "credit",
      "creek",
      "crew",
      "cricket",
      "crime",
      "crisp",
      "critic",
      "crop",
      "cross",
      "crouch",
      "crowd",
      "crucial",
      "cruel",
      "cruise",
      "crumble",
      "crunch",
      "crush",
      "cry",
      "crystal",
      "cube",
      "culture",
      "cup",
      "cupboard",
      "curious",
      "current",
      "curtain",
      "curve",
      "cushion",
      "custom",
      "cute",
      "cycle",
      "dad",
      "damage",
      "damp",
      "dance",
      "danger",
      "daring",
      "dash",
      "daughter",
      "dawn",
      "day",
      "deal",
      "debate",
      "debris",
      "decade",
      "december",
      "decide",
      "decline",
      "decorate",
      "decrease",
      "deer",
      "defense",
      "define",
      "defy",
      "degree",
      "delay",
      "deliver",
      "demand",
      "demise",
      "denial",
      "dentist",
      "deny",
      "depart",
      "depend",
      "deposit",
      "depth",
      "deputy",
      "derive",
      "describe",
      "desert",
      "design",
      "desk",
      "despair",
      "destroy",
      "detail",
      "detect",
      "develop",
      "device",
      "devote",
      "diagram",
      "dial",
      "diamond",
      "diary",
      "dice",
      "diesel",
      "diet",
      "differ",
      "digital",
      "dignity",
      "dilemma",
      "dinner",
      "dinosaur",
      "direct",
      "dirt",
      "disagree",
      "discover",
      "disease",
      "dish",
      "dismiss",
      "disorder",
      "display",
      "distance",
      "divert",
      "divide",
      "divorce",
      "dizzy",
      "doctor",
      "document",
      "dog",
      "doll",
      "dolphin",
      "domain",
      "donate",
      "donkey",
      "donor",
      "door",
      "dose",
      "double",
      "dove",
      "draft",
      "dragon",
      "drama",
      "drastic",
      "draw",
      "dream",
      "dress",
      "drift",
      "drill",
      "drink",
      "drip",
      "drive",
      "drop",
      "drum",
      "dry",
      "duck",
      "dumb",
      "dune",
      "during",
      "dust",
      "dutch",
      "duty",
      "dwarf",
      "dynamic",
      "eager",
      "eagle",
      "early",
      "earn",
      "earth",
      "easily",
      "east",
      "easy",
      "echo",
      "ecology",
      "economy",
      "edge",
      "edit",
      "educate",
      "effort",
      "egg",
      "eight",
      "either",
      "elbow",
      "elder",
      "electric",
      "elegant",
      "element",
      "elephant",
      "elevator",
      "elite",
      "else",
      "embark",
      "embody",
      "embrace",
      "emerge",
      "emotion",
      "employ",
      "empower",
      "empty",
      "enable",
      "enact",
      "end",
      "endless",
      "endorse",
      "enemy",
      "energy",
      "enforce",
      "engage",
      "engine",
      "enhance",
      "enjoy",
      "enlist",
      "enough",
      "enrich",
      "enroll",
      "ensure",
      "enter",
      "entire",
      "entry",
      "envelope",
      "episode",
      "equal",
      "equip",
      "era",
      "erase",
      "erode",
      "erosion",
      "error",
      "erupt",
      "escape",
      "essay",
      "essence",
      "estate",
      "eternal",
      "ethics",
      "evidence",
      "evil",
      "evoke",
      "evolve",
      "exact",
      "example",
      "excess",
      "exchange",
      "excite",
      "exclude",
      "excuse",
      "execute",
      "exercise",
      "exhaust",
      "exhibit",
      "exile",
      "exist",
      "exit",
      "exotic",
      "expand",
      "expect",
      "expire",
      "explain",
      "expose",
      "express",
      "extend",
      "extra",
      "eye",
      "eyebrow",
      "fabric",
      "face",
      "faculty",
      "fade",
      "faint",
      "faith",
      "fall",
      "false",
      "fame",
      "family",
      "famous",
      "fan",
      "fancy",
      "fantasy",
      "farm",
      "fashion",
      "fat",
      "fatal",
      "father",
      "fatigue",
      "fault",
      "favorite",
      "feature",
      "february",
      "federal",
      "fee",
      "feed",
      "feel",
      "female",
      "fence",
      "festival",
      "fetch",
      "fever",
      "few",
      "fiber",
      "fiction",
      "field",
      "figure",
      "file",
      "film",
      "filter",
      "final",
      "find",
      "fine",
      "finger",
      "finish",
      "fire",
      "firm",
      "first",
      "fiscal",
      "fish",
      "fit",
      "fitness",
      "fix",
      "flag",
      "flame",
      "flash",
      "flat",
      "flavor",
      "flee",
      "flight",
      "flip",
      "float",
      "flock",
      "floor",
      "flower",
      "fluid",
      "flush",
      "fly",
      "foam",
      "focus",
      "fog",
      "foil",
      "fold",
      "follow",
      "food",
      "foot",
      "force",
      "forest",
      "forget",
      "fork",
      "fortune",
      "forum",
      "forward",
      "fossil",
      "foster",
      "found",
      "fox",
      "fragile",
      "frame",
      "frequent",
      "fresh",
      "friend",
      "fringe",
      "frog",
      "front",
      "frost",
      "frown",
      "frozen",
      "fruit",
      "fuel",
      "fun",
      "funny",
      "furnace",
      "fury",
      "future",
      "gadget",
      "gain",
      "galaxy",
      "gallery",
      "game",
      "gap",
      "garage",
      "garbage",
      "garden",
      "garlic",
      "garment",
      "gas",
      "gasp",
      "gate",
      "gather",
      "gauge",
      "gaze",
      "general",
      "genius",
      "genre",
      "gentle",
      "genuine",
      "gesture",
      "ghost",
      "giant",
      "gift",
      "giggle",
      "ginger",
      "giraffe",
      "girl",
      "give",
      "glad",
      "glance",
      "glare",
      "glass",
      "glide",
      "glimpse",
      "globe",
      "gloom",
      "glory",
      "glove",
      "glow",
      "glue",
      "goat",
      "goddess",
      "gold",
      "good",
      "goose",
      "gorilla",
      "gospel",
      "gossip",
      "govern",
      "gown",
      "grab",
      "grace",
      "grain",
      "grant",
      "grape",
      "grass",
      "gravity",
      "great",
      "green",
      "grid",
      "grief",
      "grit",
      "grocery",
      "group",
      "grow",
      "grunt",
      "guard",
      "guess",
      "guide",
      "guilt",
      "guitar",
      "gun",
      "gym",
      "habit",
      "hair",
      "half",
      "hammer",
      "hamster",
      "hand",
      "happy",
      "harbor",
      "hard",
      "harsh",
      "harvest",
      "hat",
      "have",
      "hawk",
      "hazard",
      "head",
      "health",
      "heart",
      "heavy",
      "hedgehog",
      "height",
      "hello",
      "helmet",
      "help",
      "hen",
      "hero",
      "hidden",
      "high",
      "hill",
      "hint",
      "hip",
      "hire",
      "history",
      "hobby",
      "hockey",
      "hold",
      "hole",
      "holiday",
      "hollow",
      "home",
      "honey",
      "hood",
      "hope",
      "horn",
      "horror",
      "horse",
      "hospital",
      "host",
      "hotel",
      "hour",
      "hover",
      "hub",
      "huge",
      "human",
      "humble",
      "humor",
      "hundred",
      "hungry",
      "hunt",
      "hurdle",
      "hurry",
      "hurt",
      "husband",
      "hybrid",
      "ice",
      "icon",
      "idea",
      "identify",
      "idle",
      "ignore",
      "ill",
      "illegal",
      "illness",
      "image",
      "imitate",
      "immense",
      "immune",
      "impact",
      "impose",
      "improve",
      "impulse",
      "inch",
      "include",
      "income",
      "increase",
      "index",
      "indicate",
      "indoor",
      "industry",
      "infant",
      "inflict",
      "inform",
      "inhale",
      "inherit",
      "initial",
      "inject",
      "injury",
      "inmate",
      "inner",
      "innocent",
      "input",
      "inquiry",
      "insane",
      "insect",
      "inside",
      "inspire",
      "install",
      "intact",
      "interest",
      "into",
      "invest",
      "invite",
      "involve",
      "iron",
      "island",
      "isolate",
      "issue",
      "item",
      "ivory",
      "jacket",
      "jaguar",
      "jar",
      "jazz",
      "jealous",
      "jeans",
      "jelly",
      "jewel",
      "job",
      "join",
      "joke",
      "journey",
      "joy",
      "judge",
      "juice",
      "jump",
      "jungle",
      "junior",
      "junk",
      "just",
      "kangaroo",
      "keen",
      "keep",
      "ketchup",
      "key",
      "kick",
      "kid",
      "kidney",
      "kind",
      "kingdom",
      "kiss",
      "kit",
      "kitchen",
      "kite",
      "kitten",
      "kiwi",
      "knee",
      "knife",
      "knock",
      "know",
      "lab",
      "label",
      "labor",
      "ladder",
      "lady",
      "lake",
      "lamp",
      "language",
      "laptop",
      "large",
      "later",
      "latin",
      "laugh",
      "laundry",
      "lava",
      "law",
      "lawn",
      "lawsuit",
      "layer",
      "lazy",
      "leader",
      "leaf",
      "learn",
      "leave",
      "lecture",
      "left",
      "leg",
      "legal",
      "legend",
      "leisure",
      "lemon",
      "lend",
      "length",
      "lens",
      "leopard",
      "lesson",
      "letter",
      "level",
      "liar",
      "liberty",
      "library",
      "license",
      "life",
      "lift",
      "light",
      "like",
      "limb",
      "limit",
      "link",
      "lion",
      "liquid",
      "list",
      "little",
      "live",
      "lizard",
      "load",
      "loan",
      "lobster",
      "local",
      "lock",
      "logic",
      "lonely",
      "long",
      "loop",
      "lottery",
      "loud",
      "lounge",
      "love",
      "loyal",
      "lucky",
      "luggage",
      "lumber",
      "lunar",
      "lunch",
      "luxury",
      "lyrics",
      "machine",
      "mad",
      "magic",
      "magnet",
      "maid",
      "mail",
      "main",
      "major",
      "make",
      "mammal",
      "man",
      "manage",
      "mandate",
      "mango",
      "mansion",
      "manual",
      "maple",
      "marble",
      "march",
      "margin",
      "marine",
      "market",
      "marriage",
      "mask",
      "mass",
      "master",
      "match",
      "material",
      "math",
      "matrix",
      "matter",
      "maximum",
      "maze",
      "meadow",
      "mean",
      "measure",
      "meat",
      "mechanic",
      "medal",
      "media",
      "melody",
      "melt",
      "member",
      "memory",
      "mention",
      "menu",
      "mercy",
      "merge",
      "merit",
      "merry",
      "mesh",
      "message",
      "metal",
      "method",
      "middle",
      "midnight",
      "milk",
      "million",
      "mimic",
      "mind",
      "minimum",
      "minor",
      "minute",
      "miracle",
      "mirror",
      "misery",
      "miss",
      "mistake",
      "mix",
      "mixed",
      "mixture",
      "mobile",
      "model",
      "modify",
      "mom",
      "moment",
      "monitor",
      "monkey",
      "monster",
      "month",
      "moon",
      "moral",
      "more",
      "morning",
      "mosquito",
      "mother",
      "motion",
      "motor",
      "mountain",
      "mouse",
      "move",
      "movie",
      "much",
      "muffin",
      "mule",
      "multiply",
      "muscle",
      "museum",
      "mushroom",
      "music",
      "must",
      "mutual",
      "myself",
      "mystery",
      "myth",
      "naive",
      "name",
      "napkin",
      "narrow",
      "nasty",
      "nation",
      "nature",
      "near",
      "neck",
      "need",
      "negative",
      "neglect",
      "neither",
      "nephew",
      "nerve",
      "nest",
      "net",
      "network",
      "neutral",
      "never",
      "news",
      "next",
      "nice",
      "night",
      "noble",
      "noise",
      "nominee",
      "noodle",
      "normal",
      "north",
      "nose",
      "notable",
      "note",
      "nothing",
      "notice",
      "novel",
      "now",
      "nuclear",
      "number",
      "nurse",
      "nut",
      "oak",
      "obey",
      "object",
      "oblige",
      "obscure",
      "observe",
      "obtain",
      "obvious",
      "occur",
      "ocean",
      "october",
      "odor",
      "off",
      "offer",
      "office",
      "often",
      "oil",
      "okay",
      "old",
      "olive",
      "olympic",
      "omit",
      "once",
      "one",
      "onion",
      "online",
      "only",
      "open",
      "opera",
      "opinion",
      "oppose",
      "option",
      "orange",
      "orbit",
      "orchard",
      "order",
      "ordinary",
      "organ",
      "orient",
      "original",
      "orphan",
      "ostrich",
      "other",
      "outdoor",
      "outer",
      "output",
      "outside",
      "oval",
      "oven",
      "over",
      "own",
      "owner",
      "oxygen",
      "oyster",
      "ozone",
      "pact",
      "paddle",
      "page",
      "pair",
      "palace",
      "palm",
      "panda",
      "panel",
      "panic",
      "panther",
      "paper",
      "parade",
      "parent",
      "park",
      "parrot",
      "party",
      "pass",
      "patch",
      "path",
      "patient",
      "patrol",
      "pattern",
      "pause",
      "pave",
      "payment",
      "peace",
      "peanut",
      "pear",
      "peasant",
      "pelican",
      "pen",
      "penalty",
      "pencil",
      "people",
      "pepper",
      "perfect",
      "permit",
      "person",
      "pet",
      "phone",
      "photo",
      "phrase",
      "physical",
      "piano",
      "picnic",
      "picture",
      "piece",
      "pig",
      "pigeon",
      "pill",
      "pilot",
      "pink",
      "pioneer",
      "pipe",
      "pistol",
      "pitch",
      "pizza",
      "place",
      "planet",
      "plastic",
      "plate",
      "play",
      "please",
      "pledge",
      "pluck",
      "plug",
      "plunge",
      "poem",
      "poet",
      "point",
      "polar",
      "pole",
      "police",
      "pond",
      "pony",
      "pool",
      "popular",
      "portion",
      "position",
      "possible",
      "post",
      "potato",
      "pottery",
      "poverty",
      "powder",
      "power",
      "practice",
      "praise",
      "predict",
      "prefer",
      "prepare",
      "present",
      "pretty",
      "prevent",
      "price",
      "pride",
      "primary",
      "print",
      "priority",
      "prison",
      "private",
      "prize",
      "problem",
      "process",
      "produce",
      "profit",
      "program",
      "project",
      "promote",
      "proof",
      "property",
      "prosper",
      "protect",
      "proud",
      "provide",
      "public",
      "pudding",
      "pull",
      "pulp",
      "pulse",
      "pumpkin",
      "punch",
      "pupil",
      "puppy",
      "purchase",
      "purity",
      "purpose",
      "purse",
      "push",
      "put",
      "puzzle",
      "pyramid",
      "quality",
      "quantum",
      "quarter",
      "question",
      "quick",
      "quit",
      "quiz",
      "quote",
      "rabbit",
      "raccoon",
      "race",
      "rack",
      "radar",
      "radio",
      "rail",
      "rain",
      "raise",
      "rally",
      "ramp",
      "ranch",
      "random",
      "range",
      "rapid",
      "rare",
      "rate",
      "rather",
      "raven",
      "raw",
      "razor",
      "ready",
      "real",
      "reason",
      "rebel",
      "rebuild",
      "recall",
      "receive",
      "recipe",
      "record",
      "recycle",
      "reduce",
      "reflect",
      "reform",
      "refuse",
      "region",
      "regret",
      "regular",
      "reject",
      "relax",
      "release",
      "relief",
      "rely",
      "remain",
      "remember",
      "remind",
      "remove",
      "render",
      "renew",
      "rent",
      "reopen",
      "repair",
      "repeat",
      "replace",
      "report",
      "require",
      "rescue",
      "resemble",
      "resist",
      "resource",
      "response",
      "result",
      "retire",
      "retreat",
      "return",
      "reunion",
      "reveal",
      "review",
      "reward",
      "rhythm",
      "rib",
      "ribbon",
      "rice",
      "rich",
      "ride",
      "ridge",
      "rifle",
      "right",
      "rigid",
      "ring",
      "riot",
      "ripple",
      "risk",
      "ritual",
      "rival",
      "river",
      "road",
      "roast",
      "robot",
      "robust",
      "rocket",
      "romance",
      "roof",
      "rookie",
      "room",
      "rose",
      "rotate",
      "rough",
      "round",
      "route",
      "royal",
      "rubber",
      "rude",
      "rug",
      "rule",
      "run",
      "runway",
      "rural",
      "sad",
      "saddle",
      "sadness",
      "safe",
      "sail",
      "salad",
      "salmon",
      "salon",
      "salt",
      "salute",
      "same",
      "sample",
      "sand",
      "satisfy",
      "satoshi",
      "sauce",
      "sausage",
      "save",
      "say",
      "scale",
      "scan",
      "scare",
      "scatter",
      "scene",
      "scheme",
      "school",
      "science",
      "scissors",
      "scorpion",
      "scout",
      "scrap",
      "screen",
      "script",
      "scrub",
      "sea",
      "search",
      "season",
      "seat",
      "second",
      "secret",
      "section",
      "security",
      "seed",
      "seek",
      "segment",
      "select",
      "sell",
      "seminar",
      "senior",
      "sense",
      "sentence",
      "series",
      "service",
      "session",
      "settle",
      "setup",
      "seven",
      "shadow",
      "shaft",
      "shallow",
      "share",
      "shed",
      "shell",
      "sheriff",
      "shield",
      "shift",
      "shine",
      "ship",
      "shiver",
      "shock",
      "shoe",
      "shoot",
      "shop",
      "short",
      "shoulder",
      "shove",
      "shrimp",
      "shrug",
      "shuffle",
      "shy",
      "sibling",
      "sick",
      "side",
      "siege",
      "sight",
      "sign",
      "silent",
      "silk",
      "silly",
      "silver",
      "similar",
      "simple",
      "since",
      "sing",
      "siren",
      "sister",
      "situate",
      "six",
      "size",
      "skate",
      "sketch",
      "ski",
      "skill",
      "skin",
      "skirt",
      "skull",
      "slab",
      "slam",
      "sleep",
      "slender",
      "slice",
      "slide",
      "slight",
      "slim",
      "slogan",
      "slot",
      "slow",
      "slush",
      "small",
      "smart",
      "smile",
      "smoke",
      "smooth",
      "snack",
      "snake",
      "snap",
      "sniff",
      "snow",
      "soap",
      "soccer",
      "social",
      "sock",
      "soda",
      "soft",
      "solar",
      "soldier",
      "solid",
      "solution",
      "solve",
      "someone",
      "song",
      "soon",
      "sorry",
      "sort",
      "soul",
      "sound",
      "soup",
      "source",
      "south",
      "space",
      "spare",
      "spatial",
      "spawn",
      "speak",
      "special",
      "speed",
      "spell",
      "spend",
      "sphere",
      "spice",
      "spider",
      "spike",
      "spin",
      "spirit",
      "split",
      "spoil",
      "sponsor",
      "spoon",
      "sport",
      "spot",
      "spray",
      "spread",
      "spring",
      "spy",
      "square",
      "squeeze",
      "squirrel",
      "stable",
      "stadium",
      "staff",
      "stage",
      "stairs",
      "stamp",
      "stand",
      "start",
      "state",
      "stay",
      "steak",
      "steel",
      "stem",
      "step",
      "stereo",
      "stick",
      "still",
      "sting",
      "stock",
      "stomach",
      "stone",
      "stool",
      "story",
      "stove",
      "strategy",
      "street",
      "strike",
      "strong",
      "struggle",
      "student",
      "stuff",
      "stumble",
      "style",
      "subject",
      "submit",
      "subway",
      "success",
      "such",
      "sudden",
      "suffer",
      "sugar",
      "suggest",
      "suit",
      "summer",
      "sun",
      "sunny",
      "sunset",
      "super",
      "supply",
      "supreme",
      "sure",
      "surface",
      "surge",
      "surprise",
      "surround",
      "survey",
      "suspect",
      "sustain",
      "swallow",
      "swamp",
      "swap",
      "swarm",
      "swear",
      "sweet",
      "swift",
      "swim",
      "swing",
      "switch",
      "sword",
      "symbol",
      "symptom",
      "syrup",
      "system",
      "table",
      "tackle",
      "tag",
      "tail",
      "talent",
      "talk",
      "tank",
      "tape",
      "target",
      "task",
      "taste",
      "tattoo",
      "taxi",
      "teach",
      "team",
      "tell",
      "ten",
      "tenant",
      "tennis",
      "tent",
      "term",
      "test",
      "text",
      "thank",
      "that",
      "theme",
      "then",
      "theory",
      "there",
      "they",
      "thing",
      "this",
      "thought",
      "three",
      "thrive",
      "throw",
      "thumb",
      "thunder",
      "ticket",
      "tide",
      "tiger",
      "tilt",
      "timber",
      "time",
      "tiny",
      "tip",
      "tired",
      "tissue",
      "title",
      "toast",
      "tobacco",
      "today",
      "toddler",
      "toe",
      "together",
      "toilet",
      "token",
      "tomato",
      "tomorrow",
      "tone",
      "tongue",
      "tonight",
      "tool",
      "tooth",
      "top",
      "topic",
      "topple",
      "torch",
      "tornado",
      "tortoise",
      "toss",
      "total",
      "tourist",
      "toward",
      "tower",
      "town",
      "toy",
      "track",
      "trade",
      "traffic",
      "tragic",
      "train",
      "transfer",
      "trap",
      "trash",
      "travel",
      "tray",
      "treat",
      "tree",
      "trend",
      "trial",
      "tribe",
      "trick",
      "trigger",
      "trim",
      "trip",
      "trophy",
      "trouble",
      "truck",
      "true",
      "truly",
      "trumpet",
      "trust",
      "truth",
      "try",
      "tube",
      "tuition",
      "tumble",
      "tuna",
      "tunnel",
      "turkey",
      "turn",
      "turtle",
      "twelve",
      "twenty",
      "twice",
      "twin",
      "twist",
      "two",
      "type",
      "typical",
      "ugly",
      "umbrella",
      "unable",
      "unaware",
      "uncle",
      "uncover",
      "under",
      "undo",
      "unfair",
      "unfold",
      "unhappy",
      "uniform",
      "unique",
      "unit",
      "universe",
      "unknown",
      "unlock",
      "until",
      "unusual",
      "unveil",
      "update",
      "upgrade",
      "uphold",
      "upon",
      "upper",
      "upset",
      "urban",
      "urge",
      "usage",
      "use",
      "used",
      "useful",
      "useless",
      "usual",
      "utility",
      "vacant",
      "vacuum",
      "vague",
      "valid",
      "valley",
      "valve",
      "van",
      "vanish",
      "vapor",
      "various",
      "vast",
      "vault",
      "vehicle",
      "velvet",
      "vendor",
      "venture",
      "venue",
      "verb",
      "verify",
      "version",
      "very",
      "vessel",
      "veteran",
      "viable",
      "vibrant",
      "vicious",
      "victory",
      "video",
      "view",
      "village",
      "vintage",
      "violin",
      "virtual",
      "virus",
      "visa",
      "visit",
      "visual",
      "vital",
      "vivid",
      "vocal",
      "voice",
      "void",
      "volcano",
      "volume",
      "vote",
      "voyage",
      "wage",
      "wagon",
      "wait",
      "walk",
      "wall",
      "walnut",
      "want",
      "warfare",
      "warm",
      "warrior",
      "wash",
      "wasp",
      "waste",
      "water",
      "wave",
      "way",
      "wealth",
      "weapon",
      "wear",
      "weasel",
      "weather",
      "web",
      "wedding",
      "weekend",
      "weird",
      "welcome",
      "west",
      "wet",
      "whale",
      "what",
      "wheat",
      "wheel",
      "when",
      "where",
      "whip",
      "whisper",
      "wide",
      "width",
      "wife",
      "wild",
      "will",
      "win",
      "window",
      "wine",
      "wing",
      "wink",
      "winner",
      "winter",
      "wire",
      "wisdom",
      "wise",
      "wish",
      "witness",
      "wolf",
      "woman",
      "wonder",
      "wood",
      "wool",
      "word",
      "work",
      "world",
      "worry",
      "worth",
      "wrap",
      "wreck",
      "wrestle",
      "wrist",
      "write",
      "wrong",
      "yard",
      "year",
      "yellow",
      "you",
      "young",
      "youth",
      "zebra",
      "zero",
      "zone",
      "zoo",
  ];

  // this will be executed in browser environment so we can use window.crypto
  /* eslint-disable n/no-unsupported-features/node-builtins */

  /**
   * @param {Uint8Array} data
   * @returns {Promise<Uint8Array>}
   */
  async function digest$1(data) {
      // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest
      return new Uint8Array(await crypto.subtle.digest("SHA-256", data));
  }

  /**
   * @param {string[]} words
   * @param {string} passphrase
   * @returns {Promise<Uint8Array>}
   */
  async function toSeed(words, passphrase) {
      const input = words.join(" ");
      const salt = `mnemonic${passphrase}`.normalize("NFKD");

      return deriveKey(HashAlgorithm.Sha512, input, salt, 2048, 64);
  }

  /**
   * @param {string[]} words
   * @param {string[]} wordlist
   * @returns {[Uint8Array, number]}
   */
  function legacy1(words, wordlist) {
      const indicies = words.map((word) => wordlist.indexOf(word.toLowerCase()));

      const data = convertRadix(indicies, wordlist.length, 256, 33);
      const checksum = data[data.length - 1];
      const result = new Uint8Array(data.length - 1);

      for (let i = 0; i < data.length - 1; i += 1) {
          result[i] = data[i] ^ checksum;
      }

      return [result, checksum];
  }

  /**
   * @param {string[]} words
   * @param {string[]} wordlist
   * @returns {Promise<Uint8Array>}
   */
  async function legacy2(words, wordlist) {
      const concatBitsLen = words.length * 11;
      /** @type {boolean[]} */
      const concatBits = [];
      concatBits.fill(false, 0, concatBitsLen);

      for (const [wordIndex, word] of words.entries()) {
          const index = wordlist.indexOf(word.toLowerCase());

          if (index < 0) {
              throw new Error(`Word not found in wordlist: ${word}`);
          }

          for (let i = 0; i < 11; i += 1) {
              concatBits[wordIndex * 11 + i] = (index & (1 << (10 - i))) !== 0;
          }
      }

      const checksumBitsLen = concatBitsLen / 33;
      const entropyBitsLen = concatBitsLen - checksumBitsLen;
      const entropy = new Uint8Array(entropyBitsLen / 8);

      for (let i = 0; i < entropy.length; i += 1) {
          for (let j = 0; j < 8; j += 1) {
              if (concatBits[i * 8 + j]) {
                  entropy[i] |= 1 << (7 - j);
              }
          }
      }

      // Checksum validation
      const hash = await digest$1(entropy);
      const hashBits = bytesToBits(hash);

      for (let i = 0; i < checksumBitsLen; i += 1) {
          if (concatBits[entropyBitsLen + i] !== hashBits[i]) {
              throw new Error("Checksum mismatch");
          }
      }

      return entropy;
  }

  /**
   * @param {Uint8Array} data
   * @returns {number}
   */
  function crc8(data) {
      let crc = 0xff;

      for (let i = 0; i < data.length - 1; i += 1) {
          crc ^= data[i];
          for (let j = 0; j < 8; j += 1) {
              crc = (crc >>> 1) ^ ((crc & 1) === 0 ? 0 : 0xb2);
          }
      }

      return crc ^ 0xff;
  }

  /**
   * @param {number[]} nums
   * @param {number} fromRadix
   * @param {number} toRadix
   * @param {number} toLength
   * @returns {Uint8Array}
   */
  function convertRadix(nums, fromRadix, toRadix, toLength) {
      let num = new BigNumber$1(0);

      for (const element of nums) {
          num = num.times(fromRadix);
          num = num.plus(element);
      }

      const result = new Uint8Array(toLength);

      for (let i = toLength - 1; i >= 0; i -= 1) {
          const tem = num.dividedToIntegerBy(toRadix);
          const rem = num.modulo(toRadix);
          num = tem;
          result[i] = rem.toNumber();
      }

      return result;
  }

  /**
   * @param {Uint8Array} data
   * @returns {boolean[]}
   */
  function bytesToBits(data) {
      /** @type {boolean[]} */
      const bits = [];
      bits.fill(false, 0, data.length * 8);

      for (let i = 0; i < data.length; i += 1) {
          for (let j = 0; j < 8; j += 1) {
              bits[i * 8 + j] = (data[i] & (1 << (7 - j))) !== 0;
          }
      }

      return bits;
  }

  const ED25519_SEED_TEXT = "ed25519 seed";
  const ECDSA_SEED_TEXT = "Bitcoin seed";

  const HARDENED = 0x80000000;

  /// m/44'/3030'/0'/0' - All paths in EdDSA derivation are implicitly hardened.
  const HEDERA_PATH = [44, 3030, 0, 0];

  /// m/44'/3030'/0'/0
  const SLIP44_ECDSA_HEDERA_PATH = [
      44 | HARDENED,
      3030 | HARDENED,
      0 | HARDENED,
      0,
  ];

  /// m/44'/60'/0'/0
  const SLIP44_ECDSA_ETH_PATH = [
      44 | HARDENED,
      60 | HARDENED,
      0 | HARDENED,
      0,
      0,
  ];

  /**
   * Multi-word mnemonic phrase (BIP-39).
   *
   * Compatible with the official Hedera mobile
   * wallets (24-words or 22-words) and BRD (12-words).
   */
  let Mnemonic$1 = class Mnemonic {
      /**
       * @param {object} props
       * @param {string[]} props.words
       * @throws {BadMnemonicError}
       * @hideconstructor
       * @private
       */
      constructor({ words }) {
          this.words = words;
      }

      /**
       * Returns a new random 24-word mnemonic from the BIP-39
       * standard English word list.
       * @returns {Promise<Mnemonic>}
       */
      static generate() {
          return Mnemonic._generate(24);
      }

      /**
       * Returns a new random 12-word mnemonic from the BIP-39
       * standard English word list.
       * @returns {Promise<Mnemonic>}
       */
      static generate12() {
          return Mnemonic._generate(12);
      }

      /**
       * @param {number} length
       * @returns {Promise<Mnemonic>}
       */
      static async _generate(length) {
          // only 12-word or 24-word lengths are supported
          let neededEntropy;

          if (length === 12) neededEntropy = 16;
          else if (length === 24) neededEntropy = 32;
          else {
              throw new Error(
                  `unsupported phrase length ${length}, only 12 or 24 are supported`,
              );
          }

          // inlined from (ISC) with heavy alternations for modern crypto
          // https://github.com/bitcoinjs/bip39/blob/8461e83677a1d2c685d0d5a9ba2a76bd228f74c6/ts_src/index.ts#L125
          const seed = await bytesAsync(neededEntropy);
          const entropyBits = bytesToBinary(Array.from(seed));
          const checksumBits = await deriveChecksumBits(seed);
          const bits = entropyBits + checksumBits;
          const chunks = bits.match(/(.{1,11})/g);

          const words = (chunks != null ? chunks : []).map(
              (binary) => bip39Words[binaryToByte(binary)],
          );

          return new Mnemonic({ words });
      }

      /**
       * Construct a mnemonic from a list of words. Handles 12, 22 (legacy), and 24 words.
       *
       * An exception of BadMnemonicError will be thrown if the mnemonic
       * contains unknown words or fails the checksum. An invalid mnemonic
       * can still be used to create private keys, the exception will
       * contain the failing mnemonic in case you wish to ignore the
       * validation error and continue.
       * @param {string[]} words
       * @throws {BadMnemonicError}
       * @returns {Promise<Mnemonic>}
       */
      static fromWords(words) {
          return new Mnemonic({
              words,
          })._validate();
      }

      /**
       * @deprecated - Use `toStandardEd25519PrivateKey()` or `toStandardECDSAsecp256k1PrivateKey()` instead
       * Recover a private key from this mnemonic phrase, with an
       * optional passphrase.
       * @param {string} [passphrase]
       * @returns {Promise<PrivateKey>}
       */
      toPrivateKey(passphrase = "") {
          // eslint-disable-next-line deprecation/deprecation
          return this.toEd25519PrivateKey(passphrase);
      }

      /**
       * @deprecated - Use `toStandardEd25519PrivateKey()` or `toStandardECDSAsecp256k1PrivateKey()` instead
       * Recover an Ed25519 private key from this mnemonic phrase, with an
       * optional passphrase.
       * @param {string} [passphrase]
       * @param {number[]} [path]
       * @returns {Promise<PrivateKey>}
       */
      async toEd25519PrivateKey(passphrase = "", path = HEDERA_PATH) {
          let { keyData, chainCode } = await this._toKeyData(
              passphrase,
              ED25519_SEED_TEXT,
          );

          for (const index of path) {
              ({ keyData, chainCode } = await derive(
                  keyData,
                  chainCode,
                  index,
              ));
          }

          const keyPair = nacl.sign.keyPair.fromSeed(keyData);

          if (CACHE$1.privateKeyConstructor == null) {
              throw new Error("PrivateKey not found in cache");
          }

          return CACHE$1.privateKeyConstructor(
              new Ed25519PrivateKey(keyPair, chainCode),
          );
      }

      /**
       * Recover an Ed25519 private key from this mnemonic phrase, with an
       * optional passphrase.
       * @param {string} [passphrase]
       * @param {number} [index]
       * @returns {Promise<PrivateKey>}
       */
      async toStandardEd25519PrivateKey(passphrase = "", index) {
          const seed = await Mnemonic.toSeed(this.words, passphrase);
          let derivedKey = await PrivateKey$1.fromSeedED25519(seed);
          index = index == null ? 0 : index;

          for (const currentIndex of [44, 3030, 0, 0, index]) {
              derivedKey = await derivedKey.derive(currentIndex);
          }

          return derivedKey;
      }

      /**
       * @deprecated - Use `toStandardEd25519PrivateKey()` or `toStandardECDSAsecp256k1PrivateKey()` instead
       * Recover an ECDSA private key from this mnemonic phrase, with an
       * optional passphrase.
       * @param {string} [passphrase]
       * @param {number[]} [path]
       * @returns {Promise<PrivateKey>}
       */
      async toEcdsaPrivateKey(passphrase = "", path = HEDERA_PATH) {
          let { keyData, chainCode } = await this._toKeyData(
              passphrase,
              ECDSA_SEED_TEXT,
          );

          for (const index of path) {
              ({ keyData, chainCode } = await derive$1(
                  keyData,
                  chainCode,
                  index,
              ));
          }

          if (CACHE$1.privateKeyConstructor == null) {
              throw new Error("PrivateKey not found in cache");
          }

          return CACHE$1.privateKeyConstructor(
              new EcdsaPrivateKey(fromBytes(keyData), chainCode),
          );
      }

      /**
       * Recover an ECDSA private key from this mnemonic phrase, with an
       * optional passphrase.
       * @param {string} [passphrase]
       * @param {number} [index]
       * @returns {Promise<PrivateKey>}
       */
      async toStandardECDSAsecp256k1PrivateKey(passphrase = "", index) {
          const seed = await Mnemonic.toSeed(this.words, passphrase);
          let derivedKey = await PrivateKey$1.fromSeedECDSAsecp256k1(seed);
          index = index == null ? 0 : index;

          for (const currentIndex of [
              toHardenedIndex(44),
              toHardenedIndex(3030),
              toHardenedIndex(0),
              0,
              index,
          ]) {
              derivedKey = await derivedKey.derive(currentIndex);
          }

          return derivedKey;
      }

      /**
       * @param {string[]} words
       * @param {string} passphrase
       * @returns {Promise<Uint8Array>}
       */
      static async toSeed(words, passphrase) {
          return await toSeed(words, passphrase);
      }

      /**
       * @param {string} passphrase
       * @param {string} seedText
       * @returns {Promise<{ keyData: Uint8Array; chainCode: Uint8Array }>} seedText
       */
      async _toKeyData(passphrase, seedText) {
          const seed = await toSeed(this.words, passphrase);
          const digest = await hash(
              HashAlgorithm.Sha512,
              seedText,
              seed,
          );

          return {
              keyData: digest.subarray(0, 32),
              chainCode: digest.subarray(32),
          };
      }

      /**
       * Recover a mnemonic phrase from a string, splitting on spaces. Handles 12, 22 (legacy), and 24 words.
       * @param {string} mnemonic
       * @returns {Promise<Mnemonic>}
       */
      static async fromString(mnemonic) {
          return Mnemonic.fromWords(mnemonic.split(/\s|,/));
      }

      /**
       * @returns {Promise<Mnemonic>}
       * @private
       */
      async _validate() {
          //NOSONAR
          // Validate that this is a valid BIP-39 mnemonic
          // as generated by BIP-39's rules.

          // Technically, invalid mnemonics can still be used to generate valid private keys,
          // but if they became invalid due to user error then it will be difficult for the user
          // to tell the difference unless they compare the generated keys.

          // During validation, the following conditions are checked in order

          //  1)) 24 or 12 words

          //  2) All strings in {@link this.words} exist in the BIP-39
          //     standard English word list (no normalization is done)

          //  3) The calculated checksum for the mnemonic equals the
          //     checksum encoded in the mnemonic

          // If words count is 22, it means that this is a legacy private key
          if (this.words.length === 22) {
              const unknownWordIndices = this.words.reduce(
                  (/** @type {number[]} */ unknowns, word, index) =>
                      legacyWords.includes(word.toLowerCase())
                          ? unknowns
                          : [...unknowns, index],
                  [],
              );

              if (unknownWordIndices.length > 0) {
                  throw new BadMnemonicError(
                      this,
                      BadMnemonicReason.UnknownWords,
                      unknownWordIndices,
                  );
              }

              const [seed, checksum] = legacy1(this.words, legacyWords);
              const newChecksum = crc8(seed);

              if (checksum !== newChecksum) {
                  throw new BadMnemonicError(
                      this,
                      BadMnemonicReason.ChecksumMismatch,
                      [],
                  );
              }
          } else {
              if (!(this.words.length === 12 || this.words.length === 24)) {
                  throw new BadMnemonicError(
                      this,
                      BadMnemonicReason.BadLength,
                      [],
                  );
              }

              const unknownWordIndices = this.words.reduce(
                  (/** @type {number[]} */ unknowns, word, index) =>
                      bip39Words.includes(word) ? unknowns : [...unknowns, index],
                  [],
              );

              if (unknownWordIndices.length > 0) {
                  throw new BadMnemonicError(
                      this,
                      BadMnemonicReason.UnknownWords,
                      unknownWordIndices,
                  );
              }

              // FIXME: calculate checksum and compare
              // https://github.com/bitcoinjs/bip39/blob/master/ts_src/index.ts#L112

              const bits = this.words
                  .map((word) => {
                      return bip39Words
                          .indexOf(word)
                          .toString(2)
                          .padStart(11, "0");
                  })
                  .join("");

              const dividerIndex = Math.floor(bits.length / 33) * 32;
              const entropyBits = bits.slice(0, dividerIndex);
              const checksumBits = bits.slice(dividerIndex);
              const entropyBitsRegex = entropyBits.match(/(.{1,8})/g);
              const entropyBytes = /** @type {RegExpMatchArray} */ (
                  entropyBitsRegex
              ).map(binaryToByte);

              const newChecksum = await deriveChecksumBits(
                  Uint8Array.from(entropyBytes),
              );

              if (newChecksum !== checksumBits) {
                  throw new BadMnemonicError(
                      this,
                      BadMnemonicReason.ChecksumMismatch,
                      [],
                  );
              }
          }

          return this;
      }

      /**
       * @returns {Promise<PrivateKey>}
       */
      async toLegacyPrivateKey() {
          let seed;
          if (this.words.length === 22) {
              [seed] = legacy1(this.words, legacyWords);
          } else {
              seed = await legacy2(this.words, bip39Words);
          }

          if (CACHE$1.privateKeyFromBytes == null) {
              throw new Error("PrivateKey not found in cache");
          }

          return CACHE$1.privateKeyFromBytes(seed);
      }

      /**
       * @returns {string}
       */
      toString() {
          return this.words.join(" ");
      }
  };

  /**
   * @param {string} bin
   * @returns {number}
   */
  function binaryToByte(bin) {
      return parseInt(bin, 2);
  }

  /**
   * @param {number[]} bytes
   * @returns {string}
   */
  function bytesToBinary(bytes) {
      return bytes.map((x) => x.toString(2).padStart(8, "0")).join("");
  }

  /**
   * @param {Uint8Array} entropyBuffer
   * @returns {Promise<string>}
   */
  async function deriveChecksumBits(entropyBuffer) {
      const ENT = entropyBuffer.length * 8;
      const CS = ENT / 32;
      const hash = await digest$1(entropyBuffer);

      return bytesToBinary(Array.from(hash)).slice(0, CS);
  }

  // SPDX-License-Identifier: Apache-2.0

  /**
   * A simple efficient function for comparing byte arrays
   *
   * @param {Uint8Array} array1
   * @param {Uint8Array} array2
   * @returns {boolean}
   */
  function arrayEqual(array1, array2) {
      if (array1 === array2) {
          return true;
      }

      if (array1.byteLength !== array2.byteLength) {
          return false;
      }

      const view1 = new DataView(
          array1.buffer,
          array1.byteOffset,
          array1.byteLength,
      );
      const view2 = new DataView(
          array2.buffer,
          array2.byteOffset,
          array2.byteLength,
      );

      let i = array1.byteLength;

      while (i--) {
          if (view1.getUint8(i) !== view2.getUint8(i)) {
              return false;
          }
      }

      return true;
  }

  // SPDX-License-Identifier: Apache-2.0

  /**
   * @typedef {import("./contract/ContractId.js").default} ContractId
   * @typedef {import("./account/AccountId.js").default} AccountId
   * @typedef {import("./KeyList.js").default} KeyList
   * @typedef {import("./PublicKey.js").default} PublicKey
   * @typedef {import("./PrivateKey.js").default} PrivateKey
   * @typedef {import("./Mnemonic.js").default} Mnemonic
   * @typedef {import("./EvmAddress.js").default} EvmAddress
   * @typedef {import("./EthereumTransactionData.js").default} EthereumTransactionData
   * @typedef {import("./transaction/TransactionReceiptQuery.js").default} TransactionReceiptQuery
   * @typedef {import("./transaction/TransactionRecordQuery.js").default} TransactionRecordQuery
   * @typedef {import("./network/AddressBookQuery.js").default} AddressBookQuery
   */

  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.IKey} HieroProto.proto.IKey
   * @typedef {import("@hashgraph/proto").proto.IKeyList} HieroProto.proto.IKeyList
   * @typedef {import("@hashgraph/proto").proto.IThresholdKey} HieroProto.proto.IThresholdKey
   * @typedef {import("@hashgraph/proto").proto.IContractID} HieroProto.proto.IContractID
   */

  /**
   * @namespace cryptography
   * @typedef {import("@hashgraph/cryptography").PrivateKey} cryptography.PrivateKey
   * @typedef {import("@hashgraph/cryptography").Mnemonic} cryptography.Mnemonic
   */

  /**
   * @template {object} ProtobufT
   * @template {object} SdkT
   * @typedef {{ (proto: ProtobufT): SdkT }} FromProtobufKeyFuncT
   */

  /**
   * Cache class is designed to prevent cyclic dependencies in the Hiero JavaScript SDK.
   * It stores various conversion functions and configuration values that are used across
   * different parts of the SDK.
   */
  class Cache {
      constructor() {
          /** @type {number} */
          this._timeDrift = 0;

          /** @type {FromProtobufKeyFuncT<HieroProto.proto.IContractID, ContractId> | null} */
          this._contractId = null;

          /** @type {FromProtobufKeyFuncT<HieroProto.proto.IKeyList, KeyList> | null} */
          this._keyList = null;

          /** @type {FromProtobufKeyFuncT<HieroProto.proto.IThresholdKey, KeyList> | null} */
          this._thresholdKey = null;

          /** @type {FromProtobufKeyFuncT<Uint8Array, PublicKey> | null} */
          this._publicKeyED25519 = null;

          /** @type {FromProtobufKeyFuncT<Uint8Array, PublicKey> | null} */
          this._publicKeyECDSA = null;

          /** @type {((key: cryptography.PrivateKey) => PrivateKey) | null} */
          this._privateKeyConstructor = null;

          /** @type {((key: cryptography.Mnemonic) => Mnemonic) | null} */
          this._mnemonicFromString = null;

          /** @type {((shard: Long | number, realm: Long | number, key: PublicKey) => AccountId) | null} */
          this._accountIdConstructor = null;

          /** @type {FromProtobufKeyFuncT<HieroProto.proto.IContractID, ContractId> | null} */
          this._delegateContractId = null;

          /** @type {FromProtobufKeyFuncT<Uint8Array, EvmAddress> | null} */
          this._evmAddress = null;

          /** @type {((bytes: Uint8Array) => EthereumTransactionData) | null} */
          this._ethereumTransactionDataLegacyFromBytes = null;

          /** @type {((bytes: Uint8Array) => EthereumTransactionData) | null} */
          this._ethereumTransactionDataEip1559FromBytes = null;

          /** @type {((bytes: Uint8Array) => EthereumTransactionData) | null} */
          this._ethereumTransactionDataEip2930FromBytes = null;

          /** @type {(() => TransactionReceiptQuery) | null} */
          this._transactionReceiptQueryConstructor = null;

          /** @type {(() => TransactionRecordQuery) | null} */
          this._transactionRecordQueryConstructor = null;
      }

      /**
       * @param {number} timeDrift
       */
      setTimeDrift(timeDrift) {
          this._timeDrift = timeDrift;
      }

      /**
       * @returns {number}
       */
      get timeDrift() {
          if (this._timeDrift == null) {
              throw new Error("Cache.timeDrift was used before it was set");
          }

          return this._timeDrift;
      }

      /**
       * @param {FromProtobufKeyFuncT<HieroProto.proto.IContractID, ContractId>} contractId
       */
      setContractId(contractId) {
          this._contractId = contractId;
      }

      /**
       * @returns {FromProtobufKeyFuncT<HieroProto.proto.IContractID, ContractId>}
       */
      get contractId() {
          if (this._contractId == null) {
              throw new Error("Cache.contractId was used before it was set");
          }

          return this._contractId;
      }

      /**
       * @param {FromProtobufKeyFuncT<HieroProto.proto.IKeyList, KeyList>} keyList
       */
      setKeyList(keyList) {
          this._keyList = keyList;
      }

      /**
       * @returns {FromProtobufKeyFuncT<HieroProto.proto.IKeyList, KeyList>}
       */
      get keyList() {
          if (this._keyList == null) {
              throw new Error("Cache.keyList was used before it was set");
          }

          return this._keyList;
      }

      /**
       * @param {FromProtobufKeyFuncT<HieroProto.proto.IThresholdKey, KeyList>} thresholdKey
       */
      setThresholdKey(thresholdKey) {
          this._thresholdKey = thresholdKey;
      }

      /**
       * @returns {FromProtobufKeyFuncT<HieroProto.proto.IThresholdKey, KeyList>}
       */
      get thresholdKey() {
          if (this._thresholdKey == null) {
              throw new Error("Cache.thresholdKey was used before it was set");
          }

          return this._thresholdKey;
      }

      /**
       * @param {FromProtobufKeyFuncT<Uint8Array, PublicKey>} publicKeyED25519
       */
      setPublicKeyED25519(publicKeyED25519) {
          this._publicKeyED25519 = publicKeyED25519;
      }

      /**
       * @returns {FromProtobufKeyFuncT<Uint8Array, PublicKey>}
       */
      get publicKeyED25519() {
          if (this._publicKeyED25519 == null) {
              throw new Error(
                  "Cache.publicKeyED25519 was used before it was set",
              );
          }

          return this._publicKeyED25519;
      }

      /**
       * @param {FromProtobufKeyFuncT<Uint8Array, PublicKey>} publicKeyECDSA
       */
      setPublicKeyECDSA(publicKeyECDSA) {
          this._publicKeyECDSA = publicKeyECDSA;
      }

      /**
       * @returns {FromProtobufKeyFuncT<Uint8Array, PublicKey>}
       */
      get publicKeyECDSA() {
          if (this._publicKeyECDSA == null) {
              throw new Error("Cache.publicKeyECDSA was used before it was set");
          }

          return this._publicKeyECDSA;
      }

      /**
       * @param {((key: cryptography.PrivateKey) => PrivateKey)} privateKeyConstructor
       */
      setPrivateKeyConstructor(privateKeyConstructor) {
          this._privateKeyConstructor = privateKeyConstructor;
      }

      /**
       * @returns {((key: cryptography.PrivateKey) => PrivateKey)}
       */
      get privateKeyConstructor() {
          if (this._privateKeyConstructor == null) {
              throw new Error(
                  "Cache.privateKeyConstructor was used before it was set",
              );
          }

          return this._privateKeyConstructor;
      }

      /**
       * @param {((key: cryptography.Mnemonic) => Mnemonic)} mnemonicFromString
       */
      setMnemonicFromString(mnemonicFromString) {
          this._mnemonicFromString = mnemonicFromString;
      }

      /**
       * @returns {((key: cryptography.PrivateKey) => PrivateKey)}
       */
      get mnemonicFromString() {
          if (this._mnemonicFromString == null) {
              throw new Error(
                  "Cache.mnemonicFromString was used before it was set",
              );
          }

          return this.mnemonicFromString;
      }

      /**
       * @param {((shard: Long | number, realm: Long | number, key: PublicKey) => AccountId)} accountIdConstructor
       */
      setAccountIdConstructor(accountIdConstructor) {
          this._accountIdConstructor = accountIdConstructor;
      }

      /**
       * @returns {((shard: Long | number, realm: Long | number, key: PublicKey) => AccountId)}
       */
      get accountIdConstructor() {
          if (this._accountIdConstructor == null) {
              throw new Error(
                  "Cache.accountIdConstructor was used before it was set",
              );
          }

          return this._accountIdConstructor;
      }

      /**
       * @param {FromProtobufKeyFuncT<HieroProto.proto.IContractID, ContractId>} delegateContractId
       */
      setDelegateContractId(delegateContractId) {
          this._delegateContractId = delegateContractId;
      }

      /**
       * @returns {FromProtobufKeyFuncT<HieroProto.proto.IContractID, ContractId>}
       */
      get delegateContractId() {
          if (this._delegateContractId == null) {
              throw new Error(
                  "Cache.delegateContractId was used before it was set",
              );
          }

          return this._delegateContractId;
      }

      /**
       * @param {FromProtobufKeyFuncT<Uint8Array, EvmAddress>} evmAddress
       */
      setEvmAddress(evmAddress) {
          this._evmAddress = evmAddress;
      }

      /**
       * @returns {FromProtobufKeyFuncT<Uint8Array, EvmAddress>}
       */
      get evmAddress() {
          if (this._evmAddress == null) {
              throw new Error("Cache.evmAddress was used before it was set");
          }

          return this._evmAddress;
      }

      /**
       * @param {((bytes: Uint8Array) => EthereumTransactionData)} ethereumTransactionDataLegacyFromBytes
       */
      setEthereumTransactionDataLegacyFromBytes(
          ethereumTransactionDataLegacyFromBytes,
      ) {
          this._ethereumTransactionDataLegacyFromBytes =
              ethereumTransactionDataLegacyFromBytes;
      }

      /**
       * @returns {((bytes: Uint8Array) => EthereumTransactionData)}
       */
      get ethereumTransactionDataLegacyFromBytes() {
          if (this._ethereumTransactionDataLegacyFromBytes == null) {
              throw new Error(
                  "Cache.ethereumTransactionDataLegacyFromBytes was used before it was set",
              );
          }

          return this._ethereumTransactionDataLegacyFromBytes;
      }

      /**
       * @param {((bytes: Uint8Array) => EthereumTransactionData)} ethereumTransactionDataEip1559FromBytes
       */
      setEthereumTransactionDataEip1559FromBytes(
          ethereumTransactionDataEip1559FromBytes,
      ) {
          this._ethereumTransactionDataEip1559FromBytes =
              ethereumTransactionDataEip1559FromBytes;
      }

      /**
       * @returns {((bytes: Uint8Array) => EthereumTransactionData)}
       */
      get ethereumTransactionDataEip1559FromBytes() {
          if (this._ethereumTransactionDataEip1559FromBytes == null) {
              throw new Error(
                  "Cache.ethereumTransactionDataEip1559FromBytes was used before it was set",
              );
          }

          return this._ethereumTransactionDataEip1559FromBytes;
      }

      /**
       * @param {((bytes: Uint8Array) => EthereumTransactionData)} ethereumTransactionDataEip2930FromBytes
       */
      setEthereumTransactionDataEip2930FromBytes(
          ethereumTransactionDataEip2930FromBytes,
      ) {
          this._ethereumTransactionDataEip2930FromBytes =
              ethereumTransactionDataEip2930FromBytes;
      }

      /**
       * @returns {((bytes: Uint8Array) => EthereumTransactionData)}
       */
      get ethereumTransactionDataEip2930FromBytes() {
          if (this._ethereumTransactionDataEip2930FromBytes == null) {
              throw new Error(
                  "Cache.ethereumTransactionDataEip2930FromBytes was used before it was set",
              );
          }

          return this._ethereumTransactionDataEip2930FromBytes;
      }

      /**
       * @param {(() => TransactionReceiptQuery)} transactionReceiptQueryConstructor
       */
      setTransactionReceiptQueryConstructor(transactionReceiptQueryConstructor) {
          this._transactionReceiptQueryConstructor =
              transactionReceiptQueryConstructor;
      }

      /**
       * @returns {(() => TransactionReceiptQuery)}
       */
      get transactionReceiptQueryConstructor() {
          if (this._transactionReceiptQueryConstructor == null) {
              throw new Error(
                  "Cache.transactionReceiptQueryConstructor was used before it was set",
              );
          }

          return this._transactionReceiptQueryConstructor;
      }

      /**
       * @param {(() => TransactionRecordQuery)} transactionRecordQueryConstructor
       */
      setTransactionRecordQueryConstructor(transactionRecordQueryConstructor) {
          this._transactionRecordQueryConstructor =
              transactionRecordQueryConstructor;
      }

      /**
       * @returns {(() => TransactionRecordQuery)}
       */
      get transactionRecordQueryConstructor() {
          if (this._transactionRecordQueryConstructor == null) {
              throw new Error(
                  "Cache.transactionRecordQueryConstructor was used before it was set",
              );
          }

          return this._transactionRecordQueryConstructor;
      }
  }

  /**
   * This variable is strictly designed to prevent cyclic dependencies.
   */
  const CACHE = new Cache();

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.IKey} HieroProto.proto.IKey
   */

  class Key {
      /**
       * @internal
       * @abstract
       * @returns {HieroProto.proto.IKey}
       */
      // eslint-disable-next-line jsdoc/require-returns-check
      _toProtobufKey() {
          throw new Error("not implemented");
      }

      /**
       * @internal
       * @param {HieroProto.proto.IKey} key
       * @returns {Key}
       */
      static _fromProtobufKey(key) {
          if (key.contractID != null) {
              return CACHE.contractId(key.contractID);
          }

          if (key.delegatableContractId != null) {
              return CACHE.delegateContractId(key.delegatableContractId);
          }

          if (key.ed25519 != null && key.ed25519.byteLength > 0) {
              return CACHE.publicKeyED25519(key.ed25519);
          }

          if (key.ECDSASecp256k1 != null && key.ECDSASecp256k1.byteLength > 0) {
              return CACHE.publicKeyECDSA(key.ECDSASecp256k1);
          }

          if (key.thresholdKey != null && key.thresholdKey.threshold != null) {
              return CACHE.thresholdKey(key.thresholdKey);
          }

          if (key.keyList != null) {
              return CACHE.keyList(key.keyList);
          }

          // @ts-ignore
          return null;

          /* throw new Error(
              `(BUG) keyFromProtobuf: not implemented key case: ${JSON.stringify(
                  key
              )}`
          ); */
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {import("./transaction/Transaction.js").default} Transaction
   * @typedef {import("./account/AccountId.js").default} AccountId
   */

  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.IKey} HieroProto.proto.IKey
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   * @typedef {import("@hashgraph/proto").proto.ISignaturePair} HieroProto.proto.ISignaturePair
   * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
   */

  class PublicKey extends Key {
      /**
       * @internal
       * @hideconstructor
       * @param {PublicKeyCrypto} key
       */
      constructor(key) {
          super();

          this._key = key;
      }

      /**
       * @param {Uint8Array} data
       * @returns {PublicKey}
       */
      static fromBytes(data) {
          return new PublicKey(PublicKey$1.fromBytes(data));
      }

      /**
       * @param {Uint8Array} data
       * @returns {PublicKey}
       */
      static fromBytesED25519(data) {
          return new PublicKey(PublicKey$1.fromBytesED25519(data));
      }

      /**
       * @param {Uint8Array} data
       * @returns {PublicKey}
       */
      static fromBytesECDSA(data) {
          return new PublicKey(PublicKey$1.fromBytesECDSA(data));
      }

      /**
       * Parse a public key from a string of hexadecimal digits.
       *
       * The public key may optionally be prefixed with
       * the DER header.
       *
       * @param {string} text
       * @returns {PublicKey}
       */
      static fromString(text) {
          return new PublicKey(PublicKey$1.fromString(text));
      }

      /**
       * Parse an ECDSA public key from a string of hexadecimal digits.
       *
       * @param {string} text
       * @returns {PublicKey}
       */
      static fromStringECDSA(text) {
          return new PublicKey(PublicKey$1.fromStringECDSA(text));
      }

      /**
       * Parse an ED25519 public key from a string of hexadecimal digits.
       *
       * @param {string} text
       * @returns {PublicKey}
       */
      static fromStringED25519(text) {
          return new PublicKey(PublicKey$1.fromStringED25519(text));
      }

      /**
       * Verify a signature on a message with this public key.
       *
       * @param {Uint8Array} message
       * @param {Uint8Array} signature
       * @returns {boolean}
       */
      verify(message, signature) {
          return this._key.verify(message, signature);
      }

      /**
       * Reports whether this key signed the given transaction.
       * @param {Transaction} transaction
       * @returns {boolean}
       */
      verifyTransaction(transaction) {
          transaction._requireFrozen();

          if (!transaction.isFrozen()) {
              transaction.freeze();
          }

          // Note: in other SDKs, we need to check the transaction's `_signerPublicKeys` since we don't build the `_signedTransactions` list
          // before we execute the transaction (execute -> makeRequest -> buildTransaction -> signTransaction).
          // However, in JavaScript, we build the `_signedTransactions` list while signing the transaction.
          for (const signedTransaction of transaction._signedTransactions.list) {
              if (
                  signedTransaction.sigMap != null &&
                  signedTransaction.sigMap.sigPair != null
              ) {
                  let found = false;
                  for (const sigPair of signedTransaction.sigMap.sigPair) {
                      const pubKeyPrefix = /** @type {Uint8Array} */ (
                          sigPair.pubKeyPrefix
                      );
                      if (arrayEqual(pubKeyPrefix, this.toBytesRaw())) {
                          found = true;

                          const bodyBytes = /** @type {Uint8Array} */ (
                              signedTransaction.bodyBytes
                          );

                          let signature = null;
                          if (sigPair.ed25519 != null) {
                              signature = sigPair.ed25519;
                          } else if (sigPair.ECDSASecp256k1 != null) {
                              signature = sigPair.ECDSASecp256k1;
                          }

                          if (signature == null) {
                              continue;
                          }

                          if (!this.verify(bodyBytes, signature)) {
                              return false;
                          }
                      }
                  }

                  if (!found) {
                      return false;
                  }
              }
          }

          return true;
      }

      /**
       * @returns {Uint8Array}
       */
      toBytes() {
          return this._key.toBytes();
      }

      /**
       * @returns {Uint8Array}
       */
      toBytesDer() {
          return this._key.toBytesDer();
      }

      /**
       * @returns {Uint8Array}
       */
      toBytesRaw() {
          return this._key.toBytesRaw();
      }

      /**
       * @deprecated Use `toEvmAddress()` instead.
       * @returns {string}
       */
      toEthereumAddress() {
          return this._key.toEthereumAddress();
      }

      /**
       * @returns {string}
       */
      toEvmAddress() {
          return this._key.toEthereumAddress();
      }

      /**
       * @returns {string}
       */
      toString() {
          return this._key.toString();
      }

      /**
       * @returns {string}
       */
      toStringDer() {
          return this._key.toStringDer();
      }

      /**
       * @returns {string}
       */
      toStringRaw() {
          return this._key.toStringRaw();
      }

      /**
       * @param {PublicKey} other
       * @returns {boolean}
       */
      equals(other) {
          return this._key.equals(other._key);
      }

      /**
       * @returns {HieroProto.proto.IKey}
       */
      _toProtobufKey() {
          switch (this._key._type) {
              case "ED25519":
                  return {
                      ed25519: this._key.toBytesRaw(),
                  };
              case "secp256k1":
                  return {
                      ECDSASecp256k1: this._key.toBytesRaw(),
                  };
              default:
                  throw new Error(`unrecognized key type ${this._key._type}`);
          }
      }

      /**
       * @param {Uint8Array} signature
       * @returns {HieroProto.proto.ISignaturePair}
       */
      _toProtobufSignature(signature) {
          switch (this._key._type) {
              case "ED25519":
                  return {
                      pubKeyPrefix: this._key.toBytesRaw(),
                      ed25519: signature,
                  };
              case "secp256k1":
                  return {
                      pubKeyPrefix: this._key.toBytesRaw(),
                      ECDSASecp256k1: signature,
                  };
              default:
                  throw new Error(`unrecognized key type ${this._key._type}`);
          }
      }

      /**
       * @returns {string}
       */
      get type() {
          return this._key._type;
      }

      /**
       * @param {Long | number} shard
       * @param {Long | number} realm
       * @returns {AccountId}
       */
      toAccountId(shard, realm) {
          return CACHE.accountIdConstructor(shard, realm, this);
      }

      /**
       * Returns an "unusable" public key.
       * Unusable refers to a key such as an Ed25519 0x00000... public key,
       * since it is (presumably) impossible to find the 32-byte string whose SHA-512 hash begins with 32 bytes of zeros.
       *
       * @returns {PublicKey}
       */
      static unusableKey() {
          return PublicKey.fromStringED25519(
              "0000000000000000000000000000000000000000000000000000000000000000",
          );
      }
  }

  CACHE.setPublicKeyED25519((key) => PublicKey.fromBytesED25519(key));
  CACHE.setPublicKeyECDSA((key) => PublicKey.fromBytesECDSA(key));

  const version$6 = "logger/5.8.0";

  let _permanentCensorErrors = false;
  let _censorErrors = false;
  const LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
  let _logLevel = LogLevels["default"];
  let _globalLogger = null;
  function _checkNormalize() {
      try {
          const missing = [];
          // Make sure all forms of normalization are supported
          ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
              try {
                  if ("test".normalize(form) !== "test") {
                      throw new Error("bad normalize");
                  }
                  ;
              }
              catch (error) {
                  missing.push(form);
              }
          });
          if (missing.length) {
              throw new Error("missing " + missing.join(", "));
          }
          if (String.fromCharCode(0xe9).normalize("NFD") !== String.fromCharCode(0x65, 0x0301)) {
              throw new Error("broken implementation");
          }
      }
      catch (error) {
          return error.message;
      }
      return null;
  }
  const _normalizeError = _checkNormalize();
  var LogLevel$1;
  (function (LogLevel) {
      LogLevel["DEBUG"] = "DEBUG";
      LogLevel["INFO"] = "INFO";
      LogLevel["WARNING"] = "WARNING";
      LogLevel["ERROR"] = "ERROR";
      LogLevel["OFF"] = "OFF";
  })(LogLevel$1 || (LogLevel$1 = {}));
  var ErrorCode;
  (function (ErrorCode) {
      ///////////////////
      // Generic Errors
      // Unknown Error
      ErrorCode["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
      // Not Implemented
      ErrorCode["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
      // Unsupported Operation
      //   - operation
      ErrorCode["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
      // Network Error (i.e. Ethereum Network, such as an invalid chain ID)
      //   - event ("noNetwork" is not re-thrown in provider.ready; otherwise thrown)
      ErrorCode["NETWORK_ERROR"] = "NETWORK_ERROR";
      // Some sort of bad response from the server
      ErrorCode["SERVER_ERROR"] = "SERVER_ERROR";
      // Timeout
      ErrorCode["TIMEOUT"] = "TIMEOUT";
      ///////////////////
      // Operational  Errors
      // Buffer Overrun
      ErrorCode["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
      // Numeric Fault
      //   - operation: the operation being executed
      //   - fault: the reason this faulted
      ErrorCode["NUMERIC_FAULT"] = "NUMERIC_FAULT";
      ///////////////////
      // Argument Errors
      // Missing new operator to an object
      //  - name: The name of the class
      ErrorCode["MISSING_NEW"] = "MISSING_NEW";
      // Invalid argument (e.g. value is incompatible with type) to a function:
      //   - argument: The argument name that was invalid
      //   - value: The value of the argument
      ErrorCode["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
      // Missing argument to a function:
      //   - count: The number of arguments received
      //   - expectedCount: The number of arguments expected
      ErrorCode["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
      // Too many arguments
      //   - count: The number of arguments received
      //   - expectedCount: The number of arguments expected
      ErrorCode["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
      ///////////////////
      // Blockchain Errors
      // Call exception
      //  - transaction: the transaction
      //  - address?: the contract address
      //  - args?: The arguments passed into the function
      //  - method?: The Solidity method signature
      //  - errorSignature?: The EIP848 error signature
      //  - errorArgs?: The EIP848 error parameters
      //  - reason: The reason (only for EIP848 "Error(string)")
      ErrorCode["CALL_EXCEPTION"] = "CALL_EXCEPTION";
      // Insufficient funds (< value + gasLimit * gasPrice)
      //   - transaction: the transaction attempted
      ErrorCode["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
      // Nonce has already been used
      //   - transaction: the transaction attempted
      ErrorCode["NONCE_EXPIRED"] = "NONCE_EXPIRED";
      // The replacement fee for the transaction is too low
      //   - transaction: the transaction attempted
      ErrorCode["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
      // The gas limit could not be estimated
      //   - transaction: the transaction passed to estimateGas
      ErrorCode["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
      // The transaction was replaced by one with a higher gas price
      //   - reason: "cancelled", "replaced" or "repriced"
      //   - cancelled: true if reason == "cancelled" or reason == "replaced")
      //   - hash: original transaction hash
      //   - replacement: the full TransactionsResponse for the replacement
      //   - receipt: the receipt of the replacement
      ErrorCode["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
      ///////////////////
      // Interaction Errors
      // The user rejected the action, such as signing a message or sending
      // a transaction
      ErrorCode["ACTION_REJECTED"] = "ACTION_REJECTED";
  })(ErrorCode || (ErrorCode = {}));
  const HEX = "0123456789abcdef";
  let Logger$1 = class Logger {
      constructor(version) {
          Object.defineProperty(this, "version", {
              enumerable: true,
              value: version,
              writable: false
          });
      }
      _log(logLevel, args) {
          const level = logLevel.toLowerCase();
          if (LogLevels[level] == null) {
              this.throwArgumentError("invalid log level name", "logLevel", logLevel);
          }
          if (_logLevel > LogLevels[level]) {
              return;
          }
          console.log.apply(console, args);
      }
      debug(...args) {
          this._log(Logger.levels.DEBUG, args);
      }
      info(...args) {
          this._log(Logger.levels.INFO, args);
      }
      warn(...args) {
          this._log(Logger.levels.WARNING, args);
      }
      makeError(message, code, params) {
          // Errors are being censored
          if (_censorErrors) {
              return this.makeError("censored error", code, {});
          }
          if (!code) {
              code = Logger.errors.UNKNOWN_ERROR;
          }
          if (!params) {
              params = {};
          }
          const messageDetails = [];
          Object.keys(params).forEach((key) => {
              const value = params[key];
              try {
                  if (value instanceof Uint8Array) {
                      let hex = "";
                      for (let i = 0; i < value.length; i++) {
                          hex += HEX[value[i] >> 4];
                          hex += HEX[value[i] & 0x0f];
                      }
                      messageDetails.push(key + "=Uint8Array(0x" + hex + ")");
                  }
                  else {
                      messageDetails.push(key + "=" + JSON.stringify(value));
                  }
              }
              catch (error) {
                  messageDetails.push(key + "=" + JSON.stringify(params[key].toString()));
              }
          });
          messageDetails.push(`code=${code}`);
          messageDetails.push(`version=${this.version}`);
          const reason = message;
          let url = "";
          switch (code) {
              case ErrorCode.NUMERIC_FAULT: {
                  url = "NUMERIC_FAULT";
                  const fault = message;
                  switch (fault) {
                      case "overflow":
                      case "underflow":
                      case "division-by-zero":
                          url += "-" + fault;
                          break;
                      case "negative-power":
                      case "negative-width":
                          url += "-unsupported";
                          break;
                      case "unbound-bitwise-result":
                          url += "-unbound-result";
                          break;
                  }
                  break;
              }
              case ErrorCode.CALL_EXCEPTION:
              case ErrorCode.INSUFFICIENT_FUNDS:
              case ErrorCode.MISSING_NEW:
              case ErrorCode.NONCE_EXPIRED:
              case ErrorCode.REPLACEMENT_UNDERPRICED:
              case ErrorCode.TRANSACTION_REPLACED:
              case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
                  url = code;
                  break;
          }
          if (url) {
              message += " [ See: https:/\/links.ethers.org/v5-errors-" + url + " ]";
          }
          if (messageDetails.length) {
              message += " (" + messageDetails.join(", ") + ")";
          }
          // @TODO: Any??
          const error = new Error(message);
          error.reason = reason;
          error.code = code;
          Object.keys(params).forEach(function (key) {
              error[key] = params[key];
          });
          return error;
      }
      throwError(message, code, params) {
          throw this.makeError(message, code, params);
      }
      throwArgumentError(message, name, value) {
          return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {
              argument: name,
              value: value
          });
      }
      assert(condition, message, code, params) {
          if (!!condition) {
              return;
          }
          this.throwError(message, code, params);
      }
      assertArgument(condition, message, name, value) {
          if (!!condition) {
              return;
          }
          this.throwArgumentError(message, name, value);
      }
      checkNormalize(message) {
          if (_normalizeError) {
              this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
                  operation: "String.prototype.normalize", form: _normalizeError
              });
          }
      }
      checkSafeUint53(value, message) {
          if (typeof (value) !== "number") {
              return;
          }
          if (message == null) {
              message = "value not safe";
          }
          if (value < 0 || value >= 0x1fffffffffffff) {
              this.throwError(message, Logger.errors.NUMERIC_FAULT, {
                  operation: "checkSafeInteger",
                  fault: "out-of-safe-range",
                  value: value
              });
          }
          if (value % 1) {
              this.throwError(message, Logger.errors.NUMERIC_FAULT, {
                  operation: "checkSafeInteger",
                  fault: "non-integer",
                  value: value
              });
          }
      }
      checkArgumentCount(count, expectedCount, message) {
          if (message) {
              message = ": " + message;
          }
          else {
              message = "";
          }
          if (count < expectedCount) {
              this.throwError("missing argument" + message, Logger.errors.MISSING_ARGUMENT, {
                  count: count,
                  expectedCount: expectedCount
              });
          }
          if (count > expectedCount) {
              this.throwError("too many arguments" + message, Logger.errors.UNEXPECTED_ARGUMENT, {
                  count: count,
                  expectedCount: expectedCount
              });
          }
      }
      checkNew(target, kind) {
          if (target === Object || target == null) {
              this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
          }
      }
      checkAbstract(target, kind) {
          if (target === kind) {
              this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
          }
          else if (target === Object || target == null) {
              this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
          }
      }
      static globalLogger() {
          if (!_globalLogger) {
              _globalLogger = new Logger(version$6);
          }
          return _globalLogger;
      }
      static setCensorship(censorship, permanent) {
          if (!censorship && permanent) {
              this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
                  operation: "setCensorship"
              });
          }
          if (_permanentCensorErrors) {
              if (!censorship) {
                  return;
              }
              this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
                  operation: "setCensorship"
              });
          }
          _censorErrors = !!censorship;
          _permanentCensorErrors = !!permanent;
      }
      static setLogLevel(logLevel) {
          const level = LogLevels[logLevel.toLowerCase()];
          if (level == null) {
              Logger.globalLogger().warn("invalid log level - " + logLevel);
              return;
          }
          _logLevel = level;
      }
      static from(version) {
          return new Logger(version);
      }
  };
  Logger$1.errors = ErrorCode;
  Logger$1.levels = LogLevel$1;

  const version$5 = "bytes/5.8.0";

  const logger$8 = new Logger$1(version$5);
  ///////////////////////////////
  function isHexable(value) {
      return !!(value.toHexString);
  }
  function addSlice(array) {
      if (array.slice) {
          return array;
      }
      array.slice = function () {
          const args = Array.prototype.slice.call(arguments);
          return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
      };
      return array;
  }
  function isBytesLike(value) {
      return ((isHexString(value) && !(value.length % 2)) || isBytes(value));
  }
  function isInteger(value) {
      return (typeof (value) === "number" && value == value && (value % 1) === 0);
  }
  function isBytes(value) {
      if (value == null) {
          return false;
      }
      if (value.constructor === Uint8Array) {
          return true;
      }
      if (typeof (value) === "string") {
          return false;
      }
      if (!isInteger(value.length) || value.length < 0) {
          return false;
      }
      for (let i = 0; i < value.length; i++) {
          const v = value[i];
          if (!isInteger(v) || v < 0 || v >= 256) {
              return false;
          }
      }
      return true;
  }
  function arrayify(value, options) {
      if (!options) {
          options = {};
      }
      if (typeof (value) === "number") {
          logger$8.checkSafeUint53(value, "invalid arrayify value");
          const result = [];
          while (value) {
              result.unshift(value & 0xff);
              value = parseInt(String(value / 256));
          }
          if (result.length === 0) {
              result.push(0);
          }
          return addSlice(new Uint8Array(result));
      }
      if (options.allowMissingPrefix && typeof (value) === "string" && value.substring(0, 2) !== "0x") {
          value = "0x" + value;
      }
      if (isHexable(value)) {
          value = value.toHexString();
      }
      if (isHexString(value)) {
          let hex = value.substring(2);
          if (hex.length % 2) {
              if (options.hexPad === "left") {
                  hex = "0" + hex;
              }
              else if (options.hexPad === "right") {
                  hex += "0";
              }
              else {
                  logger$8.throwArgumentError("hex data is odd-length", "value", value);
              }
          }
          const result = [];
          for (let i = 0; i < hex.length; i += 2) {
              result.push(parseInt(hex.substring(i, i + 2), 16));
          }
          return addSlice(new Uint8Array(result));
      }
      if (isBytes(value)) {
          return addSlice(new Uint8Array(value));
      }
      return logger$8.throwArgumentError("invalid arrayify value", "value", value);
  }
  function concat(items) {
      const objects = items.map(item => arrayify(item));
      const length = objects.reduce((accum, item) => (accum + item.length), 0);
      const result = new Uint8Array(length);
      objects.reduce((offset, object) => {
          result.set(object, offset);
          return offset + object.length;
      }, 0);
      return addSlice(result);
  }
  function isHexString(value, length) {
      if (typeof (value) !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
          return false;
      }
      if (length && value.length !== 2 + 2 * length) {
          return false;
      }
      return true;
  }
  const HexCharacters = "0123456789abcdef";
  function hexlify(value, options) {
      if (!options) {
          options = {};
      }
      if (typeof (value) === "number") {
          logger$8.checkSafeUint53(value, "invalid hexlify value");
          let hex = "";
          while (value) {
              hex = HexCharacters[value & 0xf] + hex;
              value = Math.floor(value / 16);
          }
          if (hex.length) {
              if (hex.length % 2) {
                  hex = "0" + hex;
              }
              return "0x" + hex;
          }
          return "0x00";
      }
      if (typeof (value) === "bigint") {
          value = value.toString(16);
          if (value.length % 2) {
              return ("0x0" + value);
          }
          return "0x" + value;
      }
      if (options.allowMissingPrefix && typeof (value) === "string" && value.substring(0, 2) !== "0x") {
          value = "0x" + value;
      }
      if (isHexable(value)) {
          return value.toHexString();
      }
      if (isHexString(value)) {
          if (value.length % 2) {
              if (options.hexPad === "left") {
                  value = "0x0" + value.substring(2);
              }
              else if (options.hexPad === "right") {
                  value += "0";
              }
              else {
                  logger$8.throwArgumentError("hex data is odd-length", "value", value);
              }
          }
          return value.toLowerCase();
      }
      if (isBytes(value)) {
          let result = "0x";
          for (let i = 0; i < value.length; i++) {
              let v = value[i];
              result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];
          }
          return result;
      }
      return logger$8.throwArgumentError("invalid hexlify value", "value", value);
  }
  function hexConcat(items) {
      let result = "0x";
      items.forEach((item) => {
          result += hexlify(item).substring(2);
      });
      return result;
  }
  function hexZeroPad(value, length) {
      if (typeof (value) !== "string") {
          value = hexlify(value);
      }
      else if (!isHexString(value)) {
          logger$8.throwArgumentError("invalid hex string", "value", value);
      }
      if (value.length > 2 * length + 2) {
          logger$8.throwArgumentError("value out of range", "value", arguments[1]);
      }
      while (value.length < 2 * length + 2) {
          value = "0x0" + value.substring(2);
      }
      return value;
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.IKey} HieroProto.proto.IKey
   */

  /**
   * @typedef {import("./client/Client.js").default<*, *>} Client
   */

  /**
   *  Represents an Ethereum Virtual Machine (EVM) address.
   * This class extends the Key class and provides functionality for handling EVM addresses.
   */
  class EvmAddress extends Key {
      /**
       * @internal
       * @param {Uint8Array} bytes
       */
      constructor(bytes) {
          super();
          this._bytes = bytes;
      }

      /**
       * Creates an EvmAddress from a hex string representation.
       * @param {string} evmAddress - The hex string representing the EVM address
       * @returns {EvmAddress}
       * @throws {Error} If the input string is not the correct size
       */
      static fromString(evmAddress) {
          evmAddress = evmAddress.startsWith("0x")
              ? evmAddress.slice(2)
              : evmAddress;

          // Standard EVM address is 20 bytes which is 40 hex characters
          if (evmAddress.length !== 40) {
              throw new Error("Input EVM address string is not the correct size");
          }

          return new EvmAddress(decode$8(evmAddress));
      }

      /**
       * @param {Uint8Array} bytes
       * @returns {EvmAddress}
       */
      static fromBytes(bytes) {
          return new EvmAddress(bytes);
      }

      /**
       * @returns {Uint8Array}
       */
      toBytes() {
          return this._bytes;
      }

      /**
       * @returns {string}
       */
      toString() {
          return encode$5(this._bytes);
      }

      /**
       * @param {EvmAddress} other
       * @returns {boolean}
       */
      equals(other) {
          return arrayEqual$2(this._bytes, other._bytes);
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {import("./client/Client.js").default<*, *>} Client
   */

  /**
   * @typedef {object} IEntityId
   * @property {number | Long} num
   * @property {(number | Long)=} shard
   * @property {(number | Long)=} realm
   */

  /**
   * @typedef {object} IEntityIdResult
   * @property {Long} shard
   * @property {Long} realm
   * @property {Long} num
   */

  /**
   * @typedef {object} IEntityIdParts
   * @property {string?} shard
   * @property {string?} realm
   * @property {string} numOrHex
   * @property {string?} checksum
   */

  /**
   * @typedef {object} IEntityIdResultWithChecksum
   * @property {Long} shard
   * @property {Long} realm
   * @property {Long} num
   * @property {string | null} checksum
   */

  const regex =
      /"^(0|(?:[1-9]\\d*))\\.(0|(?:[1-9]\\d*))\\.(0|(?:[1-9]\\d*))(?:-([a-z]{5}))?$/;

  /**
   * This regex supports entity IDs
   *  - as stand alone nubmers
   *  - as shard.realm.num
   *  - as shard.realm.hex
   *  - can optionally provide checksum for any of the above
   */
  const ENTITY_ID_REGEX = /^(\d+)(?:\.(\d+)\.([a-fA-F0-9]+))?(?:-([a-z]{5}))?$/;

  /**
   * @description The length of an EVM address in bytes.
   */
  const EVM_ADDRESS_LENGTH = 20;

  /**
   * @description The length of the long-zero prefix in bytes.
   */
  const LONG_ZERO_PREFIX_LENGTH = 12;

  /**
   * @description The offset of the entity number in the EVM address.
   */
  const ENTITY_NUM_OFFSET = 16;

  /**
   * This method is called by most entity ID constructors. It's purpose is to
   * deduplicate the constuctors.
   *
   * @param {number | Long | IEntityId} props
   * @param {(number | null | Long)=} realmOrNull
   * @param {(number | null | Long)=} numOrNull
   * @returns {IEntityIdResult}
   */
  function constructor(props, realmOrNull, numOrNull) {
      // Make sure either both the second and third parameter are
      // set or not set; we shouldn't have one set, but the other not set.
      //
      //NOSONAR
      if (
          (realmOrNull == null && numOrNull != null) ||
          (realmOrNull != null && numOrNull == null)
      ) {
          throw new Error("invalid entity ID");
      }

      // If the first parameter is a number then we need to convert the
      // first, second, and third parameters into numbers. Otherwise,
      // we should look at the fields `shard`, `realm`, and `num` on
      // `props`
      const [shard, realm, num] =
          typeof props === "number" || Long.isLong(props)
              ? [
                    numOrNull != null
                        ? Long.fromValue(/** @type {Long | number} */ (props))
                        : Long.ZERO,
                    realmOrNull != null ? Long.fromValue(realmOrNull) : Long.ZERO,
                    numOrNull != null
                        ? Long.fromValue(numOrNull)
                        : Long.fromValue(/** @type {Long | number} */ (props)),
                ]
              : [
                    props.shard != null ? Long.fromValue(props.shard) : Long.ZERO,
                    props.realm != null ? Long.fromValue(props.realm) : Long.ZERO,
                    Long.fromValue(props.num),
                ];

      // Make sure none of the numbers are negative
      if (shard.isNegative() || realm.isNegative() || num.isNegative()) {
          throw new Error("negative numbers are not allowed in IDs");
      }

      return {
          shard,
          realm,
          num,
      };
  }

  /**
   * A simple comparison function for comparing entity IDs
   *
   * @param {[Long, Long, Long]} a
   * @param {[Long, Long, Long]} b
   * @returns {number}
   */
  function compare(a, b) {
      let comparison = a[0].compare(b[0]);
      if (comparison != 0) {
          return comparison;
      }

      comparison = a[1].compare(b[1]);
      if (comparison != 0) {
          return comparison;
      }

      return a[2].compare(b[2]);
  }

  /**
   * This type is part of the entity ID checksums feature which
   * is responsible for checking if an entity ID was created on
   * the same ledger ID as the client is currently using.
   *
   * @typedef {object} ParseAddressResult
   * @property {number} status
   * @property {Long} [num1]
   * @property {Long} [num2]
   * @property {Long} [num3]
   * @property {string} [correctChecksum]
   * @property {string} [givenChecksum]
   * @property {string} [noChecksumFormat]
   * @property {string} [withChecksumFormat]
   */

  /**
   * @param {string} text
   * @returns {IEntityIdParts}
   */
  function fromStringSplitter(text) {
      const match = ENTITY_ID_REGEX.exec(text);

      if (match == null) {
          throw new Error(`failed to parse entity id: ${text}`);
      }

      if (match[2] == null && match[3] == null) {
          return {
              shard: "0",
              realm: "0",
              numOrHex: match[1],
              checksum: match[4],
          };
      } else {
          return {
              shard: match[1],
              realm: match[2],
              numOrHex: match[3],
              checksum: match[4],
          };
      }
  }

  /**
   * @param {string} text
   * @returns {IEntityIdResultWithChecksum}
   */
  function fromString(text) {
      const result = fromStringSplitter(text);

      if (
          Number.isNaN(result.shard) ||
          Number.isNaN(result.realm) ||
          Number.isNaN(result.numOrHex)
      ) {
          throw new Error("invalid format for entity ID");
      }

      return {
          shard: result.shard != null ? Long.fromString(result.shard) : Long.ZERO,
          realm: result.realm != null ? Long.fromString(result.realm) : Long.ZERO,
          num: Long.fromString(result.numOrHex),
          checksum: result.checksum,
      };
  }

  /**
   * Return the shard, realm, and num from a solidity address.
   *
   * Solidity addresses are 20 bytes long and hex encoded, where the first 4
   * bytes represent the shard, the next 8 bytes represent the realm, and
   * the last 8 bytes represent the num. All in Big Endian format
   *
   * @param {string} address
   * @returns {[Long, Long, Long]}
   */
  function fromSolidityAddress(address) {
      const addr = address.startsWith("0x")
          ? decode$8(address.slice(2))
          : decode$8(address);

      if (addr.length !== EVM_ADDRESS_LENGTH) {
          throw new Error(`Invalid hex encoded solidity address length:
                expected length 40, got length ${address.length}`);
      }

      const shard = Long.fromBytesBE([0, 0, 0, 0, ...addr.slice(0, 4)]);
      const realm = Long.fromBytesBE(Array.from(addr.slice(4, 12)));
      const num = Long.fromBytesBE(Array.from(addr.slice(12, 20)));

      return [shard, realm, num];
  }

  /**
   * Parse an EVM address and return shard, realm, entity num, and optional EVM address.
   *
   * For long zero addresses (first 12 bytes are zeros): returns [shard, realm, entityNum, null]
   * For regular EVM addresses: returns [shard, realm, 0, EvmAddress]
   *
   * @param {Long | number} shard - The shard number to use
   * @param {Long | number} realm - The realm number to use
   * @param {string} address - The EVM address to parse (with or without 0x prefix)
   * @returns {[Long, Long, Long, EvmAddress | null]} - [shard, realm, entityNum, evmAddressOrNull]
   */
  function fromEvmAddress(shard, realm, address) {
      if (!isHexString$1(address)) {
          throw new Error(`Invalid EVM address hex string: ${address}`);
      }

      const addr = address.startsWith("0x")
          ? decode$8(address.slice(2))
          : decode$8(address);

      if (addr.length !== EVM_ADDRESS_LENGTH) {
          throw new Error(`Invalid hex encoded evm address length:
                expected length ${EVM_ADDRESS_LENGTH}, got length ${address.length}`);
      }

      let num = Long.ZERO;

      if (isLongZeroAddress(addr)) {
          num = Long.fromBytesBE(
              Array.from(addr.slice(LONG_ZERO_PREFIX_LENGTH, EVM_ADDRESS_LENGTH)),
          );
      }

      let shardLong = shard instanceof Long ? shard : Long.fromNumber(shard);
      let realmLong = realm instanceof Long ? realm : Long.fromNumber(realm);

      return [
          shardLong,
          realmLong,
          num,
          num.isZero() ? EvmAddress.fromBytes(addr) : null,
      ];
  }

  /**
   * Convert shard, realm, and num into a solidity address.
   *
   * See `fromSolidityAddress()` for more documentation.
   *
   * @param {[Long,Long,Long] | [number,number,number]} address
   * @returns {string}
   */
  function toSolidityAddress(address) {
      const buffer = new Uint8Array(20);
      const view = safeView(buffer);
      const [shard, realm, num] = address;

      view.setUint32(0, convertToNumber(shard));
      view.setUint32(8, convertToNumber(realm));
      view.setUint32(16, convertToNumber(num));

      return encode$5(buffer);
  }

  /**
   * @overload
   * @param {Uint8Array} evmAddressBytes - EVM address bytes to convert to hex
   * @returns {string}
   */

  /**
   * @overload
   * @param {Long} accountNum - Account number to convert to long-zero EVM address
   * @returns {string}
   */

  /**
   * Convert EVM address bytes to hex string or account num to long-zero EVM address.
   *
   * @param {Uint8Array | Long} evmAddressBytesOrAccountNum
   * @returns {string}
   */
  function toEvmAddress(evmAddressBytesOrAccountNum) {
      if (evmAddressBytesOrAccountNum instanceof Uint8Array) {
          return encode$5(evmAddressBytesOrAccountNum);
      }

      const accountNum = evmAddressBytesOrAccountNum;
      const buffer = new Uint8Array(EVM_ADDRESS_LENGTH);
      const view = safeView(buffer);

      view.setUint32(ENTITY_NUM_OFFSET, convertToNumber(accountNum));

      return encode$5(buffer);
  }

  /**
   * Parse the address string addr and return an object with the results (8 fields).
   * The first four fields are numbers, which could be implemented as signed 32 bit
   * integers, and the last four are strings.
   *
   *   status;  //the status of the parsed address
   *            //   0 = syntax error
   *            //   1 = an invalid with-checksum address (bad checksum)
   *            //   2 = a valid no-checksum address
   *            //   3 = a valid with-checksum address
   *   num1;    //the 3 numbers in the address, such as 1.2.3, with leading zeros removed
   *   num2;
   *   num3;
   *   correctchecksum;    //the correct checksum
   *   givenChecksum;      //the checksum in the address that was parsed
   *   noChecksumFormat;   //the address in no-checksum format
   *   withChecksumFormat; //the address in with-checksum format
   *
   * @param {Uint8Array} ledgerId
   * @param {string} addr
   * @returns {ParseAddressResult}
   */
  function _parseAddress(ledgerId, addr) {
      let match = regex.exec(addr);
      if (match === null) {
          let result = { status: 0 }; // When status == 0, the rest of the fields should be ignored
          return result;
      }
      let a = [
          Long.fromString(match[1]),
          Long.fromString(match[2]),
          Long.fromString(match[3]),
      ];
      let ad = `${a[0].toString()}.${a[1].toString()}.${a[2].toString()}`;
      let c = _checksum(ledgerId, ad);
      let s = match[4] === undefined ? 2 : c == match[4] ? 3 : 1; //NOSONAR
      return {
          status: s,
          num1: a[0],
          num2: a[1],
          num3: a[2],
          givenChecksum: match[4],
          correctChecksum: c,
          noChecksumFormat: ad,
          withChecksumFormat: `${ad}-${c}`,
      };
  }

  /**
   * Given an address like "0.0.123", return a checksum like "laujm"
   *
   * @param {Uint8Array} ledgerId
   * @param {string} addr
   * @returns {string}
   */
  function _checksum(ledgerId, addr) {
      let answer = "";
      let d = []; // Digits with 10 for ".", so if addr == "0.0.123" then d == [0, 10, 0, 10, 1, 2, 3]
      let s0 = 0; // Sum of even positions (mod 11)
      let s1 = 0; // Sum of odd positions (mod 11)
      let s = 0; // Weighted sum of all positions (mod p3)
      let sh = 0; // Hash of the ledger ID
      let c = 0; // The checksum, as a single number
      const p3 = 26 * 26 * 26; // 3 digits in base 26
      const p5 = 26 * 26 * 26 * 26 * 26; // 5 digits in base 26
      const ascii_a = "a".charCodeAt(0); // 97
      const m = 1000003; // Min prime greater than a million. Used for the final permutation.
      const w = 31; // Sum s of digit values weights them by powers of w. Should be coprime to p5.

      let h = new Uint8Array(ledgerId.length + 6);
      h.set(ledgerId, 0);
      h.set([0, 0, 0, 0, 0, 0], ledgerId.length);
      for (let i = 0; i < addr.length; i++) {
          //NOSONAR
          d.push(addr[i] === "." ? 10 : parseInt(addr[i], 10));
      }
      for (let i = 0; i < d.length; i++) {
          s = (w * s + d[i]) % p3;
          if (i % 2 === 0) {
              s0 = (s0 + d[i]) % 11;
          } else {
              s1 = (s1 + d[i]) % 11;
          }
      }
      for (let i = 0; i < h.length; i++) {
          sh = (w * sh + h[i]) % p5;
      }
      c = ((((addr.length % 5) * 11 + s0) * 11 + s1) * p3 + s + sh) % p5;
      c = (c * m) % p5;

      for (let i = 0; i < 5; i++) {
          answer = String.fromCharCode(ascii_a + (c % 26)) + answer;
          c /= 26;
      }

      return answer;
  }

  /**
   * Validate an entity ID checksum against a client
   *
   * @param {Long} shard
   * @param {Long} realm
   * @param {Long} num
   * @param {string | null} checksum
   * @param {Client} client
   */
  function validateChecksum(shard, realm, num, checksum, client) {
      if (client._network._ledgerId == null || checksum == null) {
          return;
      }

      const expectedChecksum = _checksum(
          client._network._ledgerId._ledgerId,
          `${shard.toString()}.${realm.toString()}.${num.toString()}`,
      );

      if (checksum != expectedChecksum) {
          throw new BadEntityIdError(
              shard,
              realm,
              num,
              checksum,
              expectedChecksum,
          );
      }
  }

  /**
   * Stringify the entity ID with a checksum.
   *
   * @param {string} string
   * @param {Client} client
   * @returns {string}
   */
  function toStringWithChecksum(string, client) {
      if (client == null) {
          throw new Error("client cannot be null");
      }

      if (client._network._ledgerId == null) {
          throw new Error(
              "cannot calculate checksum with a client that does not contain a recognzied ledger ID",
          );
      }

      const checksum = _checksum(client._network._ledgerId._ledgerId, string);

      return `${string}-${checksum}`;
  }

  /**
   * Append Buffers.
   * @param {Uint8Array} buffer1
   * @param {Uint8Array} buffer2
   * @returns {Uint8Array}
   */
  function appendBuffer(buffer1, buffer2) {
      var tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);
      tmp.set(new Uint8Array(buffer1), 0);
      tmp.set(new Uint8Array(buffer2), buffer1.byteLength);
      return tmp;
  }

  /**
   * Convert bytes to hex string.
   * @param {Uint8Array} bytes
   * @returns {string}
   */
  function toHexString(bytes) {
      var s = "0x";
      bytes.forEach(function (byte) {
          s += ("0" + (byte & 0xff).toString(16)).slice(-2);
      });
      return s;
  }

  /**
   * Deserialize the alias to public key.
   * Alias is created from ed25519 or ECDSASecp256k1 types of accounts. If hollow account is used, the alias is created from evm address.
   * For hollow accounts, please use aliasToEvmAddress.
   *
   * @param {string} alias
   * @returns {PublicKey | null}
   */
  function aliasToPublicKey(alias) {
      const bytes = base32.decode(alias);
      if (!bytes) {
          return null;
      }
      let key;
      try {
          key = libExports.proto.Key.decode(bytes);
      } catch (e) {
          throw new Error(
              "The alias is created with hollow account. Please use aliasToEvmAddress!",
          );
      }

      if (key.ed25519 != null && key.ed25519.byteLength > 0) {
          return PublicKey.fromBytes(key.ed25519);
      }

      if (key.ECDSASecp256k1 != null && key.ECDSASecp256k1.byteLength > 0) {
          return PublicKey.fromBytes(key.ECDSASecp256k1);
      }

      return null;
  }

  /**
   * Deserialize the alias to evm address.
   * Alias is created from hollow account.
   * For ed25519 or ECDSASecp256k1 accounts, please use aliasToPublicKey.
   *
   * @param {string} alias
   * @returns {string | null}
   */
  function aliasToEvmAddress(alias) {
      const bytes = base32.decode(alias);
      if (!bytes) {
          return null;
      }
      try {
          libExports.proto.Key.decode(bytes);
          throw new Error(
              "The alias is created with ed25519 or ECDSASecp256k1 account. Please use aliasToPublicKey!",
          );
      } catch (e) {
          return toHexString(bytes);
      }
  }

  /**
   * Serialize the public key to alias.
   * Alias is created from ed25519 or ECDSASecp256k1 types of accounts. If hollow account is used, the alias is created from evm address.
   *
   * @param {string | PublicKey} publicKey
   * @returns {string | null}
   */
  function publicKeyToAlias(publicKey) {
      if (
          typeof publicKey === "string" &&
          ((publicKey.startsWith("0x") && publicKey.length == 42) ||
              publicKey.length == 40)
      ) {
          if (!publicKey.startsWith("0x")) {
              publicKey = `0x${publicKey}`;
          }

          const bytes = arrayify(publicKey);
          if (!bytes) {
              return null;
          }
          return base32.encode(bytes);
      }

      const publicKeyRaw =
          typeof publicKey === "string"
              ? PublicKey.fromString(publicKey)
              : publicKey;
      let publicKeyHex = publicKeyRaw.toStringRaw();
      let leadingHex = "";

      if (publicKeyRaw._key._type === "secp256k1") {
          leadingHex = "0x3A21"; // LEADING BYTES FROM PROTOBUFS
      }

      if (publicKeyRaw._key._type === "ED25519") {
          leadingHex = "0x1220"; // LEADING BYTES FROM PROTOBUFS
      }

      if (!publicKeyHex.startsWith("0x")) {
          publicKeyHex = `0x${publicKeyHex}`;
      }

      const leadingBytes = arrayify(leadingHex);
      const publicKeyBytes = arrayify(publicKeyHex);
      const publicKeyInBytes = appendBuffer(leadingBytes, publicKeyBytes);
      const alias = base32.encode(publicKeyInBytes);
      return alias;
  }

  var EntityIdHelper = /*#__PURE__*/Object.freeze({
    __proto__: null,
    _checksum: _checksum,
    _parseAddress: _parseAddress,
    aliasToEvmAddress: aliasToEvmAddress,
    aliasToPublicKey: aliasToPublicKey,
    compare: compare,
    constructor: constructor,
    fromEvmAddress: fromEvmAddress,
    fromSolidityAddress: fromSolidityAddress,
    fromString: fromString,
    fromStringSplitter: fromStringSplitter,
    publicKeyToAlias: publicKeyToAlias,
    toEvmAddress: toEvmAddress,
    toSolidityAddress: toSolidityAddress,
    toStringWithChecksum: toStringWithChecksum,
    validateChecksum: validateChecksum
  });

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {import("./PrivateKey.js").default} PrivateKey
   */

  const HARDENED_BIT = 0x80000000;

  /**
   * Multi-word mnemonic phrase (BIP-39).
   *
   * Compatible with the official Hiero mobile
   * wallets (24-words or 22-words) and BRD (12-words).
   */
  class Mnemonic {
      /**
       * @param {MnemonicCryptography} mnemonic
       * @hideconstructor
       * @private
       */
      constructor(mnemonic) {
          this._mnemonic = mnemonic;
      }

      /**
       * Returns a new random 24-word mnemonic from the BIP-39
       * standard English word list.
       *
       * @returns {Promise<Mnemonic>}
       */
      static async generate() {
          return new Mnemonic(await Mnemonic$1._generate(24));
      }

      /**
       * Returns a new random 12-word mnemonic from the BIP-39
       * standard English word list.
       *
       * @returns {Promise<Mnemonic>}
       */
      static async generate12() {
          return new Mnemonic(await Mnemonic$1._generate(12));
      }

      /**
       * Construct a mnemonic from a list of words. Handles 12, 22 (legacy), and 24 words.
       *
       * An exception of BadMnemonicError will be thrown if the mnemonic
       * contains unknown words or fails the checksum. An invalid mnemonic
       * can still be used to create private keys, the exception will
       * contain the failing mnemonic in case you wish to ignore the
       * validation error and continue.
       *
       * @param {string[]} words
       * @throws {cryptography.BadMnemonicError}
       * @returns {Promise<Mnemonic>}
       */
      static async fromWords(words) {
          return new Mnemonic(await Mnemonic$1.fromWords(words));
      }

      /**
       * @deprecated - Use `toStandardEd25519PrivateKey()` or `toStandardECDSAsecp256k1PrivateKey()` instead
       * Recover a private key from this mnemonic phrase, with an
       * optional passphrase.
       * @param {string} [passphrase]
       * @returns {Promise<PrivateKey>}
       */
      async toPrivateKey(passphrase = "") {
          return CACHE.privateKeyConstructor(
              // eslint-disable-next-line deprecation/deprecation
              await this._mnemonic.toPrivateKey(passphrase),
          );
      }

      /**
       * @deprecated - Use `toStandardEd25519PrivateKey()` or `toStandardECDSAsecp256k1PrivateKey()` instead
       * Recover an Ed25519 private key from this mnemonic phrase, with an
       * optional passphrase.
       * @param {string} [passphrase]
       * @param {number[]} [path]
       * @returns {Promise<PrivateKey>}
       */
      async toEd25519PrivateKey(passphrase = "", path) {
          return CACHE.privateKeyConstructor(
              // eslint-disable-next-line deprecation/deprecation
              await this._mnemonic.toEd25519PrivateKey(passphrase, path),
          );
      }

      /**
       * Recover an Ed25519 private key from this mnemonic phrase, with an
       * optional passphrase.
       *
       * @param {string} [passphrase]
       * @param {number} [index]
       * @returns {Promise<PrivateKey>}
       */
      async toStandardEd25519PrivateKey(passphrase = "", index) {
          return CACHE.privateKeyConstructor(
              await this._mnemonic.toStandardEd25519PrivateKey(passphrase, index),
          );
      }

      /**
       * @deprecated - Use `toStandardEd25519PrivateKey()` or `toStandardECDSAsecp256k1PrivateKey()` instead
       * Recover an ECDSA private key from this mnemonic phrase, with an
       * optional passphrase.
       * @param {string} [passphrase]
       * @param {number[]} [path]
       * @returns {Promise<PrivateKey>}
       */
      async toEcdsaPrivateKey(passphrase = "", path) {
          return CACHE.privateKeyConstructor(
              // eslint-disable-next-line deprecation/deprecation
              await this._mnemonic.toEcdsaPrivateKey(passphrase, path),
          );
      }

      /**
       * Converts a derivation path from string to an array of integers.
       * Note that this expects precisely 5 components in the derivation path,
       * as per BIP-44:
       * `m / purpose' / coin_type' / account' / change / address_index`
       * Takes into account `'` for hardening as per BIP-32,
       * and does not prescribe which components should be hardened.
       *
       * @param {string} derivationPath    the derivation path in BIP-44 format,
       *                                   e.g. "m/44'/60'/0'/0/0"
       * @returns {Array<number>} to be used with PrivateKey#derive
       */
      calculateDerivationPathValues(derivationPath) {
          // Parse the derivation path from string into values
          const pattern = /m\/(\d+'?)\/(\d+'?)\/(\d+'?)\/(\d+'?)\/(\d+'?)/;
          const matches = pattern.exec(derivationPath);
          const values = new Array(5); // as Array<Number>;
          if (matches) {
              // Extract numbers and use apostrophe to select if is hardened
              for (let i = 1; i <= 5; i++) {
                  let value = matches[i];
                  if (value.endsWith("'")) {
                      value = value.substring(0, value.length - 1);
                      values[i - 1] = parseInt(value, 10) | HARDENED_BIT;
                  } else {
                      values[i - 1] = parseInt(value, 10);
                  }
              }
          }
          // eslint-disable-next-line @typescript-eslint/no-unsafe-return
          return values;
      }

      /**
       * Common implementation for both `toStandardECDSAsecp256k1PrivateKey`
       * functions.
       *
       * @param {string} passphrase  the passphrase used to protect the
       *                             mnemonic, use "" for none
       * @param {Array<number>} derivationPathValues derivation path as an
       *                             integer array,
       *                             see: `calculateDerivationPathValues`
       * @returns {Promise<PrivateKey>}  a private key
       */
      async toStandardECDSAsecp256k1PrivateKeyImpl(
          passphrase,
          derivationPathValues,
      ) {
          // eslint-disable-next-line deprecation/deprecation
          return await this.toEcdsaPrivateKey(passphrase, derivationPathValues);
      }

      /**
       * Recover an ECDSA private key from this mnemonic phrase, with an
       * optional passphrase.
       *
       * @param {string} [passphrase]
       * @param {number} [index]
       * @returns {Promise<PrivateKey>}
       */
      async toStandardECDSAsecp256k1PrivateKey(passphrase = "", index) {
          return CACHE.privateKeyConstructor(
              await this._mnemonic.toStandardECDSAsecp256k1PrivateKey(
                  passphrase,
                  index,
              ),
          );
      }

      /**
       * Recover an ECDSAsecp256k1 private key from this mnemonic phrase and
       * derivation path, with an optional passphrase
       *
       * @param {string} passphrase      the passphrase used to protect the mnemonic,
       *                                 use "" for none
       * @param {string} derivationPath  the derivation path in BIP-44 format,
       *                                 e.g. "m/44'/60'/0'/0/0"
       * @returns {Promise<PrivateKey>}  the private key
       */
      async toStandardECDSAsecp256k1PrivateKeyCustomDerivationPath(
          passphrase = "",
          derivationPath,
      ) {
          const derivationPathValues =
              this.calculateDerivationPathValues(derivationPath);
          return await this.toStandardECDSAsecp256k1PrivateKeyImpl(
              passphrase,
              derivationPathValues,
          );
      }

      /**
       * Recover a mnemonic phrase from a string, splitting on spaces. Handles 12, 22 (legacy), and 24 words.
       *
       * @param {string} mnemonic
       * @returns {Promise<Mnemonic>}
       */
      static async fromString(mnemonic) {
          return new Mnemonic(await Mnemonic$1.fromString(mnemonic));
      }

      /**
       * @returns {Promise<PrivateKey>}
       */
      async toLegacyPrivateKey() {
          return CACHE.privateKeyConstructor(
              await this._mnemonic.toLegacyPrivateKey(),
          );
      }

      /**
       * @param {string} passphrase
       * @returns {Promise<Uint8Array>}
       */
      async toSeed(passphrase) {
          return await Mnemonic$1.toSeed(
              this._mnemonic.words,
              passphrase,
          );
      }

      /**
       * @returns {string}
       */
      toString() {
          return this._mnemonic.toString();
      }
  }

  // SPDX-License-Identifier: Apache-2.0

  /**
   * A simple "map" type that allows indexing by objects other than
   * strings, numbers, or booleans, and doesn't use the object pointer.
   *
   * @abstract
   * @template {{ toString(): string }} KeyT
   * @template {any} ValueT
   */
  class ObjectMap {
      /**
       * @param {(s: string) => KeyT} fromString
       */
      constructor(fromString) {
          /**
           * This map is from the stringified version of the key, to the value
           *
           * @type {Map<string, ValueT>}
           */
          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
          this._map = new Map();

          /**
           * This map is from the key, to the value
           *
           * @type {Map<KeyT, ValueT>}
           */
          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
          this.__map = new Map();

          /**
           * A function pointer to convert a key into a string. So we can set each
           * value in both maps.
           */
          this._fromString = fromString;
      }

      /**
       * Get a value by key or string.
       *
       * This is the main benefit of this class. If a user provides a `KeyT` we
       * implicitly serialize it to a string and use the string version. Otherwise
       * the user will get `undefined` even for a key that exists in the map since
       * the `KeyT` the provided has a different pointer than the one we have stored.
       * The string version doesn't have this issue since JS hashes the string and
       * that would result in both `KeyT` hitting the same value even if they're
       * different pointers.
       *
       * @param {KeyT | string} key
       * @returns {?ValueT}
       */
      get(key) {
          const k = typeof key === "string" ? key : key.toString();

          const value = this._map.get(k);
          return value != null ? value : null;
      }

      /**
       * Set the key to a value in both maps
       *
       * @internal
       * @param {KeyT} key
       * @param {ValueT} value
       */
      _set(key, value) {
          const k = typeof key === "string" ? key : key.toString();

          this._map.set(k, value);
          this.__map.set(key, value);
      }

      /**
       * Create iterator of values
       *
       * @returns {IterableIterator<ValueT>}
       */
      values() {
          return this._map.values();
      }

      /**
       * Get the size of the map
       *
       * @returns {number}
       */
      get size() {
          return this._map.size;
      }

      /**
       * Get the keys of the map.
       *
       * @returns {IterableIterator<KeyT>}
       */
      keys() {
          return this.__map.keys();
      }

      /**
       * Create an iterator over key, value pairs
       *
       * @returns {IterableIterator<[KeyT, ValueT]>}
       */
      [Symbol.iterator]() {
          return this.__map[Symbol.iterator]();
      }

      /**
       * Stringify the map into _something_ readable.
       * **NOTE**: This implementation is not stable and can change.
       *
       * @returns {string}
       */
      toString() {
          /** @type {{[key: string]: any}} */
          const map = {};

          for (const [key, value] of this._map) {
              map[key] = value;
          }

          return JSON.stringify(map);
      }

      toJSON() {
          const obj = {};

          this._map.forEach((value, key) => {
              // @ts-ignore
              obj[key] = value;
          });

          return obj;
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @param {string} text
   * @returns {Uint8Array}
   */
  function decode$2(text) {
      const str = text.startsWith("0x") ? text.substring(2) : text;

      if (str.length % 2 !== 0) {
          throw new Error(
              "Invalid hex string: Must have an even number of characters.",
          );
      }

      if (/[^0-9a-fA-F]/.test(str)) {
          throw new Error(
              "Invalid hex string: Contains non-hexadecimal characters.",
          );
      }

      const bytes = new Uint8Array(str.length / 2);

      for (let i = 0; i < str.length; i += 2) {
          const byte = parseInt(str.substring(i, i + 2), 16);
          bytes[i / 2] = byte;
      }

      return Buffer.from(str, "hex");
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {import("../client/Client.js").default<*, *>} Client
   */

  /**
   * The ID for a crypto-currency account on Hedera.
   */
  class AccountId {
      /**
       * @param {number | Long | import("../EntityIdHelper").IEntityId} props
       * @param {(number | Long)=} realm
       * @param {(number | Long)=} num
       * @param {(PublicKey)=} aliasKey
       * @param {(EvmAddress)=} evmAddress
       */
      constructor(props, realm, num, aliasKey, evmAddress) {
          const result = constructor(props, realm, num);

          this.shard = result.shard;
          this.realm = result.realm;
          this.num = result.num;
          this.aliasKey = aliasKey != null ? aliasKey : null;
          this.evmAddress = evmAddress != null ? evmAddress : null;

          /**
           * @type {string | null}
           */
          this._checksum = null;
      }

      /**
       * @description Accepts the following formats as string:
       *      - as stand alone nubmers
       *      - as shard.realm.num
       *      - as shard.realm.hex (wo 0x prefix)
       *      - hex (w/wo 0x prefix)
       * @param {string} text
       * @returns {AccountId}
       */
      static fromString(text) {
          let shard = Long.ZERO;
          let realm = Long.ZERO;
          let num = Long.ZERO;
          let aliasKey = undefined;
          let evmAddress = undefined;

          if ((text.startsWith("0x") && text.length == 42) || text.length == 40) {
              evmAddress = EvmAddress.fromString(text);
          } else {
              const result = fromStringSplitter(text);

              if (Number.isNaN(result.shard) || Number.isNaN(result.realm)) {
                  throw new Error("invalid format for entity ID");
              }

              if (result.shard != null) shard = Long.fromString(result.shard);
              if (result.realm != null) realm = Long.fromString(result.realm);

              if (result.numOrHex.length < 20) {
                  num = Long.fromString(result.numOrHex);
              } else if (result.numOrHex.length == 40) {
                  evmAddress = EvmAddress.fromString(result.numOrHex);
              } else {
                  aliasKey = PublicKey.fromString(result.numOrHex);
              }
          }

          return new AccountId(shard, realm, num, aliasKey, evmAddress);
      }

      /**
       * @description This handles both long-zero format and evm address format addresses.
       * If an actual evm address is passed, please use `AccountId.populateAccountNum(client)` method
       * to get the actual `num` value, since there is no cryptographic relation to the evm address
       * and cannot be populated directly
       * @param {Long | number} shard
       * @param {Long | number} realm
       * @param {EvmAddress | string} evmAddress
       * @returns {AccountId}
       */
      static fromEvmAddress(shard, realm, evmAddress) {
          const evmAddressObj =
              typeof evmAddress === "string"
                  ? EvmAddress.fromString(evmAddress)
                  : evmAddress;

          const [shardLong, realmLong, num, address] =
              fromEvmAddress(
                  shard,
                  realm,
                  evmAddressObj.toString(),
              );

          return new AccountId(
              shardLong,
              realmLong,
              num,
              undefined,
              address || undefined,
          );
      }

      /**
       * @deprecated - Use `fromEvmAddress` instead
       * @summary Accepts an evm address only as `EvmAddress` type
       * @param {EvmAddress} evmAddress
       * @returns {AccountId}
       */
      static fromEvmPublicAddress(evmAddress) {
          return new AccountId(0, 0, 0, undefined, evmAddress);
      }

      /**
       * @internal
       * @param {HieroProto.proto.IAccountID} id
       * @returns {AccountId}
       */
      static _fromProtobuf(id) {
          let aliasKey = undefined;
          let evmAddress = undefined;

          if (id.alias != null) {
              if (id.alias.length === 20) {
                  evmAddress = EvmAddress.fromBytes(id.alias);
              } else {
                  aliasKey = Key._fromProtobufKey(
                      libExports.proto.Key.decode(id.alias),
                  );
              }
          }

          if (!(aliasKey instanceof PublicKey)) {
              aliasKey = undefined;
          }

          return new AccountId(
              id.shardNum != null ? id.shardNum : 0,
              id.realmNum != null ? id.realmNum : 0,
              id.accountNum != null ? id.accountNum : 0,
              aliasKey,
              evmAddress,
          );
      }

      /**
       * @returns {string | null}
       */
      get checksum() {
          return this._checksum;
      }

      /**
       * @returns {?EvmAddress}
       */
      getEvmAddress() {
          return this.evmAddress;
      }

      /**
       * @description Gets the actual `num` field of the `AccountId` from the Mirror Node.
       * Should be used after generating `AccountId.fromEvmAddress()` because it sets the `num` field to `0`
       * automatically since there is no connection between the `num` and the `evmAddress`
       * @param {Client} client
       * @returns {Promise<AccountId>}
       */
      async populateAccountNum(client) {
          if (this.evmAddress === null) {
              throw new Error("field `evmAddress` should not be null");
          }
          const mirrorRestApiBaseUrl = client.mirrorRestApiBaseUrl;

          const url = `${mirrorRestApiBaseUrl}/accounts/${this.evmAddress.toString()}`;

          await new Promise((resolve) => {
              setTimeout(resolve, 3000);
          });

          /* eslint-disable */
          const response = await fetch(url);
          const data = await response.json();
          const mirrorAccountId = data.account;

          this.num = Long.fromString(
              mirrorAccountId.slice(mirrorAccountId.lastIndexOf(".") + 1),
          );
          /* eslint-enable */

          return this;
      }

      /**
       * @description Populates `evmAddress` field of the `AccountId` extracted from the Mirror Node.
       * @param {Client} client
       * @returns {Promise<AccountId>}
       */
      async populateAccountEvmAddress(client) {
          if (this.num === null) {
              throw new Error("field `num` should not be null");
          }
          const mirrorRestApiBaseUrl = client.mirrorRestApiBaseUrl;

          const url = `${mirrorRestApiBaseUrl}/accounts/${this.num.toString()}`;

          await new Promise((resolve) => {
              setTimeout(resolve, 3000);
          });

          /* eslint-disable */
          const response = await fetch(url);
          const data = await response.json();
          const mirrorAccountId = data.evm_address;

          this.evmAddress = EvmAddress.fromString(mirrorAccountId);
          /* eslint-enable */

          return this;
      }

      /**
       * @deprecated - Use `validateChecksum` instead
       * @param {Client} client
       */
      validate(client) {
          console.warn("Deprecated: Use `validateChecksum` instead");
          this.validateChecksum(client);
      }

      /**
       * @param {Client} client
       */
      validateChecksum(client) {
          if (this.aliasKey != null) {
              throw new Error(
                  "cannot calculate checksum with an account ID that has a aliasKey",
              );
          }

          validateChecksum(
              this.shard,
              this.realm,
              this.num,
              this._checksum,
              client,
          );
      }

      /**
       * @param {Uint8Array} bytes
       * @returns {AccountId}
       */
      static fromBytes(bytes) {
          return AccountId._fromProtobuf(
              libExports.proto.AccountID.decode(bytes),
          );
      }

      /**
       * @deprecated - Use `fromEvmAddress` instead
       * @param {string} address
       * @returns {AccountId}
       */
      static fromSolidityAddress(address) {
          // eslint-disable-next-line @typescript-eslint/no-unsafe-call
          if (isLongZeroAddress(decode$2(address))) {
              return new AccountId(
                  ...fromSolidityAddress(address),
              );
          } else {
              return this.fromEvmAddress(0, 0, address);
          }
      }

      /**
       * @description Statically compute the EVM address. Use only with non-native EVM accounts.
       * @deprecated - Use `toEvmAddress` instead
       * If the account is EVM-native, the EVM address depends on the public key and is not directly related to the account ID.
       * @returns {string}
       */
      toSolidityAddress() {
          if (this.evmAddress != null) {
              return this.evmAddress.toString();
          } else if (
              this.aliasKey != null &&
              this.aliasKey._key._type == "secp256k1"
          ) {
              return this.aliasKey.toEvmAddress();
          } else {
              return toSolidityAddress([
                  this.shard,
                  this.realm,
                  this.num,
              ]);
          }
      }

      /**
       * @returns {string} EVM-compatible address representation of the entity
       */
      toEvmAddress() {
          if (this.evmAddress != null) {
              return toEvmAddress(this.evmAddress.toBytes());
          }

          return toEvmAddress(this.num);
      }

      //TODO remove the comments after we get to HIP-631
      /**
       * @internal
       * @returns {HieroProto.proto.IAccountID}
       */
      _toProtobuf() {
          let alias = null;
          //let evmAddress = null;

          if (this.aliasKey != null) {
              alias = libExports.proto.Key.encode(
                  this.aliasKey._toProtobufKey(),
              ).finish();
          } else if (this.evmAddress != null) {
              alias = this.evmAddress._bytes;
          }

          /* if (this.evmAddress != null) {
              evmAddress = this.evmAddress._bytes;
          } */

          const isHollowAccount = this.num.eq(Long.fromBigInt(0n)) && alias;

          if (alias) {
              return {
                  alias: isHollowAccount ? alias : null,
                  accountNum: isHollowAccount ? null : this.num,
                  shardNum: this.shard,
                  realmNum: this.realm,
              };
          }
          return {
              alias: null,
              accountNum: this.num,
              shardNum: this.shard,
              realmNum: this.realm,
          };
      }

      /**
       * @returns {Uint8Array}
       */
      toBytes() {
          return libExports.proto.AccountID.encode(this._toProtobuf()).finish();
      }

      /**
       * @returns {string}
       */
      toString() {
          let account = this.num.toString();

          if (this.aliasKey != null) {
              account = this.aliasKey.toString();
          } else if (this.evmAddress != null) {
              account = this.evmAddress.toString();
          }

          return `${this.shard.toString()}.${this.realm.toString()}.${account}`;
      }

      /**
       * @param {Client} client
       * @returns {string}
       */
      toStringWithChecksum(client) {
          if (this.aliasKey != null) {
              throw new Error(
                  "cannot calculate checksum with an account ID that has a aliasKey",
              );
          }

          return toStringWithChecksum(this.toString(), client);
      }

      /**
       * @param {this} other
       * @returns {boolean}
       */
      equals(other) {
          let account = false;

          if (this.aliasKey != null && other.aliasKey != null) {
              account = this.aliasKey.equals(other.aliasKey);
          } else if (this.evmAddress != null && other.evmAddress != null) {
              account = this.evmAddress.equals(other.evmAddress);
          } else if (
              this.aliasKey == null &&
              other.aliasKey == null &&
              this.evmAddress == null &&
              other.evmAddress == null
          ) {
              account = this.num.eq(other.num);
          }

          return (
              this.shard.eq(other.shard) && this.realm.eq(other.realm) && account
          );
      }

      /**
       * @returns {AccountId}
       */
      clone() {
          const id = new AccountId(this);
          id._checksum = this._checksum;
          id.aliasKey = this.aliasKey;
          id.evmAddress = this.evmAddress;
          return id;
      }

      /**
       * @param {AccountId} other
       * @returns {number}
       */
      compare(other) {
          let comparison = this.shard.compare(other.shard);
          if (comparison != 0) {
              return comparison;
          }

          comparison = this.realm.compare(other.realm);
          if (comparison != 0) {
              return comparison;
          }

          if (this.aliasKey != null && other.aliasKey != null) {
              const t = this.aliasKey.toString();
              const o = other.aliasKey.toString();

              if (t > o) {
                  return 1;
              } else if (t < o) {
                  return -1;
              } else {
                  return 0;
              }
          } else if (this.evmAddress != null && other.evmAddress != null) {
              const t = this.evmAddress.toString();
              const o = other.evmAddress.toString();

              if (t > o) {
                  return 1;
              } else if (t < o) {
                  return -1;
              } else {
                  return 0;
              }
          } else if (
              this.aliasKey == null &&
              other.aliasKey == null &&
              this.evmAddress == null &&
              other.evmAddress == null
          ) {
              return this.num.compare(other.num);
          } else {
              return 1;
          }
      }
  }

  CACHE.setAccountIdConstructor(
      (shard, realm, key) => new AccountId(shard, realm, Long.ZERO, key),
  );

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITimestamp} HieroProto.proto.ITimestamp
   */

  const MAX_NS = Long.fromNumber(1000000000);
  const generatedIds = new Set();

  /**
   * Represents a point in time with seconds and nanoseconds precision.
   *
   * The `Timestamp` class provides methods for creating, manipulating, and converting
   * timestamps. It supports operations such as addition of nanoseconds, conversion to
   * JavaScript Date objects, and generation of timestamps based on the current time.
   */
  class Timestamp {
      /**
       * @param {Long | number} seconds
       * @param {Long | number} nanos
       */
      constructor(seconds, nanos) {
          /**
           * @readonly
           * @type {Long}
           */
          this.seconds =
              seconds instanceof Long ? seconds : Long.fromNumber(seconds);

          /**
           * @readonly
           * @type {Long}
           */
          this.nanos = nanos instanceof Long ? nanos : Long.fromNumber(nanos);

          Object.freeze(this);
      }

      /**
       * @param {boolean} hasJitter
       * @returns {Timestamp}
       */
      static generate(hasJitter = true) {
          let jitter;
          if (hasJitter) {
              jitter = Math.floor(Math.random() * 5000) + 3000;
          } else {
              jitter = 0;
          }
          const now = Date.now() - jitter;
          const seconds = Math.floor(now / 1000) + CACHE.timeDrift;
          const nanos =
              Math.floor(now % 1000) * 1000000 +
              Math.floor(Math.random() * 1000000);

          const timestamp = new Timestamp(seconds, nanos);
          if (generatedIds.has(timestamp.toString())) {
              return this.generate();
          } else {
              generatedIds.add(timestamp.toString());
              return timestamp;
          }
      }

      /**
       * @param {string | number | Date} date
       * @returns {Timestamp}
       */
      static fromDate(date) {
          let nanos;

          if (typeof date === "number") {
              nanos = Long.fromNumber(date);
          } else if (typeof date === "string") {
              nanos = Long.fromNumber(Date.parse(date)).mul(1000000);
          } else if (date instanceof Date) {
              nanos = Long.fromNumber(date.getTime()).mul(1000000);
          } else {
              throw new TypeError(
                  `invalid type '${typeof date}' for 'data', expected 'Date'`,
              );
          }

          return new Timestamp(0, 0).plusNanos(nanos);
      }

      /**
       * @returns {Date}
       */
      toDate() {
          return new Date(
              this.seconds.toInt() * 1000 +
                  Math.floor(this.nanos.toInt() / 1000000),
          );
      }

      /**
       * @param {Long | number} nanos
       * @returns {Timestamp}
       */
      plusNanos(nanos) {
          const ns = this.nanos.add(nanos);

          return new Timestamp(this.seconds.add(ns.div(MAX_NS)), ns.mod(MAX_NS));
      }

      /**
       * @internal
       * @returns {HieroProto.proto.ITimestamp}
       */
      _toProtobuf() {
          return {
              seconds: this.seconds,
              nanos: this.nanos.toInt(),
          };
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITimestamp} timestamp
       * @returns {Timestamp}
       */
      static _fromProtobuf(timestamp) {
          return new Timestamp(
              timestamp.seconds instanceof Long
                  ? timestamp.seconds.toInt()
                  : timestamp.seconds != null
                  ? timestamp.seconds
                  : 0,

              timestamp.nanos != null ? timestamp.nanos : 0,
          );
      }

      /**
       * @returns {string}
       */
      toString() {
          const zeroPaddedNanos = String(this.nanos).padStart(9, "0");
          return `${this.seconds.toString()}.${zeroPaddedNanos}`;
      }

      /**
       * @param {Timestamp} other
       * @returns {number}
       */
      compare(other) {
          const comparison = this.seconds.compare(other.seconds);

          if (comparison != 0) {
              return comparison;
          }

          return this.nanos.compare(other.nanos);
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("./TransactionReceipt.js").default} TransactionReceipt
   * @typedef {import("./TransactionRecord.js").default} TransactionRecord
   */

  /**
   * The client-generated ID for a transaction.
   *
   * This is used for retrieving receipts and records for a transaction, for appending to a file
   * right after creating it, for instantiating a smart contract with bytecode in a file just created,
   * and internally by the network for detecting when duplicate transactions are submitted.
   */
  class TransactionId {
      /**
       * Don't use this method directly.
       * Use `TransactionId.[generate|withNonce|withValidStart]()` instead.
       *
       * @param {?AccountId} accountId
       * @param {?Timestamp} validStart
       * @param {?boolean} scheduled
       * @param {?Long | number} nonce
       */
      constructor(accountId, validStart, scheduled = false, nonce = null) {
          /**
           * The Account ID that paid for this transaction.
           *
           * @readonly
           */
          this.accountId = accountId;

          /**
           * The time from when this transaction is valid.
           *
           * When a transaction is submitted there is additionally a validDuration (defaults to 120s)
           * and together they define a time window that a transaction may be processed in.
           *
           * @readonly
           */
          this.validStart = validStart;

          this.scheduled = scheduled;

          this.nonce = null;
          if (nonce != null && nonce != 0) {
              this.setNonce(nonce);
          }

          Object.seal(this);
      }

      /**
       * @param {Long | number} nonce
       * @returns {TransactionId}
       */
      setNonce(nonce) {
          this.nonce = typeof nonce === "number" ? Long.fromNumber(nonce) : nonce;
          return this;
      }

      /**
       * @param {AccountId} accountId
       * @param {Timestamp} validStart
       * @returns {TransactionId}
       */
      static withValidStart(accountId, validStart) {
          return new TransactionId(accountId, validStart);
      }

      /**
       * Generates a new transaction ID for the given account ID.
       *
       * Note that transaction IDs are made of the valid start of the transaction and the account
       * that will be charged the transaction fees for the transaction.
       *
       * @param {AccountId | string} id
       * @returns {TransactionId}
       */
      static generate(id) {
          return new TransactionId(
              typeof id === "string"
                  ? AccountId.fromString(id)
                  : new AccountId(id),
              Timestamp.generate(),
          );
      }

      /**
       * @param {string} wholeId
       * @returns {TransactionId}
       */
      static fromString(wholeId) {
          let account, seconds, nanos, isScheduled, nonce;
          let rest;
          // 1.1.1@5.4?scheduled/117

          [account, rest] = wholeId.split("@");
          [seconds, rest] = rest.split(".");
          if (rest.includes("?")) {
              [nanos, rest] = rest.split("?scheduled");
              isScheduled = true;
              if (rest.includes("/")) {
                  nonce = rest.replace("/", "");
              } else {
                  nonce = null;
              }
          } else if (rest.includes("/")) {
              [nanos, nonce] = rest.split("/");
              isScheduled = false;
          } else {
              nanos = rest;
          }

          return new TransactionId(
              AccountId.fromString(account),
              new Timestamp(Long.fromValue(seconds), Long.fromValue(nanos)),
              isScheduled,
              nonce != null ? Long.fromString(nonce) : null,
          );
      }

      /**
       * @param {boolean} scheduled
       * @returns {this}
       */
      setScheduled(scheduled) {
          this.scheduled = scheduled;
          return this;
      }

      /**
       * @returns {string}
       */
      toString() {
          if (this.accountId != null && this.validStart != null) {
              const zeroPaddedNanos = String(this.validStart.nanos).padStart(
                  9,
                  "0",
              );
              const nonce =
                  this.nonce != null ? "/".concat(this.nonce.toString()) : "";
              const scheduled = this.scheduled ? "?scheduled" : "";
              return `${this.accountId.toString()}@${this.validStart.seconds.toString()}.${zeroPaddedNanos}${scheduled}${nonce}`;
          } else {
              throw new Error("neither `accountId` nor `validStart` are set");
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransactionID} id
       * @returns {TransactionId}
       */
      static _fromProtobuf(id) {
          if (id.accountID != null && id.transactionValidStart != null) {
              return new TransactionId(
                  AccountId._fromProtobuf(id.accountID),
                  Timestamp._fromProtobuf(id.transactionValidStart),
                  id.scheduled != null ? id.scheduled : undefined,
                  id.nonce != null ? id.nonce : undefined,
              );
          } else {
              throw new Error(
                  "Neither `nonce` or `accountID` and `transactionValidStart` are set",
              );
          }
      }

      /**
       * @internal
       * @returns {HieroProto.proto.ITransactionID}
       */
      _toProtobuf() {
          return {
              accountID:
                  this.accountId != null ? this.accountId._toProtobuf() : null,
              transactionValidStart:
                  this.validStart != null ? this.validStart._toProtobuf() : null,
              scheduled: this.scheduled,
              nonce: this.nonce != null ? this.nonce.toInt() : null,
          };
      }

      /**
       * @param {Uint8Array} bytes
       * @returns {TransactionId}
       */
      static fromBytes(bytes) {
          return TransactionId._fromProtobuf(
              libExports.proto.TransactionID.decode(bytes),
          );
      }

      /**
       * @returns {Uint8Array}
       */
      toBytes() {
          return libExports.proto.TransactionID.encode(
              this._toProtobuf(),
          ).finish();
      }

      /**
       * @returns {TransactionId}
       */
      clone() {
          return new TransactionId(
              this.accountId,
              this.validStart,
              this.scheduled,
              this.nonce,
          );
      }

      /**
       * @param {TransactionId} other
       * @returns {number}
       */
      compare(other) {
          const comparison = /** @type {AccountId} */ (this.accountId).compare(
              /** @type {AccountId} */ (other.accountId),
          );

          if (comparison != 0) {
              return comparison;
          }

          return /** @type {Timestamp} */ (this.validStart).compare(
              /** @type {Timestamp} */ (other.validStart),
          );
      }

      /**
       * @param {Client} client
       * @returns {Promise<TransactionReceipt>}
       */
      getReceipt(client) {
          return CACHE.transactionReceiptQueryConstructor()
              .setTransactionId(this)
              .execute(client);
      }

      /**
       * @param {Client} client
       * @returns {Promise<TransactionRecord>}
       */
      async getRecord(client) {
          await this.getReceipt(client);

          return CACHE.transactionRecordQueryConstructor()
              .setTransactionId(this)
              .execute(client);
      }
  }

  /**
   * @augments {ObjectMap<PublicKey, Uint8Array>}
   */
  class SignaturePairMap extends ObjectMap {
      constructor() {
          super((s) => PublicKey.fromString(s));
      }

      /**
       * This function is used to create a SignaturePairMap from an already built transaction.
       * @param {import("@hashgraph/proto").proto.ISignatureMap} sigMap
       * @returns {SignaturePairMap}
       */
      static _fromTransactionSigMap(sigMap) {
          const signatures = new SignaturePairMap();

          const sigPairs = sigMap.sigPair != null ? sigMap.sigPair : [];

          for (const sigPair of sigPairs) {
              if (sigPair.pubKeyPrefix == null) {
                  continue;
              }

              if (sigPair.ed25519 != null) {
                  signatures._set(
                      PublicKey.fromBytesED25519(sigPair.pubKeyPrefix),
                      sigPair.ed25519,
                  );
              } else if (sigPair.ECDSASecp256k1 != null) {
                  signatures._set(
                      PublicKey.fromBytesECDSA(sigPair.pubKeyPrefix),
                      sigPair.ECDSASecp256k1,
                  );
              }
          }

          return signatures;
      }

      /**
       *
       * @param {PublicKey} pubKey
       * @param {Uint8Array} signature
       * @returns {SignaturePairMap}
       */
      addSignature(pubKey, signature) {
          this._set(pubKey, signature);
          return this;
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @augments {ObjectMap<TransactionId, SignaturePairMap>}
   */
  let NodeAccountIdSignatureMap$1 = class NodeAccountIdSignatureMap extends ObjectMap {
      constructor() {
          super((s) => TransactionId.fromString(s));
      }

      /**
       * This function is used to create a NodeAccountIdSignaturemap from an already built transaction.
       * @param { import('./List.js').default<import("@hashgraph/proto").proto.ISignedTransaction>} signedTransactions
       * @returns {NodeAccountIdSignatureMap}
       */
      static _fromSignedTransactions(signedTransactions) {
          const signatures = new NodeAccountIdSignatureMap();

          for (const { bodyBytes, sigMap } of signedTransactions.list) {
              if (bodyBytes != null && sigMap != null) {
                  const body = libExports.proto.TransactionBody.decode(bodyBytes);

                  if (body.transactionID != null) {
                      const transactionId = TransactionId._fromProtobuf(
                          body.transactionID,
                      );

                      signatures._set(
                          transactionId,
                          SignaturePairMap._fromTransactionSigMap(sigMap),
                      );
                  }
              }
          }

          return signatures;
      }

      /**
       *
       * Adds a signature pair for this transaction id.
       * @param {TransactionId} txId
       * @param {import("../SignerSignature.js").PublicKey} publicKey
       * @param {Uint8Array} signature
       */
      addSignature(txId, publicKey, signature) {
          const sigPairMap = this.get(txId);
          if (sigPairMap) {
              sigPairMap.addSignature(publicKey, signature);
          } else {
              this._set(
                  txId,
                  new SignaturePairMap().addSignature(publicKey, signature),
              );
          }
      }
  };

  // SPDX-License-Identifier: Apache-2.0

  /**
   * A custom list type which round robins, supports locking, and as additional
   * QoL improvements.
   *
   * @template {any} T
   */
  class List {
      constructor() {
          /** @type {T[]} */
          this.list = [];
          this.locked = false;
          this.index = 0;
      }

      /**
       * Overwrite the entire list.
       *
       * @throws if the list is locked
       * @param {T[]} list
       * @returns {this}
       */
      setList(list) {
          if (this.locked) {
              throw new Error("list is locked");
          }

          this.list = list;
          this.index = 0;

          return this;
      }

      /**
       * Push items to the end of the list.
       *
       * @throws if the list is locked
       * @param {T[]} items
       * @returns {this}
       */
      push(...items) {
          if (this.locked) {
              throw new Error("list is locked");
          }

          this.list.push(...items);
          return this;
      }

      /**
       * Locks the list.
       *
       * @returns {this}
       */
      setLocked() {
          this.locked = true;
          return this;
      }

      /**
       * Clear the list
       */
      clear() {
          this.list = [];
          this.index = 0;
          this.locked = false;
      }

      /**
       * The get value at a particular index.
       *
       * @param {number} index
       * @returns {T}
       */
      get(index) {
          return this.list[index];
      }

      /**
       * Set value at index
       *
       * @param {number} index
       * @param {T} item
       * @returns {this}
       */
      set(index, item) {
          // QoL: If the index is at the end simply push the element to the end
          if (index === this.length) {
              this.list.push(item);
          } else {
              this.list[index] = item;
          }

          return this;
      }

      /**
       * Set value at index if it's not already set
       *
       * @throws if the list is locked
       * @param {number} index
       * @param {() => T} lambda
       * @returns {this}
       */
      setIfAbsent(index, lambda) {
          if (index == this.length || this.list[index] == null) {
              this.set(index, lambda());
          }

          return this;
      }

      /**
       * Get the current value, and advance the index
       *
       * @returns {T}
       */
      get next() {
          return this.get(this.advance());
      }

      /**
       * Get the current value.
       *
       * @returns {T}
       */
      get current() {
          return this.get(this.index);
      }

      /**
       * Advance the index to the next element in a round robin fashion
       *
       * @returns {number}
       */
      advance() {
          const index = this.index;
          this.index = (this.index + 1) % this.list.length;
          return index;
      }

      /**
       * Is the list empty
       *
       * @returns {boolean}
       */
      get isEmpty() {
          return this.length === 0;
      }

      /**
       * Get the length of the list
       *
       * @returns {number}
       */
      get length() {
          return this.list.length;
      }

      /**
       * Shallow clone this list.
       * Perhaps we should explicitly call this `shallowClone()` since it doesn't
       * clone the list inside?
       *
       * @returns {List<T>}
       */
      clone() {
          /** @type {List<T>} */
          const list = new List();
          list.list = this.list;
          list.locked = this.locked;
          return list;
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * Represents a mapping of account IDs to their corresponding signatures for transactions.
   *
   * The `SignatureMap` class is used to manage and store signatures associated with
   * different accounts in a transaction. It allows for adding signatures, retrieving
   * them, and converting the signature map to and from various formats.
   */

  /**
   * @augments {ObjectMap<AccountId, NodeAccountIdSignatureMap>}
   */
  let SignatureMap$1 = class SignatureMap extends ObjectMap {
      /**
       * @typedef {import("../transaction/TransactionId.js").default} TransactionId
       * @typedef {import("../transaction/SignaturePairMap.js").default} SignaturePairMap
       */
      constructor() {
          super((s) => AccountId.fromString(s));
      }

      /**
       * This function is used to create a SignatureMap from an already built transaction.
       * @param {import("./Transaction.js").default} transaction
       * @returns {SignatureMap}
       */
      static _fromTransaction(transaction) {
          const signatures = new SignatureMap();

          const rowLength = transaction._nodeAccountIds.length;
          const columns = transaction._signedTransactions.length / rowLength;

          /*
          this setup implies that the signed transactions are stored sequentially
          in the signed transactions list. This means that the first rowLength
          signed transactions are for the first node account id, the next rowLength
          signed transactions are for the second node account id and so on.
          */
          for (let row = 0; row < rowLength; row++) {
              /** @type { List<import("@hashgraph/proto").proto.ISignedTransaction> } */
              const signedTransactions = new List();

              for (let col = 0; col < columns; col++) {
                  signedTransactions.push(
                      transaction._signedTransactions.get(col * rowLength + row),
                  );
              }

              signatures._set(
                  transaction._nodeAccountIds.list[row],
                  NodeAccountIdSignatureMap$1._fromSignedTransactions(
                      signedTransactions,
                  ),
              );
          }

          return signatures;
      }

      /**
       * Updates the signature map with the given signature.
       * by generating a new node account id signature map if it does not exist
       * or adding the signature to the existing node account id signature map.
       *
       * @param {AccountId} nodeId
       * @param {TransactionId} txId
       * @param {import("../SignerSignature.js").PublicKey} publicKey
       * @param {Uint8Array} signature
       * @returns {SignatureMap}
       */
      addSignature(nodeId, txId, publicKey, signature) {
          let nodeAccountIdSigdMap = this.get(nodeId);

          if (!nodeAccountIdSigdMap) {
              nodeAccountIdSigdMap = new NodeAccountIdSignatureMap$1();
              this._set(nodeId, nodeAccountIdSigdMap);
          }

          nodeAccountIdSigdMap.addSignature(txId, publicKey, signature);
          this._set(nodeId, nodeAccountIdSigdMap);

          return this;
      }
      /**
       * @returns {SignaturePairMap[]}
       */
      getFlatSignatureList() {
          const flatSignatureList = [];

          for (const nodeAccountIdSignatureMap of this.values()) {
              for (const tx of nodeAccountIdSignatureMap.values()) {
                  flatSignatureList.push(tx);
              }
          }

          return flatSignatureList;
      }
  };

  /* eslint-disable @typescript-eslint/no-unsafe-return */
  /**
   * A class to decode ASN.1 encoded data, typically used for parsing cryptographic key data.
   * @class
   */
  class ASN1Decoder {
      /**
       * Creates a new ASN1Decoder instance.
       * @param {Uint8Array|ArrayBuffer} data - The ASN.1 encoded data to decode.
       */
      constructor(data) {
          /**
           * @private
           * @type {Uint8Array}
           */
          this.data = new Uint8Array(data);

          /**
           * @private
           * @type {number}
           */
          this.pos = 0;

          /**
           * @private
           * @type {string[]}
           */
          this.oids = [];

          /**
           * @private
           * @type {{[key: string]: string}}
           */
          this.oidMap = {
              "1.3.132.0.10": "ecdsa",
              "1.3.101.112": "ed25519",
              "1.2.840.10045.2.1": "pubkey",
          };

          /**
           * @private
           * @type {boolean}
           */
          this.isPublicKey = false;
      }

      /**
       * Reads the length field from the ASN.1 data.
       * @private
       * @returns {number} The length value.
       */
      readLength() {
          let length = this.data[this.pos++];
          if (length & 0x80) {
              let numBytes = length & 0x7f;
              length = 0;
              for (let i = 0; i < numBytes; i++) {
                  length = (length << 8) | this.data[this.pos++];
              }
          }
          return length;
      }

      /**
       * Reads the type field from the ASN.1 data.
       * @private
       * @returns {number} The type value.
       */
      readType() {
          return this.data[this.pos++];
      }

      /**
       * Reads an integer value from the ASN.1 data.
       * @private
       * @returns {{integer: number}} Object containing the integer value.
       */
      readInteger() {
          const length = this.readLength();
          let value = 0;
          for (let i = 0; i < length; i++) {
              value = (value << 8) | this.data[this.pos++];
          }
          return { integer: value };
      }

      /**
       * Reads an octet string from the ASN.1 data.
       * @private
       * @returns {{pkey: Uint8Array}} Object containing the private key data.
       */
      readOctetString() {
          const length = this.readLength();
          const value = this.data.slice(this.pos, this.pos + length);
          this.pos += length;
          return { pkey: value };
      }

      /**
       * Reads a bit string from the ASN.1 data.
       * @private
       * @returns {{unusedBits: number, pubkey: Uint8Array}} Object containing the public key data and unused bits.
       */
      readBitString() {
          const length = this.readLength();
          const unusedBits = this.data[this.pos++]; // First byte indicates the number of unused bits
          const value = this.data.slice(this.pos, this.pos + length - 1);
          this.pos += length - 1;
          return { unusedBits, pubkey: value };
      }

      /**
       * Reads an object identifier from the ASN.1 data.
       * @private
       * @returns {{oid: string}} Object containing the OID as a string.
       */
      readObjectIdentifier() {
          const length = this.readLength();
          const endPos = this.pos + length;
          const oid = [];
          let value = 0;

          // The first byte contains the first two components
          const firstByte = this.data[this.pos++];
          oid.push(Math.floor(firstByte / 40));
          oid.push(firstByte % 40);

          while (this.pos < endPos) {
              const byte = this.data[this.pos++];
              value = (value << 7) | (byte & 0x7f);
              if (!(byte & 0x80)) {
                  oid.push(value);
                  value = 0;
              }
          }

          const oidStr = oid.join(".");
          this.oids.push(oidStr);
          return { oid: oidStr }; // Return OID as a string
      }

      /**
       * Gets the list of object identifiers found during decoding.
       * @returns {string[]} Array of OID strings.
       */
      getOids() {
          return this.oids;
      }

      /**
       * Gets the key types corresponding to the OIDs found during decoding.
       * @returns {string[]} Array of key type strings.
       */
      getOidKeyTypes() {
          return this.oids.map((oid) => this.oidMap[oid] || "unknown");
      }

      /**
       * Reads a sequence from the ASN.1 data.
       * @private
       * @returns {Array<any>} Array of decoded items in the sequence.
       */
      readSequence() {
          const length = this.readLength();
          const endPos = this.pos + length;
          const items = []; // this would better be map or obj
          while (this.pos < endPos) {
              items.push(this.read());
          }

          // eslint-disable-next-line @typescript-eslint/no-unsafe-return
          return items;
      }

      /**
       * Reads and decodes the next ASN.1 element.
       * @returns {any} The decoded ASN.1 element.
       * @throws {Error} If an unsupported type is encountered.
       */
      read() {
          const type = this.readType();

          switch (type) {
              case 0x02: // INTEGER
                  return this.readInteger();
              case 0x03: // BIT STRING FOR PUBKEY
                  return this.readBitString();
              case 0x04: // OCTET STRING FOR PKEY
                  return this.readOctetString();
              case 0x06: // OBJECT IDENTIFIER FOR CURVE TYPE
                  return this.readObjectIdentifier();
              case 0x30: // SEQUENCE
                  return this.readSequence();
              case 0xa0: // NODE TAG COULD BE TREATED AS SEQUENCE
                  return this.readSequence();
              case 0xa1: // NODE TAG COULD BE TREATED AS SEQUENCE
                  return this.readSequence();
              default:
                  throw new Error(`Unsupported type: ${type}`);
          }
      }

      /**
       * Checks if the decoded key is a public key.
       * @returns {boolean} True if the key is a public key, false otherwise.
       */
      isPublicKeyType() {
          return this.isPublicKey;
      }
  }

  // SPDX-License-Identifier: Apache-2.0

  /**
   * @typedef {import("./transaction/Transaction.js").default} Transaction
   */

  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.IKey} HieroProto.proto.IKey
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   * @typedef {import("@hashgraph/proto").proto.ISignaturePair} HieroProto.proto.ISignaturePair
   * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
   */

  class PrivateKey extends Key {
      /**
       * @internal
       * @hideconstructor
       * @param {PrivateKeyCrypto} key
       */
      constructor(key) {
          super();

          this._key = key;
      }

      /**
       * Generate a random Ed25519 private key.
       *
       * @returns {PrivateKey}
       */
      static generateED25519() {
          return new PrivateKey(PrivateKey$1.generateED25519());
      }

      /**
       * Generate a random EDSA private key.
       *
       * @returns {PrivateKey}
       */
      static generateECDSA() {
          return new PrivateKey(PrivateKey$1.generateECDSA());
      }

      /**
       * Depredated - Use `generateED25519()` instead
       * Generate a random Ed25519 private key.
       *
       * @returns {PrivateKey}
       */
      static generate() {
          return PrivateKey.generateED25519();
      }

      /**
       * Depredated - Use `generateED25519Async()` instead
       * Generate a random Ed25519 private key.
       *
       * @returns {Promise<PrivateKey>}
       */
      static async generateAsync() {
          return new PrivateKey(await PrivateKey$1.generateAsync());
      }

      /**
       * Generate a random Ed25519 private key.
       *
       * @returns {Promise<PrivateKey>}
       */
      static async generateED25519Async() {
          return new PrivateKey(await PrivateKey$1.generateED25519Async());
      }

      /**
       * Generate a random ECDSA private key.
       *
       * @returns {Promise<PrivateKey>}
       */
      static async generateECDSAAsync() {
          return new PrivateKey(await PrivateKey$1.generateECDSAAsync());
      }

      /**
       * Construct a private key from bytes. Requires DER header.
       *
       * @param {Uint8Array} data
       * @returns {PrivateKey}
       */
      static fromBytes(data) {
          const keyString = hexlify(data);
          if (PrivateKey.isDerKey(keyString)) {
              if (PrivateKey.getAlgorithm(keyString) === "ecdsa") {
                  return new PrivateKey(PrivateKey$1.fromBytesECDSA(data));
              } else {
                  return new PrivateKey(PrivateKey$1.fromBytesED25519(data));
              }
          }

          // If the key is not DER, we assume it's a raw private key
          // this will default to ED25519 as we dont have a way
          // to determine the type of the key based on the raw bytes
          return new PrivateKey(PrivateKey$1.fromBytes(data));
      }

      /**
       * Construct a ECDSA private key from bytes.
       *
       * @param {Uint8Array} data
       * @returns {PrivateKey}
       */
      static fromBytesECDSA(data) {
          return new PrivateKey(PrivateKey$1.fromBytesECDSA(data));
      }

      /**
       * Construct a ED25519 private key from bytes.
       *
       * @param {Uint8Array} data
       * @returns {PrivateKey}
       */
      static fromBytesED25519(data) {
          return new PrivateKey(PrivateKey$1.fromBytesED25519(data));
      }

      /**
       * @deprecated - Use fromStringECDSA() or fromStringED2551() on a HEX-encoded string
       * and fromStringDer() on a HEX-encoded string with DER prefix instead.
       * Construct a private key from a hex-encoded string. Requires DER header.
       * @param {string} text
       * @returns {PrivateKey}
       */
      static fromString(text) {
          if (PrivateKey.isDerKey(text)) {
              return this.fromStringDer(text);
          }
          // If the key is not DER, we assume it's a raw private key
          // this will default to ED25519 as we dont have a way
          // to determine the type of the key based on the raw bytes
          return new PrivateKey(PrivateKey$1.fromString(text));
      }

      /**
       * Construct a private key from a HEX-encoded string with a der prefix
       *
       * @param {string} text
       * @returns {PrivateKey}
       */
      static fromStringDer(text) {
          // previous versions of the library used to accept non-der encoded private keys here
          // and it fallbacked to PrivateKey.fromString() so we need to keep this behavior
          if (!PrivateKey.isDerKey(text)) {
              // eslint-disable-next-line deprecation/deprecation
              return PrivateKey.fromString(text);
          }

          if (PrivateKey.getAlgorithm(text) === "ecdsa") {
              return this.fromStringECDSA(text);
          } else {
              return this.fromStringED25519(text);
          }
      }

      /**
       * Construct a ECDSA private key from a hex-encoded string.
       *
       * @param {string} text
       * @returns {PrivateKey}
       */
      static fromStringECDSA(text) {
          return new PrivateKey(PrivateKey$1.fromStringECDSA(text));
      }

      /**
       * Construct a Ed25519 private key from a hex-encoded string.
       *
       * @param {string} text
       * @returns {PrivateKey}
       */
      static fromStringED25519(text) {
          return new PrivateKey(PrivateKey$1.fromStringED25519(text));
      }

      /**
       * Construct a Ed25519 private key from a Uint8Array seed.
       *
       * @param {Uint8Array} seed
       * @returns {Promise<PrivateKey>}
       */
      static async fromSeedED25519(seed) {
          return new PrivateKey(await PrivateKey$1.fromSeedED25519(seed));
      }

      /**
       * Construct a Ed25519 private key from a Uint8Array seed.
       *
       * @param {Uint8Array} seed
       * @returns {Promise<PrivateKey>}
       */
      static async fromSeedECDSAsecp256k1(seed) {
          return new PrivateKey(
              await PrivateKey$1.fromSeedECDSAsecp256k1(seed),
          );
      }

      /**
       * @deprecated - Use `Mnemonic.from[Words|String]().to[Ed25519|Ecdsa]PrivateKey()` instead
       *
       * Recover a private key from a mnemonic phrase (and optionally a password).
       * @param {Mnemonic  | string} mnemonic
       * @param {string} [passphrase]
       * @returns {Promise<PrivateKey>}
       */
      static async fromMnemonic(mnemonic, passphrase = "") {
          if (mnemonic instanceof Mnemonic) {
              return new PrivateKey(
                  // eslint-disable-next-line deprecation/deprecation
                  await PrivateKey$1.fromMnemonic(
                      mnemonic._mnemonic,
                      passphrase,
                  ),
              );
          }

          return new PrivateKey(
              // eslint-disable-next-line deprecation/deprecation
              await PrivateKey$1.fromMnemonic(mnemonic, passphrase),
          );
      }

      /**
       * Recover a private key from a keystore, previously created by `.toKeystore()`.
       *
       * This key will _not_ support child key derivation.
       *
       * @param {Uint8Array} data
       * @param {string} [passphrase]
       * @returns {Promise<PrivateKey>}
       * @throws {cryptography.BadKeyError} If the passphrase is incorrect or the hash fails to validate.
       */
      static async fromKeystore(data, passphrase = "") {
          return new PrivateKey(
              await PrivateKey$1.fromKeystore(data, passphrase),
          );
      }

      /**
       * Recover a private key from a pem string; the private key may be encrypted.
       *
       * This method assumes the .pem file has been converted to a string already.
       *
       * If `passphrase` is not null or empty, this looks for the first `ENCRYPTED PRIVATE KEY`
       * section and uses `passphrase` to decrypt it; otherwise, it looks for the first `PRIVATE KEY`
       * section and decodes that as a DER-encoded  private key.
       *
       * @param {string} data
       * @param {string} [passphrase]
       * @returns {Promise<PrivateKey>}
       */
      static async fromPem(data, passphrase = "") {
          return new PrivateKey(await PrivateKey$1.fromPem(data, passphrase));
      }

      /**
       * Derive a new private key at the given wallet index.
       *
       * Only currently supported for keys created with `fromMnemonic()`; other keys will throw
       * an error.
       *
       * You can check if a key supports derivation with `.supportsDerivation()`
       *
       * @param {number} index
       * @returns {Promise<PrivateKey>}
       * @throws If this key does not support derivation.
       */
      async derive(index) {
          return new PrivateKey(await this._key.derive(index));
      }

      /**
       * @param {number} index
       * @returns {Promise<PrivateKey>}
       * @throws If this key does not support derivation.
       */
      async legacyDerive(index) {
          return new PrivateKey(await this._key.legacyDerive(index));
      }

      /**
       * Get the public key associated with this private key.
       *
       * The public key can be freely given and used by other parties to verify
       * the signatures generated by this private key.
       *
       * @returns {PublicKey}
       */
      get publicKey() {
          return new PublicKey(this._key.publicKey);
      }

      /**
       * Get the public key associated with this private key.
       *
       * The public key can be freely given and used by other parties to verify
       * the signatures generated by this private key.
       *
       * @returns {?Uint8Array}
       */
      get chainCode() {
          return this._key._chainCode;
      }

      /**
       * Sign a message with this private key.
       *
       * @param {Uint8Array} bytes
       * @returns {Uint8Array} - The signature bytes without the message
       */
      sign(bytes) {
          return this._key.sign(bytes);
      }

      /**
       * @deprecated - Use legacy=false flag to use the modern approach
       * or don't pass it at all.
       * @overload
       * @param {Transaction} transaction
       * @param {true} legacy
       * @returns {Uint8Array | Uint8Array[] }
       */

      /**
       * @overload
       * @param {Transaction} transaction
       * @param {false} [legacy]
       * @returns {SignatureMap}
       */

      /**
       * @param {Transaction} transaction
       * @param {boolean} [legacy]
       * @returns {Uint8Array | Uint8Array[] | SignatureMap}
       */
      signTransaction(transaction, legacy = false) {
          if (legacy) {
              return this._signTransactionLegacy(transaction);
          }

          const sigMap = new SignatureMap$1();

          for (const signedTx of transaction._signedTransactions.list) {
              const bodyBytes = signedTx.bodyBytes;
              if (!bodyBytes) throw new Error("Body bytes are missing");

              const body = libExports.proto.TransactionBody.decode(bodyBytes);
              if (!body.transactionID || !body.nodeAccountID) {
                  throw new Error(
                      "Transaction ID or Node Account ID not found in the signed transaction",
                  );
              }

              const nodeId = AccountId._fromProtobuf(body.nodeAccountID);
              const transactionId = TransactionId._fromProtobuf(
                  body.transactionID,
              );
              const sig = this._key.sign(bodyBytes);
              sigMap.addSignature(nodeId, transactionId, this.publicKey, sig);
          }

          transaction.addSignature(this.publicKey, sigMap);
          return sigMap;
      }

      /**
       * deprecated - This method is deprecated and will be removed in future versions.
       * Use the `signTransaction` method with the `legacy=false` flag or don't
       * pass it all for the modern approach.
       * @param {Transaction} transaction
       * @returns {Uint8Array | Uint8Array[]}
       */
      _signTransactionLegacy(transaction) {
          const signatures = transaction._signedTransactions.list.map(
              (signedTransaction) => {
                  const bodyBytes = signedTransaction.bodyBytes;
                  if (!bodyBytes) {
                      return new Uint8Array();
                  }

                  return this._key.sign(bodyBytes);
              },
          );
          transaction.addSignature(this.publicKey, signatures);
          // Return directly Uint8Array if there is only one signature
          return signatures.length === 1 ? signatures[0] : signatures;
      }

      /**
       * Check if `derive` can be called on this private key.
       *
       * This is only the case if the key was created from a mnemonic.
       *
       * @returns {boolean}
       */
      isDerivable() {
          return this._key.isDerivable();
      }

      /**
       * @returns {Uint8Array}
       */
      toBytes() {
          return this._key.toBytes();
      }

      /**
       * @returns {Uint8Array}
       */
      toBytesDer() {
          return this._key.toBytesDer();
      }

      /**
       * @returns {Uint8Array}
       */
      toBytesRaw() {
          return this._key.toBytesRaw();
      }

      /**
       * @returns {string}
       */
      toString() {
          return this._key.toStringDer();
      }

      /**
       * @returns {string}
       */
      toStringDer() {
          return this._key.toStringDer();
      }

      /**
       * @returns {string}
       */
      toStringRaw() {
          return this._key.toStringRaw();
      }

      /**
       * Create a keystore with a given passphrase.
       *
       * The key can be recovered later with `fromKeystore()`.
       *
       * Note that this will not retain the ancillary data used for
       * deriving child keys, thus `.derive()` on the restored key will
       * throw even if this instance supports derivation.
       *
       * @param {string} [passphrase]
       * @returns {Promise<Uint8Array>}
       */
      toKeystore(passphrase = "") {
          return this._key.toKeystore(passphrase);
      }

      /**
       * @returns {HieroProto.proto.IKey}
       */
      _toProtobufKey() {
          return this.publicKey._toProtobufKey();
      }

      /**
       * @param {Long | number} shard
       * @param {Long | number} realm
       * @returns {AccountId}
       */
      toAccountId(shard, realm) {
          return this.publicKey.toAccountId(shard, realm);
      }

      /**
       * @returns {string}
       */
      get type() {
          return this._key._type;
      }

      /**
       * Recover the recovery ID used in the signature for the given message.
       *
       * **Note:** This method only works for ECDSA secp256k1 keys.
       * @param {Uint8Array} r - 32-byte `r` component of the signature
       * @param {Uint8Array} s - 32-byte `s` component of the signature
       * @param {Uint8Array} message - The original (unhashed) message
       * @returns {number} Recovery ID (03), or -1 if not found or not applicable
       */
      getRecoveryId(r, s, message) {
          return this._key.getRecoveryId(r, s, message);
      }

      /**
       * @param {string} privateKey
       * @returns { "ecdsa" | "ed25519"}
       */
      static getAlgorithm(privateKey) {
          if (!PrivateKey.isDerKey(privateKey)) {
              throw new Error("Only der keys are supported");
          }

          const decoder = new ASN1Decoder(Uint8Array.from(decode$8(privateKey)));
          decoder.read();
          const decodedKeyType = decoder.getOidKeyTypes()[0];
          // @ts-ignored
          return decodedKeyType;
      }

      /**
       * @internal
       * @param {string} key
       * @returns {boolean}
       */
      static isDerKey(key) {
          try {
              const data = Uint8Array.from(decode$8(key));
              const decoder = new ASN1Decoder(data);
              decoder.read(); // Attempt to read the ASN.1 structure
              return true;
          } catch (error) {
              return false;
          }
      }
  }

  CACHE.setPrivateKeyConstructor((key) => new PrivateKey(key));

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.IKey} HieroProto.proto.IKey
   * @typedef {import("@hashgraph/proto").proto.IKeyList} HieroProto.proto.IKeyList
   * @typedef {import("@hashgraph/proto").proto.IThresholdKey} HieroProto.proto.IThresholdKey
   */

  /**
   * A list of Keys (`Key`) with an optional threshold.
   */
  class KeyList extends Key {
      /**
       * @param {?Key[]} [keys]
       * @param {?number} [threshold]
       */
      constructor(keys, threshold) {
          super();

          /**
           * @private
           * @type {Key[]}
           */
          // @ts-ignore
          if (keys == null) this._keys = [];
          //checks if the value for `keys` is passed as a single key
          //rather than a list that contains just one key
          else if (keys instanceof Key) this._keys = [keys];
          else this._keys = keys;

          /**
           * @type {?number}
           */
          this._threshold = threshold == null ? null : threshold;
      }

      /**
       * @param {Key[]} keys
       * @returns {KeyList}
       */
      static of(...keys) {
          return new KeyList(keys, null);
      }

      /**
       * @template T
       * @param {ArrayLike<Key>} arrayLike
       * @param {((key: Key) => Key)} [mapFn]
       * @param {T} [thisArg]
       * @returns {KeyList}
       */
      static from(arrayLike, mapFn, thisArg) {
          if (mapFn == null) {
              return new KeyList(Array.from(arrayLike));
          }

          return new KeyList(Array.from(arrayLike, mapFn, thisArg));
      }

      /**
       * @returns {?number}
       */
      get threshold() {
          return this._threshold;
      }

      /**
       * @param {number} threshold
       * @returns {this}
       */
      setThreshold(threshold) {
          this._threshold = threshold;
          return this;
      }

      /**
       * @param {Key[]} keys
       * @returns {number}
       */
      push(...keys) {
          return this._keys.push(...keys);
      }

      /**
       * @param {number} start
       * @param {number} deleteCount
       * @param {Key[]} items
       * @returns {KeyList}
       */
      splice(start, deleteCount, ...items) {
          return new KeyList(
              this._keys.splice(start, deleteCount, ...items),
              this.threshold,
          );
      }

      /**
       * @param {number=} start
       * @param {number=} end
       * @returns {KeyList}
       */
      slice(start, end) {
          return new KeyList(this._keys.slice(start, end), this.threshold);
      }

      /**
       * @returns {Iterator<Key>}
       */
      [Symbol.iterator]() {
          return this._keys[Symbol.iterator]();
      }

      /**
       * @returns {Key[]}
       */
      toArray() {
          // eslint-disable-next-line @typescript-eslint/no-unsafe-return
          return this._keys.slice();
      }

      /**
       * @returns {string}
       */
      toString() {
          return JSON.stringify({
              threshold: this._threshold,
              keys: this._keys.toString(),
          });
      }

      /**
       * @returns {HieroProto.proto.IKey}
       */
      _toProtobufKey() {
          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-return
          const keys = this._keys.map((key) => key._toProtobufKey());

          if (this.threshold == null) {
              return { keyList: { keys } };
          } else {
              return {
                  thresholdKey: {
                      threshold: this.threshold,
                      keys: { keys },
                  },
              };
          }
      }

      /**
       * @param {HieroProto.proto.IKeyList} key
       * @returns {KeyList}
       */
      static __fromProtobufKeyList(key) {
          const keys = (key.keys != null ? key.keys : []).map((key) =>
              Key._fromProtobufKey(key),
          );
          return new KeyList(keys);
      }

      /**
       * @param {HieroProto.proto.IThresholdKey} key
       * @returns {KeyList}
       */
      static __fromProtobufThresoldKey(key) {
          const list = KeyList.__fromProtobufKeyList(
              key.keys != null ? key.keys : {},
          );
          list.setThreshold(key.threshold != null ? key.threshold : 0);
          return list;
      }
  }

  CACHE.setKeyList((key) => KeyList.__fromProtobufKeyList(key));
  CACHE.setThresholdKey((key) => KeyList.__fromProtobufThresoldKey(key));

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {{low: number, high: number, unsigned: boolean}} LongObject
   * @typedef {import("long")} Long
   */

  /**
   * @param {Long | number | string | LongObject | BigNumber} value
   * @returns {BigNumber}
   */
  function valueToLong(value) {
      if (BigNumber$1.isBigNumber(value)) {
          return value;
      } else {
          return new BigNumber$1(value.toString());
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * Represents a unit of HBAR currency measurement in the Hedera network.
   * Defines the various denominations of HBAR (tinybar, microbar, millibar, hbar, kilobar, megabar, gigabar)
   * and provides utilities for converting between these units. Each unit has a name, symbol, and conversion
   * rate to tinybar (the smallest unit of HBAR).
   */
  class HbarUnit {
      /**
       * @internal
       * @param {string} name
       * @param {string} symbol
       * @param {BigNumber} tinybar
       */
      constructor(name, symbol, tinybar) {
          /**
           * @internal
           * @readonly
           */
          this._name = name;

          /**
           * @internal
           * @readonly
           */
          this._symbol = symbol;

          /**
           * @internal
           * @readonly
           */
          this._tinybar = tinybar;

          Object.freeze(this);
      }

      /**
       * @param {string} unit
       * @returns {HbarUnit}
       */
      static fromString(unit) {
          switch (unit) {
              case HbarUnit.Hbar._symbol:
                  return HbarUnit.Hbar;
              case HbarUnit.Tinybar._symbol:
                  return HbarUnit.Tinybar;
              case HbarUnit.Microbar._symbol:
                  return HbarUnit.Microbar;
              case HbarUnit.Millibar._symbol:
                  return HbarUnit.Millibar;
              case HbarUnit.Kilobar._symbol:
                  return HbarUnit.Kilobar;
              case HbarUnit.Megabar._symbol:
                  return HbarUnit.Megabar;
              case HbarUnit.Gigabar._symbol:
                  return HbarUnit.Gigabar;
              default:
                  throw new Error("Unknown unit.");
          }
      }
  }

  HbarUnit.Tinybar = new HbarUnit("tinybar", "t", new BigNumber$1(1));

  HbarUnit.Microbar = new HbarUnit("microbar", "", new BigNumber$1(100));

  HbarUnit.Millibar = new HbarUnit("millibar", "m", new BigNumber$1(100000));

  HbarUnit.Hbar = new HbarUnit("hbar", "", new BigNumber$1("100000000"));

  HbarUnit.Kilobar = new HbarUnit(
      "kilobar",
      "k",
      new BigNumber$1(1000).multipliedBy(new BigNumber$1("100000000")),
  );

  HbarUnit.Megabar = new HbarUnit(
      "megabar",
      "M",
      new BigNumber$1(1000000).multipliedBy(new BigNumber$1("100000000")),
  );

  HbarUnit.Gigabar = new HbarUnit(
      "gigabar",
      "G",
      new BigNumber$1("1000000000").multipliedBy(new BigNumber$1("100000000")),
  );

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {import("./long.js").LongObject} LongObject
   */

  /**
   * Represents a quantity of hbar (), the native currency of the Hedera network.
   * Provides utilities for handling different hbar denominations and conversions.
   */
  class Hbar {
      /**
       * @param {number | string | Long | LongObject | BigNumber} amount
       * @param {HbarUnit=} unit
       */
      constructor(amount, unit = HbarUnit.Hbar) {
          if (unit === HbarUnit.Tinybar) {
              this._valueInTinybar = valueToLong(amount);
          } else {
              /** @type {BigNumber} */
              let bigAmount;

              if (Long.isLong(amount)) {
                  bigAmount = new BigNumber$1(amount.toString(10));
              } else if (
                  BigNumber$1.isBigNumber(amount) ||
                  typeof amount === "string" ||
                  typeof amount === "number"
              ) {
                  bigAmount = new BigNumber$1(amount);
              } else {
                  bigAmount = new BigNumber$1(0);
              }

              /**
               * @type {BigNumber}
               */
              this._valueInTinybar = bigAmount.multipliedBy(unit._tinybar);
          }
          if (!this._valueInTinybar.isInteger()) {
              throw new Error("Hbar in tinybars contains decimals");
          }
      }

      /**
       * @param {number | Long | string | BigNumber} amount
       * @param {HbarUnit} unit
       * @returns {Hbar}
       */
      static from(amount, unit) {
          return new Hbar(amount, unit);
      }

      /**
       * @param {number | Long | string | BigNumber} amount
       * @returns {Hbar}
       */
      static fromTinybars(amount) {
          if (typeof amount === "string") {
              return this.fromString(amount, HbarUnit.Tinybar);
          }
          return new Hbar(amount, HbarUnit.Tinybar);
      }

      /**
       * @param {string} str
       * @param {HbarUnit=} unit
       * @returns {Hbar}
       */
      static fromString(str, unit = HbarUnit.Hbar) {
          const pattern = /^((?:\+|-)?\d+(?:\.\d+)?)(?: (t||m||k|M|G))?$/;
          if (pattern.test(str)) {
              let [amount, symbol] = str.split(" ");
              if (symbol != null) {
                  unit = HbarUnit.fromString(symbol);
              }
              return new Hbar(new BigNumber$1(amount), unit);
          } else {
              throw new Error("invalid argument provided");
          }
      }

      /**
       * @param {HbarUnit} unit
       * @returns {BigNumber}
       */
      to(unit) {
          return this._valueInTinybar.dividedBy(unit._tinybar);
      }

      /**
       * @returns {BigNumber}
       */
      toBigNumber() {
          return this.to(HbarUnit.Hbar);
      }

      /**
       * @returns {Long}
       */
      toTinybars() {
          return Long.fromValue(this._valueInTinybar.toFixed());
      }

      /**
       * @returns {Hbar}
       */
      negated() {
          return Hbar.fromTinybars(this._valueInTinybar.negated());
      }

      /**
       * @returns {boolean}
       */
      isNegative() {
          return this._valueInTinybar.isNegative();
      }

      /**
       * @param {HbarUnit=} unit
       * @returns {string}
       */
      toString(unit) {
          if (unit != null) {
              return `${this._valueInTinybar
                .dividedBy(unit._tinybar)
                .toString()} ${unit._symbol}`;
          }

          if (
              this._valueInTinybar.isLessThan(10000) &&
              this._valueInTinybar.isGreaterThan(-1e4)
          ) {
              return `${this._valueInTinybar.toFixed()} ${
                HbarUnit.Tinybar._symbol
            }`;
          }

          return `${this.to(HbarUnit.Hbar).toString()} ${HbarUnit.Hbar._symbol}`;
      }
  }

  // SPDX-License-Identifier: Apache-2.0

  /**
   * @typedef {import("./Status.js").default} Status
   * @typedef {import("./transaction/TransactionId.js").default} TransactionId
   */

  /**
   * @typedef {object} StatusErrorJSON
   * @property {string} name
   * @property {string} status
   * @property {string} transactionId
   * @property {string} message
   */

  class StatusError extends Error {
      /**
       * @param {object} props
       * @param {Status} props.status
       * @param {TransactionId} props.transactionId
       * @param {string} message
       */
      constructor(props, message) {
          super(message);

          this.name = "StatusError";

          this.status = props.status;

          this.transactionId = props.transactionId;

          this.message = message;

          if (typeof Error.captureStackTrace !== "undefined") {
              Error.captureStackTrace(this, StatusError);
          }
      }

      /**
       * @returns {StatusErrorJSON}
       */
      toJSON() {
          return {
              name: this.name,
              status: this.status.toString(),
              transactionId: this.transactionId.toString(),
              message: this.message,
          };
      }

      /**
       * @returns {string}
       */
      toString() {
          return JSON.stringify(this.toJSON());
      }

      /**
       * @returns {StatusErrorJSON}
       */
      valueOf() {
          return this.toJSON();
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {import("./Status.js").default} Status
   * @typedef {import("./transaction/TransactionId.js").default} TransactionId
   * @typedef {import("./transaction/TransactionReceipt.js").default} TransactionReceipt
   */

  /**
   * Represents an error that occurs when a transaction receipt indicates a failure
   * on the Hedera network. The `ReceiptStatusError` class extends the base
   * `StatusError` class and provides additional context specific to receipt-related
   * failures, such as the transaction ID, status, and any associated messages.
   *
   * This error is typically thrown when a transaction has been processed, but the
   * receipt indicates that it did not complete successfully. It allows developers to
   * handle such errors effectively in their applications by providing detailed
   * information about the failure.
   */
  class ReceiptStatusError extends StatusError {
      /**
       * @param {object} props
       * @param {TransactionReceipt} props.transactionReceipt
       * @param {Status} props.status
       * @param {TransactionId} props.transactionId
       */
      constructor(props) {
          super(
              props,
              `receipt for transaction ${props.transactionId.toString()} contained error status ${props.status.toString()}`,
          );

          /**
           * @type {TransactionReceipt}
           * @readonly
           */
          this.transactionReceipt = props.transactionReceipt;
      }
  }

  // SPDX-License-Identifier: Apache-2.0

  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ResponseCodeEnum} HieroProto.proto.ResponseCodeEnum
   */

  class Status {
      /**
       * @hideconstructor
       * @internal
       * @param {number} code
       */
      constructor(code) {
          /** @readonly */
          this._code = code;

          Object.freeze(this);
      }

      /**
       * @returns {string}
       */
      toString() {
          switch (this) {
              case Status.Ok:
                  return "OK";
              case Status.InvalidTransaction:
                  return "INVALID_TRANSACTION";
              case Status.PayerAccountNotFound:
                  return "PAYER_ACCOUNT_NOT_FOUND";
              case Status.InvalidNodeAccount:
                  return "INVALID_NODE_ACCOUNT";
              case Status.TransactionExpired:
                  return "TRANSACTION_EXPIRED";
              case Status.InvalidTransactionStart:
                  return "INVALID_TRANSACTION_START";
              case Status.InvalidTransactionDuration:
                  return "INVALID_TRANSACTION_DURATION";
              case Status.InvalidSignature:
                  return "INVALID_SIGNATURE";
              case Status.MemoTooLong:
                  return "MEMO_TOO_LONG";
              case Status.InsufficientTxFee:
                  return "INSUFFICIENT_TX_FEE";
              case Status.InsufficientPayerBalance:
                  return "INSUFFICIENT_PAYER_BALANCE";
              case Status.DuplicateTransaction:
                  return "DUPLICATE_TRANSACTION";
              case Status.Busy:
                  return "BUSY";
              case Status.NotSupported:
                  return "NOT_SUPPORTED";
              case Status.InvalidFileId:
                  return "INVALID_FILE_ID";
              case Status.InvalidAccountId:
                  return "INVALID_ACCOUNT_ID";
              case Status.InvalidContractId:
                  return "INVALID_CONTRACT_ID";
              case Status.InvalidTransactionId:
                  return "INVALID_TRANSACTION_ID";
              case Status.ReceiptNotFound:
                  return "RECEIPT_NOT_FOUND";
              case Status.RecordNotFound:
                  return "RECORD_NOT_FOUND";
              case Status.InvalidSolidityId:
                  return "INVALID_SOLIDITY_ID";
              case Status.Unknown:
                  return "UNKNOWN";
              case Status.Success:
                  return "SUCCESS";
              case Status.FailInvalid:
                  return "FAIL_INVALID";
              case Status.FailFee:
                  return "FAIL_FEE";
              case Status.FailBalance:
                  return "FAIL_BALANCE";
              case Status.KeyRequired:
                  return "KEY_REQUIRED";
              case Status.BadEncoding:
                  return "BAD_ENCODING";
              case Status.InsufficientAccountBalance:
                  return "INSUFFICIENT_ACCOUNT_BALANCE";
              case Status.InvalidSolidityAddress:
                  return "INVALID_SOLIDITY_ADDRESS";
              case Status.InsufficientGas:
                  return "INSUFFICIENT_GAS";
              case Status.ContractSizeLimitExceeded:
                  return "CONTRACT_SIZE_LIMIT_EXCEEDED";
              case Status.LocalCallModificationException:
                  return "LOCAL_CALL_MODIFICATION_EXCEPTION";
              case Status.ContractRevertExecuted:
                  return "CONTRACT_REVERT_EXECUTED";
              case Status.ContractExecutionException:
                  return "CONTRACT_EXECUTION_EXCEPTION";
              case Status.InvalidReceivingNodeAccount:
                  return "INVALID_RECEIVING_NODE_ACCOUNT";
              case Status.MissingQueryHeader:
                  return "MISSING_QUERY_HEADER";
              case Status.AccountUpdateFailed:
                  return "ACCOUNT_UPDATE_FAILED";
              case Status.InvalidKeyEncoding:
                  return "INVALID_KEY_ENCODING";
              case Status.NullSolidityAddress:
                  return "NULL_SOLIDITY_ADDRESS";
              case Status.ContractUpdateFailed:
                  return "CONTRACT_UPDATE_FAILED";
              case Status.InvalidQueryHeader:
                  return "INVALID_QUERY_HEADER";
              case Status.InvalidFeeSubmitted:
                  return "INVALID_FEE_SUBMITTED";
              case Status.InvalidPayerSignature:
                  return "INVALID_PAYER_SIGNATURE";
              case Status.KeyNotProvided:
                  return "KEY_NOT_PROVIDED";
              case Status.InvalidExpirationTime:
                  return "INVALID_EXPIRATION_TIME";
              case Status.NoWaclKey:
                  return "NO_WACL_KEY";
              case Status.FileContentEmpty:
                  return "FILE_CONTENT_EMPTY";
              case Status.InvalidAccountAmounts:
                  return "INVALID_ACCOUNT_AMOUNTS";
              case Status.EmptyTransactionBody:
                  return "EMPTY_TRANSACTION_BODY";
              case Status.InvalidTransactionBody:
                  return "INVALID_TRANSACTION_BODY";
              case Status.InvalidSignatureTypeMismatchingKey:
                  return "INVALID_SIGNATURE_TYPE_MISMATCHING_KEY";
              case Status.InvalidSignatureCountMismatchingKey:
                  return "INVALID_SIGNATURE_COUNT_MISMATCHING_KEY";
              case Status.EmptyLiveHashBody:
                  return "EMPTY_LIVE_HASH_BODY";
              case Status.EmptyLiveHash:
                  return "EMPTY_LIVE_HASH";
              case Status.EmptyLiveHashKeys:
                  return "EMPTY_LIVE_HASH_KEYS";
              case Status.InvalidLiveHashSize:
                  return "INVALID_LIVE_HASH_SIZE";
              case Status.EmptyQueryBody:
                  return "EMPTY_QUERY_BODY";
              case Status.EmptyLiveHashQuery:
                  return "EMPTY_LIVE_HASH_QUERY";
              case Status.LiveHashNotFound:
                  return "LIVE_HASH_NOT_FOUND";
              case Status.AccountIdDoesNotExist:
                  return "ACCOUNT_ID_DOES_NOT_EXIST";
              case Status.LiveHashAlreadyExists:
                  return "LIVE_HASH_ALREADY_EXISTS";
              case Status.InvalidFileWacl:
                  return "INVALID_FILE_WACL";
              case Status.SerializationFailed:
                  return "SERIALIZATION_FAILED";
              case Status.TransactionOversize:
                  return "TRANSACTION_OVERSIZE";
              case Status.TransactionTooManyLayers:
                  return "TRANSACTION_TOO_MANY_LAYERS";
              case Status.ContractDeleted:
                  return "CONTRACT_DELETED";
              case Status.PlatformNotActive:
                  return "PLATFORM_NOT_ACTIVE";
              case Status.KeyPrefixMismatch:
                  return "KEY_PREFIX_MISMATCH";
              case Status.PlatformTransactionNotCreated:
                  return "PLATFORM_TRANSACTION_NOT_CREATED";
              case Status.InvalidRenewalPeriod:
                  return "INVALID_RENEWAL_PERIOD";
              case Status.InvalidPayerAccountId:
                  return "INVALID_PAYER_ACCOUNT_ID";
              case Status.AccountDeleted:
                  return "ACCOUNT_DELETED";
              case Status.FileDeleted:
                  return "FILE_DELETED";
              case Status.AccountRepeatedInAccountAmounts:
                  return "ACCOUNT_REPEATED_IN_ACCOUNT_AMOUNTS";
              case Status.SettingNegativeAccountBalance:
                  return "SETTING_NEGATIVE_ACCOUNT_BALANCE";
              case Status.ObtainerRequired:
                  return "OBTAINER_REQUIRED";
              case Status.ObtainerSameContractId:
                  return "OBTAINER_SAME_CONTRACT_ID";
              case Status.ObtainerDoesNotExist:
                  return "OBTAINER_DOES_NOT_EXIST";
              case Status.ModifyingImmutableContract:
                  return "MODIFYING_IMMUTABLE_CONTRACT";
              case Status.FileSystemException:
                  return "FILE_SYSTEM_EXCEPTION";
              case Status.AutorenewDurationNotInRange:
                  return "AUTORENEW_DURATION_NOT_IN_RANGE";
              case Status.ErrorDecodingBytestring:
                  return "ERROR_DECODING_BYTESTRING";
              case Status.ContractFileEmpty:
                  return "CONTRACT_FILE_EMPTY";
              case Status.ContractBytecodeEmpty:
                  return "CONTRACT_BYTECODE_EMPTY";
              case Status.InvalidInitialBalance:
                  return "INVALID_INITIAL_BALANCE";
              case Status.InvalidReceiveRecordThreshold:
                  return "INVALID_RECEIVE_RECORD_THRESHOLD";
              case Status.InvalidSendRecordThreshold:
                  return "INVALID_SEND_RECORD_THRESHOLD";
              case Status.AccountIsNotGenesisAccount:
                  return "ACCOUNT_IS_NOT_GENESIS_ACCOUNT";
              case Status.PayerAccountUnauthorized:
                  return "PAYER_ACCOUNT_UNAUTHORIZED";
              case Status.InvalidFreezeTransactionBody:
                  return "INVALID_FREEZE_TRANSACTION_BODY";
              case Status.FreezeTransactionBodyNotFound:
                  return "FREEZE_TRANSACTION_BODY_NOT_FOUND";
              case Status.TransferListSizeLimitExceeded:
                  return "TRANSFER_LIST_SIZE_LIMIT_EXCEEDED";
              case Status.ResultSizeLimitExceeded:
                  return "RESULT_SIZE_LIMIT_EXCEEDED";
              case Status.NotSpecialAccount:
                  return "NOT_SPECIAL_ACCOUNT";
              case Status.ContractNegativeGas:
                  return "CONTRACT_NEGATIVE_GAS";
              case Status.ContractNegativeValue:
                  return "CONTRACT_NEGATIVE_VALUE";
              case Status.InvalidFeeFile:
                  return "INVALID_FEE_FILE";
              case Status.InvalidExchangeRateFile:
                  return "INVALID_EXCHANGE_RATE_FILE";
              case Status.InsufficientLocalCallGas:
                  return "INSUFFICIENT_LOCAL_CALL_GAS";
              case Status.EntityNotAllowedToDelete:
                  return "ENTITY_NOT_ALLOWED_TO_DELETE";
              case Status.AuthorizationFailed:
                  return "AUTHORIZATION_FAILED";
              case Status.FileUploadedProtoInvalid:
                  return "FILE_UPLOADED_PROTO_INVALID";
              case Status.FileUploadedProtoNotSavedToDisk:
                  return "FILE_UPLOADED_PROTO_NOT_SAVED_TO_DISK";
              case Status.FeeScheduleFilePartUploaded:
                  return "FEE_SCHEDULE_FILE_PART_UPLOADED";
              case Status.ExchangeRateChangeLimitExceeded:
                  return "EXCHANGE_RATE_CHANGE_LIMIT_EXCEEDED";
              case Status.MaxContractStorageExceeded:
                  return "MAX_CONTRACT_STORAGE_EXCEEDED";
              case Status.TransferAccountSameAsDeleteAccount:
                  return "TRANSFER_ACCOUNT_SAME_AS_DELETE_ACCOUNT";
              case Status.TotalLedgerBalanceInvalid:
                  return "TOTAL_LEDGER_BALANCE_INVALID";
              case Status.ExpirationReductionNotAllowed:
                  return "EXPIRATION_REDUCTION_NOT_ALLOWED";
              case Status.MaxGasLimitExceeded:
                  return "MAX_GAS_LIMIT_EXCEEDED";
              case Status.MaxFileSizeExceeded:
                  return "MAX_FILE_SIZE_EXCEEDED";
              case Status.ReceiverSigRequired:
                  return "RECEIVER_SIG_REQUIRED";
              case Status.InvalidTopicId:
                  return "INVALID_TOPIC_ID";
              case Status.InvalidAdminKey:
                  return "INVALID_ADMIN_KEY";
              case Status.InvalidSubmitKey:
                  return "INVALID_SUBMIT_KEY";
              case Status.Unauthorized:
                  return "UNAUTHORIZED";
              case Status.InvalidTopicMessage:
                  return "INVALID_TOPIC_MESSAGE";
              case Status.InvalidAutorenewAccount:
                  return "INVALID_AUTORENEW_ACCOUNT";
              case Status.AutorenewAccountNotAllowed:
                  return "AUTORENEW_ACCOUNT_NOT_ALLOWED";
              case Status.TopicExpired:
                  return "TOPIC_EXPIRED";
              case Status.InvalidChunkNumber:
                  return "INVALID_CHUNK_NUMBER";
              case Status.InvalidChunkTransactionId:
                  return "INVALID_CHUNK_TRANSACTION_ID";
              case Status.AccountFrozenForToken:
                  return "ACCOUNT_FROZEN_FOR_TOKEN";
              case Status.TokensPerAccountLimitExceeded:
                  return "TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED";
              case Status.InvalidTokenId:
                  return "INVALID_TOKEN_ID";
              case Status.InvalidTokenDecimals:
                  return "INVALID_TOKEN_DECIMALS";
              case Status.InvalidTokenInitialSupply:
                  return "INVALID_TOKEN_INITIAL_SUPPLY";
              case Status.InvalidTreasuryAccountForToken:
                  return "INVALID_TREASURY_ACCOUNT_FOR_TOKEN";
              case Status.InvalidTokenSymbol:
                  return "INVALID_TOKEN_SYMBOL";
              case Status.TokenHasNoFreezeKey:
                  return "TOKEN_HAS_NO_FREEZE_KEY";
              case Status.TransfersNotZeroSumForToken:
                  return "TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN";
              case Status.MissingTokenSymbol:
                  return "MISSING_TOKEN_SYMBOL";
              case Status.TokenSymbolTooLong:
                  return "TOKEN_SYMBOL_TOO_LONG";
              case Status.AccountKycNotGrantedForToken:
                  return "ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN";
              case Status.TokenHasNoKycKey:
                  return "TOKEN_HAS_NO_KYC_KEY";
              case Status.InsufficientTokenBalance:
                  return "INSUFFICIENT_TOKEN_BALANCE";
              case Status.TokenWasDeleted:
                  return "TOKEN_WAS_DELETED";
              case Status.TokenHasNoSupplyKey:
                  return "TOKEN_HAS_NO_SUPPLY_KEY";
              case Status.TokenHasNoWipeKey:
                  return "TOKEN_HAS_NO_WIPE_KEY";
              case Status.InvalidTokenMintAmount:
                  return "INVALID_TOKEN_MINT_AMOUNT";
              case Status.InvalidTokenBurnAmount:
                  return "INVALID_TOKEN_BURN_AMOUNT";
              case Status.TokenNotAssociatedToAccount:
                  return "TOKEN_NOT_ASSOCIATED_TO_ACCOUNT";
              case Status.CannotWipeTokenTreasuryAccount:
                  return "CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT";
              case Status.InvalidKycKey:
                  return "INVALID_KYC_KEY";
              case Status.InvalidWipeKey:
                  return "INVALID_WIPE_KEY";
              case Status.InvalidFreezeKey:
                  return "INVALID_FREEZE_KEY";
              case Status.InvalidSupplyKey:
                  return "INVALID_SUPPLY_KEY";
              case Status.MissingTokenName:
                  return "MISSING_TOKEN_NAME";
              case Status.TokenNameTooLong:
                  return "TOKEN_NAME_TOO_LONG";
              case Status.InvalidWipingAmount:
                  return "INVALID_WIPING_AMOUNT";
              case Status.TokenIsImmutable:
                  return "TOKEN_IS_IMMUTABLE";
              case Status.TokenAlreadyAssociatedToAccount:
                  return "TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT";
              case Status.TransactionRequiresZeroTokenBalances:
                  return "TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES";
              case Status.AccountIsTreasury:
                  return "ACCOUNT_IS_TREASURY";
              case Status.TokenIdRepeatedInTokenList:
                  return "TOKEN_ID_REPEATED_IN_TOKEN_LIST";
              case Status.TokenTransferListSizeLimitExceeded:
                  return "TOKEN_TRANSFER_LIST_SIZE_LIMIT_EXCEEDED";
              case Status.EmptyTokenTransferBody:
                  return "EMPTY_TOKEN_TRANSFER_BODY";
              case Status.EmptyTokenTransferAccountAmounts:
                  return "EMPTY_TOKEN_TRANSFER_ACCOUNT_AMOUNTS";
              case Status.InvalidScheduleId:
                  return "INVALID_SCHEDULE_ID";
              case Status.ScheduleIsImmutable:
                  return "SCHEDULE_IS_IMMUTABLE";
              case Status.InvalidSchedulePayerId:
                  return "INVALID_SCHEDULE_PAYER_ID";
              case Status.InvalidScheduleAccountId:
                  return "INVALID_SCHEDULE_ACCOUNT_ID";
              case Status.NoNewValidSignatures:
                  return "NO_NEW_VALID_SIGNATURES";
              case Status.UnresolvableRequiredSigners:
                  return "UNRESOLVABLE_REQUIRED_SIGNERS";
              case Status.ScheduledTransactionNotInWhitelist:
                  return "SCHEDULED_TRANSACTION_NOT_IN_WHITELIST";
              case Status.SomeSignaturesWereInvalid:
                  return "SOME_SIGNATURES_WERE_INVALID";
              case Status.TransactionIdFieldNotAllowed:
                  return "TRANSACTION_ID_FIELD_NOT_ALLOWED";
              case Status.IdenticalScheduleAlreadyCreated:
                  return "IDENTICAL_SCHEDULE_ALREADY_CREATED";
              case Status.InvalidZeroByteInString:
                  return "INVALID_ZERO_BYTE_IN_STRING";
              case Status.ScheduleAlreadyDeleted:
                  return "SCHEDULE_ALREADY_DELETED";
              case Status.ScheduleAlreadyExecuted:
                  return "SCHEDULE_ALREADY_EXECUTED";
              case Status.MessageSizeTooLarge:
                  return "MESSAGE_SIZE_TOO_LARGE";
              case Status.OperationRepeatedInBucketGroups:
                  return "OPERATION_REPEATED_IN_BUCKET_GROUPS";
              case Status.BucketCapacityOverflow:
                  return "BUCKET_CAPACITY_OVERFLOW";
              case Status.NodeCapacityNotSufficientForOperation:
                  return "NODE_CAPACITY_NOT_SUFFICIENT_FOR_OPERATION";
              case Status.BucketHasNoThrottleGroups:
                  return "BUCKET_HAS_NO_THROTTLE_GROUPS";
              case Status.ThrottleGroupHasZeroOpsPerSec:
                  return "THROTTLE_GROUP_HAS_ZERO_OPS_PER_SEC";
              case Status.SuccessButMissingExpectedOperation:
                  return "SUCCESS_BUT_MISSING_EXPECTED_OPERATION";
              case Status.UnparseableThrottleDefinitions:
                  return "UNPARSEABLE_THROTTLE_DEFINITIONS";
              case Status.InvalidThrottleDefinitions:
                  return "INVALID_THROTTLE_DEFINITIONS";
              case Status.AccountExpiredAndPendingRemoval:
                  return "ACCOUNT_EXPIRED_AND_PENDING_REMOVAL";
              case Status.InvalidTokenMaxSupply:
                  return "INVALID_TOKEN_MAX_SUPPLY";
              case Status.InvalidTokenNftSerialNumber:
                  return "INVALID_TOKEN_NFT_SERIAL_NUMBER";
              case Status.InvalidNftId:
                  return "INVALID_NFT_ID";
              case Status.MetadataTooLong:
                  return "METADATA_TOO_LONG";
              case Status.BatchSizeLimitExceeded:
                  return "BATCH_SIZE_LIMIT_EXCEEDED";
              case Status.InvalidQueryRange:
                  return "INVALID_QUERY_RANGE";
              case Status.FractionDividesByZero:
                  return "FRACTION_DIVIDES_BY_ZERO";
              case Status.InsufficientPayerBalanceForCustomFee:
                  return "INSUFFICIENT_PAYER_BALANCE_FOR_CUSTOM_FEE";
              case Status.CustomFeesListTooLong:
                  return "CUSTOM_FEES_LIST_TOO_LONG";
              case Status.InvalidCustomFeeCollector:
                  return "INVALID_CUSTOM_FEE_COLLECTOR";
              case Status.InvalidTokenIdInCustomFees:
                  return "INVALID_TOKEN_ID_IN_CUSTOM_FEES";
              case Status.TokenNotAssociatedToFeeCollector:
                  return "TOKEN_NOT_ASSOCIATED_TO_FEE_COLLECTOR";
              case Status.TokenMaxSupplyReached:
                  return "TOKEN_MAX_SUPPLY_REACHED";
              case Status.SenderDoesNotOwnNftSerialNo:
                  return "SENDER_DOES_NOT_OWN_NFT_SERIAL_NO";
              case Status.CustomFeeNotFullySpecified:
                  return "CUSTOM_FEE_NOT_FULLY_SPECIFIED";
              case Status.CustomFeeMustBePositive:
                  return "CUSTOM_FEE_MUST_BE_POSITIVE";
              case Status.TokenHasNoFeeScheduleKey:
                  return "TOKEN_HAS_NO_FEE_SCHEDULE_KEY";
              case Status.CustomFeeOutsideNumericRange:
                  return "CUSTOM_FEE_OUTSIDE_NUMERIC_RANGE";
              case Status.RoyaltyFractionCannotExceedOne:
                  return "ROYALTY_FRACTION_CANNOT_EXCEED_ONE";
              case Status.FractionalFeeMaxAmountLessThanMinAmount:
                  return "FRACTIONAL_FEE_MAX_AMOUNT_LESS_THAN_MIN_AMOUNT";
              case Status.CustomScheduleAlreadyHasNoFees:
                  return "CUSTOM_SCHEDULE_ALREADY_HAS_NO_FEES";
              case Status.CustomFeeDenominationMustBeFungibleCommon:
                  return "CUSTOM_FEE_DENOMINATION_MUST_BE_FUNGIBLE_COMMON";
              case Status.CustomFractionalFeeOnlyAllowedForFungibleCommon:
                  return "CUSTOM_FRACTIONAL_FEE_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON";
              case Status.InvalidCustomFeeScheduleKey:
                  return "INVALID_CUSTOM_FEE_SCHEDULE_KEY";
              case Status.InvalidTokenMintMetadata:
                  return "INVALID_TOKEN_MINT_METADATA";
              case Status.InvalidTokenBurnMetadata:
                  return "INVALID_TOKEN_BURN_METADATA";
              case Status.CurrentTreasuryStillOwnsNfts:
                  return "CURRENT_TREASURY_STILL_OWNS_NFTS";
              case Status.AccountStillOwnsNfts:
                  return "ACCOUNT_STILL_OWNS_NFTS";
              case Status.TreasuryMustOwnBurnedNft:
                  return "TREASURY_MUST_OWN_BURNED_NFT";
              case Status.AccountDoesNotOwnWipedNft:
                  return "ACCOUNT_DOES_NOT_OWN_WIPED_NFT";
              case Status.AccountAmountTransfersOnlyAllowedForFungibleCommon:
                  return "ACCOUNT_AMOUNT_TRANSFERS_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON";
              case Status.MaxNftsInPriceRegimeHaveBeenMinted:
                  return "MAX_NFTS_IN_PRICE_REGIME_HAVE_BEEN_MINTED";
              case Status.PayerAccountDeleted:
                  return "PAYER_ACCOUNT_DELETED";
              case Status.CustomFeeChargingExceededMaxRecursionDepth:
                  return "CUSTOM_FEE_CHARGING_EXCEEDED_MAX_RECURSION_DEPTH";
              case Status.CustomFeeChargingExceededMaxAccountAmounts:
                  return "CUSTOM_FEE_CHARGING_EXCEEDED_MAX_ACCOUNT_AMOUNTS";
              case Status.InsufficientSenderAccountBalanceForCustomFee:
                  return "INSUFFICIENT_SENDER_ACCOUNT_BALANCE_FOR_CUSTOM_FEE";
              case Status.SerialNumberLimitReached:
                  return "SERIAL_NUMBER_LIMIT_REACHED";
              case Status.CustomRoyaltyFeeOnlyAllowedForNonFungibleUnique:
                  return "CUSTOM_ROYALTY_FEE_ONLY_ALLOWED_FOR_NON_FUNGIBLE_UNIQUE";
              case Status.NoRemainingAutomaticAssociations:
                  return "NO_REMAINING_AUTOMATIC_ASSOCIATIONS";
              case Status.ExistingAutomaticAssociationsExceedGivenLimit:
                  return "EXISTING_AUTOMATIC_ASSOCIATIONS_EXCEED_GIVEN_LIMIT";
              case Status.RequestedNumAutomaticAssociationsExceedsAssociationLimit:
                  return "REQUESTED_NUM_AUTOMATIC_ASSOCIATIONS_EXCEEDS_ASSOCIATION_LIMIT";
              case Status.TokenIsPaused:
                  return "TOKEN_IS_PAUSED";
              case Status.TokenHasNoPauseKey:
                  return "TOKEN_HAS_NO_PAUSE_KEY";
              case Status.InvalidPauseKey:
                  return "INVALID_PAUSE_KEY";
              case Status.FreezeUpdateFileDoesNotExist:
                  return "FREEZE_UPDATE_FILE_DOES_NOT_EXIST";
              case Status.FreezeUpdateFileHashDoesNotMatch:
                  return "FREEZE_UPDATE_FILE_HASH_DOES_NOT_MATCH";
              case Status.NoUpgradeHasBeenPrepared:
                  return "NO_UPGRADE_HAS_BEEN_PREPARED";
              case Status.NoFreezeIsScheduled:
                  return "NO_FREEZE_IS_SCHEDULED";
              case Status.UpdateFileHashChangedSincePrepareUpgrade:
                  return "UPDATE_FILE_HASH_CHANGED_SINCE_PREPARE_UPGRADE";
              case Status.FreezeStartTimeMustBeFuture:
                  return "FREEZE_START_TIME_MUST_BE_FUTURE";
              case Status.PreparedUpdateFileIsImmutable:
                  return "PREPARED_UPDATE_FILE_IS_IMMUTABLE";
              case Status.FreezeAlreadyScheduled:
                  return "FREEZE_ALREADY_SCHEDULED";
              case Status.FreezeUpgradeInProgress:
                  return "FREEZE_UPGRADE_IN_PROGRESS";
              case Status.UpdateFileIdDoesNotMatchPrepared:
                  return "UPDATE_FILE_ID_DOES_NOT_MATCH_PREPARED";
              case Status.UpdateFileHashDoesNotMatchPrepared:
                  return "UPDATE_FILE_HASH_DOES_NOT_MATCH_PREPARED";
              case Status.ConsensusGasExhausted:
                  return "CONSENSUS_GAS_EXHAUSTED";
              case Status.RevertedSuccess:
                  return "REVERTED_SUCCESS";
              case Status.MaxStorageInPriceRegimeHasBeenUsed:
                  return "MAX_STORAGE_IN_PRICE_REGIME_HAS_BEEN_USED";
              case Status.InvalidAliasKey:
                  return "INVALID_ALIAS_KEY";
              case Status.UnexpectedTokenDecimals:
                  return "UNEXPECTED_TOKEN_DECIMALS";
              case Status.InvalidProxyAccountId:
                  return "INVALID_PROXY_ACCOUNT_ID";
              case Status.InvalidTransferAccountId:
                  return "INVALID_TRANSFER_ACCOUNT_ID";
              case Status.InvalidFeeCollectorAccountId:
                  return "INVALID_FEE_COLLECTOR_ACCOUNT_ID";
              case Status.AliasIsImmutable:
                  return "ALIAS_IS_IMMUTABLE";
              case Status.SpenderAccountSameAsOwner:
                  return "SPENDER_ACCOUNT_SAME_AS_OWNER";
              case Status.AmountExceedsTokenMaxSupply:
                  return "AMOUNT_EXCEEDS_TOKEN_MAX_SUPPLY";
              case Status.NegativeAllowanceAmount:
                  return "NEGATIVE_ALLOWANCE_AMOUNT";
              case Status.CannotApproveForAllFungibleCommon:
                  return "CANNOT_APPROVE_FOR_ALL_FUNGIBLE_COMMON";
              case Status.SpenderDoesNotHaveAllowance:
                  return "SPENDER_DOES_NOT_HAVE_ALLOWANCE";
              case Status.AmountExceedsAllowance:
                  return "AMOUNT_EXCEEDS_ALLOWANCE";
              case Status.MaxAllowancesExceeded:
                  return "MAX_ALLOWANCES_EXCEEDED";
              case Status.EmptyAllowances:
                  return "EMPTY_ALLOWANCES";
              case Status.SpenderAccountRepeatedInAllowances:
                  return "SPENDER_ACCOUNT_REPEATED_IN_ALLOWANCES";
              case Status.RepeatedSerialNumsInNftAllowances:
                  return "REPEATED_SERIAL_NUMS_IN_NFT_ALLOWANCES";
              case Status.FungibleTokenInNftAllowances:
                  return "FUNGIBLE_TOKEN_IN_NFT_ALLOWANCES";
              case Status.NftInFungibleTokenAllowances:
                  return "NFT_IN_FUNGIBLE_TOKEN_ALLOWANCES";
              case Status.InvalidAllowanceOwnerId:
                  return "INVALID_ALLOWANCE_OWNER_ID";
              case Status.InvalidAllowanceSpenderId:
                  return "INVALID_ALLOWANCE_SPENDER_ID";
              case Status.RepeatedAllowancesToDelete:
                  return "REPEATED_ALLOWANCES_TO_DELETE";
              case Status.InvalidDelegatingSpender:
                  return "INVALID_DELEGATING_SPENDER";
              case Status.DelegatingSpenderCannotGrantApproveForAll:
                  return "DELEGATING_SPENDER_CANNOT_GRANT_APPROVE_FOR_ALL";
              case Status.DelegatingSpenderDoesNotHaveApproveForAll:
                  return "DELEGATING_SPENDER_DOES_NOT_HAVE_APPROVE_FOR_ALL";
              case Status.ScheduleExpirationTimeTooFarInFuture:
                  return "SCHEDULE_EXPIRATION_TIME_TOO_FAR_IN_FUTURE";
              case Status.ScheduleExpirationTimeMustBeHigherThanConsensusTime:
                  return "SCHEDULE_EXPIRATION_TIME_MUST_BE_HIGHER_THAN_CONSENSUS_TIME";
              case Status.ScheduleFutureThrottleExceeded:
                  return "SCHEDULE_FUTURE_THROTTLE_EXCEEDED";
              case Status.ScheduleFutureGasLimitExceeded:
                  return "SCHEDULE_FUTURE_GAS_LIMIT_EXCEEDED";
              case Status.InvalidEthereumTransaction:
                  return "INVALID_ETHEREUM_TRANSACTION";
              case Status.WrongChainId:
                  return "WRONG_CHAIN_ID";
              case Status.WrongNonce:
                  return "WRONG_NONCE";
              case Status.AccessListUnsupported:
                  return "ACCESS_LIST_UNSUPPORTED";
              case Status.SchedulePendingExpiration:
                  return "SCHEDULE_PENDING_EXPIRATION";
              case Status.ContractIsTokenTreasury:
                  return "CONTRACT_IS_TOKEN_TREASURY";
              case Status.ContractHasNonZeroTokenBalances:
                  return "CONTRACT_HAS_NON_ZERO_TOKEN_BALANCES";
              case Status.ContractExpiredAndPendingRemoval:
                  return "CONTRACT_EXPIRED_AND_PENDING_REMOVAL";
              case Status.ContractHasNoAutoRenewAccount:
                  return "CONTRACT_HAS_NO_AUTO_RENEW_ACCOUNT";
              case Status.PermanentRemovalRequiresSystemInitiation:
                  return "PERMANENT_REMOVAL_REQUIRES_SYSTEM_INITIATION";
              case Status.ProxyAccountIdFieldIsDeprecated:
                  return "PROXY_ACCOUNT_ID_FIELD_IS_DEPRECATED";
              case Status.SelfStakingIsNotAllowed:
                  return "SELF_STAKING_IS_NOT_ALLOWED";
              case Status.InvalidStakingId:
                  return "INVALID_STAKING_ID";
              case Status.StakingNotEnabled:
                  return "STAKING_NOT_ENABLED";
              case Status.InvalidPrngRange:
                  return "INVALID_PRNG_RANGE";
              case Status.MaxEntitiesInPriceRegimeHaveBeenCreated:
                  return "MAX_ENTITIES_IN_PRICE_REGIME_HAVE_BEEN_CREATED";
              case Status.InvalidFullPrefixSignatureForPrecompile:
                  return "INVALID_FULL_PREFIX_SIGNATURE_FOR_PRECOMPILE";
              case Status.InsufficientBalancesForStorageRent:
                  return "INSUFFICIENT_BALANCES_FOR_STORAGE_RENT";
              case Status.MaxChildRecordsExceeded:
                  return "MAX_CHILD_RECORDS_EXCEEDED";
              case Status.InsufficientBalancesForRenewalFees:
                  return "INSUFFICIENT_BALANCES_FOR_RENEWAL_FEES";
              case Status.TransactionHasUnknownFields:
                  return "TRANSACTION_HAS_UNKNOWN_FIELDS";
              case Status.AccountIsImmutable:
                  return "ACCOUNT_IS_IMMUTABLE";
              case Status.AliasAlreadyAssigned:
                  return "ALIAS_ALREADY_ASSIGNED";
              case Status.InvalidMetadataKey:
                  return "INVALID_METADATA_KEY";
              case Status.TokenHasNoMetadataKey:
                  return "TOKEN_HAS_NO_METADATA_KEY";
              case Status.MissingTokenMetadata:
                  return "MISSING_TOKEN_METADATA";
              case Status.MissingSerialNumbers:
                  return "MISSING_SERIAL_NUMBERS";
              case Status.TokenHasNoAdminKey:
                  return "TOKEN_HAS_NO_ADMIN_KEY";
              case Status.NodeDeleted:
                  return "NODE_DELETED";
              case Status.InvalidNodeId:
                  return "INVALID_NODE_ID";
              case Status.InvalidGossipEndpoint:
                  return "INVALID_GOSSIP_ENDPOINT";
              case Status.InvalidNodeAccountId:
                  return "INVALID_NODE_ACCOUNT_ID";
              case Status.InvalidNodeDescription:
                  return "INVALID_NODE_DESCRIPTION";
              case Status.InvalidServiceEndpoint:
                  return "INVALID_SERVICE_ENDPOINT";
              case Status.InvalidGossipCaCertificate:
                  return "INVALID_GOSSIP_CA_CERTIFICATE";
              case Status.InvalidGrpcCertificate:
                  return "INVALID_GRPC_CERTIFICATE";
              case Status.InvalidMaxAutoAssociations:
                  return "INVALID_MAX_AUTO_ASSOCIATIONS";
              case Status.MaxNodesCreated:
                  return "MAX_NODES_CREATED";
              case Status.IpFqdnCannotBeSetForSameEndpoint:
                  return "IP_FQDN_CANNOT_BE_SET_FOR_SAME_ENDPOINT";
              case Status.GossipEndpointCannotHaveFqdn:
                  return "GOSSIP_ENDPOINT_CANNOT_HAVE_FQDN";
              case Status.FqdnSizeTooLarge:
                  return "FQDN_SIZE_TOO_LARGE";
              case Status.InvalidEndpoint:
                  return "INVALID_ENDPOINT";
              case Status.GossipEndpointsExceededLimit:
                  return "GOSSIP_ENDPOINTS_EXCEEDED_LIMIT";
              case Status.ServiceEndpointsExceededLimit:
                  return "SERVICE_ENDPOINTS_EXCEEDED_LIMIT";
              case Status.InvalidIpv4Address:
                  return "INVALID_IPV4_ADDRESS";
              case Status.TokenReferenceRepeated:
                  return "TOKEN_REFERENCE_REPEATED";
              case Status.InvalidOwnerId:
                  return "INVALID_OWNER_ID";
              case Status.TokenReferenceListSizeLimitExceeded:
                  return "TOKEN_REFERENCE_LIST_SIZE_LIMIT_EXCEEDED";
              case Status.EmptyTokenReferenceList:
                  return "EMPTY_TOKEN_REFERENCE_LIST";
              case Status.UpdateNodeAccountNotAllowed:
                  return "UPDATE_NODE_ACCOUNT_NOT_ALLOWED";
              case Status.TokenHasNoMetadataOrSupplyKey:
                  return "TOKEN_HAS_NO_METADATA_OR_SUPPLY_KEY";
              case Status.EmptyPendingAirdropIdList:
                  return "EMPTY_PENDING_AIRDROP_ID_LIST";
              case Status.PendingAirdropIdRepeated:
                  return "PENDING_AIRDROP_ID_REPEATED";
              case Status.MaxPendingAirdropIdExceeded:
                  return "PENDING_AIRDROP_ID_LIST_TOO_LONG";
              case Status.PendingNftAirdropAlreadyExists:
                  return "PENDING_NFT_AIRDROP_ALREADY_EXISTS";
              case Status.AccountHasPendingAirdrops:
                  return "ACCOUNT_HAS_PENDING_AIRDROPS";
              case Status.ThrottledAtConsensus:
                  return "THROTTLED_AT_CONSENSUS";
              case Status.InvalidPendingAirdropId:
                  return "INVALID_PENDING_AIRDROP_ID";
              case Status.TokenAirdropWithFallbackRoyalty:
                  return "TOKEN_AIRDROP_WITH_FALLBACK_ROYALTY";
              case Status.InvalidTokenInPendingAirdrop:
                  return "INVALID_TOKEN_IN_PENDING_AIRDROP";
              case Status.ScheduleExpiryIsBusy:
                  return "SCHEDULE_EXPIRY_IS_BUSY";
              case Status.InvalidGrpcCertificateHash:
                  return "INVALID_GRPC_CERTIFICATE_HASH";
              case Status.MissingExpiryTime:
                  return "MISSING_EXPIRY_TIME";
              case Status.NoSchedulingAllowedAfterScheduledRecursion:
                  return "NO_SCHEDULING_ALLOWED_AFTER_SCHEDULED_RECURSION";
              case Status.RecursiveSchedulingLimitReached:
                  return "RECURSIVE_SCHEDULING_LIMIT_REACHED";
              case Status.WaitingForLedgerId:
                  return "WAITING_FOR_LEDGER_ID";
              case Status.MaxEntriesForFeeExemptKeyListExceeded:
                  return "MAX_ENTRIES_FOR_FEE_EXEMPT_KEY_LIST_EXCEEDED";
              case Status.FeeExemptKeyListContainsDuplicatedKeys:
                  return "FEE_EXEMPT_KEY_LIST_CONTAINS_DUPLICATED_KEYS";
              case Status.InvalidKeyInFeeExemptKeyList:
                  return "INVALID_KEY_IN_FEE_EXEMPT_KEY_LIST";
              case Status.InvalidFeeScheduleKey:
                  return "INVALID_FEE_SCHEDULE_KEY";
              case Status.FeeScheduleKeyCannotBeUpdated:
                  return "FEE_SCHEDULE_KEY_CANNOT_BE_UPDATED";
              case Status.FeeScheduleKeyNotSet:
                  return "FEE_SCHEDULE_KEY_NOT_SET";
              case Status.MaxCustomFeeLimitExceeded:
                  return "MAX_CUSTOM_FEE_LIMIT_EXCEEDED";
              case Status.NoValidMaxCustomFee:
                  return "NO_VALID_MAX_CUSTOM_FEE";
              case Status.InvalidMaxCustomFees:
                  return "INVALID_MAX_CUSTOM_FEES";
              case Status.DuplicateDenominationInMaxCustomFeeList:
                  return "DUPLICATE_DENOMINATION_IN_MAX_CUSTOM_FEE_LIST";
              case Status.DuplicateAccountIdInMaxCustomFeeList:
                  return "DUPLICATE_ACCOUNT_ID_IN_MAX_CUSTOM_FEE_LIST";
              case Status.MaxCustomFeesIsNotSupported:
                  return "MAX_CUSTOM_FEES_IS_NOT_SUPPORTED";
              case Status.BatchListEmpty:
                  return "BATCH_LIST_EMPTY";
              case Status.BatchListContainsDuplicates:
                  return "BATCH_LIST_CONTAINS_DUPLICATES";
              case Status.BatchTransactionInBlacklist:
                  return "BATCH_TRANSACTION_IN_BLACKLIST";
              case Status.InnerTransactionFailed:
                  return "INNER_TRANSACTION_FAILED";
              case Status.MissingBatchKey:
                  return "MISSING_BATCH_KEY";
              case Status.BatchKeySetOnNonInnerTransaction:
                  return "BATCH_KEY_SET_ON_NON_INNER_TRANSACTION";
              case Status.InvalidBatchKey:
                  return "INVALID_BATCH_KEY";
              case Status.ScheduleExpiryNotConfigurable:
                  return "SCHEDULE_EXPIRY_NOT_CONFIGURABLE";
              case Status.CreatingSystemEntities:
                  return "CREATING_SYSTEM_ENTITIES";

              case Status.ThrottleGroupLcmOverflow:
                  return "THROTTLE_GROUP_LCM_OVERFLOW";
              case Status.AirdropContainsMultipleSendersForAToken:
                  return "AIRDROP_CONTAINS_MULTIPLE_SENDERS_FOR_A_TOKEN";
              case Status.GrpcWebProxyNotSupported:
                  return "GRPC_WEB_PROXY_NOT_SUPPORTED";
              case Status.NftTransfersOnlyAllowedForNonFungibleUnique:
                  return "NFT_TRANSFERS_ONLY_ALLOWED_FOR_NON_FUNGIBLE_UNIQUE";
              default:
                  return `UNKNOWN (${this._code})`;
          }
      }

      /**
       * @internal
       * @param {number} code
       * @returns {Status}
       */
      static _fromCode(code) {
          switch (code) {
              case 0:
                  return Status.Ok;
              case 1:
                  return Status.InvalidTransaction;
              case 2:
                  return Status.PayerAccountNotFound;
              case 3:
                  return Status.InvalidNodeAccount;
              case 4:
                  return Status.TransactionExpired;
              case 5:
                  return Status.InvalidTransactionStart;
              case 6:
                  return Status.InvalidTransactionDuration;
              case 7:
                  return Status.InvalidSignature;
              case 8:
                  return Status.MemoTooLong;
              case 9:
                  return Status.InsufficientTxFee;
              case 10:
                  return Status.InsufficientPayerBalance;
              case 11:
                  return Status.DuplicateTransaction;
              case 12:
                  return Status.Busy;
              case 13:
                  return Status.NotSupported;
              case 14:
                  return Status.InvalidFileId;
              case 15:
                  return Status.InvalidAccountId;
              case 16:
                  return Status.InvalidContractId;
              case 17:
                  return Status.InvalidTransactionId;
              case 18:
                  return Status.ReceiptNotFound;
              case 19:
                  return Status.RecordNotFound;
              case 20:
                  return Status.InvalidSolidityId;
              case 21:
                  return Status.Unknown;
              case 22:
                  return Status.Success;
              case 23:
                  return Status.FailInvalid;
              case 24:
                  return Status.FailFee;
              case 25:
                  return Status.FailBalance;
              case 26:
                  return Status.KeyRequired;
              case 27:
                  return Status.BadEncoding;
              case 28:
                  return Status.InsufficientAccountBalance;
              case 29:
                  return Status.InvalidSolidityAddress;
              case 30:
                  return Status.InsufficientGas;
              case 31:
                  return Status.ContractSizeLimitExceeded;
              case 32:
                  return Status.LocalCallModificationException;
              case 33:
                  return Status.ContractRevertExecuted;
              case 34:
                  return Status.ContractExecutionException;
              case 35:
                  return Status.InvalidReceivingNodeAccount;
              case 36:
                  return Status.MissingQueryHeader;
              case 37:
                  return Status.AccountUpdateFailed;
              case 38:
                  return Status.InvalidKeyEncoding;
              case 39:
                  return Status.NullSolidityAddress;
              case 40:
                  return Status.ContractUpdateFailed;
              case 41:
                  return Status.InvalidQueryHeader;
              case 42:
                  return Status.InvalidFeeSubmitted;
              case 43:
                  return Status.InvalidPayerSignature;
              case 44:
                  return Status.KeyNotProvided;
              case 45:
                  return Status.InvalidExpirationTime;
              case 46:
                  return Status.NoWaclKey;
              case 47:
                  return Status.FileContentEmpty;
              case 48:
                  return Status.InvalidAccountAmounts;
              case 49:
                  return Status.EmptyTransactionBody;
              case 50:
                  return Status.InvalidTransactionBody;
              case 51:
                  return Status.InvalidSignatureTypeMismatchingKey;
              case 52:
                  return Status.InvalidSignatureCountMismatchingKey;
              case 53:
                  return Status.EmptyLiveHashBody;
              case 54:
                  return Status.EmptyLiveHash;
              case 55:
                  return Status.EmptyLiveHashKeys;
              case 56:
                  return Status.InvalidLiveHashSize;
              case 57:
                  return Status.EmptyQueryBody;
              case 58:
                  return Status.EmptyLiveHashQuery;
              case 59:
                  return Status.LiveHashNotFound;
              case 60:
                  return Status.AccountIdDoesNotExist;
              case 61:
                  return Status.LiveHashAlreadyExists;
              case 62:
                  return Status.InvalidFileWacl;
              case 63:
                  return Status.SerializationFailed;
              case 64:
                  return Status.TransactionOversize;
              case 65:
                  return Status.TransactionTooManyLayers;
              case 66:
                  return Status.ContractDeleted;
              case 67:
                  return Status.PlatformNotActive;
              case 68:
                  return Status.KeyPrefixMismatch;
              case 69:
                  return Status.PlatformTransactionNotCreated;
              case 70:
                  return Status.InvalidRenewalPeriod;
              case 71:
                  return Status.InvalidPayerAccountId;
              case 72:
                  return Status.AccountDeleted;
              case 73:
                  return Status.FileDeleted;
              case 74:
                  return Status.AccountRepeatedInAccountAmounts;
              case 75:
                  return Status.SettingNegativeAccountBalance;
              case 76:
                  return Status.ObtainerRequired;
              case 77:
                  return Status.ObtainerSameContractId;
              case 78:
                  return Status.ObtainerDoesNotExist;
              case 79:
                  return Status.ModifyingImmutableContract;
              case 80:
                  return Status.FileSystemException;
              case 81:
                  return Status.AutorenewDurationNotInRange;
              case 82:
                  return Status.ErrorDecodingBytestring;
              case 83:
                  return Status.ContractFileEmpty;
              case 84:
                  return Status.ContractBytecodeEmpty;
              case 85:
                  return Status.InvalidInitialBalance;
              case 86:
                  return Status.InvalidReceiveRecordThreshold;
              case 87:
                  return Status.InvalidSendRecordThreshold;
              case 88:
                  return Status.AccountIsNotGenesisAccount;
              case 89:
                  return Status.PayerAccountUnauthorized;
              case 90:
                  return Status.InvalidFreezeTransactionBody;
              case 91:
                  return Status.FreezeTransactionBodyNotFound;
              case 92:
                  return Status.TransferListSizeLimitExceeded;
              case 93:
                  return Status.ResultSizeLimitExceeded;
              case 94:
                  return Status.NotSpecialAccount;
              case 95:
                  return Status.ContractNegativeGas;
              case 96:
                  return Status.ContractNegativeValue;
              case 97:
                  return Status.InvalidFeeFile;
              case 98:
                  return Status.InvalidExchangeRateFile;
              case 99:
                  return Status.InsufficientLocalCallGas;
              case 100:
                  return Status.EntityNotAllowedToDelete;
              case 101:
                  return Status.AuthorizationFailed;
              case 102:
                  return Status.FileUploadedProtoInvalid;
              case 103:
                  return Status.FileUploadedProtoNotSavedToDisk;
              case 104:
                  return Status.FeeScheduleFilePartUploaded;
              case 105:
                  return Status.ExchangeRateChangeLimitExceeded;
              case 106:
                  return Status.MaxContractStorageExceeded;
              case 107:
                  return Status.TransferAccountSameAsDeleteAccount;
              case 108:
                  return Status.TotalLedgerBalanceInvalid;
              case 110:
                  return Status.ExpirationReductionNotAllowed;
              case 111:
                  return Status.MaxGasLimitExceeded;
              case 112:
                  return Status.MaxFileSizeExceeded;
              case 113:
                  return Status.ReceiverSigRequired;
              case 150:
                  return Status.InvalidTopicId;
              case 155:
                  return Status.InvalidAdminKey;
              case 156:
                  return Status.InvalidSubmitKey;
              case 157:
                  return Status.Unauthorized;
              case 158:
                  return Status.InvalidTopicMessage;
              case 159:
                  return Status.InvalidAutorenewAccount;
              case 160:
                  return Status.AutorenewAccountNotAllowed;
              case 162:
                  return Status.TopicExpired;
              case 163:
                  return Status.InvalidChunkNumber;
              case 164:
                  return Status.InvalidChunkTransactionId;
              case 165:
                  return Status.AccountFrozenForToken;
              case 166:
                  return Status.TokensPerAccountLimitExceeded;
              case 167:
                  return Status.InvalidTokenId;
              case 168:
                  return Status.InvalidTokenDecimals;
              case 169:
                  return Status.InvalidTokenInitialSupply;
              case 170:
                  return Status.InvalidTreasuryAccountForToken;
              case 171:
                  return Status.InvalidTokenSymbol;
              case 172:
                  return Status.TokenHasNoFreezeKey;
              case 173:
                  return Status.TransfersNotZeroSumForToken;
              case 174:
                  return Status.MissingTokenSymbol;
              case 175:
                  return Status.TokenSymbolTooLong;
              case 176:
                  return Status.AccountKycNotGrantedForToken;
              case 177:
                  return Status.TokenHasNoKycKey;
              case 178:
                  return Status.InsufficientTokenBalance;
              case 179:
                  return Status.TokenWasDeleted;
              case 180:
                  return Status.TokenHasNoSupplyKey;
              case 181:
                  return Status.TokenHasNoWipeKey;
              case 182:
                  return Status.InvalidTokenMintAmount;
              case 183:
                  return Status.InvalidTokenBurnAmount;
              case 184:
                  return Status.TokenNotAssociatedToAccount;
              case 185:
                  return Status.CannotWipeTokenTreasuryAccount;
              case 186:
                  return Status.InvalidKycKey;
              case 187:
                  return Status.InvalidWipeKey;
              case 188:
                  return Status.InvalidFreezeKey;
              case 189:
                  return Status.InvalidSupplyKey;
              case 190:
                  return Status.MissingTokenName;
              case 191:
                  return Status.TokenNameTooLong;
              case 192:
                  return Status.InvalidWipingAmount;
              case 193:
                  return Status.TokenIsImmutable;
              case 194:
                  return Status.TokenAlreadyAssociatedToAccount;
              case 195:
                  return Status.TransactionRequiresZeroTokenBalances;
              case 196:
                  return Status.AccountIsTreasury;
              case 197:
                  return Status.TokenIdRepeatedInTokenList;
              case 198:
                  return Status.TokenTransferListSizeLimitExceeded;
              case 199:
                  return Status.EmptyTokenTransferBody;
              case 200:
                  return Status.EmptyTokenTransferAccountAmounts;
              case 201:
                  return Status.InvalidScheduleId;
              case 202:
                  return Status.ScheduleIsImmutable;
              case 203:
                  return Status.InvalidSchedulePayerId;
              case 204:
                  return Status.InvalidScheduleAccountId;
              case 205:
                  return Status.NoNewValidSignatures;
              case 206:
                  return Status.UnresolvableRequiredSigners;
              case 207:
                  return Status.ScheduledTransactionNotInWhitelist;
              case 208:
                  return Status.SomeSignaturesWereInvalid;
              case 209:
                  return Status.TransactionIdFieldNotAllowed;
              case 210:
                  return Status.IdenticalScheduleAlreadyCreated;
              case 211:
                  return Status.InvalidZeroByteInString;
              case 212:
                  return Status.ScheduleAlreadyDeleted;
              case 213:
                  return Status.ScheduleAlreadyExecuted;
              case 214:
                  return Status.MessageSizeTooLarge;
              case 215:
                  return Status.OperationRepeatedInBucketGroups;
              case 216:
                  return Status.BucketCapacityOverflow;
              case 217:
                  return Status.NodeCapacityNotSufficientForOperation;
              case 218:
                  return Status.BucketHasNoThrottleGroups;
              case 219:
                  return Status.ThrottleGroupHasZeroOpsPerSec;
              case 220:
                  return Status.SuccessButMissingExpectedOperation;
              case 221:
                  return Status.UnparseableThrottleDefinitions;
              case 222:
                  return Status.InvalidThrottleDefinitions;
              case 223:
                  return Status.AccountExpiredAndPendingRemoval;
              case 224:
                  return Status.InvalidTokenMaxSupply;
              case 225:
                  return Status.InvalidTokenNftSerialNumber;
              case 226:
                  return Status.InvalidNftId;
              case 227:
                  return Status.MetadataTooLong;
              case 228:
                  return Status.BatchSizeLimitExceeded;
              case 229:
                  return Status.InvalidQueryRange;
              case 230:
                  return Status.FractionDividesByZero;
              case 231:
                  return Status.InsufficientPayerBalanceForCustomFee;
              case 232:
                  return Status.CustomFeesListTooLong;
              case 233:
                  return Status.InvalidCustomFeeCollector;
              case 234:
                  return Status.InvalidTokenIdInCustomFees;
              case 235:
                  return Status.TokenNotAssociatedToFeeCollector;
              case 236:
                  return Status.TokenMaxSupplyReached;
              case 237:
                  return Status.SenderDoesNotOwnNftSerialNo;
              case 238:
                  return Status.CustomFeeNotFullySpecified;
              case 239:
                  return Status.CustomFeeMustBePositive;
              case 240:
                  return Status.TokenHasNoFeeScheduleKey;
              case 241:
                  return Status.CustomFeeOutsideNumericRange;
              case 242:
                  return Status.RoyaltyFractionCannotExceedOne;
              case 243:
                  return Status.FractionalFeeMaxAmountLessThanMinAmount;
              case 244:
                  return Status.CustomScheduleAlreadyHasNoFees;
              case 245:
                  return Status.CustomFeeDenominationMustBeFungibleCommon;
              case 246:
                  return Status.CustomFractionalFeeOnlyAllowedForFungibleCommon;
              case 247:
                  return Status.InvalidCustomFeeScheduleKey;
              case 248:
                  return Status.InvalidTokenMintMetadata;
              case 249:
                  return Status.InvalidTokenBurnMetadata;
              case 250:
                  return Status.CurrentTreasuryStillOwnsNfts;
              case 251:
                  return Status.AccountStillOwnsNfts;
              case 252:
                  return Status.TreasuryMustOwnBurnedNft;
              case 253:
                  return Status.AccountDoesNotOwnWipedNft;
              case 254:
                  return Status.AccountAmountTransfersOnlyAllowedForFungibleCommon;
              case 255:
                  return Status.MaxNftsInPriceRegimeHaveBeenMinted;
              case 256:
                  return Status.PayerAccountDeleted;
              case 257:
                  return Status.CustomFeeChargingExceededMaxRecursionDepth;
              case 258:
                  return Status.CustomFeeChargingExceededMaxAccountAmounts;
              case 259:
                  return Status.InsufficientSenderAccountBalanceForCustomFee;
              case 260:
                  return Status.SerialNumberLimitReached;
              case 261:
                  return Status.CustomRoyaltyFeeOnlyAllowedForNonFungibleUnique;
              case 262:
                  return Status.NoRemainingAutomaticAssociations;
              case 263:
                  return Status.ExistingAutomaticAssociationsExceedGivenLimit;
              case 264:
                  return Status.RequestedNumAutomaticAssociationsExceedsAssociationLimit;
              case 265:
                  return Status.TokenIsPaused;
              case 266:
                  return Status.TokenHasNoPauseKey;
              case 267:
                  return Status.InvalidPauseKey;
              case 268:
                  return Status.FreezeUpdateFileDoesNotExist;
              case 269:
                  return Status.FreezeUpdateFileHashDoesNotMatch;
              case 270:
                  return Status.NoUpgradeHasBeenPrepared;
              case 271:
                  return Status.NoFreezeIsScheduled;
              case 272:
                  return Status.UpdateFileHashChangedSincePrepareUpgrade;
              case 273:
                  return Status.FreezeStartTimeMustBeFuture;
              case 274:
                  return Status.PreparedUpdateFileIsImmutable;
              case 275:
                  return Status.FreezeAlreadyScheduled;
              case 276:
                  return Status.FreezeUpgradeInProgress;
              case 277:
                  return Status.UpdateFileIdDoesNotMatchPrepared;
              case 278:
                  return Status.UpdateFileHashDoesNotMatchPrepared;
              case 279:
                  return Status.ConsensusGasExhausted;
              case 280:
                  return Status.RevertedSuccess;
              case 281:
                  return Status.MaxStorageInPriceRegimeHasBeenUsed;
              case 282:
                  return Status.InvalidAliasKey;
              case 283:
                  return Status.UnexpectedTokenDecimals;
              case 284:
                  return Status.InvalidProxyAccountId;
              case 285:
                  return Status.InvalidTransferAccountId;
              case 286:
                  return Status.InvalidFeeCollectorAccountId;
              case 287:
                  return Status.AliasIsImmutable;
              case 288:
                  return Status.SpenderAccountSameAsOwner;
              case 289:
                  return Status.AmountExceedsTokenMaxSupply;
              case 290:
                  return Status.NegativeAllowanceAmount;
              case 291:
                  return Status.CannotApproveForAllFungibleCommon;
              case 292:
                  return Status.SpenderDoesNotHaveAllowance;
              case 293:
                  return Status.AmountExceedsAllowance;
              case 294:
                  return Status.MaxAllowancesExceeded;
              case 295:
                  return Status.EmptyAllowances;
              case 296:
                  return Status.SpenderAccountRepeatedInAllowances;
              case 297:
                  return Status.RepeatedSerialNumsInNftAllowances;
              case 298:
                  return Status.FungibleTokenInNftAllowances;
              case 299:
                  return Status.NftInFungibleTokenAllowances;
              case 300:
                  return Status.InvalidAllowanceOwnerId;
              case 301:
                  return Status.InvalidAllowanceSpenderId;
              case 302:
                  return Status.RepeatedAllowancesToDelete;
              case 303:
                  return Status.InvalidDelegatingSpender;
              case 304:
                  return Status.DelegatingSpenderCannotGrantApproveForAll;
              case 305:
                  return Status.DelegatingSpenderDoesNotHaveApproveForAll;
              case 306:
                  return Status.ScheduleExpirationTimeTooFarInFuture;
              case 307:
                  return Status.ScheduleExpirationTimeMustBeHigherThanConsensusTime;
              case 308:
                  return Status.ScheduleFutureThrottleExceeded;
              case 309:
                  return Status.ScheduleFutureGasLimitExceeded;
              case 310:
                  return Status.InvalidEthereumTransaction;
              case 311:
                  return Status.WrongChainId;
              case 312:
                  return Status.WrongNonce;
              case 313:
                  return Status.AccessListUnsupported;
              case 314:
                  return Status.SchedulePendingExpiration;
              case 315:
                  return Status.ContractIsTokenTreasury;
              case 316:
                  return Status.ContractHasNonZeroTokenBalances;
              case 317:
                  return Status.ContractExpiredAndPendingRemoval;
              case 318:
                  return Status.ContractHasNoAutoRenewAccount;
              case 319:
                  return Status.PermanentRemovalRequiresSystemInitiation;
              case 320:
                  return Status.ProxyAccountIdFieldIsDeprecated;
              case 321:
                  return Status.SelfStakingIsNotAllowed;
              case 322:
                  return Status.InvalidStakingId;
              case 323:
                  return Status.StakingNotEnabled;
              case 324:
                  return Status.InvalidPrngRange;
              case 325:
                  return Status.MaxEntitiesInPriceRegimeHaveBeenCreated;
              case 326:
                  return Status.InvalidFullPrefixSignatureForPrecompile;
              case 327:
                  return Status.InsufficientBalancesForStorageRent;
              case 328:
                  return Status.MaxChildRecordsExceeded;
              case 329:
                  return Status.InsufficientBalancesForRenewalFees;
              case 330:
                  return Status.TransactionHasUnknownFields;
              case 331:
                  return Status.AccountIsImmutable;
              case 332:
                  return Status.AliasAlreadyAssigned;
              case 333:
                  return Status.InvalidMetadataKey;
              case 334:
                  return Status.TokenHasNoMetadataKey;
              case 335:
                  return Status.MissingTokenMetadata;
              case 336:
                  return Status.MissingSerialNumbers;
              case 337:
                  return Status.TokenHasNoAdminKey;
              case 338:
                  return Status.NodeDeleted;
              case 339:
                  return Status.InvalidNodeId;
              case 340:
                  return Status.InvalidGossipEndpoint;
              case 341:
                  return Status.InvalidNodeAccountId;
              case 342:
                  return Status.InvalidNodeDescription;
              case 343:
                  return Status.InvalidServiceEndpoint;
              case 344:
                  return Status.InvalidGossipCaCertificate;
              case 345:
                  return Status.InvalidGrpcCertificate;
              case 346:
                  return Status.InvalidMaxAutoAssociations;
              case 347:
                  return Status.MaxNodesCreated;
              case 348:
                  return Status.IpFqdnCannotBeSetForSameEndpoint;
              case 349:
                  return Status.GossipEndpointCannotHaveFqdn;
              case 350:
                  return Status.FqdnSizeTooLarge;
              case 351:
                  return Status.InvalidEndpoint;
              case 352:
                  return Status.GossipEndpointsExceededLimit;
              case 353:
                  return Status.TokenReferenceRepeated;
              case 354:
                  return Status.InvalidOwnerId;
              case 355:
                  return Status.TokenReferenceListSizeLimitExceeded;
              case 356:
                  return Status.ServiceEndpointsExceededLimit;
              case 357:
                  return Status.InvalidIpv4Address;
              case 358:
                  return Status.EmptyTokenReferenceList;
              case 359:
                  return Status.UpdateNodeAccountNotAllowed;
              case 360:
                  return Status.TokenHasNoMetadataOrSupplyKey;
              case 361:
                  return Status.EmptyPendingAirdropIdList;
              case 362:
                  return Status.PendingAirdropIdRepeated;
              case 363:
                  return Status.MaxPendingAirdropIdExceeded;
              case 364:
                  return Status.PendingNftAirdropAlreadyExists;
              case 365:
                  return Status.AccountHasPendingAirdrops;
              case 366:
                  return Status.ThrottledAtConsensus;
              case 367:
                  return Status.InvalidPendingAirdropId;
              case 368:
                  return Status.TokenAirdropWithFallbackRoyalty;
              case 369:
                  return Status.InvalidTokenInPendingAirdrop;
              case 370:
                  return Status.ScheduleExpiryIsBusy;
              case 371:
                  return Status.InvalidGrpcCertificateHash;
              case 372:
                  return Status.MissingExpiryTime;
              case 373:
                  return Status.NoSchedulingAllowedAfterScheduledRecursion;
              case 374:
                  return Status.RecursiveSchedulingLimitReached;
              case 375:
                  return Status.WaitingForLedgerId;
              case 376:
                  return Status.MaxEntriesForFeeExemptKeyListExceeded;
              case 377:
                  return Status.FeeExemptKeyListContainsDuplicatedKeys;
              case 378:
                  return Status.InvalidKeyInFeeExemptKeyList;
              case 379:
                  return Status.InvalidFeeScheduleKey;
              case 380:
                  return Status.FeeScheduleKeyCannotBeUpdated;
              case 381:
                  return Status.FeeScheduleKeyNotSet;
              case 382:
                  return Status.MaxCustomFeeLimitExceeded;
              case 383:
                  return Status.NoValidMaxCustomFee;
              case 384:
                  return Status.InvalidMaxCustomFees;
              case 385:
                  return Status.DuplicateDenominationInMaxCustomFeeList;
              case 386:
                  return Status.DuplicateAccountIdInMaxCustomFeeList;
              case 387:
                  return Status.MaxCustomFeesIsNotSupported;
              case 388:
                  return Status.BatchListEmpty;
              case 389:
                  return Status.BatchListContainsDuplicates;
              case 390:
                  return Status.BatchTransactionInBlacklist;
              case 391:
                  return Status.InnerTransactionFailed;
              case 392:
                  return Status.MissingBatchKey;
              case 393:
                  return Status.BatchKeySetOnNonInnerTransaction;
              case 394:
                  return Status.InvalidBatchKey;
              case 395:
                  return Status.ScheduleExpiryNotConfigurable;
              case 396:
                  return Status.CreatingSystemEntities;
              case 397:
                  return Status.ThrottleGroupLcmOverflow;
              case 398:
                  return Status.AirdropContainsMultipleSendersForAToken;
              case 399:
                  return Status.GrpcWebProxyNotSupported;
              case 400:
                  return Status.NftTransfersOnlyAllowedForNonFungibleUnique;
              default:
                  throw new Error(
                      `(BUG) Status.fromCode() does not handle code: ${code}`,
                  );
          }
      }

      /**
       * @returns {HieroProto.proto.ResponseCodeEnum}
       */
      valueOf() {
          return this._code;
      }
  }

  /**
   * The transaction passed the precheck validations.
   */
  Status.Ok = new Status(0);

  /**
   * For any error not handled by specific error codes listed below.
   */
  Status.InvalidTransaction = new Status(1);

  /**
   * Payer account does not exist.
   */
  Status.PayerAccountNotFound = new Status(2);

  /**
   * Node Account provided does not match the node account of the node the transaction was submitted
   * to.
   */
  Status.InvalidNodeAccount = new Status(3);

  /**
   * Pre-Check error when TransactionValidStart + transactionValidDuration is less than current
   * consensus time.
   */
  Status.TransactionExpired = new Status(4);

  /**
   * Transaction start time is greater than current consensus time
   */
  Status.InvalidTransactionStart = new Status(5);

  /**
   * The given transactionValidDuration was either non-positive, or greater than the maximum
   * valid duration of 180 secs.
   *
   */
  Status.InvalidTransactionDuration = new Status(6);

  /**
   * The transaction signature is not valid
   */
  Status.InvalidSignature = new Status(7);

  /**
   * Transaction memo size exceeded 100 bytes
   */
  Status.MemoTooLong = new Status(8);

  /**
   * The fee provided in the transaction is insufficient for this type of transaction
   */
  Status.InsufficientTxFee = new Status(9);

  /**
   * The payer account has insufficient cryptocurrency to pay the transaction fee
   */
  Status.InsufficientPayerBalance = new Status(10);

  /**
   * This transaction ID is a duplicate of one that was submitted to this node or reached consensus
   * in the last 180 seconds (receipt period)
   */
  Status.DuplicateTransaction = new Status(11);

  /**
   * If API is throttled out
   */
  Status.Busy = new Status(12);

  /**
   * The API is not currently supported
   */
  Status.NotSupported = new Status(13);

  /**
   * The file id is invalid or does not exist
   */
  Status.InvalidFileId = new Status(14);

  /**
   * The account id is invalid or does not exist
   */
  Status.InvalidAccountId = new Status(15);

  /**
   * The contract id is invalid or does not exist
   */
  Status.InvalidContractId = new Status(16);

  /**
   * Transaction id is not valid
   */
  Status.InvalidTransactionId = new Status(17);

  /**
   * Receipt for given transaction id does not exist
   */
  Status.ReceiptNotFound = new Status(18);

  /**
   * Record for given transaction id does not exist
   */
  Status.RecordNotFound = new Status(19);

  /**
   * The solidity id is invalid or entity with this solidity id does not exist
   */
  Status.InvalidSolidityId = new Status(20);

  /**
   * The responding node has submitted the transaction to the network. Its final status is still
   * unknown.
   */
  Status.Unknown = new Status(21);

  /**
   * The transaction succeeded
   */
  Status.Success = new Status(22);

  /**
   * There was a system error and the transaction failed because of invalid request parameters.
   */
  Status.FailInvalid = new Status(23);

  /**
   * There was a system error while performing fee calculation, reserved for future.
   */
  Status.FailFee = new Status(24);

  /**
   * There was a system error while performing balance checks, reserved for future.
   */
  Status.FailBalance = new Status(25);

  /**
   * Key not provided in the transaction body
   */
  Status.KeyRequired = new Status(26);

  /**
   * Unsupported algorithm/encoding used for keys in the transaction
   */
  Status.BadEncoding = new Status(27);

  /**
   * When the account balance is not sufficient for the transfer
   */
  Status.InsufficientAccountBalance = new Status(28);

  /**
   * During an update transaction when the system is not able to find the Users Solidity address
   */
  Status.InvalidSolidityAddress = new Status(29);

  /**
   * Not enough gas was supplied to execute transaction
   */
  Status.InsufficientGas = new Status(30);

  /**
   * contract byte code size is over the limit
   */
  Status.ContractSizeLimitExceeded = new Status(31);

  /**
   * local execution (query) is requested for a function which changes state
   */
  Status.LocalCallModificationException = new Status(32);

  /**
   * Contract REVERT OPCODE executed
   */
  Status.ContractRevertExecuted = new Status(33);

  /**
   * For any contract execution related error not handled by specific error codes listed above.
   */
  Status.ContractExecutionException = new Status(34);

  /**
   * In Query validation, account with +ve(amount) value should be Receiving node account, the
   * receiver account should be only one account in the list
   */
  Status.InvalidReceivingNodeAccount = new Status(35);

  /**
   * Header is missing in Query request
   */
  Status.MissingQueryHeader = new Status(36);

  /**
   * The update of the account failed
   */
  Status.AccountUpdateFailed = new Status(37);

  /**
   * Provided key encoding was not supported by the system
   */
  Status.InvalidKeyEncoding = new Status(38);

  /**
   * null solidity address
   */
  Status.NullSolidityAddress = new Status(39);

  /**
   * update of the contract failed
   */
  Status.ContractUpdateFailed = new Status(40);

  /**
   * the query header is invalid
   */
  Status.InvalidQueryHeader = new Status(41);

  /**
   * Invalid fee submitted
   */
  Status.InvalidFeeSubmitted = new Status(42);

  /**
   * Payer signature is invalid
   */
  Status.InvalidPayerSignature = new Status(43);

  /**
   * The keys were not provided in the request.
   */
  Status.KeyNotProvided = new Status(44);

  /**
   * Expiration time provided in the transaction was invalid.
   */
  Status.InvalidExpirationTime = new Status(45);

  /**
   * WriteAccess Control Keys are not provided for the file
   */
  Status.NoWaclKey = new Status(46);

  /**
   * The contents of file are provided as empty.
   */
  Status.FileContentEmpty = new Status(47);

  /**
   * The crypto transfer credit and debit do not sum equal to 0
   */
  Status.InvalidAccountAmounts = new Status(48);

  /**
   * Transaction body provided is empty
   */
  Status.EmptyTransactionBody = new Status(49);

  /**
   * Invalid transaction body provided
   */
  Status.InvalidTransactionBody = new Status(50);

  /**
   * the type of key (base ed25519 key, KeyList, or ThresholdKey) does not match the type of
   * signature (base ed25519 signature, SignatureList, or ThresholdKeySignature)
   */
  Status.InvalidSignatureTypeMismatchingKey = new Status(51);

  /**
   * the number of key (KeyList, or ThresholdKey) does not match that of signature (SignatureList,
   * or ThresholdKeySignature). e.g. if a keyList has 3 base keys, then the corresponding
   * signatureList should also have 3 base signatures.
   */
  Status.InvalidSignatureCountMismatchingKey = new Status(52);

  /**
   * the livehash body is empty
   */
  Status.EmptyLiveHashBody = new Status(53);

  /**
   * the livehash data is missing
   */
  Status.EmptyLiveHash = new Status(54);

  /**
   * the keys for a livehash are missing
   */
  Status.EmptyLiveHashKeys = new Status(55);

  /**
   * the livehash data is not the output of a SHA-384 digest
   */
  Status.InvalidLiveHashSize = new Status(56);

  /**
   * the query body is empty
   */
  Status.EmptyQueryBody = new Status(57);

  /**
   * the crypto livehash query is empty
   */
  Status.EmptyLiveHashQuery = new Status(58);

  /**
   * the livehash is not present
   */
  Status.LiveHashNotFound = new Status(59);

  /**
   * the account id passed has not yet been created.
   */
  Status.AccountIdDoesNotExist = new Status(60);

  /**
   * the livehash already exists for a given account
   */
  Status.LiveHashAlreadyExists = new Status(61);

  /**
   * File WACL keys are invalid
   */
  Status.InvalidFileWacl = new Status(62);

  /**
   * Serialization failure
   */
  Status.SerializationFailed = new Status(63);

  /**
   * The size of the Transaction is greater than transactionMaxBytes
   */
  Status.TransactionOversize = new Status(64);

  /**
   * The Transaction has more than 50 levels
   */
  Status.TransactionTooManyLayers = new Status(65);

  /**
   * Contract is marked as deleted
   */
  Status.ContractDeleted = new Status(66);

  /**
   * the platform node is either disconnected or lagging behind.
   */
  Status.PlatformNotActive = new Status(67);

  /**
   * one public key matches more than one prefixes on the signature map
   */
  Status.KeyPrefixMismatch = new Status(68);

  /**
   * transaction not created by platform due to large backlog
   */
  Status.PlatformTransactionNotCreated = new Status(69);

  /**
   * auto renewal period is not a positive number of seconds
   */
  Status.InvalidRenewalPeriod = new Status(70);

  /**
   * the response code when a smart contract id is passed for a crypto API request
   */
  Status.InvalidPayerAccountId = new Status(71);

  /**
   * the account has been marked as deleted
   */
  Status.AccountDeleted = new Status(72);

  /**
   * the file has been marked as deleted
   */
  Status.FileDeleted = new Status(73);

  /**
   * same accounts repeated in the transfer account list
   */
  Status.AccountRepeatedInAccountAmounts = new Status(74);

  /**
   * attempting to set negative balance value for crypto account
   */
  Status.SettingNegativeAccountBalance = new Status(75);

  /**
   * when deleting smart contract that has crypto balance either transfer account or transfer smart
   * contract is required
   */
  Status.ObtainerRequired = new Status(76);

  /**
   * when deleting smart contract that has crypto balance you can not use the same contract id as
   * transferContractId as the one being deleted
   */
  Status.ObtainerSameContractId = new Status(77);

  /**
   * transferAccountId or transferContractId specified for contract delete does not exist
   */
  Status.ObtainerDoesNotExist = new Status(78);

  /**
   * attempting to modify (update or delete a immutable smart contract, i.e. one created without a
   * admin key)
   */
  Status.ModifyingImmutableContract = new Status(79);

  /**
   * Unexpected exception thrown by file system functions
   */
  Status.FileSystemException = new Status(80);

  /**
   * the duration is not a subset of [MINIMUM_AUTORENEW_DURATION,MAXIMUM_AUTORENEW_DURATION]
   */
  Status.AutorenewDurationNotInRange = new Status(81);

  /**
   * Decoding the smart contract binary to a byte array failed. Check that the input is a valid hex
   * string.
   */
  Status.ErrorDecodingBytestring = new Status(82);

  /**
   * File to create a smart contract was of length zero
   */
  Status.ContractFileEmpty = new Status(83);

  /**
   * Bytecode for smart contract is of length zero
   */
  Status.ContractBytecodeEmpty = new Status(84);

  /**
   * Attempt to set negative initial balance
   */
  Status.InvalidInitialBalance = new Status(85);

  /**
   * [Deprecated]. attempt to set negative receive record threshold
   */
  Status.InvalidReceiveRecordThreshold = new Status(86);

  /**
   * [Deprecated]. attempt to set negative send record threshold
   */
  Status.InvalidSendRecordThreshold = new Status(87);

  /**
   * Special Account Operations should be performed by only Genesis account, return this code if it
   * is not Genesis Account
   */
  Status.AccountIsNotGenesisAccount = new Status(88);

  /**
   * The fee payer account doesn't have permission to submit such Transaction
   */
  Status.PayerAccountUnauthorized = new Status(89);

  /**
   * FreezeTransactionBody is invalid
   */
  Status.InvalidFreezeTransactionBody = new Status(90);

  /**
   * FreezeTransactionBody does not exist
   */
  Status.FreezeTransactionBodyNotFound = new Status(91);

  /**
   * Exceeded the number of accounts (both from and to) allowed for crypto transfer list
   */
  Status.TransferListSizeLimitExceeded = new Status(92);

  /**
   * Smart contract result size greater than specified maxResultSize
   */
  Status.ResultSizeLimitExceeded = new Status(93);

  /**
   * The payer account is not a special account(account 0.0.55)
   */
  Status.NotSpecialAccount = new Status(94);

  /**
   * Negative gas was offered in smart contract call
   */
  Status.ContractNegativeGas = new Status(95);

  /**
   * Negative value / initial balance was specified in a smart contract call / create
   */
  Status.ContractNegativeValue = new Status(96);

  /**
   * Failed to update fee file
   */
  Status.InvalidFeeFile = new Status(97);

  /**
   * Failed to update exchange rate file
   */
  Status.InvalidExchangeRateFile = new Status(98);

  /**
   * Payment tendered for contract local call cannot cover both the fee and the gas
   */
  Status.InsufficientLocalCallGas = new Status(99);

  /**
   * Entities with Entity ID below 1000 are not allowed to be deleted
   */
  Status.EntityNotAllowedToDelete = new Status(100);

  /**
   * Violating one of these rules: 1) treasury account can update all entities below 0.0.1000, 2)
   * account 0.0.50 can update all entities from 0.0.51 - 0.0.80, 3) Network Function Master Account
   * A/c 0.0.50 - Update all Network Function accounts & perform all the Network Functions listed
   * below, 4) Network Function Accounts: i) A/c 0.0.55 - Update Address Book files (0.0.101/102),
   * ii) A/c 0.0.56 - Update Fee schedule (0.0.111), iii) A/c 0.0.57 - Update Exchange Rate
   * (0.0.112).
   */
  Status.AuthorizationFailed = new Status(101);

  /**
   * Fee Schedule Proto uploaded but not valid (append or update is required)
   */
  Status.FileUploadedProtoInvalid = new Status(102);

  /**
   * Fee Schedule Proto uploaded but not valid (append or update is required)
   */
  Status.FileUploadedProtoNotSavedToDisk = new Status(103);

  /**
   * Fee Schedule Proto File Part uploaded
   */
  Status.FeeScheduleFilePartUploaded = new Status(104);

  /**
   * The change on Exchange Rate exceeds Exchange_Rate_Allowed_Percentage
   */
  Status.ExchangeRateChangeLimitExceeded = new Status(105);

  /**
   * Contract permanent storage exceeded the currently allowable limit
   */
  Status.MaxContractStorageExceeded = new Status(106);

  /**
   * Transfer Account should not be same as Account to be deleted
   */
  Status.TransferAccountSameAsDeleteAccount = new Status(107);

  Status.TotalLedgerBalanceInvalid = new Status(108);
  /**
   * The expiration date/time on a smart contract may not be reduced
   */
  Status.ExpirationReductionNotAllowed = new Status(110);

  /**
   * Gas exceeded currently allowable gas limit per transaction
   */
  Status.MaxGasLimitExceeded = new Status(111);

  /**
   * File size exceeded the currently allowable limit
   */
  Status.MaxFileSizeExceeded = new Status(112);

  /**
   * When a valid signature is not provided for operations on account with receiverSigRequired=true
   */
  Status.ReceiverSigRequired = new Status(113);

  /**
   * The Topic ID specified is not in the system.
   */
  Status.InvalidTopicId = new Status(150);

  /**
   * A provided admin key was invalid.
   */
  Status.InvalidAdminKey = new Status(155);

  /**
   * A provided submit key was invalid.
   */
  Status.InvalidSubmitKey = new Status(156);

  /**
   * An attempted operation was not authorized (ie - a deleteTopic for a topic with no adminKey).
   */
  Status.Unauthorized = new Status(157);

  /**
   * A ConsensusService message is empty.
   */
  Status.InvalidTopicMessage = new Status(158);

  /**
   * The autoRenewAccount specified is not a valid, active account.
   */
  Status.InvalidAutorenewAccount = new Status(159);

  /**
   * An adminKey was not specified on the topic, so there must not be an autoRenewAccount.
   */
  Status.AutorenewAccountNotAllowed = new Status(160);

  /**
   * The topic has expired, was not automatically renewed, and is in a 7 day grace period before the
   * topic will be deleted unrecoverably. This error response code will not be returned until
   * autoRenew functionality is supported by HAPI.
   */
  Status.TopicExpired = new Status(162);

  /**
   * chunk number must be from 1 to total (chunks) inclusive.
   */
  Status.InvalidChunkNumber = new Status(163);

  /**
   * For every chunk, the payer account that is part of initialTransactionID must match the Payer Account of this transaction. The entire initialTransactionID should match the transactionID of the first chunk, but this is not checked or enforced by Hedera except when the chunk number is 1.
   */
  Status.InvalidChunkTransactionId = new Status(164);

  /**
   * Account is frozen and cannot transact with the token
   */
  Status.AccountFrozenForToken = new Status(165);

  /**
   * An involved account already has more than <tt>tokens.maxPerAccount</tt> associations with non-deleted tokens.
   */
  Status.TokensPerAccountLimitExceeded = new Status(166);

  /**
   * The token is invalid or does not exist
   */
  Status.InvalidTokenId = new Status(167);

  /**
   * Invalid token decimals
   */
  Status.InvalidTokenDecimals = new Status(168);

  /**
   * Invalid token initial supply
   */
  Status.InvalidTokenInitialSupply = new Status(169);

  /**
   * Treasury Account does not exist or is deleted
   */
  Status.InvalidTreasuryAccountForToken = new Status(170);

  /**
   * Token Symbol is not UTF-8 capitalized alphabetical string
   */
  Status.InvalidTokenSymbol = new Status(171);

  /**
   * Freeze key is not set on token
   */
  Status.TokenHasNoFreezeKey = new Status(172);

  /**
   * Amounts in transfer list are not net zero
   */
  Status.TransfersNotZeroSumForToken = new Status(173);

  /**
   * A token symbol was not provided
   */
  Status.MissingTokenSymbol = new Status(174);

  /**
   * The provided token symbol was too long
   */
  Status.TokenSymbolTooLong = new Status(175);

  /**
   * KYC must be granted and account does not have KYC granted
   */
  Status.AccountKycNotGrantedForToken = new Status(176);

  /**
   * KYC key is not set on token
   */
  Status.TokenHasNoKycKey = new Status(177);

  /**
   * Token balance is not sufficient for the transaction
   */
  Status.InsufficientTokenBalance = new Status(178);

  /**
   * Token transactions cannot be executed on deleted token
   */
  Status.TokenWasDeleted = new Status(179);

  /**
   * Supply key is not set on token
   */
  Status.TokenHasNoSupplyKey = new Status(180);

  /**
   * Wipe key is not set on token
   */
  Status.TokenHasNoWipeKey = new Status(181);

  /**
   * The requested token mint amount would cause an invalid total supply
   */
  Status.InvalidTokenMintAmount = new Status(182);

  /**
   * The requested token burn amount would cause an invalid total supply
   */
  Status.InvalidTokenBurnAmount = new Status(183);

  /**
   * A required token-account relationship is missing
   */
  Status.TokenNotAssociatedToAccount = new Status(184);

  /**
   * The target of a wipe operation was the token treasury account
   */
  Status.CannotWipeTokenTreasuryAccount = new Status(185);

  /**
   * The provided KYC key was invalid.
   */
  Status.InvalidKycKey = new Status(186);

  /**
   * The provided wipe key was invalid.
   */
  Status.InvalidWipeKey = new Status(187);

  /**
   * The provided freeze key was invalid.
   */
  Status.InvalidFreezeKey = new Status(188);

  /**
   * The provided supply key was invalid.
   */
  Status.InvalidSupplyKey = new Status(189);

  /**
   * Token Name is not provided
   */
  Status.MissingTokenName = new Status(190);

  /**
   * Token Name is too long
   */
  Status.TokenNameTooLong = new Status(191);

  /**
   * The provided wipe amount must not be negative, zero or bigger than the token holder balance
   */
  Status.InvalidWipingAmount = new Status(192);

  /**
   * Token does not have Admin key set, thus update/delete transactions cannot be performed
   */
  Status.TokenIsImmutable = new Status(193);

  /**
   * An <tt>associateToken</tt> operation specified a token already associated to the account
   */
  Status.TokenAlreadyAssociatedToAccount = new Status(194);

  /**
   * An attempted operation is invalid until all token balances for the target account are zero
   */
  Status.TransactionRequiresZeroTokenBalances = new Status(195);

  /**
   * An attempted operation is invalid because the account is a treasury
   */
  Status.AccountIsTreasury = new Status(196);

  /**
   * Same TokenIDs present in the token list
   */
  Status.TokenIdRepeatedInTokenList = new Status(197);

  /**
   * Exceeded the number of token transfers (both from and to) allowed for token transfer list
   */
  Status.TokenTransferListSizeLimitExceeded = new Status(198);

  /**
   * TokenTransfersTransactionBody has no TokenTransferList
   */
  Status.EmptyTokenTransferBody = new Status(199);

  /**
   * TokenTransfersTransactionBody has a TokenTransferList with no AccountAmounts
   */
  Status.EmptyTokenTransferAccountAmounts = new Status(200);

  /**
   * The Scheduled entity does not exist; or has now expired, been deleted, or been executed
   */
  Status.InvalidScheduleId = new Status(201);

  /**
   * The Scheduled entity cannot be modified. Admin key not set
   */
  Status.ScheduleIsImmutable = new Status(202);

  /**
   * The provided Scheduled Payer does not exist
   */
  Status.InvalidSchedulePayerId = new Status(203);

  /**
   * The Schedule Create Transaction TransactionID account does not exist
   */
  Status.InvalidScheduleAccountId = new Status(204);

  /**
   * The provided sig map did not contain any new valid signatures from required signers of the scheduled transaction
   */
  Status.NoNewValidSignatures = new Status(205);

  /**
   * The required signers for a scheduled transaction cannot be resolved, for example because they do not exist or have been deleted
   */
  Status.UnresolvableRequiredSigners = new Status(206);

  /**
   * Only whitelisted transaction types may be scheduled
   */
  Status.ScheduledTransactionNotInWhitelist = new Status(207);

  /**
   * At least one of the signatures in the provided sig map did not represent a valid signature for any required signer
   */
  Status.SomeSignaturesWereInvalid = new Status(208);

  /**
   * The scheduled field in the TransactionID may not be set to true
   */
  Status.TransactionIdFieldNotAllowed = new Status(209);

  /**
   * A schedule already exists with the same identifying fields of an attempted ScheduleCreate (that is, all fields other than scheduledPayerAccountID)
   */
  Status.IdenticalScheduleAlreadyCreated = new Status(210);

  /**
   * A string field in the transaction has a UTF-8 encoding with the prohibited zero byte
   */
  Status.InvalidZeroByteInString = new Status(211);

  /**
   * A schedule being signed or deleted has already been deleted
   */
  Status.ScheduleAlreadyDeleted = new Status(212);

  /**
   * A schedule being signed or deleted has already been executed
   */
  Status.ScheduleAlreadyExecuted = new Status(213);

  /**
   * ConsensusSubmitMessage request's message size is larger than allowed.
   */
  Status.MessageSizeTooLarge = new Status(214);

  /**
   * An operation was assigned to more than one throttle group in a given bucket
   */
  Status.OperationRepeatedInBucketGroups = new Status(215);

  /**
   * The capacity needed to satisfy all opsPerSec groups in a bucket overflowed a signed 8-byte integral type
   */
  Status.BucketCapacityOverflow = new Status(216);

  /**
   * Given the network size in the address book, the node-level capacity for an operation would never be enough to accept a single request; usually means a bucket burstPeriod should be increased
   */
  Status.NodeCapacityNotSufficientForOperation = new Status(217);

  /**
   * A bucket was defined without any throttle groups
   */
  Status.BucketHasNoThrottleGroups = new Status(218);

  /**
   * A throttle group was granted zero opsPerSec
   */
  Status.ThrottleGroupHasZeroOpsPerSec = new Status(219);

  /**
   * The throttle definitions file was updated, but some supported operations were not assigned a bucket
   */
  Status.SuccessButMissingExpectedOperation = new Status(220);

  /**
   * The new contents for the throttle definitions system file were not valid protobuf
   */
  Status.UnparseableThrottleDefinitions = new Status(221);

  /**
   * The new throttle definitions system file were invalid, and no more specific error could be divined
   */
  Status.InvalidThrottleDefinitions = new Status(222);

  /**
   * The transaction references an account which has passed its expiration without renewal funds available, and currently remains in the ledger only because of the grace period given to expired entities
   */
  Status.AccountExpiredAndPendingRemoval = new Status(223);

  /**
   * Invalid token max supply
   */
  Status.InvalidTokenMaxSupply = new Status(224);

  /**
   * Invalid token nft serial number
   */
  Status.InvalidTokenNftSerialNumber = new Status(225);

  /**
   * Invalid nft id
   */
  Status.InvalidNftId = new Status(226);

  /**
   * Nft metadata is too long
   */
  Status.MetadataTooLong = new Status(227);

  /**
   * Repeated operations count exceeds the limit
   */
  Status.BatchSizeLimitExceeded = new Status(228);

  /**
   * The range of data to be gathered is out of the set boundaries
   */
  Status.InvalidQueryRange = new Status(229);

  /**
   * A custom fractional fee set a denominator of zero
   */
  Status.FractionDividesByZero = new Status(230);

  /**
   * The transaction payer could not afford a custom fee
   */
  Status.InsufficientPayerBalanceForCustomFee = new Status(231);

  /**
   * More than 10 custom fees were specified
   */
  Status.CustomFeesListTooLong = new Status(232);

  /**
   * Any of the feeCollector accounts for customFees is invalid
   */
  Status.InvalidCustomFeeCollector = new Status(233);

  /**
   * Any of the token Ids in customFees is invalid
   */
  Status.InvalidTokenIdInCustomFees = new Status(234);

  /**
   * Any of the token Ids in customFees are not associated to feeCollector
   */
  Status.TokenNotAssociatedToFeeCollector = new Status(235);

  /**
   * A token cannot have more units minted due to its configured supply ceiling
   */
  Status.TokenMaxSupplyReached = new Status(236);

  /**
   * The transaction attempted to move an NFT serial number from an account other than its owner
   */
  Status.SenderDoesNotOwnNftSerialNo = new Status(237);

  /**
   * A custom fee schedule entry did not specify either a fixed or fractional fee
   */
  Status.CustomFeeNotFullySpecified = new Status(238);

  /**
   * Only positive fees may be assessed at this time
   */
  Status.CustomFeeMustBePositive = new Status(239);

  /**
   * Fee schedule key is not set on token
   */
  Status.TokenHasNoFeeScheduleKey = new Status(240);

  /**
   * A fractional custom fee exceeded the range of a 64-bit signed integer
   */
  Status.CustomFeeOutsideNumericRange = new Status(241);

  /**
   * A royalty cannot exceed the total fungible value exchanged for an NFT
   */
  Status.RoyaltyFractionCannotExceedOne = new Status(242);

  /**
   * Each fractional custom fee must have its maximum_amount, if specified, at least its minimum_amount
   */
  Status.FractionalFeeMaxAmountLessThanMinAmount = new Status(243);

  /**
   * A fee schedule update tried to clear the custom fees from a token whose fee schedule was already empty
   */
  Status.CustomScheduleAlreadyHasNoFees = new Status(244);

  /**
   * Only tokens of type FUNGIBLE_COMMON can be used to as fee schedule denominations
   */
  Status.CustomFeeDenominationMustBeFungibleCommon = new Status(245);

  /**
   * Only tokens of type FUNGIBLE_COMMON can have fractional fees
   */
  Status.CustomFractionalFeeOnlyAllowedForFungibleCommon = new Status(246);

  /**
   * The provided custom fee schedule key was invalid
   */
  Status.InvalidCustomFeeScheduleKey = new Status(247);

  /**
   * The requested token mint metadata was invalid
   */
  Status.InvalidTokenMintMetadata = new Status(248);

  /**
   * The requested token burn metadata was invalid
   */
  Status.InvalidTokenBurnMetadata = new Status(249);

  /**
   * The treasury for a unique token cannot be changed until it owns no NFTs
   */
  Status.CurrentTreasuryStillOwnsNfts = new Status(250);

  /**
   * An account cannot be dissociated from a unique token if it owns NFTs for the token
   */
  Status.AccountStillOwnsNfts = new Status(251);

  /**
   * A NFT can only be burned when owned by the unique token's treasury
   */
  Status.TreasuryMustOwnBurnedNft = new Status(252);

  /**
   * An account did not own the NFT to be wiped
   */
  Status.AccountDoesNotOwnWipedNft = new Status(253);

  /**
   * An AccountAmount token transfers list referenced a token type other than FUNGIBLE_COMMON
   */
  Status.AccountAmountTransfersOnlyAllowedForFungibleCommon = new Status(254);

  /**
   * All the NFTs allowed in the current price regime have already been minted
   */
  Status.MaxNftsInPriceRegimeHaveBeenMinted = new Status(255);

  /**
   * The payer account has been marked as deleted
   */
  Status.PayerAccountDeleted = new Status(256);

  /**
   * The reference chain of custom fees for a transferred token exceeded the maximum length of 2
   */
  Status.CustomFeeChargingExceededMaxRecursionDepth = new Status(257);

  /**
   * More than 20 balance adjustments were to satisfy a CryptoTransfer and its implied custom fee payments
   */
  Status.CustomFeeChargingExceededMaxAccountAmounts = new Status(258);

  /**
   * The sender account in the token transfer transaction could not afford a custom fee
   */
  Status.InsufficientSenderAccountBalanceForCustomFee = new Status(259);

  /**
   * Currently no more than 4,294,967,295 NFTs may be minted for a given unique token type
   */
  Status.SerialNumberLimitReached = new Status(260);

  /**
   * Only tokens of type NON_FUNGIBLE_UNIQUE can have royalty fees
   */
  Status.CustomRoyaltyFeeOnlyAllowedForNonFungibleUnique = new Status(261);

  /**
   * The account has reached the limit on the automatic associations count.
   */
  Status.NoRemainingAutomaticAssociations = new Status(262);

  /**
   * Already existing automatic associations are more than the new maximum automatic associations.
   */
  Status.ExistingAutomaticAssociationsExceedGivenLimit = new Status(263);

  /**
   * Cannot set the number of automatic associations for an account more than the maximum allowed
   * token associations <tt>tokens.maxPerAccount</tt>.
   */
  Status.RequestedNumAutomaticAssociationsExceedsAssociationLimit = new Status(
      264,
  );

  /**
   * Token is paused. This Token cannot be a part of any kind of Transaction until unpaused.
   */
  Status.TokenIsPaused = new Status(265);

  /**
   * Pause key is not set on token
   */
  Status.TokenHasNoPauseKey = new Status(266);

  /**
   * The provided pause key was invalid
   */
  Status.InvalidPauseKey = new Status(267);

  /**
   * The update file in a freeze transaction body must exist.
   */
  Status.FreezeUpdateFileDoesNotExist = new Status(268);

  /**
   * The hash of the update file in a freeze transaction body must match the in-memory hash.
   */
  Status.FreezeUpdateFileHashDoesNotMatch = new Status(269);

  /**
   * A FREEZE_UPGRADE transaction was handled with no previous update prepared.
   */
  Status.NoUpgradeHasBeenPrepared = new Status(270);

  /**
   * A FREEZE_ABORT transaction was handled with no scheduled freeze.
   */
  Status.NoFreezeIsScheduled = new Status(271);

  /**
   * The update file hash when handling a FREEZE_UPGRADE transaction differs from the file
   * hash at the time of handling the PREPARE_UPGRADE transaction.
   */
  Status.UpdateFileHashChangedSincePrepareUpgrade = new Status(272);

  /**
   * The given freeze start time was in the (consensus) past.
   */
  Status.FreezeStartTimeMustBeFuture = new Status(273);

  /**
   * The prepared update file cannot be updated or appended until either the upgrade has
   * been completed, or a FREEZE_ABORT has been handled.
   */
  Status.PreparedUpdateFileIsImmutable = new Status(274);

  /**
   * Once a freeze is scheduled, it must be aborted before any other type of freeze can
   * can be performed.
   */
  Status.FreezeAlreadyScheduled = new Status(275);

  /**
   * If an NMT upgrade has been prepared, the following operation must be a FREEZE_UPGRADE.
   * (To issue a FREEZE_ONLY, submit a FREEZE_ABORT first.)
   */
  Status.FreezeUpgradeInProgress = new Status(276);

  /**
   * If an NMT upgrade has been prepared, the subsequent FREEZE_UPGRADE transaction must
   * confirm the id of the file to be used in the upgrade.
   */
  Status.UpdateFileIdDoesNotMatchPrepared = new Status(277);

  /**
   * If an NMT upgrade has been prepared, the subsequent FREEZE_UPGRADE transaction must
   * confirm the hash of the file to be used in the upgrade.
   */
  Status.UpdateFileHashDoesNotMatchPrepared = new Status(278);

  /**
   * Consensus throttle did not allow execution of this transaction. System is throttled at
   * consensus level.
   */
  Status.ConsensusGasExhausted = new Status(279);

  /**
   * A precompiled contract succeeded, but was later reverted.
   */
  Status.RevertedSuccess = new Status(280);

  /**
   * All contract storage allocated to the current price regime has been consumed.
   */
  Status.MaxStorageInPriceRegimeHasBeenUsed = new Status(281);

  /**
   * An alias used in a CryptoTransfer transaction is not the serialization of a primitive Key
   * message--that is, a Key with a single Ed25519 or ECDSA(secp256k1) public key and no
   * unknown protobuf fields.
   */
  Status.InvalidAliasKey = new Status(282);

  /**
   * A fungible token transfer expected a different number of decimals than the involved
   * type actually has.
   */
  Status.UnexpectedTokenDecimals = new Status(283);

  /**
   * The proxy account id is invalid or does not exist.
   */
  Status.InvalidProxyAccountId = new Status(284);

  /**
   * The transfer account id in CryptoDelete transaction is invalid or does not exist.
   */
  Status.InvalidTransferAccountId = new Status(285);

  /**
   * The fee collector account id in TokenFeeScheduleUpdate is invalid or does not exist.
   */
  Status.InvalidFeeCollectorAccountId = new Status(286);

  /**
   * The alias already set on an account cannot be updated using CryptoUpdate transaction.
   */
  Status.AliasIsImmutable = new Status(287);

  /**
   * An approved allowance specifies a spender account that is the same as the hbar/token
   * owner account.
   */
  Status.SpenderAccountSameAsOwner = new Status(288);

  /**
   * The establishment or adjustment of an approved allowance cause the token allowance
   * to exceed the token maximum supply.
   */
  Status.AmountExceedsTokenMaxSupply = new Status(289);

  /**
   * The specified amount for an approved allowance cannot be negative.
   */
  Status.NegativeAllowanceAmount = new Status(290);

  /**
   * The approveForAll flag cannot be set for a fungible token.
   */
  Status.CannotApproveForAllFungibleCommon = new Status(291);

  /**
   * The spender does not have an existing approved allowance with the hbar/token owner.
   */
  Status.SpenderDoesNotHaveAllowance = new Status(292);

  /**
   * The transfer amount exceeds the current approved allowance for the spender account.
   */
  Status.AmountExceedsAllowance = new Status(293);

  /**
   * The payer account of an approveAllowances or adjustAllowance transaction is attempting
   * to go beyond the maximum allowed number of allowances.
   */
  Status.MaxAllowancesExceeded = new Status(294);

  /**
   * No allowances have been specified in the approval/adjust transaction.
   */
  Status.EmptyAllowances = new Status(295);

  /**
   * Spender is repeated more than once in Crypto or Token or NFT allowance lists in a single
   * CryptoApproveAllowance or CryptoAdjustAllowance transaction.
   */
  Status.SpenderAccountRepeatedInAllowances = new Status(296);

  /**
   * Serial numbers are repeated in nft allowance for a single spender account
   */
  Status.RepeatedSerialNumsInNftAllowances = new Status(297);

  /**
   * Fungible common token used in NFT allowances
   */
  Status.FungibleTokenInNftAllowances = new Status(298);

  /**
   * Non fungible token used in fungible token allowances
   */
  Status.NftInFungibleTokenAllowances = new Status(299);

  /**
   * The account id specified as the owner is invalid or does not exist.
   */
  Status.InvalidAllowanceOwnerId = new Status(300);

  /**
   * The account id specified as the spender is invalid or does not exist.
   */
  Status.InvalidAllowanceSpenderId = new Status(301);

  /**
   * If the CryptoDeleteAllowance transaction has repeated crypto or token or Nft allowances to delete.
   */
  Status.RepeatedAllowancesToDelete = new Status(302);

  /**
   * If the account Id specified as the delegating spender is invalid or does not exist.
   */
  Status.InvalidDelegatingSpender = new Status(303);

  /**
   * The delegating Spender cannot grant approveForAll allowance on a NFT token type for another spender.
   */
  Status.DelegatingSpenderCannotGrantApproveForAll = new Status(304);

  /**
   * The delegating Spender cannot grant allowance on a NFT serial for another spender as it doesnt not have approveForAll
   * granted on token-owner.
   */
  Status.DelegatingSpenderDoesNotHaveApproveForAll = new Status(305);

  /**
   * The scheduled transaction could not be created because it's expiration_time was too far in the future.
   */
  Status.ScheduleExpirationTimeTooFarInFuture = new Status(306);

  /**
   * The scheduled transaction could not be created because it's expiration_time was less than or equal to the consensus time.
   */
  Status.ScheduleExpirationTimeMustBeHigherThanConsensusTime = new Status(307);

  /**
   * The scheduled transaction could not be created because it would cause throttles to be violated on the specified expiration_time.
   */
  Status.ScheduleFutureThrottleExceeded = new Status(308);

  /**
   * The scheduled transaction could not be created because it would cause the gas limit to be violated on the specified expiration_time.
   */
  Status.ScheduleFutureGasLimitExceeded = new Status(309);

  /**
   * The ethereum transaction either failed parsing or failed signature validation, or some other EthereumTransaction error not covered by another response code.
   */
  Status.InvalidEthereumTransaction = new Status(310);

  /**
   * EthereumTransaction was signed against a chainId that this network does not support.
   */
  Status.WrongChainId = new Status(311);

  /**
   * This transaction specified an ethereumNonce that is not the current ethereumNonce of the account.
   */
  Status.WrongNonce = new Status(312);

  /**
   * The ethereum transaction specified an access list, which the network does not support.
   */
  Status.AccessListUnsupported = new Status(313);

  /**
   * The scheduled transaction is pending expiration.
   */
  Status.SchedulePendingExpiration = new Status(314);

  /**
   * A selfdestruct or ContractDelete targeted a contract that is a token treasury.
   */
  Status.ContractIsTokenTreasury = new Status(315);

  /**
   * A selfdestruct or ContractDelete targeted a contract with non-zero token balances.
   */
  Status.ContractHasNonZeroTokenBalances = new Status(316);

  /**
   * A contract referenced by a transaction is "detached"; that is, expired and lacking any
   * hbar funds for auto-renewal payment---but still within its post-expiry grace period.
   */
  Status.ContractExpiredAndPendingRemoval = new Status(317);

  /**
   * A ContractUpdate requested removal of a contract's auto-renew account, but that contract has
   * no auto-renew account.
   */
  Status.ContractHasNoAutoRenewAccount = new Status(318);

  /**
   * A delete transaction submitted via HAPI set permanent_removal=true
   */
  Status.PermanentRemovalRequiresSystemInitiation = new Status(319);

  /*
   * A CryptoCreate or ContractCreate used the deprecated proxyAccountID field.
   */
  Status.ProxyAccountIdFieldIsDeprecated = new Status(320);

  /**
   * An account set the staked_account_id to itself in CryptoUpdate or ContractUpdate transactions.
   */
  Status.SelfStakingIsNotAllowed = new Status(321);

  /**
   * The staking account id or staking node id given is invalid or does not exist.
   */
  Status.InvalidStakingId = new Status(322);

  /**
   * Native staking, while implemented, has not yet enabled by the council.
   */
  Status.StakingNotEnabled = new Status(323);

  /**
   * The range provided in PRNG transaction is negative.
   */
  Status.InvalidPrngRange = new Status(324);

  /**
   * The maximum number of entities allowed in the current price regime have been created.
   */
  Status.MaxEntitiesInPriceRegimeHaveBeenCreated = new Status(325);

  /**
   * The full prefix signature for precompile is not valid
   */
  Status.InvalidFullPrefixSignatureForPrecompile = new Status(326);

  /**
   * The combined balances of a contract and its auto-renew account (if any) did not cover
   * the rent charged for net new storage used in a transaction.
   */
  Status.InsufficientBalancesForStorageRent = new Status(327);

  /**
   * A contract transaction tried to use more than the allowed number of child records, via
   * either system contract records or internal contract creations.
   */
  Status.MaxChildRecordsExceeded = new Status(328);

  /**
   * The combined balances of a contract and its auto-renew account (if any) or balance of an account did not cover
   * the auto-renewal fees in a transaction.
   */
  Status.InsufficientBalancesForRenewalFees = new Status(329);

  /**
   * A transaction's protobuf message includes unknown fields; could mean that a client
   * expects not-yet-released functionality to be available.
   */
  Status.TransactionHasUnknownFields = new Status(330);

  /**
   * The account cannot be modified. Account's key is not set
   */
  Status.AccountIsImmutable = new Status(331);

  /**
   * An alias that is assigned to an account or contract cannot be assigned to another account or contract.
   */
  Status.AliasAlreadyAssigned = new Status(332);

  /**
   * A provided metadata key was invalid. Verification includes, for example, checking the size of Ed25519 and ECDSA(secp256k1) public keys.
   */
  Status.InvalidMetadataKey = new Status(333);

  /**
   * Metadata key is not set on token
   */
  Status.TokenHasNoMetadataKey = new Status(334);

  /**
   * Token Metadata is not provided
   */
  Status.MissingTokenMetadata = new Status(335);

  /**
   * NFT serial numbers are missing in the TokenUpdateNftsTransactionBody
   */
  Status.MissingSerialNumbers = new Status(336);

  /**
   * Admin key is not set on token
   */
  Status.TokenHasNoAdminKey = new Status(337);

  /**
   * The node has been marked as deleted
   */
  Status.NodeDeleted = new Status(338);

  /**
   * A node is not found during update and delete node transaction
   */
  Status.InvalidNodeId = new Status(339);

  /**
   * gossip_endpoint has a fully qualified domain name instead of ip
   */
  Status.InvalidGossipEndpoint = new Status(340);

  /**
   * The node account_id is invalid
   */
  Status.InvalidNodeAccountId = new Status(341);

  /**
   * The node description is invalid
   */
  Status.InvalidNodeDescription = new Status(342);

  /**
   * service_endpoint is invalid
   */
  Status.InvalidServiceEndpoint = new Status(343);

  /**
   * gossip_ca_certificate is invalid
   */
  Status.InvalidGossipCaCertificate = new Status(344);

  /**
   * grpc_certificate_hash is invalid
   */
  Status.InvalidGrpcCertificate = new Status(345);

  /**
   * The maximum automatic associations value is not valid.
   * The most common cause for this error is a value less than `-1`.
   */
  Status.InvalidMaxAutoAssociations = new Status(346);

  /**
   * The maximum number of nodes allowed in the address book have been created.
   */
  Status.MaxNodesCreated = new Status(347);

  /**
   * In ServiceEndpoint, domain_name and ipAddressV4 are mutually exclusive
   */
  Status.IpFqdnCannotBeSetForSameEndpoint = new Status(348);

  /**
   * Fully qualified domain name is not allowed in gossip_endpoint
   */
  Status.GossipEndpointCannotHaveFqdn = new Status(349);

  /**
   * In ServiceEndpoint, domain_name size too large
   */
  Status.FqdnSizeTooLarge = new Status(350);

  /**
   * ServiceEndpoint is invalid
   */
  Status.InvalidEndpoint = new Status(351);

  /**
   * The number of gossip endpoints exceeds the limit
   */
  Status.GossipEndpointsExceededLimit = new Status(352);

  /**
   * The transaction attempted to use duplicate `TokenReference`.<br/>
   * This affects `TokenReject` attempting to reject same token reference more than once.
   */
  Status.TokenReferenceRepeated = new Status(353);

  /**
   * The account id specified as the owner in `TokenReject` is invalid or does not exist.
   */
  Status.InvalidOwnerId = new Status(354);

  /**
   * The transaction attempted to use more than the allowed number of `TokenReference`.
   */
  Status.TokenReferenceListSizeLimitExceeded = new Status(355);

  /**
   * The number of service endpoints exceeds the limit
   */
  Status.ServiceEndpointsExceededLimit = new Status(356);

  /*
   * The IPv4 address is invalid
   */
  Status.InvalidIpv4Address = new Status(357);

  /**
   * The transaction attempted to use empty `TokenReference` list.
   */
  Status.EmptyTokenReferenceList = new Status(358);

  /*
   * The node account is not allowed to be updated
   */
  Status.UpdateNodeAccountNotAllowed = new Status(359);

  /*
   * The token has no metadata or supply key
   */
  Status.TokenHasNoMetadataOrSupplyKey = new Status(360);

  /**
   * The transaction attempted to the use an empty List of `PendingAirdropId`.
   */
  Status.EmptyPendingAirdropIdList = new Status(361);

  /**
   * The transaction attempted to the same `PendingAirdropId` twice.
   */
  Status.PendingAirdropIdRepeated = new Status(362);

  /**
   * The transaction attempted to use more than the allowed number of `PendingAirdropId`.
   */
  Status.MaxPendingAirdropIdExceeded = new Status(363);

  /*
   * A pending airdrop already exists for the specified NFT.
   */
  Status.PendingNftAirdropAlreadyExists = new Status(364);

  /*
   * The identified account is sender for one or more pending airdrop(s)
   * and cannot be deleted.<br/>
   * Requester should cancel all pending airdrops before resending
   * this transaction.
   */
  Status.AccountHasPendingAirdrops = new Status(365);

  /**
   * Consensus throttle did not allow execution of this transaction.<br/>
   * The transaction should be retried after a modest delay.
   */
  Status.ThrottledAtConsensus = new Status(366);

  /**
   * The provided pending airdrop id is invalid.<br/>
   * This pending airdrop MAY already be claimed or cancelled.
   * <p>
   * The client SHOULD query a mirror node to determine the current status of
   * the pending airdrop.
   */
  Status.InvalidPendingAirdropId = new Status(367);

  /**
   * The token to be airdropped has a fallback royalty fee and cannot be
   * sent or claimed via an airdrop transaction.
   */
  Status.TokenAirdropWithFallbackRoyalty = new Status(368);

  /**
   * This airdrop claim is for a pending airdrop with an invalid token.<br/>
   * The token might be deleted, or the sender may not have enough tokens
   * to fulfill the offer.
   * <p>
   * The client SHOULD query mirror node to determine the status of the pending
   * airdrop and whether the sender can fulfill the offer.
   */
  Status.InvalidTokenInPendingAirdrop = new Status(369);

  /**
   * A scheduled transaction configured to wait for expiry to execute was given
   * an expiry time at which there is already too many transactions scheduled to
   * expire; its creation must be retried with a different expiry.
   */
  Status.ScheduleExpiryIsBusy = new Status(370);

  /**
   * The provided gRPC certificate hash is invalid.
   */
  Status.InvalidGrpcCertificateHash = new Status(371);

  /**
   * A scheduled transaction configured to wait for expiry to execute was not
   * given an explicit expiration time.
   */
  Status.MissingExpiryTime = new Status(372);

  /**
   * A contract operation attempted to schedule another transaction after it
   * had already scheduled a recursive contract call.
   */
  Status.NoSchedulingAllowedAfterScheduledRecursion = new Status(373);

  /**
   * A contract can schedule recursive calls a finite number of times (this is
   * approximately four million times with typical network configuration.)
   */
  Status.RecursiveSchedulingLimitReached = new Status(374);

  /**
   * The target network is waiting for the ledger ID to be set, which is a
   * side effect of finishing the network's TSS construction.
   */
  Status.WaitingForLedgerId = new Status(375);

  /**
   * The provided fee exempt key list size exceeded the limit.
   */
  Status.MaxEntriesForFeeExemptKeyListExceeded = new Status(376);

  /**
   * The provided fee exempt key list contains duplicated keys.
   */
  Status.FeeExemptKeyListContainsDuplicatedKeys = new Status(377);

  /**
   * The provided fee exempt key list contains an invalid key.
   */
  Status.InvalidKeyInFeeExemptKeyList = new Status(378);

  /**
   * The provided fee schedule key contains an invalid key.
   */
  Status.InvalidFeeScheduleKey = new Status(379);

  /**
   * If a fee schedule key is not set when we create a topic
   * we cannot add it on update.
   */
  Status.FeeScheduleKeyCannotBeUpdated = new Status(380);

  /**
   * If the topic's custom fees are updated the topic SHOULD have a
   * fee schedule key
   */
  Status.FeeScheduleKeyNotSet = new Status(381);

  /**
   * The fee amount is exceeding the amount that the payer
   * is willing to pay.
   */
  Status.MaxCustomFeeLimitExceeded = new Status(382);

  /**
   * There are no corresponding custom fees.
   */
  Status.NoValidMaxCustomFee = new Status(383);

  /**
   * The provided list contains invalid max custom fee.
   */
  Status.InvalidMaxCustomFees = new Status(384);

  /**
   * The provided max custom fee list contains fees with
   * duplicate denominations.
   */
  Status.DuplicateDenominationInMaxCustomFeeList = new Status(385);

  /**
   * The provided max custom fee list contains fees with
   * duplicate account id.
   */
  Status.DuplicateAccountIdInMaxCustomFeeList = new Status(386);

  /**
   * Max custom fees list is not supported for this operation.
   */
  Status.MaxCustomFeesIsNotSupported = new Status(387);

  /**
   * The list of batch transactions is empty
   */
  Status.BatchListEmpty = new Status(388);

  /**
   * The list of batch transactions contains duplicated transactions
   */
  Status.BatchListContainsDuplicates = new Status(389);

  /**
   * The list of batch transactions contains a transaction type that is
   * in the AtomicBatch blacklist as configured in the network.
   */
  Status.BatchTransactionInBlacklist = new Status(390);

  /**
   * The inner transaction of a batch transaction failed
   */
  Status.InnerTransactionFailed = new Status(391);

  /**
   * The inner transaction of a batch transaction is missing a batch key
   */
  Status.MissingBatchKey = new Status(392);

  /**
   * The batch key is set for a non batch transaction
   */
  Status.BatchKeySetOnNonInnerTransaction = new Status(393);

  /**
   * The batch key is not valid
   */
  Status.InvalidBatchKey = new Status(394);

  /**
   * The schedule expiry is not configurable
   */
  Status.ScheduleExpiryNotConfigurable = new Status(395);

  /**
   * Creating system entities
   */
  Status.CreatingSystemEntities = new Status(396);

  /**
   * The least common multiple of the throttle group's milliOpsPerSec is too large and it's overflowing.
   */
  Status.ThrottleGroupLcmOverflow = new Status(397);

  /**
   * Token airdrop transactions can not contain multiple senders for a single token.
   */
  Status.AirdropContainsMultipleSendersForAToken = new Status(398);

  /**
   * The GRPC proxy endpoint is set in the NodeCreate or NodeUpdate transaction, which the network does not support.
   */
  Status.GrpcWebProxyNotSupported = new Status(399);

  /**
   * An NFT transfers list referenced a token type other than NON_FUNGIBLE_UNIQUE.
   */
  Status.NftTransfersOnlyAllowedForNonFungibleUnique = new Status(400);

  // SPDX-License-Identifier: Apache-2.0

  class GrpcStatus {
      /**
       * @hideconstructor
       * @internal
       * @param {number} code
       */
      constructor(code) {
          /** @readonly */
          this._code = code;

          Object.freeze(this);
      }

      /**
       * @internal
       * @param {number} code
       * @returns {GrpcStatus}
       */
      static _fromValue(code) {
          switch (code) {
              case 0:
                  return GrpcStatus.Ok;
              case 1:
                  return GrpcStatus.Cancelled;
              case 2:
                  return GrpcStatus.Unknown;
              case 3:
                  return GrpcStatus.InvalidArgument;
              case 4:
                  return GrpcStatus.DeadlineExceeded;
              case 5:
                  return GrpcStatus.NotFound;
              case 6:
                  return GrpcStatus.AlreadyExists;
              case 7:
                  return GrpcStatus.PermissionDenied;
              case 8:
                  return GrpcStatus.ResourceExhausted;
              case 9:
                  return GrpcStatus.FailedPrecondition;
              case 10:
                  return GrpcStatus.Aborted;
              case 11:
                  return GrpcStatus.OutOfRange;
              case 12:
                  return GrpcStatus.Unimplemented;
              case 13:
                  return GrpcStatus.Internal;
              case 14:
                  return GrpcStatus.Unavailable;
              case 15:
                  return GrpcStatus.DataLoss;
              case 16:
                  return GrpcStatus.Unauthenticated;
              case 17:
                  return GrpcStatus.Timeout;
              case 18:
                  return GrpcStatus.GrpcWeb;
              default:
                  throw new Error(
                      "(BUG) non-exhaustive GrpcStatus switch statement",
                  );
          }
      }

      /**
       * @returns {string}
       */
      toString() {
          switch (this) {
              case GrpcStatus.Ok:
                  return "OK";
              case GrpcStatus.Cancelled:
                  return "CANCELLED";
              case GrpcStatus.Unknown:
                  return "UNKNOWN";
              case GrpcStatus.InvalidArgument:
                  return "INVALID_ARGUMENT";
              case GrpcStatus.DeadlineExceeded:
                  return "DEADLINE_EXCEEDED";
              case GrpcStatus.NotFound:
                  return "NOT_FOUND";
              case GrpcStatus.AlreadyExists:
                  return "ALREADY_EXISTS";
              case GrpcStatus.PermissionDenied:
                  return "PERMISSION_DENIED";
              case GrpcStatus.Unauthenticated:
                  return "UNAUTHENTICATED";
              case GrpcStatus.ResourceExhausted:
                  return "RESOURCE_EXHAUSTED";
              case GrpcStatus.FailedPrecondition:
                  return "FAILED_PRECONDITION";
              case GrpcStatus.Aborted:
                  return "ABORTED";
              case GrpcStatus.OutOfRange:
                  return "OUT_OF_RANGE";
              case GrpcStatus.Unimplemented:
                  return "UNIMPLEMENTED";
              case GrpcStatus.Internal:
                  return "INTERNAL";
              case GrpcStatus.Unavailable:
                  return "UNAVAILABLE";
              case GrpcStatus.DataLoss:
                  return "DATA_LOSS";
              case GrpcStatus.Timeout:
                  return "TIMEOUT";
              case GrpcStatus.GrpcWeb:
                  return "GRPC_WEB";
              default:
                  return `UNKNOWN (${this._code})`;
          }
      }

      /**
       * @returns {number}
       */
      valueOf() {
          return this._code;
      }
  }

  GrpcStatus.Ok = new GrpcStatus(0);
  GrpcStatus.Cancelled = new GrpcStatus(1);
  GrpcStatus.Unknown = new GrpcStatus(2);
  GrpcStatus.InvalidArgument = new GrpcStatus(3);
  GrpcStatus.DeadlineExceeded = new GrpcStatus(4);
  GrpcStatus.NotFound = new GrpcStatus(5);
  GrpcStatus.AlreadyExists = new GrpcStatus(6);
  GrpcStatus.PermissionDenied = new GrpcStatus(7);
  GrpcStatus.ResourceExhausted = new GrpcStatus(8);
  GrpcStatus.FailedPrecondition = new GrpcStatus(9);
  GrpcStatus.Aborted = new GrpcStatus(10);
  GrpcStatus.OutOfRange = new GrpcStatus(11);
  GrpcStatus.Unimplemented = new GrpcStatus(12);
  GrpcStatus.Internal = new GrpcStatus(13);
  GrpcStatus.Unavailable = new GrpcStatus(14);
  GrpcStatus.DataLoss = new GrpcStatus(15);
  GrpcStatus.Unauthenticated = new GrpcStatus(16);
  GrpcStatus.Timeout = new GrpcStatus(17);
  GrpcStatus.GrpcWeb = new GrpcStatus(18);

  // SPDX-License-Identifier: Apache-2.0


  /**
   * Describes how the gRPC request failed.
   *
   * Exists in order for the Hiero JavaScript SDK to produce the same error type for gRPC errors regardless of
   * operating in node or the browser.
   *
   * Definition taken from <https://grpc.github.io/grpc/node/grpc.html#~ServiceError>.
   */
  class GrpcServiceError extends Error {
      /**
       * @param {GrpcStatus} status
       * @param {string} [nodeAccountId]
       */
      constructor(status, nodeAccountId) {
          super(
              `gRPC service failed with: Status: ${status.toString()}, Code: ${status.valueOf()}`,
          );

          /**
           * @readonly
           */
          this.status = status;

          /**
           * Optional: node account ID associated with the error
           */
          this.nodeAccountId = nodeAccountId;

          this.name = "GrpcServiceError";

          if (typeof Error.captureStackTrace !== "undefined") {
              Error.captureStackTrace(this, GrpcServiceError);
          }
      }

      /**
       * @param {Error & { code?: number; details?: string }} obj
       * @returns {Error}
       */
      static _fromResponse(obj) {
          if (obj.code != null && obj.details != null) {
              const status = GrpcStatus._fromValue(obj.code);
              const err = new GrpcServiceError(status);
              err.stack += `\nCaused by: ${
                obj.stack ? obj.stack.toString() : ""
            }`;
              err.message += `: ${obj.details}`;
              return err;
          } else {
              return /** @type {Error} */ (obj);
          }
      }

      /**
       * @returns {string}
       */
      toString() {
          return `${this.name}: ${this.message}`;
      }
  }

  // SPDX-License-Identifier: Apache-2.0

  class HttpStatus {
      /**
       * @hideconstructor
       * @internal
       * @param {number} code
       */
      constructor(code) {
          /** @readonly */
          this._code = code;

          Object.freeze(this);
      }

      /**
       * @internal
       * @param {number} code
       * @returns {HttpStatus}
       */
      static _fromValue(code) {
          return new HttpStatus(code);
      }

      /**
       * @returns {string}
       */
      toString() {
          return this._code.toString();
      }

      /**
       * @returns {number}
       */
      valueOf() {
          return this._code;
      }
  }

  // SPDX-License-Identifier: Apache-2.0
  // eslint-disable-next-line @typescript-eslint/no-unused-vars

  /**
   * Describes how the http request failed.
   */
  class HttpError extends Error {
      /**
       * @param {HttpStatus} status
       */
      constructor(status) {
          super(`failed with error code: ${status.toString()}`);

          /**
           * @readonly
           */
          this.status = status;

          this.name = "HttpError";

          if (typeof Error.captureStackTrace !== "undefined") {
              Error.captureStackTrace(this, HttpError);
          }
      }
  }

  // SPDX-License-Identifier: Apache-2.0
  /**
   * @typedef {object} MaxAttemptsOrTimeoutErrorJSON
   * @property {string} message
   * @property {string} nodeAccountId
   *
   */

  class MaxAttemptsOrTimeoutError extends Error {
      /**
       * @param {string} message
       * @param {string} nodeAccountId
       */
      constructor(message, nodeAccountId) {
          // Call the Error constructor with the message
          super(message);

          // Assign the nodeAccountId as a custom property
          this.nodeAccountId = nodeAccountId;
      }

      toJSON() {
          return {
              message: this.message,
              nodeAccountId: this.nodeAccountId,
          };
      }

      /**
       * @returns {string}
       */
      toString() {
          return JSON.stringify(this.toJSON());
      }

      /**
       * @returns {MaxAttemptsOrTimeoutErrorJSON}
       */
      valueOf() {
          return this.toJSON();
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {import("./account/AccountId.js").default} AccountId
   * @typedef {import("./channel/Channel.js").default} Channel
   * @typedef {import("./channel/MirrorChannel.js").default} MirrorChannel
   * @typedef {import("./transaction/TransactionId.js").default} TransactionId
   * @typedef {import("./client/Client.js").ClientOperator} ClientOperator
   * @typedef {import("./Signer.js").Signer} Signer
   * @typedef {import("./PublicKey.js").default} PublicKey
   * @typedef {import("./logger/Logger.js").default} Logger
   */

  /**
   * @enum {string}
   */
  const ExecutionState = {
      Finished: "Finished",
      Retry: "Retry",
      Error: "Error",
  };

  const RST_STREAM = /\brst[^0-9a-zA-Z]stream\b/i;
  const DEFAULT_MAX_ATTEMPTS = 10;

  /**
   * @abstract
   * @internal
   * @template RequestT
   * @template ResponseT
   * @template OutputT
   */
  class Executable {
      constructor() {
          /**
           * The number of times we can retry the grpc call
           *
           * @internal
           * @type {number}
           */
          this._maxAttempts = DEFAULT_MAX_ATTEMPTS;

          /**
           * List of node account IDs for each transaction that has been
           * built.
           *
           * @internal
           * @type {List<AccountId>}
           */
          this._nodeAccountIds = new List();

          /**
           * List of the transaction node account IDs to check if
           * the node account ID of the request is in the list
           *
           * @protected
           * @type {Array<string>}
           */
          this.transactionNodeIds = [];

          /**
           * @internal
           */
          this._signOnDemand = false;

          /**
           * This is the request's min backoff
           *
           * @internal
           * @type {number | null}
           */
          this._minBackoff = null;

          /**
           * This is the request's max backoff
           *
           * @internal
           * @type {number}
           */
          this._maxBackoff = 8000;

          /**
           * The operator that was used to execute this request.
           * The reason we save the operator in the request is because of the signing on
           * demand feature. This feature requires us to sign new request on each attempt
           * meaning if a client with an operator was used we'd need to sign with the operator
           * on each attempt.
           *
           * @internal
           * @type {ClientOperator | null}
           */
          this._operator = null;

          /**
           * The complete timeout for running the `execute()` method
           *
           * @internal
           * @type {number | null}
           */
          this._requestTimeout = null;

          /**
           * The grpc request timeout aka deadline.
           *
           * The reason we have this is because there were times that consensus nodes held the grpc
           * connection, but didn't return anything; not error nor regular response. This resulted
           * in some weird behavior in the SDKs. To fix this we've added a grpc deadline to prevent
           * nodes from stalling the executing of a request.
           *
           * @internal
           * @type {number | null}
           */
          this._grpcDeadline = null;

          /**
           * Logger
           *
           * @protected
           * @type {Logger | null}
           */
          this._logger = null;
      }

      /**
       * Get the list of node account IDs on the request. If no nodes are set, then null is returned.
       * The reasoning for this is simply "legacy behavior".
       *
       * @returns {?AccountId[]}
       */
      get nodeAccountIds() {
          if (this._nodeAccountIds.isEmpty) {
              return null;
          } else {
              this._nodeAccountIds.setLocked();
              return this._nodeAccountIds.list;
          }
      }

      /**
       * Set the node account IDs on the request
       *
       * @param {AccountId[]} nodeIds
       * @returns {this}
       */
      setNodeAccountIds(nodeIds) {
          // Set the node account IDs, and lock the list. This will require `execute`
          // to use these nodes instead of random nodes from the network.
          this._nodeAccountIds.setList(nodeIds).setLocked();
          return this;
      }

      /**
       * @deprecated
       * @returns {number}
       */
      get maxRetries() {
          console.warn("Deprecated: use maxAttempts instead");
          return this.maxAttempts;
      }

      /**
       * @param {number} maxRetries
       * @returns {this}
       */
      setMaxRetries(maxRetries) {
          console.warn("Deprecated: use setMaxAttempts() instead");
          return this.setMaxAttempts(maxRetries);
      }

      /**
       * Get the max attempts on the request
       *
       * @returns {number}
       */
      get maxAttempts() {
          return this._maxAttempts;
      }

      /**
       * Set the max attempts on the request
       *
       * @param {number} maxAttempts
       * @returns {this}
       */
      setMaxAttempts(maxAttempts) {
          this._maxAttempts = maxAttempts;

          return this;
      }

      /**
       * Get the grpc deadline
       *
       * @returns {?number}
       */
      get grpcDeadline() {
          return this._grpcDeadline;
      }

      /**
       * Set the grpc deadline
       *
       * @param {number} grpcDeadline
       * @returns {this}
       */
      setGrpcDeadline(grpcDeadline) {
          this._grpcDeadline = grpcDeadline;

          return this;
      }

      /**
       * Set the min backoff for the request
       *
       * @param {number} minBackoff
       * @returns {this}
       */
      setMinBackoff(minBackoff) {
          // Honestly we shouldn't be checking for null since that should be TypeScript's job.
          // Also verify that min backoff is not greater than max backoff.
          if (minBackoff == null) {
              throw new Error("minBackoff cannot be null.");
          } else if (this._maxBackoff != null && minBackoff > this._maxBackoff) {
              throw new Error("minBackoff cannot be larger than maxBackoff.");
          }
          this._minBackoff = minBackoff;
          return this;
      }

      /**
       * Get the min backoff
       *
       * @returns {number | null}
       */
      get minBackoff() {
          return this._minBackoff;
      }

      /**
       * Set the max backoff for the request
       *
       * @param {?number} maxBackoff
       * @returns {this}
       */
      setMaxBackoff(maxBackoff) {
          // Honestly we shouldn't be checking for null since that should be TypeScript's job.
          // Also verify that max backoff is not less than min backoff.
          if (maxBackoff == null) {
              throw new Error("maxBackoff cannot be null.");
          } else if (this._minBackoff != null && maxBackoff < this._minBackoff) {
              throw new Error("maxBackoff cannot be smaller than minBackoff.");
          }
          this._maxBackoff = maxBackoff;
          return this;
      }

      /**
       * Get the max backoff
       *
       * @returns {number}
       */
      get maxBackoff() {
          return this._maxBackoff;
      }

      /**
       * This method is responsible for doing any work before the executing process begins.
       * For paid queries this will result in executing a cost query, for transactions this
       * will make sure we save the operator and sign any requests that need to be signed
       * in case signing on demand is disabled.
       *
       * @abstract
       * @protected
       * @param {import("./client/Client.js").default<Channel, *>} client
       * @returns {Promise<void>}
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _beforeExecute(client) {
          throw new Error("not implemented");
      }

      /**
       * Create a protobuf request which will be passed into the `_execute()` method
       *
       * @abstract
       * @protected
       * @returns {Promise<RequestT>}
       */
      _makeRequestAsync() {
          throw new Error("not implemented");
      }

      /**
       * This name is a bit wrong now, but the purpose of this method is to map the
       * request and response into an error. This method will only be called when
       * `_shouldRetry` returned `ExecutionState.Error`
       *
       * @abstract
       * @internal
       * @param {RequestT} request
       * @param {ResponseT} response
       * @param {AccountId} nodeId
       * @returns {Error}
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _mapStatusError(request, response, nodeId) {
          throw new Error("not implemented");
      }

      /**
       * Map the request, response, and the node account ID used for this attempt into a response.
       * This method will only be called when `_shouldRetry` returned `ExecutionState.Finished`
       *
       * @abstract
       * @protected
       * @param {ResponseT} response
       * @param {AccountId} nodeAccountId
       * @param {RequestT} request
       * @returns {Promise<OutputT>}
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _mapResponse(response, nodeAccountId, request) {
          throw new Error("not implemented");
      }

      /**
       * Perform a single grpc call with the given request. Each request has it's own
       * required service so we just pass in channel, and it'$ the request's responsiblity
       * to use the right service and call the right grpc method.
       *
       * @abstract
       * @internal
       * @param {Channel} channel
       * @param {RequestT} request
       * @returns {Promise<ResponseT>}
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _execute(channel, request) {
          throw new Error("not implemented");
      }

      /**
       * Return the current transaction ID for the request. All requests which are
       * use the same transaction ID for each node, but the catch is that `Transaction`
       * implicitly supports chunked transactions. Meaning there could be multiple
       * transaction IDs stored in the request, and a different transaction ID will be used
       * on subsequent calls to `execute()`
       *
       * FIXME: This method can most likely be removed, although some further inspection
       * is required.
       *
       * @abstract
       * @protected
       * @returns {TransactionId}
       */
      _getTransactionId() {
          throw new Error("not implemented");
      }

      /**
       * Return the log ID for this particular request
       *
       * Log IDs are simply a string constructed to make it easy to track each request's
       * execution even when mulitple requests are executing in parallel. Typically, this
       * method returns the format of `[<request type>.<timestamp of the transaction ID>]`
       *
       * Maybe we should deduplicate this using ${this.consturtor.name}
       *
       * @abstract
       * @internal
       * @returns {string}
       */
      _getLogId() {
          throw new Error("not implemented");
      }

      /**
       * Serialize the request into bytes
       *
       * @abstract
       * @param {RequestT} request
       * @returns {Uint8Array}
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _requestToBytes(request) {
          throw new Error("not implemented");
      }

      /**
       * Serialize the response into bytes
       *
       * @abstract
       * @param {ResponseT} response
       * @returns {Uint8Array}
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _responseToBytes(response) {
          throw new Error("not implemented");
      }

      /**
       * Determine if we should continue the execution process, error, or finish.
       *
       * FIXME: This method should really be called something else. Initially it returned
       * a boolean so `shouldRetry` made sense, but now it returns an enum, so the name
       * no longer makes sense.
       *
       * @abstract
       * @protected
       * @param {RequestT} request
       * @param {ResponseT} response
       * @returns {[Status, ExecutionState]}
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _shouldRetry(request, response) {
          throw new Error("not implemented");
      }

      /**
       * Determine if we should error based on the gRPC status
       *
       * Unlike `shouldRetry` this method does in fact still return a boolean
       *
       * @protected
       * @param {Error} error
       * @returns {boolean}
       */
      _shouldRetryExceptionally(error) {
          if (error instanceof GrpcServiceError) {
              return (
                  error.status._code === GrpcStatus.Timeout._code ||
                  error.status._code === GrpcStatus.DeadlineExceeded._code ||
                  error.status._code === GrpcStatus.Unavailable._code ||
                  error.status._code === GrpcStatus.ResourceExhausted._code ||
                  error.status._code === GrpcStatus.GrpcWeb._code ||
                  (error.status._code === GrpcStatus.Internal._code &&
                      RST_STREAM.test(error.message))
              );
          } else {
              // if we get to the 'else' statement, the 'error' is instanceof 'HttpError'
              // and in this case, we have to retry always
              return true;
          }
      }

      /**
       * A helper method for setting the operator on the request
       *
       * @internal
       * @param {AccountId} accountId
       * @param {PublicKey} publicKey
       * @param {(message: Uint8Array) => Promise<Uint8Array>} transactionSigner
       * @returns {this}
       */
      _setOperatorWith(accountId, publicKey, transactionSigner) {
          this._operator = {
              transactionSigner,
              accountId,
              publicKey,
          };
          return this;
      }

      /**
       * Execute this request using the signer
       *
       * This method is part of the signature providers feature
       * https://hips.hedera.com/hip/hip-338
       *
       * @param {Signer} signer
       * @returns {Promise<OutputT>}
       */
      async executeWithSigner(signer) {
          return signer.call(this);
      }

      /**
       * @returns {boolean}
       * @abstract
       * @protected
       */
      isBatchedAndNotBatchTransaction() {
          return false;
      }

      /**
       * Execute the request using a client and an optional request timeout
       *
       * @template {Channel} ChannelT
       * @template {MirrorChannel} MirrorChannelT
       * @param {import("./client/Client.js").default<ChannelT, MirrorChannelT>} client
       * @param {number=} requestTimeout
       * @returns {Promise<OutputT>}
       */
      async execute(client, requestTimeout) {
          // we check if its local node then backoff mechanism should be disabled
          // and we increase the retry attempts
          const isLocalNode = client.network["127.0.0.1:50211"] != null;

          if (this.isBatchedAndNotBatchTransaction()) {
              throw new Error(
                  "Cannot execute batchified transaction outside of BatchTransaction",
              );
          }

          // If the logger on the request is not set, use the logger in client
          // (if set, otherwise do not use logger)
          this._logger =
              this._logger == null
                  ? client._logger != null
                      ? client._logger
                      : null
                  : this._logger;

          // If the request timeout is set on the request we'll prioritize that instead
          // of the parameter provided, and if the parameter isn't provided we'll
          // use the default request timeout on client
          if (this._requestTimeout == null) {
              this._requestTimeout =
                  requestTimeout != null ? requestTimeout : client.requestTimeout;
          }

          // If the grpc deadline is not set on the request, use the default value from client
          if (this._grpcDeadline == null) {
              this._grpcDeadline = client.grpcDeadline;
          }

          // Some request need to perform additional requests before the executing
          // such as paid queries need to fetch the cost of the query before
          // finally executing the actual query.
          await this._beforeExecute(client);

          // If the max backoff on the request is not set, use the default value in client
          if (this._maxBackoff == null) {
              this._maxBackoff = client.maxBackoff;
          }

          // If the min backoff on the request is not set, use the default value in client
          if (this._minBackoff == null) {
              this._minBackoff = client.minBackoff;
          }

          // Save the start time to be used later with request timeout
          const startTime = Date.now();

          // Saves each error we get so when we err due to max attempts exceeded we'll have
          // the last error that was returned by the consensus node
          let persistentError = null;

          // If the max attempts on the request is not set, use the default value in client
          // If the default value in client is not set, use a default of 10.
          //
          // FIXME: current implementation is wrong, update to follow comment above.
          // ... existing code ...
          const LOCAL_NODE_ATTEMPTS = 1000;
          const maxAttempts = isLocalNode
              ? LOCAL_NODE_ATTEMPTS
              : client._maxAttempts ?? this._maxAttempts;

          // Checks if has a valid nodes to which the TX can be sent
          if (this.transactionNodeIds.length) {
              const nodeAccountIds = this._nodeAccountIds.list.map((nodeId) =>
                  nodeId.toString(),
              );

              const hasValidNodes = this.transactionNodeIds.some((nodeId) =>
                  nodeAccountIds.includes(nodeId),
              );

              if (!hasValidNodes) {
                  const displayNodeAccountIds =
                      nodeAccountIds.length > 2
                          ? `${nodeAccountIds.slice(0, 2).join(", ")} ...`
                          : nodeAccountIds.join(", ");
                  const isSingleNode = nodeAccountIds.length === 1;

                  throw new Error(
                      `Attempting to execute a transaction against node${
                        isSingleNode ? "" : "s"
                    } ${displayNodeAccountIds}, ` +
                          `which ${
                            isSingleNode ? "is" : "are"
                        } not included in the Client's node list. Please review your Client configuration.`,
                  );
              }
          }

          // The retry loop
          for (let attempt = 1; attempt <= maxAttempts; attempt += 1) {
              // Determine if we've exceeded request timeout
              if (
                  this._requestTimeout != null &&
                  startTime + this._requestTimeout <= Date.now()
              ) {
                  throw new MaxAttemptsOrTimeoutError(
                      `timeout exceeded`,
                      this._nodeAccountIds.isEmpty
                          ? "No node account ID set"
                          : this._nodeAccountIds.current.toString(),
                  );
              }

              let nodeAccountId;
              let node;

              if (this._nodeAccountIds.isEmpty) {
                  node = client._network.getNode();
                  nodeAccountId = node.accountId;
                  this._nodeAccountIds.setList([nodeAccountId]);
              } else {
                  nodeAccountId = this._nodeAccountIds.current;
                  node = client._network.getNode(nodeAccountId);
              }

              if (node == null) {
                  throw new Error(
                      `NodeAccountId not recognized: ${nodeAccountId.toString()}`,
                  );
              }

              if (this.transactionNodeIds.length) {
                  const isNodeAccountIdValid = this.transactionNodeIds.includes(
                      nodeAccountId.toString(),
                  );

                  if (!isNodeAccountIdValid) {
                      console.error(
                          `Attempting to execute a transaction against node ${nodeAccountId.toString()}, which is not included in the Client's node list. Please review your Client configuration.`,
                      );

                      this._nodeAccountIds.advance();
                      continue;
                  }
              }

              // Get the log ID for the request.
              const logId = this._getLogId();
              if (this._logger) {
                  this._logger.debug(
                      `[${logId}] Node AccountID: ${node.accountId.toString()}, IP: ${node.address.toString()}`,
                  );
              }

              const channel = node.getChannel();

              // Set the gRPC deadline on the channel if this query has a custom deadline
              if (this._grpcDeadline != null) {
                  channel.setGrpcDeadline(this._grpcDeadline);
              }

              const request = await this._makeRequestAsync();

              let response;

              if (!node.isHealthy()) {
                  const isLastNode =
                      this._nodeAccountIds.index ===
                      this._nodeAccountIds.list.length - 1;

                  // Check if the request is a transaction receipt or record
                  // request to retry 10 times, because getReceiptQuery/getRecordQuery
                  // are single node requests
                  if (
                      isTransactionReceiptOrRecordRequest(request) ||
                      isLocalNode
                  ) {
                      await delayForAttempt(
                          isLocalNode,
                          attempt,
                          this._minBackoff,
                          this._maxBackoff,
                      );
                      continue;
                  }

                  if (isLastNode || this._nodeAccountIds.length <= 1) {
                      throw new Error(
                          `Network connectivity issue: All nodes are unhealthy. Original node list: ${this._nodeAccountIds.list.join(
                            ", ",
                        )}`,
                      );
                  }

                  if (this._logger) {
                      this._logger.debug(
                          `[${logId}] Node is not healthy, trying the next node.`,
                      );
                  }

                  this._nodeAccountIds.advance();
                  continue;
              }

              this._nodeAccountIds.advance();

              try {
                  // Race the execution promise against the grpc timeout to prevent grpc connections
                  // from blocking this request
                  const promises = [];

                  // If a grpc deadline is set, we should race it, otherwise the only thing in the
                  // list of promises will be the execution promise.
                  if (this._grpcDeadline != null) {
                      promises.push(
                          // eslint-disable-next-line ie11/no-loop-func
                          new Promise((_, reject) =>
                              setTimeout(
                                  // eslint-disable-next-line ie11/no-loop-func
                                  () =>
                                      reject(
                                          new GrpcServiceError(
                                              GrpcStatus.DeadlineExceeded,
                                          ),
                                      ),
                                  /** @type {number=} */ (this._grpcDeadline),
                              ),
                          ),
                      );
                  }
                  if (this._logger) {
                      this._logger.trace(
                          `[${this._getLogId()}] sending protobuf ${encode$5(
                            this._requestToBytes(request),
                        )}`,
                      );
                  }

                  promises.push(this._execute(channel, request));
                  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                  response = /** @type {ResponseT} */ (
                      await Promise.race(promises)
                  );
              } catch (err) {
                  // If we received a grpc status error we need to determine if
                  // we should retry on this error, or err from the request entirely.
                  const error = GrpcServiceError._fromResponse(
                      /** @type {Error} */ (err),
                  );

                  // Save the error in case we retry
                  persistentError = error;
                  if (this._logger) {
                      this._logger.debug(
                          `[${logId}] received error ${JSON.stringify(error)}`,
                      );
                  }

                  if (
                      (error instanceof GrpcServiceError ||
                          error instanceof HttpError) &&
                      this._shouldRetryExceptionally(error) &&
                      attempt <= maxAttempts
                  ) {
                      // Increase the backoff for the particular node and remove it from
                      // the healthy node list
                      if (this._logger) {
                          this._logger.debug(
                              `[${this._getLogId()}] node with accountId: ${node.accountId.toString()} and proxy IP: ${node.address.toString()} is unhealthy`,
                          );
                      }

                      client._network.increaseBackoff(node);
                      continue;
                  }

                  throw err;
              }
              if (this._logger) {
                  this._logger.trace(
                      `[${this._getLogId()}] sending protobuf ${encode$5(
                        this._responseToBytes(response),
                    )}`,
                  );
              }

              // If we didn't receive an error we should decrease the current nodes backoff
              // in case it is a recovering node
              client._network.decreaseBackoff(node);

              // Determine what execution state we're in by the response
              // For transactions this would be as simple as checking the response status is `OK`
              // while for _most_ queries it would check if the response status is `SUCCESS`
              // The only odd balls are `TransactionReceiptQuery` and `TransactionRecordQuery`
              const [status, shouldRetry] = this._shouldRetry(request, response);
              if (
                  status.toString() !== Status.Ok.toString() &&
                  status.toString() !== Status.Success.toString()
              ) {
                  persistentError = status;
              }

              // Determine by the executing state what we should do
              switch (shouldRetry) {
                  case ExecutionState.Retry:
                      await delayForAttempt(
                          isLocalNode,
                          attempt,
                          this._minBackoff,
                          this._maxBackoff,
                      );
                      continue;
                  case ExecutionState.Finished:
                      return this._mapResponse(response, nodeAccountId, request);
                  case ExecutionState.Error:
                      throw this._mapStatusError(
                          request,
                          response,
                          nodeAccountId,
                      );
                  default:
                      throw new Error(
                          "(BUG) non-exhaustive switch statement for `ExecutionState`",
                      );
              }
          }

          // We'll only get here if we've run out of attempts, so we return an error wrapping the
          // persistent error we saved before.

          throw new MaxAttemptsOrTimeoutError(
              `max attempts of ${maxAttempts.toString()} was reached for request with last error being: ${
                persistentError != null ? persistentError.toString() : ""
            }`,
              this._nodeAccountIds.current.toString(),
          );
      }

      /**
       * The current purpose of this method is to easily support signature providers since
       * signature providers need to serialize _any_ request into bytes. `Query` and `Transaction`
       * already implement `toBytes()` so it only made sense to make it available here too.
       *
       * @abstract
       * @returns {Uint8Array}
       */
      toBytes() {
          throw new Error("not implemented");
      }

      /**
       * Set logger
       *
       * @param {Logger} logger
       * @returns {this}
       */
      setLogger(logger) {
          this._logger = logger;
          return this;
      }

      /**
       * Get logger if set
       *
       * @returns {?Logger}
       */
      get logger() {
          return this._logger;
      }
  }

  /**
   * Checks if the request is a transaction receipt or record request
   *
   * @template T
   * @param {T} request - The request to check
   * @returns {boolean} - True if the request is a transaction receipt or record
   */
  function isTransactionReceiptOrRecordRequest(request) {
      if (typeof request !== "object" || request === null) {
          return false;
      }

      return (
          "transactionGetReceipt" in request || "transactionGetRecord" in request
      );
  }

  /**
   * A simple function that returns a promise timeout for a specific period of time
   *
   * @param {boolean} isLocalNode
   * @param {number} attempt
   * @param {number} minBackoff
   * @param {number} maxBackoff
   * @returns {Promise<void>}
   */
  function delayForAttempt(isLocalNode, attempt, minBackoff, maxBackoff) {
      if (isLocalNode) {
          return new Promise((resolve) => setTimeout(resolve, minBackoff));
      }

      // 0.1s, 0.2s, 0.4s, 0.8s, ...
      const ms = Math.min(
          Math.floor(minBackoff * Math.pow(2, attempt)),
          maxBackoff,
      );
      return new Promise((resolve) => setTimeout(resolve, ms));
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {import("./Status.js").default} Status
   * @typedef {import("./transaction/TransactionId.js").default} TransactionId
   * @typedef {import("./contract/ContractFunctionResult.js").default} ContractFunctionResult
   * @typedef {import("./account/AccountId.js").default} AccountId
   */

  /**
   * @typedef {object} PrecheckStatusErrorJSON
   * @property {string} name
   * @property {string} status
   * @property {string} transactionId
   * @property {?string | null} nodeId
   * @property {string} message
   * @property {?ContractFunctionResult} contractFunctionResult
   */

  /**
   * Represents an error that occurs during the pre-check phase of a transaction
   * on the Hedera network. The `PrecheckStatusError` class extends the base
   * `StatusError` class and provides additional context specific to pre-check
   * failures, such as the transaction ID, status, and any associated messages.
   *
   * This error is typically thrown when a transaction fails to meet the necessary
   * conditions before being processed, allowing developers to handle such errors
   * gracefully in their applications. The error includes details about the failure,
   * making it easier to diagnose issues related to transaction submissions.
   */
  class PrecheckStatusError extends StatusError {
      /**
       * @param {object} props
       * @param {Status} props.status
       * @param {TransactionId} props.transactionId
       * @param {AccountId} props.nodeId
       * @param {?ContractFunctionResult} props.contractFunctionResult
       */
      constructor(props) {
          super(
              props,
              `transaction ${props.transactionId.toString()} failed precheck with status ${props.status.toString()} against node account id ${props.nodeId.toString()}`,
          );

          /**
           * @type {?ContractFunctionResult}
           * @readonly
           */
          this.contractFunctionResult = props.contractFunctionResult;

          /**
           * @type {AccountId}
           * @readonly
           */
          this.nodeId = props.nodeId;
      }

      /**
       * @returns {PrecheckStatusErrorJSON}
       */
      toJSON() {
          return {
              name: this.name,
              status: this.status.toString(),
              transactionId: this.transactionId.toString(),
              nodeId: this.nodeId.toString(),
              message: this.message,
              contractFunctionResult: this.contractFunctionResult,
          };
      }
  }

  // SPDX-License-Identifier: Apache-2.0

  /**
   * @typedef {import("./Hbar.js").default} Hbar
   */

  /**
   * Error thrown when a query's cost exceeds the maximum payment amount set on the client.
   *
   * This error is used to prevent unexpectedly expensive queries from being automatically executed.
   * When this error occurs, the user can either:
   * 1. Increase the maximum query payment on the client
   * 2. Explicitly approve the higher cost for this specific query
   */
  class MaxQueryPaymentExceeded extends Error {
      /**
       * @param {Hbar} queryCost
       * @param {Hbar} maxQueryPayment
       */
      constructor(queryCost, maxQueryPayment) {
          super();

          this.message = `query cost of ${queryCost.toString()} HBAR exceeds max set on client: ${maxQueryPayment.toString()} HBAR`;
          this.name = "MaxQueryPaymentExceededError";
          this.queryCost = queryCost;
          this.maxQueryPayment = maxQueryPayment;
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   * @typedef {import("../Status.js").default} Status
   * @typedef {import("../Executable.js").ExecutionState} ExecutionState
   * @typedef {import("../client/Client.js").ClientOperator} ClientOperator
   * @typedef {import("../PublicKey.js").default} PublicKey
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("../logger/Logger.js").default} Logger
   */

  /**
   * Base class for all query-related functionality that can be shared between Query and CostQuery.
   *
   * @abstract
   * @template RequestT
   * @template ResponseT
   * @template OutputT
   * @augments {Executable<RequestT, ResponseT, OutputT>}
   */
  class QueryBase extends Executable {
      constructor() {
          super();
      }

      /**
       * Create a payment transaction for a query
       *
       * @param {TransactionId} paymentTransactionId
       * @param {AccountId} nodeId
       * @param {?ClientOperator} operator
       * @param {Hbar} paymentAmount
       * @returns {Promise<HieroProto.proto.ITransaction>}
       */
      async _makePaymentTransaction(
          paymentTransactionId,
          nodeId,
          operator,
          paymentAmount,
      ) {
          const accountAmounts = [];

          // If an operator is provided then we should make sure we transfer
          // from the operator to the node.
          // If an operator is not provided we simply create an effectively
          // empty account amounts
          if (operator != null) {
              accountAmounts.push({
                  accountID: operator.accountId._toProtobuf(),
                  amount: paymentAmount.negated().toTinybars(),
              });
              accountAmounts.push({
                  accountID: nodeId._toProtobuf(),
                  amount: paymentAmount.toTinybars(),
              });
          } else {
              accountAmounts.push({
                  accountID: new AccountId(0)._toProtobuf(),
                  amount: paymentAmount.negated().toTinybars(),
              });
              accountAmounts.push({
                  accountID: nodeId._toProtobuf(),
                  amount: paymentAmount.toTinybars(),
              });
          }

          /**
           * @type {HieroProto.proto.ITransactionBody}
           */
          const body = {
              transactionID: paymentTransactionId._toProtobuf(),
              nodeAccountID: nodeId._toProtobuf(),
              transactionFee: new Hbar(1).toTinybars(),
              transactionValidDuration: {
                  seconds: Long.fromNumber(120),
              },
              cryptoTransfer: {
                  transfers: {
                      accountAmounts,
                  },
              },
          };

          /** @type {HieroProto.proto.ISignedTransaction} */
          const signedTransaction = {
              bodyBytes: libExports.proto.TransactionBody.encode(body).finish(),
          };

          // Sign the transaction if an operator is provided
          if (operator != null) {
              const signature = await operator.transactionSigner(
                  /** @type {Uint8Array} */ (signedTransaction.bodyBytes),
              );

              signedTransaction.sigMap = {
                  sigPair: [operator.publicKey._toProtobufSignature(signature)],
              };
          }

          // Create and return a `proto.Transaction`
          return {
              signedTransactionBytes:
                  libExports.proto.SignedTransaction.encode(
                      signedTransaction,
                  ).finish(),
          };
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../Status.js").default} Status
   * @typedef {import("../Executable.js").ExecutionState} ExecutionState
   */

  /**
   * @template OutputT
   * @augments {QueryBase<HieroProto.proto.IQuery, HieroProto.proto.IResponse, Hbar>}
   */
  class CostQuery extends QueryBase {
      /**
       * @param {import("./Query.js").default<OutputT>} query
       */
      constructor(query) {
          super();

          this._query = query;
          this._grpcDeadline = query._grpcDeadline;
          this._requestTimeout = query._requestTimeout;
          this._nodeAccountIds = query._nodeAccountIds.clone();
          this._operator = query._operator;

          /**
           * @type {HieroProto.proto.IQueryHeader | null}
           */
          this._header = null;
      }

      /**
       * @returns {TransactionId}
       */
      _getTransactionId() {
          return this._query._getTransactionId();
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          return `CostQuery:${this._query._getLogId()}`;
      }

      /**
       * @abstract
       * @protected
       * @param {import("../client/Client.js").default<*, *>} client
       * @returns {Promise<void>}
       */
      async _beforeExecute(client) {
          if (client == null) {
              throw new Error("Cannot do CostQuery without Client");
          }

          const operator =
              this._operator != null ? this._operator : client._operator;

          if (operator == null) {
              throw new Error(
                  "`client` must have an `operator` or an explicit payment transaction must be provided",
              );
          }

          if (this._query._nodeAccountIds.isEmpty) {
              this._query._nodeAccountIds.setList(
                  client._network.getNodeAccountIdsForExecute(),
              );
          }

          // operator.accountId
          const transactionId = TransactionId.generate(operator.accountId);
          if (this._query.paymentTransactionId == null) {
              this._query.setPaymentTransactionId(transactionId);
          }

          const logId = this._getLogId();
          const nodeId = new AccountId(0);
          const paymentTransactionId =
              /** @type {import("../transaction/TransactionId.js").default} */
              (TransactionId.generate(new AccountId(0)));
          const paymentAmount = new Hbar(0);
          if (this._logger) {
              this._logger.debug(
                  `[${logId}] making a payment transaction for node ${nodeId.toString()} and transaction ID ${paymentTransactionId.toString()} with amount ${paymentAmount.toString()}`,
              );
          }

          this._header = {
              payment: await this._makePaymentTransaction(
                  paymentTransactionId,
                  new AccountId(0),
                  operator,
                  paymentAmount,
              ),
              responseType: libExports.proto.ResponseType.COST_ANSWER,
          };
      }

      /**
       * @abstract
       * @internal
       * @returns {Promise<HieroProto.proto.IQuery>}
       */
      _makeRequestAsync() {
          return Promise.resolve(
              this._query._onMakeRequest(
                  /** @type {HieroProto.proto.IQueryHeader} */ (this._header),
              ),
          );
      }

      /**
       * @abstract
       * @internal
       * @param {HieroProto.proto.IQuery} request
       * @param {HieroProto.proto.IResponse} response
       * @returns {[Status, ExecutionState]}
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _shouldRetry(request, response) {
          return this._query._shouldRetry(request, response);
      }

      /**
       * @abstract
       * @internal
       * @param {HieroProto.proto.IQuery} request
       * @param {HieroProto.proto.IResponse} response
       * @param {AccountId} nodeId
       * @returns {Error}
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _mapStatusError(request, response, nodeId) {
          return this._query._mapStatusError(request, response, nodeId);
      }

      /**
       * @override
       * @internal
       * @param {HieroProto.proto.IResponse} response
       * @param {AccountId} nodeAccountId
       * @param {HieroProto.proto.IQuery} request
       * @returns {Promise<Hbar>}
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _mapResponse(response, nodeAccountId, request) {
          const cost = this._query._mapResponseHeader(response).cost;
          return Promise.resolve(
              Hbar.fromTinybars(/** @type {Long | number} */ (cost)),
          );
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.IQuery} request
       * @returns {Promise<HieroProto.proto.IResponse>}
       */
      _execute(channel, request) {
          return this._query._execute(channel, request);
      }

      /**
       * @param {HieroProto.proto.Query} request
       * @returns {Uint8Array}
       */
      _requestToBytes(request) {
          return this._query._requestToBytes(request);
      }

      /**
       * @param {HieroProto.proto.Response} response
       * @returns {Uint8Array}
       */
      _responseToBytes(response) {
          return this._query._responseToBytes(response);
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../channel/MirrorChannel.js").default} MirrorChannel
   * @typedef {import("../PublicKey.js").default} PublicKey
   * @typedef {import("../client/Client.js").ClientOperator} ClientOperator
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("../logger/Logger.js").default} Logger
   */

  /**
   * This registry holds a bunch of callbacks for `fromProtobuf()` implementations
   * Since this is essentially aa cache, perhaps we should move this variable into the `Cache`
   * type for consistency?
   *
   * @type {Map<HieroProto.proto.Query["query"], (query: HieroProto.proto.IQuery) => Query<*>>}
   */
  const QUERY_REGISTRY = new Map();

  /**
   * Base class for all queries that can be submitted to Hedera.
   *
   * @abstract
   * @template OutputT
   * @augments {QueryBase<HieroProto.proto.IQuery, HieroProto.proto.IResponse, OutputT>}
   */
  class Query extends QueryBase {
      constructor() {
          super();

          /**
           * The payment transaction ID
           *
           * @type {?TransactionId}
           */
          this._paymentTransactionId = null;

          /**
           * The payment transactions list where each index points to a different node
           *
           * @type {HieroProto.proto.ITransaction[]}
           */
          this._paymentTransactions = [];

          /**
           * The amount being paid to the node for this query.
           * A user can set this field explicitly, or we'll query the value during execution.
           *
           * @type {?Hbar}
           */
          this._queryPayment = null;

          /**
           * The maximum query payment a user is willing to pay. Unlike `Transaction.maxTransactionFee`
           * this field only exists in the SDK; there is no protobuf field equivalent. If and when
           * we query the actual cost of the query and the cost is greater than the max query payment
           * we'll throw a `MaxQueryPaymentExceeded` error.
           *
           * @type {?Hbar}
           */
          this._maxQueryPayment = null;

          /**
           * This is strictly used for `_getLogId()` which requires a timestamp. The timestamp it typically
           * uses comes from the payment transaction ID, but that field is not set if this query is free.
           * For those occasions we use this timestamp field generated at query construction instead.
           *
           * @type {number}
           */
          this._timestamp = Date.now();
      }

      /**
       * Deserialize a query from bytes. The bytes should be a `proto.Query`.
       *
       * @template T
       * @param {Uint8Array} bytes
       * @returns {Query<T>}
       */
      static fromBytes(bytes) {
          const query = libExports.proto.Query.decode(bytes);

          if (query.query == null) {
              throw new Error("(BUG) query.query was not set in the protobuf");
          }

          const fromProtobuf =
              /** @type {(query: HieroProto.proto.IQuery) => Query<T>} */ (
                  QUERY_REGISTRY.get(query.query)
              );

          if (fromProtobuf == null) {
              throw new Error(
                  `(BUG) Query.fromBytes() not implemented for type ${query.query}`,
              );
          }

          return fromProtobuf(query);
      }

      /**
       * Serialize the query into bytes.
       *
       * **NOTE**: Does not preserve payment transactions
       *
       * @returns {Uint8Array}
       */
      toBytes() {
          return libExports.proto.Query.encode(this._makeRequest()).finish();
      }

      /**
       * Set an explicit payment amount for this query.
       *
       * The client will submit exactly this amount for the payment of this query. Hedera
       * will not return any remainder.
       *
       * @param {Hbar} queryPayment
       * @returns {this}
       */
      setQueryPayment(queryPayment) {
          this._queryPayment = queryPayment;

          return this;
      }

      /**
       * Set the maximum payment allowable for this query.
       *
       * @param {Hbar} maxQueryPayment
       * @returns {this}
       */
      setMaxQueryPayment(maxQueryPayment) {
          this._maxQueryPayment = maxQueryPayment;

          return this;
      }

      /**
       * Fetch the cost of this query from a consensus node
       *
       * @param {import("../client/Client.js").default<Channel, *>} client
       * @returns {Promise<Hbar>}
       */
      async getCost(client) {
          // The node account IDs must be set to execute a cost query
          if (this._nodeAccountIds.isEmpty) {
              this._nodeAccountIds.setList(
                  client._network.getNodeAccountIdsForExecute(),
              );
          }

          // Change the timestamp. Should we be doing this?
          this._timestamp = Date.now();
          const cost = await new CostQuery(this).execute(client);
          return Hbar.fromTinybars(
              cost._valueInTinybar.multipliedBy(1.1).toFixed(0),
          );
      }

      /**
       * Set he payment transaction explicitly
       *
       * @param {TransactionId} paymentTransactionId
       * @returns {this}
       */
      setPaymentTransactionId(paymentTransactionId) {
          this._paymentTransactionId = paymentTransactionId;
          return this;
      }

      /**
       * Get the payment transaction ID
       *
       * @returns {?TransactionId}
       */
      get paymentTransactionId() {
          return this._paymentTransactionId;
      }

      /**
       * Get the current transaction ID, and make sure it's not null
       *
       * @returns {TransactionId}
       */
      _getTransactionId() {
          if (this._paymentTransactionId == null) {
              throw new Error(
                  "Query.PaymentTransactionId was not set duration execution",
              );
          }

          return this._paymentTransactionId;
      }

      /**
       * Is payment required for this query. By default most queries require payment
       * so the default implementation returns true.
       *
       * @protected
       * @returns {boolean}
       */
      _isPaymentRequired() {
          return true;
      }

      /**
       * Validate checksums of the query.
       *
       * @param {Client} client
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars,@typescript-eslint/no-empty-function
      _validateChecksums(client) {
          // Shouldn't we be checking `paymentTransactionId` here sine it contains an `accountId`?
          // Do nothing
      }

      /**
       * Before we proceed exeuction, we need to do a couple checks
       *
       * @template {MirrorChannel} MirrorChannelT
       * @param {import("../client/Client.js").default<Channel, MirrorChannelT>} client
       * @returns {Promise<void>}
       */
      async _beforeExecute(client) {
          // If we're executing this query multiple times the the payment transaction ID list
          // will already be set
          if (this._paymentTransactions.length > 0) {
              return;
          }

          // Check checksums if enabled
          if (client.isAutoValidateChecksumsEnabled()) {
              this._validateChecksums(client);
          }

          // If the nodes aren't set, set them.
          if (this._nodeAccountIds.isEmpty) {
              this._nodeAccountIds.setList(
                  client._network.getNodeAccountIdsForExecute(),
              );
          }

          // Save the operator
          this._operator =
              this._operator != null ? this._operator : client._operator;

          // And payment is required
          if (this._isPaymentRequired()) {
              // Assign the account IDs to which the transaction should be sent.
              this.transactionNodeIds = Object.values(client.network).map(
                  (accountNodeId) => accountNodeId.toString(),
              );

              // And the client has an operator
              if (this._operator != null) {
                  // Generate the payment transaction ID
                  this._paymentTransactionId = TransactionId.generate(
                      this._operator.accountId,
                  );
              } else {
                  // If payment is required, but an operator did not exist, throw an error
                  throw new Error(
                      "`client` must have an `operator` or an explicit payment transaction must be provided",
                  );
              }
          } else {
              // If the payment transaction ID is not set, but this query doesn't require a payment
              // set the payment transaction ID to an empty transaction ID.
              // FIXME: Should use `TransactionId.withValidStart()` instead
              this._paymentTransactionId = TransactionId.generate(
                  new AccountId(0),
              );
          }

          let cost = new Hbar(0);

          const maxQueryPayment =
              this._maxQueryPayment != null
                  ? this._maxQueryPayment
                  : client.defaultMaxQueryPayment;

          if (this._queryPayment != null) {
              cost = this._queryPayment;
          } else if (
              this._paymentTransactions.length === 0 &&
              this._isPaymentRequired()
          ) {
              // If the query payment was not explictly set, fetch the actual cost.
              const actualCost = await this.getCost(client);

              // Confirm it's less than max query payment
              if (
                  maxQueryPayment.toTinybars().toInt() <
                  actualCost.toTinybars().toInt()
              ) {
                  throw new MaxQueryPaymentExceeded(actualCost, maxQueryPayment);
              }

              cost = actualCost;
              if (this._logger) {
                  this._logger.debug(
                      `[${this._getLogId()}] received cost for query ${cost.toString()}`,
                  );
              }
          }

          // Set the either queried cost, or the original value back into `queryPayment`
          // in case a user executes same query multiple times. However, users should
          // really not be executing the same query multiple times meaning this is
          // typically not needed.
          this._queryPayment = cost;

          // Not sure if we should be overwritting this field tbh.
          this._timestamp = Date.now();

          this._nodeAccountIds.setLocked();

          // Generate the payment transactions
          for (const nodeId of this._nodeAccountIds.list) {
              const logId = this._getLogId();
              const paymentTransactionId =
                  /** @type {import("../transaction/TransactionId.js").default} */ (
                      this._paymentTransactionId
                  );
              const paymentAmount = /** @type {Hbar} */ (this._queryPayment);

              if (this._logger) {
                  this._logger.debug(
                      `[${logId}] making a payment transaction for node ${nodeId.toString()} and transaction ID ${paymentTransactionId.toString()} with amount ${paymentAmount.toString()}`,
                  );
              }

              this._paymentTransactions.push(
                  await this._makePaymentTransaction(
                      paymentTransactionId,
                      nodeId,
                      this._isPaymentRequired() ? this._operator : null,
                      paymentAmount,
                  ),
              );
          }
      }

      /**
       * @abstract
       * @internal
       * @param {HieroProto.proto.IResponse} response
       * @returns {HieroProto.proto.IResponseHeader}
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _mapResponseHeader(response) {
          throw new Error("not implemented");
      }

      /**
       * @protected
       * @returns {HieroProto.proto.IQueryHeader}
       */
      _makeRequestHeader() {
          /** @type {HieroProto.proto.IQueryHeader} */
          let header = {};

          if (this._isPaymentRequired() && this._paymentTransactions.length > 0) {
              header = {
                  responseType: libExports.proto.ResponseType.ANSWER_ONLY,
                  payment: this._paymentTransactions[this._nodeAccountIds.index],
              };
          }

          return header;
      }

      /**
       * @abstract
       * @internal
       * @param {HieroProto.proto.IQueryHeader} header
       * @returns {HieroProto.proto.IQuery}
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _onMakeRequest(header) {
          throw new Error("not implemented");
      }

      /**
       * @internal
       * @returns {HieroProto.proto.IQuery}
       */
      _makeRequest() {
          /** @type {HieroProto.proto.IQueryHeader} */
          let header = {};

          if (this._isPaymentRequired() && this._paymentTransactions != null) {
              header = {
                  payment: this._paymentTransactions[this._nodeAccountIds.index],
                  responseType: libExports.proto.ResponseType.ANSWER_ONLY,
              };
          }

          return this._onMakeRequest(header);
      }

      /**
       * @override
       * @internal
       * @returns {Promise<HieroProto.proto.IQuery>}
       */
      async _makeRequestAsync() {
          /** @type {HieroProto.proto.IQueryHeader} */
          let header = {
              responseType: libExports.proto.ResponseType.ANSWER_ONLY,
          };

          const logId = this._getLogId();
          const nodeId = this._nodeAccountIds.current;
          const paymentTransactionId = TransactionId.generate(
              this._operator ? this._operator.accountId : new AccountId(0),
          );
          const paymentAmount = /** @type {Hbar} */ (this._queryPayment);

          if (this._logger) {
              this._logger.debug(
                  `[${logId}] making a payment transaction for node ${nodeId.toString()} and transaction ID ${paymentTransactionId.toString()} with amount ${paymentAmount.toString()}`,
              );
          }

          header.payment = await this._makePaymentTransaction(
              paymentTransactionId,
              nodeId,
              this._isPaymentRequired() ? this._operator : null,
              paymentAmount,
          );

          return this._onMakeRequest(header);
      }

      /**
       * @override
       * @internal
       * @param {HieroProto.proto.IQuery} request
       * @param {HieroProto.proto.IResponse} response
       * @returns {[Status, ExecutionState]}
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _shouldRetry(request, response) {
          const { nodeTransactionPrecheckCode } =
              this._mapResponseHeader(response);

          const status = Status._fromCode(
              nodeTransactionPrecheckCode != null
                  ? nodeTransactionPrecheckCode
                  : libExports.proto.ResponseCodeEnum.OK,
          );
          if (this._logger) {
              this._logger.debug(
                  `[${this._getLogId()}] received status ${status.toString()}`,
              );
          }

          switch (status) {
              case Status.Busy:
              case Status.Unknown:
              case Status.PlatformTransactionNotCreated:
              case Status.PlatformNotActive:
                  return [status, ExecutionState.Retry];
              case Status.Ok:
                  return [status, ExecutionState.Finished];
              default:
                  return [status, ExecutionState.Error];
          }
      }

      /**
       * @override
       * @internal
       * @param {HieroProto.proto.IQuery} request
       * @param {HieroProto.proto.IResponse} response
       * @param {AccountId} nodeId
       * @returns {Error}
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _mapStatusError(request, response, nodeId) {
          const { nodeTransactionPrecheckCode } =
              this._mapResponseHeader(response);

          const status = Status._fromCode(
              nodeTransactionPrecheckCode != null
                  ? nodeTransactionPrecheckCode
                  : libExports.proto.ResponseCodeEnum.OK,
          );

          return new PrecheckStatusError({
              nodeId,
              status,
              transactionId: this._getTransactionId(),
              contractFunctionResult: null,
          });
      }

      /**
       * @param {HieroProto.proto.Query} request
       * @returns {Uint8Array}
       */
      _requestToBytes(request) {
          return libExports.proto.Query.encode(request).finish();
      }

      /**
       * @param {HieroProto.proto.Response} response
       * @returns {Uint8Array}
       */
      _responseToBytes(response) {
          return libExports.proto.Response.encode(response).finish();
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {import("../client/Client.js").default<*, *>} Client
   */

  /**
   * The ID for a crypto-currency contract on Hedera.
   */
  class ContractId extends Key {
      /**
       * @param {number | Long | import("../EntityIdHelper").IEntityId} props
       * @param {(number | Long)=} realm
       * @param {(number | Long)=} num
       * @param {Uint8Array=} evmAddress
       */
      constructor(props, realm, num, evmAddress) {
          super();

          const result = constructor(props, realm, num);

          this.shard = result.shard;
          this.realm = result.realm;
          this.num = result.num;

          this.evmAddress = evmAddress != null ? evmAddress : null;

          /**
           * @type {string | null}
           */
          this._checksum = null;
      }

      /**
       * @description This handles both long-zero format and evm address format addresses.
       * If an actual evm address is passed, please use `ContractId.populateAccountNum(client)` method
       * to get the actual `num` value, since there is no cryptographic relation to the evm address
       * and cannot be populated directly
       * @param {Long | number} shard
       * @param {Long | number} realm
       * @param {string} evmAddress
       * @returns {ContractId}
       */
      static fromEvmAddress(shard, realm, evmAddress) {
          const evmAddressObj = EvmAddress.fromString(evmAddress);

          const [shardLong, realmLong, num, address] =
              fromEvmAddress(
                  shard,
                  realm,
                  evmAddressObj.toString(),
              );

          return new ContractId(shardLong, realmLong, num, address?.toBytes());
      }

      /**
       * @param {string} text
       * @returns {ContractId}
       */
      static fromString(text) {
          const result = fromStringSplitter(text);

          if (Number.isNaN(result.shard) || Number.isNaN(result.realm)) {
              throw new Error("invalid format for entity ID");
          }

          const shard =
              result.shard != null ? Long.fromString(result.shard) : Long.ZERO;
          const realm =
              result.realm != null ? Long.fromString(result.realm) : Long.ZERO;
          const [num, evmAddress] =
              result.numOrHex.length < 40
                  ? [Long.fromString(result.numOrHex), undefined]
                  : [Long.ZERO, decode$8(result.numOrHex)];

          return new ContractId(shard, realm, num, evmAddress);
      }

      /**
       * @internal
       * @param {HieroProto.proto.IContractID} id
       * @returns {ContractId}
       */
      static _fromProtobuf(id) {
          const contractId = new ContractId(
              id.shardNum != null ? id.shardNum : 0,
              id.realmNum != null ? id.realmNum : 0,
              id.contractNum != null ? id.contractNum : 0,
          );

          return contractId;
      }

      /**
       * @returns {string | null}
       */
      get checksum() {
          return this._checksum;
      }

      /**
       * @description Gets the actual `num` field of the `ContractId` from the Mirror Node.
       * Should be used after generating `ContractId.fromEvmAddress()` because it sets the `num` field to `0`
       * automatically since there is no connection between the `num` and the `evmAddress`
       * @param {Client} client
       * @returns {Promise<ContractId>}
       */
      async populateAccountNum(client) {
          const mirrorRestApiBaseUrl = client.mirrorRestApiBaseUrl;
          const url = `${mirrorRestApiBaseUrl}/contracts/${this.toEvmAddress()}`;

          /* eslint-disable */
          const response = await fetch(url);
          const data = await response.json();
          const mirrorAccountId = data.contract_id;

          this.num = Long.fromString(
              mirrorAccountId.slice(mirrorAccountId.lastIndexOf(".") + 1),
          );
          /* eslint-enable */

          return this;
      }

      /**
       * @deprecated - Use `validateChecksum` instead
       * @param {Client} client
       */
      validate(client) {
          console.warn("Deprecated: Use `validateChecksum` instead");
          this.validateChecksum(client);
      }

      /**
       * @param {Client} client
       */
      validateChecksum(client) {
          validateChecksum(
              this.shard,
              this.realm,
              this.num,
              this._checksum,
              client,
          );
      }

      /**
       * @param {Uint8Array} bytes
       * @returns {ContractId}
       */
      static fromBytes(bytes) {
          return ContractId._fromProtobuf(
              libExports.proto.ContractID.decode(bytes),
          );
      }

      /**
       * @deprecated - Use `fromEvmAddress` instead
       * @param {string} address
       * @returns {ContractId}
       */
      static fromSolidityAddress(address) {
          // eslint-disable-next-line @typescript-eslint/no-unsafe-call
          if (isLongZeroAddress(decode$8(address))) {
              return new ContractId(
                  ...fromSolidityAddress(address),
              );
          } else {
              return this.fromEvmAddress(0, 0, address);
          }
      }

      /**
       * @deprecated - Use `toEvmAddress` instead
       * @returns {string}
       */
      toSolidityAddress() {
          if (this.evmAddress != null) {
              return encode$5(this.evmAddress);
          } else {
              return toSolidityAddress([
                  this.shard,
                  this.realm,
                  this.num,
              ]);
          }
      }

      /**
       * @returns {string} EVM-compatible address representation of the entity
       */
      toEvmAddress() {
          if (this.evmAddress != null) {
              return toEvmAddress(this.evmAddress);
          }

          return toEvmAddress(this.num);
      }
      /**
       * @internal
       * @returns {HieroProto.proto.IContractID}
       */
      _toProtobuf() {
          return {
              contractNum: this.num,
              shardNum: this.shard,
              realmNum: this.realm,
              evmAddress: this.evmAddress,
          };
      }

      /**
       * @returns {string}
       */
      toString() {
          if (this.evmAddress != null) {
              return `${this.shard.toString()}.${this.realm.toString()}.${encode$5(
                this.evmAddress,
            )}`;
          } else {
              return `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}`;
          }
      }

      /**
       * @param {Client} client
       * @returns {string}
       */
      toStringWithChecksum(client) {
          return toStringWithChecksum(this.toString(), client);
      }

      /**
       * @returns {Uint8Array}
       */
      toBytes() {
          return libExports.proto.ContractID.encode(this._toProtobuf()).finish();
      }

      /**
       * @returns {ContractId}
       */
      clone() {
          const id = new ContractId(this);
          id._checksum = this._checksum;
          id.evmAddress = this.evmAddress;
          return id;
      }

      /**
       * @param {ContractId} other
       * @returns {number}
       */
      compare(other) {
          return compare(
              [this.shard, this.realm, this.num],
              [other.shard, other.realm, other.num],
          );
      }

      /**
       * @param {this} other
       * @returns {boolean}
       */
      equals(other) {
          let evmAddresses = false;
          if (this.evmAddress != null && other.evmAddress != null) {
              evmAddresses = arrayEqual(this.evmAddress, other.evmAddress);
          }

          return (
              this.shard.eq(other.shard) &&
              this.realm.eq(other.realm) &&
              this.num.eq(other.num) &&
              evmAddresses
          );
      }

      /**
       * @returns {HieroProto.proto.IKey}
       */
      _toProtobufKey() {
          return {
              contractID: this._toProtobuf(),
          };
      }

      /**
       * @param {HieroProto.proto.IContractID} key
       * @returns {ContractId}
       */
      static __fromProtobufKey(key) {
          return ContractId._fromProtobuf(key);
      }
  }

  CACHE.setContractId((key) => ContractId.__fromProtobufKey(key));

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {import("../client/Client.js").default<*, *>} Client
   */

  /**
   * The ID for a crypto-currency file on Hedera.
   */
  class FileId {
      /**
       * @param {number | Long | import("../EntityIdHelper").IEntityId} props
       * @param {(number | Long)=} realm
       * @param {(number | Long)=} num
       */
      constructor(props, realm, num) {
          const result = constructor(props, realm, num);

          this.shard = result.shard;
          this.realm = result.realm;
          this.num = result.num;

          /**
           * @type {string | null}
           */
          this._checksum = null;
      }

      /**
       * @param {number} shard
       * @param {number} realm
       * @returns {FileId}
       */
      static getAddressBookFileIdFor(shard = 0, realm = 0) {
          return new FileId({ num: 102, shard, realm });
      }

      /**
       * @param {number} shard
       * @param {number} realm
       * @returns {FileId}
       */
      static getFeeScheduleFileIdFor(shard = 0, realm = 0) {
          return new FileId({ num: 111, shard, realm });
      }

      /**
       * @param {number} shard
       * @param {number} realm
       * @returns {FileId}
       */
      static getExchangeRatesFileIdFor(shard = 0, realm = 0) {
          return new FileId({ num: 112, shard, realm });
      }

      /**
       * @param {string} text
       * @returns {FileId}
       */
      static fromString(text) {
          const result = fromString(text);
          const id = new FileId(result);
          id._checksum = result.checksum;
          return id;
      }

      /**
       * @internal
       * @param {HieroProto.proto.IFileID} id
       * @returns {FileId}
       */
      static _fromProtobuf(id) {
          const fileId = new FileId(
              id.shardNum != null ? Long.fromString(id.shardNum.toString()) : 0,
              id.realmNum != null ? Long.fromString(id.realmNum.toString()) : 0,
              id.fileNum != null ? Long.fromString(id.fileNum.toString()) : 0,
          );

          return fileId;
      }

      /**
       * @returns {string | null}
       */
      get checksum() {
          return this._checksum;
      }

      /**
       * @deprecated - Use `validateChecksum` instead
       * @param {Client} client
       */
      validate(client) {
          console.warn("Deprecated: Use `validateChecksum` instead");
          this.validateChecksum(client);
      }

      /**
       * @param {Client} client
       */
      validateChecksum(client) {
          validateChecksum(
              this.shard,
              this.realm,
              this.num,
              this._checksum,
              client,
          );
      }

      /**
       * @param {Uint8Array} bytes
       * @returns {FileId}
       */
      static fromBytes(bytes) {
          return FileId._fromProtobuf(libExports.proto.FileID.decode(bytes));
      }

      /**
       * @param {string} address
       * @deprecated - Use `fromEvmAddress` instead
       * @returns {FileId}
       */
      static fromSolidityAddress(address) {
          const [shard, realm, file] =
              fromSolidityAddress(address);
          return new FileId(shard, realm, file);
      }

      /**
       * @param {number} shard
       * @param {number} realm
       * @param {string} address
       * @returns {FileId}
       */
      static fromEvmAddress(shard, realm, address) {
          const addressBytes = EvmAddress.fromString(address).toBytes();
          const isLongZero = isLongZeroAddress(addressBytes);

          if (!isLongZero) {
              throw new Error(
                  "FileId.fromEvmAddress does not support non-long-zero addresses",
              );
          }

          const [shardLong, realmLong, fileLong] = fromEvmAddress(
              shard,
              realm,
              address,
          );
          return new FileId(shardLong, realmLong, fileLong);
      }

      /**
       * @deprecated - Use `toEvmAddress` instead
       * @returns {string} solidity address
       */
      toSolidityAddress() {
          return toSolidityAddress([
              this.shard,
              this.realm,
              this.num,
          ]);
      }

      /**
       * @returns {string} EVM-compatible address representation of the entity
       */
      toEvmAddress() {
          return toEvmAddress(this.num);
      }

      /**
       * @internal
       * @returns {HieroProto.proto.IFileID}
       */
      _toProtobuf() {
          return {
              fileNum: this.num,
              shardNum: this.shard,
              realmNum: this.realm,
          };
      }

      /**
       * @returns {string}
       */
      toString() {
          return `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}`;
      }

      /**
       * @param {Client} client
       * @returns {string}
       */
      toStringWithChecksum(client) {
          return toStringWithChecksum(this.toString(), client);
      }

      /**
       * @returns {Uint8Array}
       */
      toBytes() {
          return libExports.proto.FileID.encode(this._toProtobuf()).finish();
      }

      /**
       * @returns {FileId}
       */
      clone() {
          const id = new FileId(this);
          id._checksum = this._checksum;
          return id;
      }

      /**
       * @param {FileId} other
       * @returns {number}
       */
      compare(other) {
          return compare(
              [this.shard, this.realm, this.num],
              [other.shard, other.realm, other.num],
          );
      }
  }

  /**
   * The public node address book for the current network.
   */
  FileId.ADDRESS_BOOK = new FileId(102);

  /**
   * The current fee schedule for the network.
   */
  FileId.FEE_SCHEDULE = new FileId(111);

  /**
   * The current exchange rate of HBAR to USD.
   */
  FileId.EXCHANGE_RATES = new FileId(112);

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {import("long")} Long
   * @typedef {import("../client/Client.js").default<*, *>} Client
   */

  /**
   * Unique identifier for a topic (used by the consensus service).
   */
  class TopicId {
      /**
       * @param {number | Long | import("../EntityIdHelper").IEntityId} props
       * @param {(number | Long)=} realm
       * @param {(number | Long)=} num
       */
      constructor(props, realm, num) {
          const result = constructor(props, realm, num);

          this.shard = result.shard;
          this.realm = result.realm;
          this.num = result.num;

          /**
           * @type {string | null}
           */
          this._checksum = null;
      }

      /**
       * @param {string} text
       * @returns {TopicId}
       */
      static fromString(text) {
          const result = fromString(text);
          const id = new TopicId(result);
          id._checksum = result.checksum;
          return id;
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITopicID} id
       * @returns {TopicId}
       */
      static _fromProtobuf(id) {
          const topicId = new TopicId(
              id.shardNum != null ? id.shardNum : 0,
              id.realmNum != null ? id.realmNum : 0,
              id.topicNum != null ? id.topicNum : 0,
          );

          return topicId;
      }

      /**
       * @returns {string | null}
       */
      get checksum() {
          return this._checksum;
      }

      /**
       * @deprecated - Use `validateChecksum` instead
       * @param {Client} client
       */
      validate(client) {
          console.warn("Deprecated: Use `validateChecksum` instead");
          this.validateChecksum(client);
      }

      /**
       * @param {Client} client
       */
      validateChecksum(client) {
          validateChecksum(
              this.shard,
              this.realm,
              this.num,
              this._checksum,
              client,
          );
      }

      /**
       * @param {Uint8Array} bytes
       * @returns {TopicId}
       */
      static fromBytes(bytes) {
          return TopicId._fromProtobuf(libExports.proto.TopicID.decode(bytes));
      }

      /**
       * @param {string} address
       * @deprecated - Use `fromEvmAddress` instead
       * @returns {TopicId}
       */
      static fromSolidityAddress(address) {
          const [shard, realm, topic] =
              fromSolidityAddress(address);
          return new TopicId(shard, realm, topic);
      }

      /**
       * @param {number} shard
       * @param {number} realm
       * @param {string} address
       * @returns {TopicId}
       */
      static fromEvmAddress(shard, realm, address) {
          const addressBytes = EvmAddress.fromString(address).toBytes();
          const isLongZero = isLongZeroAddress(addressBytes);

          if (!isLongZero) {
              throw new Error(
                  "TopicId.fromEvmAddress does not support non-long-zero addresses",
              );
          }

          const [shardLong, realmLong, topicLong] = fromEvmAddress(
              shard,
              realm,
              address,
          );
          return new TopicId(shardLong, realmLong, topicLong);
      }

      /**
       * @deprecated - Use `toEvmAddress` instead
       * @returns {string}
       */
      toSolidityAddress() {
          return toSolidityAddress([
              this.shard,
              this.realm,
              this.num,
          ]);
      }

      /**
       * @returns {string} EVM-compatible address representation of the entity
       */
      toEvmAddress() {
          return toEvmAddress(this.num);
      }

      /**
       * @returns {HieroProto.proto.ITopicID}
       */
      _toProtobuf() {
          return {
              topicNum: this.num,
              shardNum: this.shard,
              realmNum: this.realm,
          };
      }

      /**
       * @returns {string}
       */
      toString() {
          return `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}`;
      }

      /**
       * @param {Client} client
       * @returns {string}
       */
      toStringWithChecksum(client) {
          return toStringWithChecksum(this.toString(), client);
      }

      /**
       * @returns {Uint8Array}
       */
      toBytes() {
          return libExports.proto.TopicID.encode(this._toProtobuf()).finish();
      }

      /**
       * @returns {TopicId}
       */
      clone() {
          const id = new TopicId(this);
          id._checksum = this._checksum;
          return id;
      }

      /**
       * @param {TopicId} other
       * @returns {number}
       */
      compare(other) {
          return compare(
              [this.shard, this.realm, this.num],
              [other.shard, other.realm, other.num],
          );
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {import("long")} Long
   * @typedef {import("../client/Client.js").default<*, *>} Client
   */

  /**
   * The ID for a crypto-currency token on Hedera.
   */
  class TokenId {
      /**
       * @param {number | Long | import("../EntityIdHelper").IEntityId} props
       * @param {(number | Long)=} realm
       * @param {(number | Long)=} num
       */
      constructor(props, realm, num) {
          const result = constructor(props, realm, num);

          this.shard = result.shard;
          this.realm = result.realm;
          this.num = result.num;

          /**
           * @type {string | null}
           */
          this._checksum = null;
      }

      /**
       * @param {string} text
       * @returns {TokenId}
       */
      static fromString(text) {
          const result = fromString(text);
          const id = new TokenId(result);
          id._checksum = result.checksum;
          return id;
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITokenID} id
       * @returns {TokenId}
       */
      static _fromProtobuf(id) {
          const tokenId = new TokenId(
              id.shardNum != null ? id.shardNum : 0,
              id.realmNum != null ? id.realmNum : 0,
              id.tokenNum != null ? id.tokenNum : 0,
          );

          return tokenId;
      }

      /**
       * @returns {string | null}
       */
      get checksum() {
          return this._checksum;
      }

      /**
       * @deprecated - Use `validateChecksum` instead
       * @param {Client} client
       */
      validate(client) {
          console.warn("Deprecated: Use `validateChecksum` instead");
          this.validateChecksum(client);
      }

      /**
       * @param {Client} client
       */
      validateChecksum(client) {
          validateChecksum(
              this.shard,
              this.realm,
              this.num,
              this._checksum,
              client,
          );
      }

      /**
       * @param {Uint8Array} bytes
       * @returns {TokenId}
       */
      static fromBytes(bytes) {
          return TokenId._fromProtobuf(libExports.proto.TokenID.decode(bytes));
      }

      /**
       * @param {string} address
       * @deprecated - Use `fromEvmAddress` instead
       * @returns {TokenId}
       */
      static fromSolidityAddress(address) {
          return new TokenId(...fromSolidityAddress(address));
      }

      /**
       * @param {number} shard
       * @param {number} realm
       * @param {string} address
       * @returns {TokenId}
       */
      static fromEvmAddress(shard, realm, address) {
          const addressBytes = EvmAddress.fromString(address).toBytes();
          const isLongZero = isLongZeroAddress(addressBytes);

          if (!isLongZero) {
              throw new Error(
                  "TokenId.fromEvmAddress does not support non-long-zero addresses",
              );
          }

          const [shardLong, realmLong, tokenLong] = fromEvmAddress(
              shard,
              realm,
              address,
          );
          return new TokenId(shardLong, realmLong, tokenLong);
      }

      /**
       * @deprecated - Use `toEvmAddress` instead
       * @returns {string} solidity address
       */
      toSolidityAddress() {
          return toSolidityAddress([
              this.shard,
              this.realm,
              this.num,
          ]);
      }

      /**
       * @returns {string}
       */
      toEvmAddress() {
          return toEvmAddress(this.num);
      }

      /**
       * @internal
       * @returns {HieroProto.proto.ITokenID}
       */
      _toProtobuf() {
          return {
              tokenNum: this.num,
              shardNum: this.shard,
              realmNum: this.realm,
          };
      }

      /**
       * @returns {string}
       */
      toString() {
          return `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}`;
      }

      /**
       * @param {Client} client
       * @returns {string}
       */
      toStringWithChecksum(client) {
          return toStringWithChecksum(this.toString(), client);
      }

      /**
       * @returns {Uint8Array}
       */
      toBytes() {
          return libExports.proto.TokenID.encode(this._toProtobuf()).finish();
      }

      /**
       * @returns {TokenId}
       */
      clone() {
          const id = new TokenId(this);
          id._checksum = this._checksum;
          return id;
      }

      /**
       * @param {TokenId} other
       * @returns {number}
       */
      compare(other) {
          return compare(
              [this.shard, this.realm, this.num],
              [other.shard, other.realm, other.num],
          );
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {import("long")} Long
   * @typedef {import("../client/Client.js").default<*, *>} Client
   */

  /**
   * Class representing a unique identifier for a scheduled transaction on the Hedera network.
   *
   * A ScheduleId consists of three components:
   * Shard ID: The shard number where the schedule exists
   * Realm ID: The realm number within the shard
   * Schedule Number: The unique number identifying the schedule
   * @augments {EntityId<HieroProto.proto.IScheduleID>}
   */

  class ScheduleId {
      /**
       * @param {number | Long | import("../EntityIdHelper").IEntityId} props
       * @param {(number | Long)=} realm
       * @param {(number | Long)=} num
       */
      constructor(props, realm, num) {
          const result = constructor(props, realm, num);

          this.shard = result.shard;
          this.realm = result.realm;
          this.num = result.num;

          /**
           * @type {string | null}
           */
          this._checksum = null;
      }

      /**
       * @param {string} text
       * @returns {ScheduleId}
       */
      static fromString(text) {
          const result = fromString(text);
          const id = new ScheduleId(result);
          id._checksum = result.checksum;
          return id;
      }

      /**
       * @internal
       * @param {HieroProto.proto.IScheduleID} id
       * @returns {ScheduleId}
       */
      static _fromProtobuf(id) {
          const scheduleId = new ScheduleId(
              id.shardNum != null ? id.shardNum : 0,
              id.realmNum != null ? id.realmNum : 0,
              id.scheduleNum != null ? id.scheduleNum : 0,
          );

          return scheduleId;
      }

      /**
       * @returns {string | null}
       */
      get checksum() {
          return this._checksum;
      }

      /**
       * @deprecated - Use `validateChecksum` instead
       * @param {Client} client
       */
      validate(client) {
          console.warn("Deprecated: Use `validateChecksum` instead");
          this.validateChecksum(client);
      }

      /**
       * @param {Client} client
       */
      validateChecksum(client) {
          validateChecksum(
              this.shard,
              this.realm,
              this.num,
              this._checksum,
              client,
          );
      }

      /**
       * @param {Uint8Array} bytes
       * @returns {ScheduleId}
       */
      static fromBytes(bytes) {
          return ScheduleId._fromProtobuf(
              libExports.proto.ScheduleID.decode(bytes),
          );
      }

      /**
       * @param {string} address
       * @returns {ScheduleId}
       */
      static fromSolidityAddress(address) {
          return new ScheduleId(...fromSolidityAddress(address));
      }

      /**
       * @returns {string}
       */
      toSolidityAddress() {
          return toSolidityAddress([this.shard, this.realm, this.num]);
      }

      /**
       * @internal
       * @returns {HieroProto.proto.ScheduleID}
       */
      _toProtobuf() {
          return {
              scheduleNum: this.num,
              shardNum: this.shard,
              realmNum: this.realm,
          };
      }

      /**
       * @returns {string}
       */
      toString() {
          return `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}`;
      }

      /**
       * @param {Client} client
       * @returns {string}
       */
      toStringWithChecksum(client) {
          return toStringWithChecksum(this.toString(), client);
      }

      /**
       * @returns {Uint8Array}
       */
      toBytes() {
          return libExports.proto.ScheduleID.encode(this._toProtobuf()).finish();
      }

      /**
       * @returns {ScheduleId}
       */
      clone() {
          const id = new ScheduleId(this);
          id._checksum = this._checksum;
          return id;
      }

      /**
       * @param {ScheduleId} other
       * @returns {number}
       */
      compare(other) {
          return compare(
              [this.shard, this.realm, this.num],
              [other.shard, other.realm, other.num],
          );
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {object} ExchangeRateJSON
   * @property {number} hbars
   * @property {number} cents
   * @property {Date} expirationTime
   * @property {number} exchangeRateInCents
   */

  /**
   * Represents an exchange rate between hbars and cents (USD).
   * This class provides functionality for handling and converting exchange rates
   * between Hedera's native HBAR currency and US cents.
   */
  class ExchangeRate {
      /**
       * @private
       * @param {object} props
       * @param {number} props.hbars
       * @param {number} props.cents
       * @param {Date} props.expirationTime
       */
      constructor(props) {
          /**
           * Denotes Hbar equivalent to cents (USD)
           *
           * @readonly
           * @type {number}
           */
          this.hbars = props.hbars;

          /**
           * Denotes cents (USD) equivalent to Hbar
           *
           * @readonly
           * @type {number}
           */
          this.cents = props.cents;

          /**
           * Expiration time of this exchange rate
           *
           * @readonly
           * @type {Date}
           */
          this.expirationTime = props.expirationTime;

          /**
           * Calculated exchange rate
           *
           * @readonly
           * @type {number}
           */
          this.exchangeRateInCents = props.cents / props.hbars;

          Object.freeze(this);
      }

      /**
       * @internal
       * @param {import("@hashgraph/proto").proto.IExchangeRate} rate
       * @returns {ExchangeRate}
       */
      static _fromProtobuf(rate) {
          return new ExchangeRate({
              hbars: /** @type {number} */ (rate.hbarEquiv),
              cents: /** @type {number} */ (rate.centEquiv),
              expirationTime: new Date(
                  rate.expirationTime != null
                      ? rate.expirationTime.seconds != null
                          ? Long.isLong(rate.expirationTime.seconds)
                              ? rate.expirationTime.seconds.toInt() * 1000
                              : rate.expirationTime.seconds
                          : 0
                      : 0,
              ),
          });
      }

      /**
       * @internal
       * @returns {import("@hashgraph/proto").proto.IExchangeRate}
       */
      _toProtobuf() {
          return {
              hbarEquiv: this.hbars,
              centEquiv: this.cents,
              expirationTime: {
                  seconds: Long.fromNumber(
                      Math.trunc(this.expirationTime.getTime() / 1000),
                  ),
              },
          };
      }

      /**
       * @returns {ExchangeRateJSON}
       */
      toJSON() {
          return {
              hbars: this.hbars,
              cents: this.cents,
              expirationTime: this.expirationTime,
              exchangeRateInCents: this.exchangeRateInCents,
          };
      }

      /**
       * @returns {string}
       */
      toString() {
          return JSON.stringify(this.toJSON());
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {import("../ExchangeRate.js").ExchangeRateJSON} ExchangeRateJSON
   */

  /**
   * @typedef {object} TransactionReceiptJSON
   * @property {string} status
   * @property {?string} accountId
   * @property {?string} filedId
   * @property {?string} contractId
   * @property {?string} topicId
   * @property {?string} tokenId
   * @property {?string} scheduleId
   * @property {?ExchangeRateJSON} exchangeRate
   * @property {?ExchangeRateJSON} nextExchangeRate
   * @property {?string} topicSequenceNumber
   * @property {?string} topicRunningHash
   * @property {?string} totalSupply
   * @property {?string} scheduledTransactionId
   * @property {string[]} serials
   * @property {TransactionReceiptJSON[]} duplicates
   * @property {TransactionReceiptJSON[]} children
   * @property {?string} nodeId
   */

  /**
   * The consensus result for a transaction, which might not be currently known,
   * or may succeed or fail.
   */
  class TransactionReceipt {
      /**
       * @private
       * @param {object} props
       * @param {Status} props.status
       * @param {?AccountId} props.accountId
       * @param {?FileId} props.fileId
       * @param {?ContractId} props.contractId
       * @param {?TopicId} props.topicId
       * @param {?TokenId} props.tokenId
       * @param {?ScheduleId} props.scheduleId
       * @param {?ExchangeRate} props.exchangeRate
       * @param {?ExchangeRate} props.nextExchangeRate
       * @param {?Long} props.topicSequenceNumber
       * @param {?Uint8Array} props.topicRunningHash
       * @param {?Long} props.totalSupply
       * @param {?TransactionId} props.scheduledTransactionId
       * @param {Long[]} props.serials
       * @param {TransactionReceipt[]} props.duplicates
       * @param {TransactionReceipt[]} props.children
       * @param {?Long} props.nodeId
       */
      constructor(props) {
          /**
           * Whether the transaction succeeded or failed (or is unknown).
           *
           * @readonly
           */
          this.status = props.status;

          /**
           * The account ID, if a new account was created.
           *
           * @readonly
           */
          this.accountId = props.accountId;

          /**
           * The file ID, if a new file was created.
           *
           * @readonly
           */
          this.fileId = props.fileId;

          /**
           * The contract ID, if a new contract was created.
           *
           * @readonly
           */
          this.contractId = props.contractId;

          /**
           * The topic ID, if a new topic was created.
           *
           * @readonly
           */
          this.topicId = props.topicId;

          /**
           * The token ID, if a new token was created.
           *
           * @readonly
           */
          this.tokenId = props.tokenId;

          /**
           * The schedule ID, if a new schedule was created.
           *
           * @readonly
           */
          this.scheduleId = props.scheduleId;

          /**
           * The exchange rate of Hbars to cents (USD).
           *
           * @readonly
           */
          this.exchangeRate = props.exchangeRate;

          /**
           * The next exchange rate of Hbars to cents (USD).
           *
           * @readonly
           */
          this.nextExchangeRate = props.nextExchangeRate;

          /**
           * Updated sequence number for a consensus service topic.
           *
           * @readonly
           */
          this.topicSequenceNumber = props.topicSequenceNumber;

          /**
           * Updated running hash for a consensus service topic.
           *
           * @readonly
           */
          this.topicRunningHash = props.topicRunningHash;

          /**
           * Updated total supply for a token
           *
           * @readonly
           */
          this.totalSupply = props.totalSupply;

          this.scheduledTransactionId = props.scheduledTransactionId;

          this.serials = props.serials ?? [];

          /**
           * @readonly
           */
          this.duplicates = props.duplicates ?? [];

          /**
           * @readonly
           */
          this.children = props.children ?? [];

          /**
           * @readonly
           * @description In the receipt of a NodeCreate, NodeUpdate, NodeDelete, the id of the newly created node.
           * An affected node identifier.
           * This value SHALL be set following a `createNode` transaction.
           * This value SHALL be set following a `updateNode` transaction.
           * This value SHALL be set following a `deleteNode` transaction.
           * This value SHALL NOT be set following any other transaction.
           */
          this.nodeId = props.nodeId;

          Object.freeze(this);
      }

      /**
       * @internal
       * @returns {HieroProto.proto.ITransactionGetReceiptResponse}
       */
      _toProtobuf() {
          const duplicates = this.duplicates.map(
              (receipt) =>
                  /** @type {HieroProto.proto.ITransactionReceipt} */ (
                      receipt._toProtobuf().receipt
                  ),
          );
          const children = this.children.map(
              (receipt) =>
                  /** @type {HieroProto.proto.ITransactionReceipt} */ (
                      receipt._toProtobuf().receipt
                  ),
          );

          return {
              duplicateTransactionReceipts: duplicates,
              childTransactionReceipts: children,
              receipt: {
                  status: this.status.valueOf(),

                  accountID:
                      this.accountId != null
                          ? this.accountId._toProtobuf()
                          : null,
                  fileID: this.fileId != null ? this.fileId._toProtobuf() : null,
                  contractID:
                      this.contractId != null
                          ? this.contractId._toProtobuf()
                          : null,
                  topicID:
                      this.topicId != null ? this.topicId._toProtobuf() : null,
                  tokenID:
                      this.tokenId != null ? this.tokenId._toProtobuf() : null,
                  scheduleID:
                      this.scheduleId != null
                          ? this.scheduleId._toProtobuf()
                          : null,

                  topicRunningHash:
                      this.topicRunningHash == null
                          ? null
                          : this.topicRunningHash,

                  topicSequenceNumber: this.topicSequenceNumber,

                  exchangeRate: {
                      nextRate:
                          this.nextExchangeRate != null
                              ? this.nextExchangeRate._toProtobuf()
                              : null,
                      currentRate:
                          this.exchangeRate != null
                              ? this.exchangeRate._toProtobuf()
                              : null,
                  },

                  scheduledTransactionID:
                      this.scheduledTransactionId != null
                          ? this.scheduledTransactionId._toProtobuf()
                          : null,

                  serialNumbers: this.serials,
                  newTotalSupply: this.totalSupply,
                  nodeId: this.nodeId,
              },
          };
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransactionGetReceiptResponse} response
       * @returns {TransactionReceipt}
       */
      static _fromProtobuf(response) {
          const receipt = /** @type {HieroProto.proto.ITransactionReceipt} */ (
              response.receipt
          );

          const children =
              response.childTransactionReceipts != null
                  ? response.childTransactionReceipts.map((child) =>
                        TransactionReceipt._fromProtobuf({ receipt: child }),
                    )
                  : [];

          const duplicates =
              response.duplicateTransactionReceipts != null
                  ? response.duplicateTransactionReceipts.map((duplicate) =>
                        TransactionReceipt._fromProtobuf({ receipt: duplicate }),
                    )
                  : [];

          return new TransactionReceipt({
              status: Status._fromCode(
                  receipt.status != null ? receipt.status : 0,
              ),

              accountId:
                  receipt.accountID != null
                      ? AccountId._fromProtobuf(receipt.accountID)
                      : null,

              fileId:
                  receipt.fileID != null
                      ? FileId._fromProtobuf(receipt.fileID)
                      : null,

              contractId:
                  receipt.contractID != null
                      ? ContractId._fromProtobuf(receipt.contractID)
                      : null,

              topicId:
                  receipt.topicID != null
                      ? TopicId._fromProtobuf(receipt.topicID)
                      : null,

              tokenId:
                  receipt.tokenID != null
                      ? TokenId._fromProtobuf(receipt.tokenID)
                      : null,

              scheduleId:
                  receipt.scheduleID != null
                      ? ScheduleId._fromProtobuf(receipt.scheduleID)
                      : null,

              exchangeRate:
                  receipt.exchangeRate != null
                      ? ExchangeRate._fromProtobuf(
                            /** @type {HieroProto.proto.IExchangeRate} */
                            (receipt.exchangeRate.currentRate),
                        )
                      : null,

              nextExchangeRate:
                  receipt.exchangeRate != null
                      ? ExchangeRate._fromProtobuf(
                            /** @type {HieroProto.proto.IExchangeRate} */
                            (receipt.exchangeRate.nextRate),
                        )
                      : null,

              topicSequenceNumber:
                  receipt.topicSequenceNumber == null
                      ? null
                      : Long.fromString(receipt.topicSequenceNumber.toString()),

              topicRunningHash:
                  receipt.topicRunningHash != null
                      ? new Uint8Array(receipt.topicRunningHash)
                      : null,

              totalSupply:
                  receipt.newTotalSupply != null
                      ? Long.fromString(receipt.newTotalSupply.toString())
                      : null,

              scheduledTransactionId:
                  receipt.scheduledTransactionID != null
                      ? TransactionId._fromProtobuf(
                            receipt.scheduledTransactionID,
                        )
                      : null,
              serials:
                  receipt.serialNumbers != null
                      ? receipt.serialNumbers.map((serial) =>
                            Long.fromValue(serial),
                        )
                      : [],
              children,
              duplicates,
              nodeId: receipt.nodeId != null ? receipt.nodeId : null,
          });
      }

      /**
       * @param {Uint8Array} bytes
       * @returns {TransactionReceipt}
       */
      static fromBytes(bytes) {
          return TransactionReceipt._fromProtobuf(
              libExports.proto.TransactionGetReceiptResponse.decode(bytes),
          );
      }

      /**
       * @returns {Uint8Array}
       */
      toBytes() {
          return libExports.proto.TransactionGetReceiptResponse.encode(
              this._toProtobuf(),
          ).finish();
      }

      /**
       * @returns {TransactionReceiptJSON}
       */
      toJSON() {
          return {
              status: this.status.toString(),
              accountId: this.accountId?.toString() || null,
              filedId: this.fileId?.toString() || null,
              contractId: this.contractId?.toString() || null,
              topicId: this.topicId?.toString() || null,
              tokenId: this.tokenId?.toString() || null,
              scheduleId: this.scheduleId?.toString() || null,
              exchangeRate: this.exchangeRate?.toJSON() || null,
              nextExchangeRate: this.nextExchangeRate?.toJSON() || null,
              topicSequenceNumber: this.topicSequenceNumber?.toString() || null,
              topicRunningHash:
                  this.topicRunningHash != null
                      ? encode$5(this.topicRunningHash)
                      : null,
              totalSupply: this.totalSupply?.toString() || null,
              scheduledTransactionId:
                  this.scheduledTransactionId?.toString() || null,
              serials: this.serials.map((serial) => serial.toString()),
              duplicates: this.duplicates.map((receipt) => receipt.toJSON()),
              children: this.children.map((receipt) => receipt.toJSON()),
              nodeId: this.nodeId?.toString() || null,
          };
      }

      /**
       * @returns {string}
       */
      toString() {
          return JSON.stringify(this.toJSON());
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  const { proto: proto$7 } = HieroProto;

  /**
   * @typedef {import("../account/AccountId.js").default} AccountId
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   */

  /**
   * Get the receipt of a transaction, given its transaction ID.
   *
   * <p>Once a transaction reaches consensus, then information about whether it succeeded or failed
   * will be available until the end of the receipt period.
   *
   * <p>This query is free.
   * @augments {Query<TransactionReceipt>}
   */
  class TransactionReceiptQuery extends Query {
      /**
       * @param {object} [props]
       * @param {TransactionId | string} [props.transactionId]
       * @param {boolean} [props.includeDuplicates]
       * @param {boolean} [props.includeChildren]
       * @param {boolean} [props.validateStatus]
       */
      constructor(props = {}) {
          super();

          /**
           * @private
           * @type {?TransactionId}
           */
          this._transactionId = null;

          /**
           * @private
           * @type {?boolean}
           */
          this._includeChildren = null;

          /**
           * @private
           * @type {?boolean}
           */
          this._includeDuplicates = null;

          this._validateStatus = true;

          if (props.transactionId != null) {
              this.setTransactionId(props.transactionId);
          }

          if (props.includeChildren != null) {
              this.setIncludeChildren(props.includeChildren);
          }

          if (props.includeDuplicates != null) {
              this.setIncludeDuplicates(props.includeDuplicates);
          }

          if (props.validateStatus != null) {
              this.setValidateStatus(props.validateStatus);
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.IQuery} query
       * @returns {TransactionReceiptQuery}
       */
      static _fromProtobuf(query) {
          const receipt =
              /** @type {HieroProto.proto.ITransactionGetReceiptQuery} */ (
                  query.transactionGetReceipt
              );

          return new TransactionReceiptQuery({
              transactionId: receipt.transactionID
                  ? TransactionId._fromProtobuf(receipt.transactionID)
                  : undefined,
              includeDuplicates:
                  receipt.includeDuplicates != null
                      ? receipt.includeDuplicates
                      : undefined,
              includeChildren:
                  receipt.includeChildReceipts != null
                      ? receipt.includeChildReceipts
                      : undefined,
          });
      }

      /**
       * @returns {?TransactionId}
       */
      get transactionId() {
          return this._transactionId;
      }

      /**
       * Set the transaction ID for which the receipt is being requested.
       *
       * @param {TransactionId | string} transactionId
       * @returns {this}
       */
      setTransactionId(transactionId) {
          this._transactionId =
              typeof transactionId === "string"
                  ? TransactionId.fromString(transactionId)
                  : transactionId.clone();

          return this;
      }

      /**
       * @param {boolean} includeDuplicates
       * @returns {TransactionReceiptQuery}
       */
      setIncludeDuplicates(includeDuplicates) {
          this._includeDuplicates = includeDuplicates;
          return this;
      }

      /**
       * @returns {boolean}
       */
      get includeDuplicates() {
          return this._includeDuplicates != null
              ? this._includeDuplicates
              : false;
      }

      /**
       * @param {boolean} includeChildren
       * @returns {TransactionReceiptQuery}
       */
      setIncludeChildren(includeChildren) {
          this._includeChildren = includeChildren;
          return this;
      }

      /**
       * @returns {boolean}
       */
      get includeChildren() {
          return this._includeChildren != null ? this._includeChildren : false;
      }

      /**
       * @param {boolean} validateStatus
       * @returns {this}
       */
      setValidateStatus(validateStatus) {
          this._validateStatus = validateStatus;
          return this;
      }

      /**
       * @returns {boolean}
       */
      get validateStatus() {
          return this._validateStatus;
      }

      /**
       * @override
       * @protected
       * @returns {boolean}
       */
      _isPaymentRequired() {
          return false;
      }

      /**
       * @override
       * @internal
       * @param {HieroProto.proto.IQuery} request
       * @param {HieroProto.proto.IResponse} response
       * @returns {[Status, ExecutionState]}
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _shouldRetry(request, response) {
          const { nodeTransactionPrecheckCode } =
              this._mapResponseHeader(response);

          let status = Status._fromCode(
              nodeTransactionPrecheckCode != null
                  ? nodeTransactionPrecheckCode
                  : proto$7.ResponseCodeEnum.OK,
          );

          if (this._logger) {
              this._logger.debug(
                  `[${this._getLogId()}] received node precheck status ${status.toString()}`,
              );
          }

          switch (status) {
              case Status.Busy:
              case Status.Unknown:
              case Status.ReceiptNotFound:
              case Status.PlatformNotActive:
                  return [status, ExecutionState.Retry];
              case Status.Ok:
                  break;
              default:
                  return [status, ExecutionState.Error];
          }

          const transactionGetReceipt =
              /** @type {HieroProto.proto.ITransactionGetReceiptResponse} */ (
                  response.transactionGetReceipt
              );
          const receipt = /** @type {HieroProto.proto.ITransactionReceipt} */ (
              transactionGetReceipt.receipt
          );
          const receiptStatusCode =
              /** @type {HieroProto.proto.ResponseCodeEnum} */ (receipt.status);

          status = Status._fromCode(receiptStatusCode);

          if (this._logger) {
              this._logger.debug(
                  `[${this._getLogId()}] received receipt status ${status.toString()}`,
              );
          }

          switch (status) {
              case Status.Busy:
              case Status.Unknown:
              case Status.ReceiptNotFound:
                  return [status, ExecutionState.Retry];
              case Status.Success:
              case Status.FeeScheduleFilePartUploaded:
                  return [status, ExecutionState.Finished];
              default:
                  return [
                      status,
                      this._validateStatus
                          ? ExecutionState.Error
                          : ExecutionState.Finished,
                  ];
          }
      }

      /**
       * @returns {TransactionId}
       */
      _getTransactionId() {
          if (this._transactionId != null) {
              return this._transactionId;
          }

          return super._getTransactionId();
      }

      /**
       * @override
       * @internal
       * @param {HieroProto.proto.IQuery} request
       * @param {HieroProto.proto.IResponse} response
       * @param {AccountId} nodeId
       * @returns {Error}
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _mapStatusError(request, response, nodeId) {
          const { nodeTransactionPrecheckCode } =
              this._mapResponseHeader(response);

          let status = Status._fromCode(
              nodeTransactionPrecheckCode != null
                  ? nodeTransactionPrecheckCode
                  : proto$7.ResponseCodeEnum.OK,
          );

          switch (status) {
              case Status.Ok:
                  // Do nothing
                  break;

              default:
                  return new PrecheckStatusError({
                      nodeId,
                      status,
                      transactionId: this._getTransactionId(),
                      contractFunctionResult: null,
                  });
          }

          const transactionGetReceipt =
              /** @type {HieroProto.proto.ITransactionGetReceiptResponse} */ (
                  response.transactionGetReceipt
              );
          const receipt = /** @type {HieroProto.proto.ITransactionReceipt} */ (
              transactionGetReceipt.receipt
          );
          const receiptStatusCode =
              /** @type {HieroProto.proto.ResponseCodeEnum} */ (receipt.status);

          status = Status._fromCode(receiptStatusCode);

          if (this._transactionId == null) {
              throw new Error(
                  "Failed to construct `ReceiptStatusError` because `transactionId` is `null`",
              );
          }

          return new ReceiptStatusError({
              status,
              transactionId: this._transactionId,
              transactionReceipt: TransactionReceipt._fromProtobuf(
                  transactionGetReceipt,
              ),
          });
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          if (
              this._transactionId != null &&
              this._transactionId.accountId != null
          ) {
              this._transactionId.accountId.validateChecksum(client);
          }
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.IQuery} request
       * @returns {Promise<HieroProto.proto.IResponse>}
       */
      _execute(channel, request) {
          return channel.crypto.getTransactionReceipts(request);
      }

      /**
       * @override
       * @internal
       * @param {HieroProto.proto.IResponse} response
       * @returns {HieroProto.proto.IResponseHeader}
       */
      _mapResponseHeader(response) {
          const transactionGetReceipt =
              /** @type {HieroProto.proto.ITransactionGetReceiptResponse} */ (
                  response.transactionGetReceipt
              );
          return /** @type {HieroProto.proto.IResponseHeader} */ (
              transactionGetReceipt.header
          );
      }

      /**
       * @protected
       * @override
       * @param {HieroProto.proto.IResponse} response
       * @param {AccountId} nodeAccountId
       * @param {HieroProto.proto.IQuery} request
       * @returns {Promise<TransactionReceipt>}
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _mapResponse(response, nodeAccountId, request) {
          const transactionGetReceipt =
              /** @type {HieroProto.proto.ITransactionGetReceiptResponse} */ (
                  response.transactionGetReceipt
              );

          return Promise.resolve(
              TransactionReceipt._fromProtobuf(transactionGetReceipt),
          );
      }

      /**
       * @override
       * @internal
       * @param {HieroProto.proto.IQueryHeader} header
       * @returns {HieroProto.proto.IQuery}
       */
      _onMakeRequest(header) {
          return {
              transactionGetReceipt: {
                  header,
                  transactionID:
                      this._transactionId != null
                          ? this._transactionId._toProtobuf()
                          : null,
                  includeDuplicates: this._includeDuplicates,
                  includeChildReceipts: this._includeChildren,
              },
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          return `TransactionReceiptQuery:${this._timestamp.toString()}`;
      }
  }

  QUERY_REGISTRY.set(
      "transactionGetReceipt",
      // eslint-disable-next-line @typescript-eslint/unbound-method
      TransactionReceiptQuery._fromProtobuf,
  );

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {object} TransferJSON
   * @property {string} accountId
   * @property {string} amount
   * @property {boolean} isApproved
   */

  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.IAccountAmount} HieroProto.proto.IAccountAmount
   * @typedef {import("@hashgraph/proto").proto.IAccountID} HieroProto.proto.IAccountID
   */

  /**
   * @typedef {import("bignumber.js").default} BigNumber
   * @typedef {import("long")} Long
   */

  /**
   * An account, and the amount that it sends or receives during a cryptocurrency transfer.
   */
  class Transfer {
      /**
       * @internal
       * @param {object} props
       * @param {AccountId | string} props.accountId
       * @param {number | string | Long | BigNumber | Hbar} props.amount
       * @param {boolean} props.isApproved
       */
      constructor(props) {
          /**
           * The Account ID that sends or receives cryptocurrency.
           *
           * @readonly
           */
          this.accountId =
              props.accountId instanceof AccountId
                  ? props.accountId
                  : AccountId.fromString(props.accountId);

          /**
           * The amount of tinybars that the account sends(negative) or receives(positive).
           */
          this.amount =
              props.amount instanceof Hbar
                  ? props.amount
                  : new Hbar(props.amount);

          this.isApproved = props.isApproved;
      }

      /**
       * @internal
       * @param {HieroProto.proto.IAccountAmount[]} accountAmounts
       * @returns {Transfer[]}
       */
      static _fromProtobuf(accountAmounts) {
          const transfers = [];

          for (const transfer of accountAmounts) {
              transfers.push(
                  new Transfer({
                      accountId: AccountId._fromProtobuf(
                          /** @type {HieroProto.proto.IAccountID} */ (
                              transfer.accountID
                          ),
                      ),
                      amount: Hbar.fromTinybars(
                          transfer.amount != null ? transfer.amount : 0,
                      ),
                      isApproved: /** @type {boolean} */ (transfer.isApproval),
                  }),
              );
          }

          return transfers;
      }

      /**
       * @internal
       * @returns {HieroProto.proto.IAccountAmount}
       */
      _toProtobuf() {
          return {
              accountID: this.accountId._toProtobuf(),
              amount: this.amount.toTinybars(),
              isApproval: this.isApproved,
          };
      }

      /**
       * @returns {TransferJSON}
       */
      toJSON() {
          return {
              accountId: this.accountId.toString(),
              amount: this.amount.toTinybars().toString(),
              isApproved: this.isApproved,
          };
      }

      /**
       * @returns {string}
       */
      toString() {
          return JSON.stringify(this.toJSON());
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.IContractLoginfo} HieroProto.proto.IContractLoginfo
   * @typedef {import("@hashgraph/proto").proto.IContractID} HieroProto.proto.IContractID
   */

  /**
   * The log information for an event returned by a smart contract function call. One function call
   * may return several such events.
   */
  class ContractLogInfo {
      /**
       * @param {object} props
       * @param {ContractId} props.contractId
       * @param {Uint8Array} props.bloom
       * @param {Uint8Array[]} props.topics
       * @param {Uint8Array} props.data
       */
      constructor(props) {
          /**
           * Address of a contract that emitted the event.
           *
           * @readonly
           */
          this.contractId = props.contractId;

          /**
           * Bloom filter for a particular log.
           *
           * @readonly
           */
          this.bloom = props.bloom;

          /**
           * Topics of a particular event.
           *
           * @readonly
           */
          this.topics = props.topics;

          /**
           * Event data.
           *
           * @readonly
           */
          this.data = props.data;

          Object.freeze(this);
      }

      /**
       * @internal
       * @param {HieroProto.proto.IContractLoginfo} info
       * @returns {ContractLogInfo}
       */
      static _fromProtobuf(info) {
          return new ContractLogInfo({
              contractId: ContractId._fromProtobuf(
                  /** @type {HieroProto.proto.IContractID} */ (info.contractID),
              ),
              bloom: info.bloom != null ? info.bloom : new Uint8Array(),
              topics: info.topic != null ? info.topic : [],
              data: info.data != null ? info.data : new Uint8Array(),
          });
      }

      /**
       * @internal
       * @returns {HieroProto.proto.IContractLoginfo}
       */
      _toProtobuf() {
          return {
              contractID: this.contractId._toProtobuf(),
              bloom: this.bloom,
              topic: this.topics,
              data: this.data,
          };
      }
  }

  // SPDX-License-Identifier: Apache-2.0

  /**
   * @param {Uint8Array} data
   * @returns {string}
   */
  function decode$1(data) {
      // eslint-disable-next-line n/no-unsupported-features/node-builtins
      return new TextDecoder().decode(data);
  }

  /**
   * @param {string} text
   * @returns {Uint8Array}
   */
  function encode$1(text) {
      // eslint-disable-next-line n/no-unsupported-features/node-builtins
      return new TextEncoder().encode(text);
  }

  var bn$1 = {exports: {}};

  var bn = bn$1.exports;

  var hasRequiredBn;

  function requireBn () {
  	if (hasRequiredBn) return bn$1.exports;
  	hasRequiredBn = 1;
  	(function (module) {
  		(function (module, exports) {

  		  // Utils
  		  function assert (val, msg) {
  		    if (!val) throw new Error(msg || 'Assertion failed');
  		  }

  		  // Could use `inherits` module, but don't want to move from single file
  		  // architecture yet.
  		  function inherits (ctor, superCtor) {
  		    ctor.super_ = superCtor;
  		    var TempCtor = function () {};
  		    TempCtor.prototype = superCtor.prototype;
  		    ctor.prototype = new TempCtor();
  		    ctor.prototype.constructor = ctor;
  		  }

  		  // BN

  		  function BN (number, base, endian) {
  		    if (BN.isBN(number)) {
  		      return number;
  		    }

  		    this.negative = 0;
  		    this.words = null;
  		    this.length = 0;

  		    // Reduction context
  		    this.red = null;

  		    if (number !== null) {
  		      if (base === 'le' || base === 'be') {
  		        endian = base;
  		        base = 10;
  		      }

  		      this._init(number || 0, base || 10, endian || 'be');
  		    }
  		  }
  		  if (typeof module === 'object') {
  		    module.exports = BN;
  		  } else {
  		    exports.BN = BN;
  		  }

  		  BN.BN = BN;
  		  BN.wordSize = 26;

  		  var Buffer;
  		  try {
  		    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
  		      Buffer = window.Buffer;
  		    } else {
  		      Buffer = require$$0.Buffer;
  		    }
  		  } catch (e) {
  		  }

  		  BN.isBN = function isBN (num) {
  		    if (num instanceof BN) {
  		      return true;
  		    }

  		    return num !== null && typeof num === 'object' &&
  		      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  		  };

  		  BN.max = function max (left, right) {
  		    if (left.cmp(right) > 0) return left;
  		    return right;
  		  };

  		  BN.min = function min (left, right) {
  		    if (left.cmp(right) < 0) return left;
  		    return right;
  		  };

  		  BN.prototype._init = function init (number, base, endian) {
  		    if (typeof number === 'number') {
  		      return this._initNumber(number, base, endian);
  		    }

  		    if (typeof number === 'object') {
  		      return this._initArray(number, base, endian);
  		    }

  		    if (base === 'hex') {
  		      base = 16;
  		    }
  		    assert(base === (base | 0) && base >= 2 && base <= 36);

  		    number = number.toString().replace(/\s+/g, '');
  		    var start = 0;
  		    if (number[0] === '-') {
  		      start++;
  		      this.negative = 1;
  		    }

  		    if (start < number.length) {
  		      if (base === 16) {
  		        this._parseHex(number, start, endian);
  		      } else {
  		        this._parseBase(number, base, start);
  		        if (endian === 'le') {
  		          this._initArray(this.toArray(), base, endian);
  		        }
  		      }
  		    }
  		  };

  		  BN.prototype._initNumber = function _initNumber (number, base, endian) {
  		    if (number < 0) {
  		      this.negative = 1;
  		      number = -number;
  		    }
  		    if (number < 0x4000000) {
  		      this.words = [number & 0x3ffffff];
  		      this.length = 1;
  		    } else if (number < 0x10000000000000) {
  		      this.words = [
  		        number & 0x3ffffff,
  		        (number / 0x4000000) & 0x3ffffff
  		      ];
  		      this.length = 2;
  		    } else {
  		      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
  		      this.words = [
  		        number & 0x3ffffff,
  		        (number / 0x4000000) & 0x3ffffff,
  		        1
  		      ];
  		      this.length = 3;
  		    }

  		    if (endian !== 'le') return;

  		    // Reverse the bytes
  		    this._initArray(this.toArray(), base, endian);
  		  };

  		  BN.prototype._initArray = function _initArray (number, base, endian) {
  		    // Perhaps a Uint8Array
  		    assert(typeof number.length === 'number');
  		    if (number.length <= 0) {
  		      this.words = [0];
  		      this.length = 1;
  		      return this;
  		    }

  		    this.length = Math.ceil(number.length / 3);
  		    this.words = new Array(this.length);
  		    for (var i = 0; i < this.length; i++) {
  		      this.words[i] = 0;
  		    }

  		    var j, w;
  		    var off = 0;
  		    if (endian === 'be') {
  		      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
  		        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
  		        this.words[j] |= (w << off) & 0x3ffffff;
  		        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
  		        off += 24;
  		        if (off >= 26) {
  		          off -= 26;
  		          j++;
  		        }
  		      }
  		    } else if (endian === 'le') {
  		      for (i = 0, j = 0; i < number.length; i += 3) {
  		        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
  		        this.words[j] |= (w << off) & 0x3ffffff;
  		        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
  		        off += 24;
  		        if (off >= 26) {
  		          off -= 26;
  		          j++;
  		        }
  		      }
  		    }
  		    return this._strip();
  		  };

  		  function parseHex4Bits (string, index) {
  		    var c = string.charCodeAt(index);
  		    // '0' - '9'
  		    if (c >= 48 && c <= 57) {
  		      return c - 48;
  		    // 'A' - 'F'
  		    } else if (c >= 65 && c <= 70) {
  		      return c - 55;
  		    // 'a' - 'f'
  		    } else if (c >= 97 && c <= 102) {
  		      return c - 87;
  		    } else {
  		      assert(false, 'Invalid character in ' + string);
  		    }
  		  }

  		  function parseHexByte (string, lowerBound, index) {
  		    var r = parseHex4Bits(string, index);
  		    if (index - 1 >= lowerBound) {
  		      r |= parseHex4Bits(string, index - 1) << 4;
  		    }
  		    return r;
  		  }

  		  BN.prototype._parseHex = function _parseHex (number, start, endian) {
  		    // Create possibly bigger array to ensure that it fits the number
  		    this.length = Math.ceil((number.length - start) / 6);
  		    this.words = new Array(this.length);
  		    for (var i = 0; i < this.length; i++) {
  		      this.words[i] = 0;
  		    }

  		    // 24-bits chunks
  		    var off = 0;
  		    var j = 0;

  		    var w;
  		    if (endian === 'be') {
  		      for (i = number.length - 1; i >= start; i -= 2) {
  		        w = parseHexByte(number, start, i) << off;
  		        this.words[j] |= w & 0x3ffffff;
  		        if (off >= 18) {
  		          off -= 18;
  		          j += 1;
  		          this.words[j] |= w >>> 26;
  		        } else {
  		          off += 8;
  		        }
  		      }
  		    } else {
  		      var parseLength = number.length - start;
  		      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
  		        w = parseHexByte(number, start, i) << off;
  		        this.words[j] |= w & 0x3ffffff;
  		        if (off >= 18) {
  		          off -= 18;
  		          j += 1;
  		          this.words[j] |= w >>> 26;
  		        } else {
  		          off += 8;
  		        }
  		      }
  		    }

  		    this._strip();
  		  };

  		  function parseBase (str, start, end, mul) {
  		    var r = 0;
  		    var b = 0;
  		    var len = Math.min(str.length, end);
  		    for (var i = start; i < len; i++) {
  		      var c = str.charCodeAt(i) - 48;

  		      r *= mul;

  		      // 'a'
  		      if (c >= 49) {
  		        b = c - 49 + 0xa;

  		      // 'A'
  		      } else if (c >= 17) {
  		        b = c - 17 + 0xa;

  		      // '0' - '9'
  		      } else {
  		        b = c;
  		      }
  		      assert(c >= 0 && b < mul, 'Invalid character');
  		      r += b;
  		    }
  		    return r;
  		  }

  		  BN.prototype._parseBase = function _parseBase (number, base, start) {
  		    // Initialize as zero
  		    this.words = [0];
  		    this.length = 1;

  		    // Find length of limb in base
  		    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
  		      limbLen++;
  		    }
  		    limbLen--;
  		    limbPow = (limbPow / base) | 0;

  		    var total = number.length - start;
  		    var mod = total % limbLen;
  		    var end = Math.min(total, total - mod) + start;

  		    var word = 0;
  		    for (var i = start; i < end; i += limbLen) {
  		      word = parseBase(number, i, i + limbLen, base);

  		      this.imuln(limbPow);
  		      if (this.words[0] + word < 0x4000000) {
  		        this.words[0] += word;
  		      } else {
  		        this._iaddn(word);
  		      }
  		    }

  		    if (mod !== 0) {
  		      var pow = 1;
  		      word = parseBase(number, i, number.length, base);

  		      for (i = 0; i < mod; i++) {
  		        pow *= base;
  		      }

  		      this.imuln(pow);
  		      if (this.words[0] + word < 0x4000000) {
  		        this.words[0] += word;
  		      } else {
  		        this._iaddn(word);
  		      }
  		    }

  		    this._strip();
  		  };

  		  BN.prototype.copy = function copy (dest) {
  		    dest.words = new Array(this.length);
  		    for (var i = 0; i < this.length; i++) {
  		      dest.words[i] = this.words[i];
  		    }
  		    dest.length = this.length;
  		    dest.negative = this.negative;
  		    dest.red = this.red;
  		  };

  		  function move (dest, src) {
  		    dest.words = src.words;
  		    dest.length = src.length;
  		    dest.negative = src.negative;
  		    dest.red = src.red;
  		  }

  		  BN.prototype._move = function _move (dest) {
  		    move(dest, this);
  		  };

  		  BN.prototype.clone = function clone () {
  		    var r = new BN(null);
  		    this.copy(r);
  		    return r;
  		  };

  		  BN.prototype._expand = function _expand (size) {
  		    while (this.length < size) {
  		      this.words[this.length++] = 0;
  		    }
  		    return this;
  		  };

  		  // Remove leading `0` from `this`
  		  BN.prototype._strip = function strip () {
  		    while (this.length > 1 && this.words[this.length - 1] === 0) {
  		      this.length--;
  		    }
  		    return this._normSign();
  		  };

  		  BN.prototype._normSign = function _normSign () {
  		    // -0 = 0
  		    if (this.length === 1 && this.words[0] === 0) {
  		      this.negative = 0;
  		    }
  		    return this;
  		  };

  		  // Check Symbol.for because not everywhere where Symbol defined
  		  // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility
  		  if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {
  		    try {
  		      BN.prototype[Symbol.for('nodejs.util.inspect.custom')] = inspect;
  		    } catch (e) {
  		      BN.prototype.inspect = inspect;
  		    }
  		  } else {
  		    BN.prototype.inspect = inspect;
  		  }

  		  function inspect () {
  		    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  		  }

  		  /*

  		  var zeros = [];
  		  var groupSizes = [];
  		  var groupBases = [];

  		  var s = '';
  		  var i = -1;
  		  while (++i < BN.wordSize) {
  		    zeros[i] = s;
  		    s += '0';
  		  }
  		  groupSizes[0] = 0;
  		  groupSizes[1] = 0;
  		  groupBases[0] = 0;
  		  groupBases[1] = 0;
  		  var base = 2 - 1;
  		  while (++base < 36 + 1) {
  		    var groupSize = 0;
  		    var groupBase = 1;
  		    while (groupBase < (1 << BN.wordSize) / base) {
  		      groupBase *= base;
  		      groupSize += 1;
  		    }
  		    groupSizes[base] = groupSize;
  		    groupBases[base] = groupBase;
  		  }

  		  */

  		  var zeros = [
  		    '',
  		    '0',
  		    '00',
  		    '000',
  		    '0000',
  		    '00000',
  		    '000000',
  		    '0000000',
  		    '00000000',
  		    '000000000',
  		    '0000000000',
  		    '00000000000',
  		    '000000000000',
  		    '0000000000000',
  		    '00000000000000',
  		    '000000000000000',
  		    '0000000000000000',
  		    '00000000000000000',
  		    '000000000000000000',
  		    '0000000000000000000',
  		    '00000000000000000000',
  		    '000000000000000000000',
  		    '0000000000000000000000',
  		    '00000000000000000000000',
  		    '000000000000000000000000',
  		    '0000000000000000000000000'
  		  ];

  		  var groupSizes = [
  		    0, 0,
  		    25, 16, 12, 11, 10, 9, 8,
  		    8, 7, 7, 7, 7, 6, 6,
  		    6, 6, 6, 6, 6, 5, 5,
  		    5, 5, 5, 5, 5, 5, 5,
  		    5, 5, 5, 5, 5, 5, 5
  		  ];

  		  var groupBases = [
  		    0, 0,
  		    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
  		    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
  		    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
  		    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
  		    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  		  ];

  		  BN.prototype.toString = function toString (base, padding) {
  		    base = base || 10;
  		    padding = padding | 0 || 1;

  		    var out;
  		    if (base === 16 || base === 'hex') {
  		      out = '';
  		      var off = 0;
  		      var carry = 0;
  		      for (var i = 0; i < this.length; i++) {
  		        var w = this.words[i];
  		        var word = (((w << off) | carry) & 0xffffff).toString(16);
  		        carry = (w >>> (24 - off)) & 0xffffff;
  		        off += 2;
  		        if (off >= 26) {
  		          off -= 26;
  		          i--;
  		        }
  		        if (carry !== 0 || i !== this.length - 1) {
  		          out = zeros[6 - word.length] + word + out;
  		        } else {
  		          out = word + out;
  		        }
  		      }
  		      if (carry !== 0) {
  		        out = carry.toString(16) + out;
  		      }
  		      while (out.length % padding !== 0) {
  		        out = '0' + out;
  		      }
  		      if (this.negative !== 0) {
  		        out = '-' + out;
  		      }
  		      return out;
  		    }

  		    if (base === (base | 0) && base >= 2 && base <= 36) {
  		      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
  		      var groupSize = groupSizes[base];
  		      // var groupBase = Math.pow(base, groupSize);
  		      var groupBase = groupBases[base];
  		      out = '';
  		      var c = this.clone();
  		      c.negative = 0;
  		      while (!c.isZero()) {
  		        var r = c.modrn(groupBase).toString(base);
  		        c = c.idivn(groupBase);

  		        if (!c.isZero()) {
  		          out = zeros[groupSize - r.length] + r + out;
  		        } else {
  		          out = r + out;
  		        }
  		      }
  		      if (this.isZero()) {
  		        out = '0' + out;
  		      }
  		      while (out.length % padding !== 0) {
  		        out = '0' + out;
  		      }
  		      if (this.negative !== 0) {
  		        out = '-' + out;
  		      }
  		      return out;
  		    }

  		    assert(false, 'Base should be between 2 and 36');
  		  };

  		  BN.prototype.toNumber = function toNumber () {
  		    var ret = this.words[0];
  		    if (this.length === 2) {
  		      ret += this.words[1] * 0x4000000;
  		    } else if (this.length === 3 && this.words[2] === 0x01) {
  		      // NOTE: at this stage it is known that the top bit is set
  		      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
  		    } else if (this.length > 2) {
  		      assert(false, 'Number can only safely store up to 53 bits');
  		    }
  		    return (this.negative !== 0) ? -ret : ret;
  		  };

  		  BN.prototype.toJSON = function toJSON () {
  		    return this.toString(16, 2);
  		  };

  		  if (Buffer) {
  		    BN.prototype.toBuffer = function toBuffer (endian, length) {
  		      return this.toArrayLike(Buffer, endian, length);
  		    };
  		  }

  		  BN.prototype.toArray = function toArray (endian, length) {
  		    return this.toArrayLike(Array, endian, length);
  		  };

  		  var allocate = function allocate (ArrayType, size) {
  		    if (ArrayType.allocUnsafe) {
  		      return ArrayType.allocUnsafe(size);
  		    }
  		    return new ArrayType(size);
  		  };

  		  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
  		    this._strip();

  		    var byteLength = this.byteLength();
  		    var reqLength = length || Math.max(1, byteLength);
  		    assert(byteLength <= reqLength, 'byte array longer than desired length');
  		    assert(reqLength > 0, 'Requested array length <= 0');

  		    var res = allocate(ArrayType, reqLength);
  		    var postfix = endian === 'le' ? 'LE' : 'BE';
  		    this['_toArrayLike' + postfix](res, byteLength);
  		    return res;
  		  };

  		  BN.prototype._toArrayLikeLE = function _toArrayLikeLE (res, byteLength) {
  		    var position = 0;
  		    var carry = 0;

  		    for (var i = 0, shift = 0; i < this.length; i++) {
  		      var word = (this.words[i] << shift) | carry;

  		      res[position++] = word & 0xff;
  		      if (position < res.length) {
  		        res[position++] = (word >> 8) & 0xff;
  		      }
  		      if (position < res.length) {
  		        res[position++] = (word >> 16) & 0xff;
  		      }

  		      if (shift === 6) {
  		        if (position < res.length) {
  		          res[position++] = (word >> 24) & 0xff;
  		        }
  		        carry = 0;
  		        shift = 0;
  		      } else {
  		        carry = word >>> 24;
  		        shift += 2;
  		      }
  		    }

  		    if (position < res.length) {
  		      res[position++] = carry;

  		      while (position < res.length) {
  		        res[position++] = 0;
  		      }
  		    }
  		  };

  		  BN.prototype._toArrayLikeBE = function _toArrayLikeBE (res, byteLength) {
  		    var position = res.length - 1;
  		    var carry = 0;

  		    for (var i = 0, shift = 0; i < this.length; i++) {
  		      var word = (this.words[i] << shift) | carry;

  		      res[position--] = word & 0xff;
  		      if (position >= 0) {
  		        res[position--] = (word >> 8) & 0xff;
  		      }
  		      if (position >= 0) {
  		        res[position--] = (word >> 16) & 0xff;
  		      }

  		      if (shift === 6) {
  		        if (position >= 0) {
  		          res[position--] = (word >> 24) & 0xff;
  		        }
  		        carry = 0;
  		        shift = 0;
  		      } else {
  		        carry = word >>> 24;
  		        shift += 2;
  		      }
  		    }

  		    if (position >= 0) {
  		      res[position--] = carry;

  		      while (position >= 0) {
  		        res[position--] = 0;
  		      }
  		    }
  		  };

  		  if (Math.clz32) {
  		    BN.prototype._countBits = function _countBits (w) {
  		      return 32 - Math.clz32(w);
  		    };
  		  } else {
  		    BN.prototype._countBits = function _countBits (w) {
  		      var t = w;
  		      var r = 0;
  		      if (t >= 0x1000) {
  		        r += 13;
  		        t >>>= 13;
  		      }
  		      if (t >= 0x40) {
  		        r += 7;
  		        t >>>= 7;
  		      }
  		      if (t >= 0x8) {
  		        r += 4;
  		        t >>>= 4;
  		      }
  		      if (t >= 0x02) {
  		        r += 2;
  		        t >>>= 2;
  		      }
  		      return r + t;
  		    };
  		  }

  		  BN.prototype._zeroBits = function _zeroBits (w) {
  		    // Short-cut
  		    if (w === 0) return 26;

  		    var t = w;
  		    var r = 0;
  		    if ((t & 0x1fff) === 0) {
  		      r += 13;
  		      t >>>= 13;
  		    }
  		    if ((t & 0x7f) === 0) {
  		      r += 7;
  		      t >>>= 7;
  		    }
  		    if ((t & 0xf) === 0) {
  		      r += 4;
  		      t >>>= 4;
  		    }
  		    if ((t & 0x3) === 0) {
  		      r += 2;
  		      t >>>= 2;
  		    }
  		    if ((t & 0x1) === 0) {
  		      r++;
  		    }
  		    return r;
  		  };

  		  // Return number of used bits in a BN
  		  BN.prototype.bitLength = function bitLength () {
  		    var w = this.words[this.length - 1];
  		    var hi = this._countBits(w);
  		    return (this.length - 1) * 26 + hi;
  		  };

  		  function toBitArray (num) {
  		    var w = new Array(num.bitLength());

  		    for (var bit = 0; bit < w.length; bit++) {
  		      var off = (bit / 26) | 0;
  		      var wbit = bit % 26;

  		      w[bit] = (num.words[off] >>> wbit) & 0x01;
  		    }

  		    return w;
  		  }

  		  // Number of trailing zero bits
  		  BN.prototype.zeroBits = function zeroBits () {
  		    if (this.isZero()) return 0;

  		    var r = 0;
  		    for (var i = 0; i < this.length; i++) {
  		      var b = this._zeroBits(this.words[i]);
  		      r += b;
  		      if (b !== 26) break;
  		    }
  		    return r;
  		  };

  		  BN.prototype.byteLength = function byteLength () {
  		    return Math.ceil(this.bitLength() / 8);
  		  };

  		  BN.prototype.toTwos = function toTwos (width) {
  		    if (this.negative !== 0) {
  		      return this.abs().inotn(width).iaddn(1);
  		    }
  		    return this.clone();
  		  };

  		  BN.prototype.fromTwos = function fromTwos (width) {
  		    if (this.testn(width - 1)) {
  		      return this.notn(width).iaddn(1).ineg();
  		    }
  		    return this.clone();
  		  };

  		  BN.prototype.isNeg = function isNeg () {
  		    return this.negative !== 0;
  		  };

  		  // Return negative clone of `this`
  		  BN.prototype.neg = function neg () {
  		    return this.clone().ineg();
  		  };

  		  BN.prototype.ineg = function ineg () {
  		    if (!this.isZero()) {
  		      this.negative ^= 1;
  		    }

  		    return this;
  		  };

  		  // Or `num` with `this` in-place
  		  BN.prototype.iuor = function iuor (num) {
  		    while (this.length < num.length) {
  		      this.words[this.length++] = 0;
  		    }

  		    for (var i = 0; i < num.length; i++) {
  		      this.words[i] = this.words[i] | num.words[i];
  		    }

  		    return this._strip();
  		  };

  		  BN.prototype.ior = function ior (num) {
  		    assert((this.negative | num.negative) === 0);
  		    return this.iuor(num);
  		  };

  		  // Or `num` with `this`
  		  BN.prototype.or = function or (num) {
  		    if (this.length > num.length) return this.clone().ior(num);
  		    return num.clone().ior(this);
  		  };

  		  BN.prototype.uor = function uor (num) {
  		    if (this.length > num.length) return this.clone().iuor(num);
  		    return num.clone().iuor(this);
  		  };

  		  // And `num` with `this` in-place
  		  BN.prototype.iuand = function iuand (num) {
  		    // b = min-length(num, this)
  		    var b;
  		    if (this.length > num.length) {
  		      b = num;
  		    } else {
  		      b = this;
  		    }

  		    for (var i = 0; i < b.length; i++) {
  		      this.words[i] = this.words[i] & num.words[i];
  		    }

  		    this.length = b.length;

  		    return this._strip();
  		  };

  		  BN.prototype.iand = function iand (num) {
  		    assert((this.negative | num.negative) === 0);
  		    return this.iuand(num);
  		  };

  		  // And `num` with `this`
  		  BN.prototype.and = function and (num) {
  		    if (this.length > num.length) return this.clone().iand(num);
  		    return num.clone().iand(this);
  		  };

  		  BN.prototype.uand = function uand (num) {
  		    if (this.length > num.length) return this.clone().iuand(num);
  		    return num.clone().iuand(this);
  		  };

  		  // Xor `num` with `this` in-place
  		  BN.prototype.iuxor = function iuxor (num) {
  		    // a.length > b.length
  		    var a;
  		    var b;
  		    if (this.length > num.length) {
  		      a = this;
  		      b = num;
  		    } else {
  		      a = num;
  		      b = this;
  		    }

  		    for (var i = 0; i < b.length; i++) {
  		      this.words[i] = a.words[i] ^ b.words[i];
  		    }

  		    if (this !== a) {
  		      for (; i < a.length; i++) {
  		        this.words[i] = a.words[i];
  		      }
  		    }

  		    this.length = a.length;

  		    return this._strip();
  		  };

  		  BN.prototype.ixor = function ixor (num) {
  		    assert((this.negative | num.negative) === 0);
  		    return this.iuxor(num);
  		  };

  		  // Xor `num` with `this`
  		  BN.prototype.xor = function xor (num) {
  		    if (this.length > num.length) return this.clone().ixor(num);
  		    return num.clone().ixor(this);
  		  };

  		  BN.prototype.uxor = function uxor (num) {
  		    if (this.length > num.length) return this.clone().iuxor(num);
  		    return num.clone().iuxor(this);
  		  };

  		  // Not ``this`` with ``width`` bitwidth
  		  BN.prototype.inotn = function inotn (width) {
  		    assert(typeof width === 'number' && width >= 0);

  		    var bytesNeeded = Math.ceil(width / 26) | 0;
  		    var bitsLeft = width % 26;

  		    // Extend the buffer with leading zeroes
  		    this._expand(bytesNeeded);

  		    if (bitsLeft > 0) {
  		      bytesNeeded--;
  		    }

  		    // Handle complete words
  		    for (var i = 0; i < bytesNeeded; i++) {
  		      this.words[i] = ~this.words[i] & 0x3ffffff;
  		    }

  		    // Handle the residue
  		    if (bitsLeft > 0) {
  		      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
  		    }

  		    // And remove leading zeroes
  		    return this._strip();
  		  };

  		  BN.prototype.notn = function notn (width) {
  		    return this.clone().inotn(width);
  		  };

  		  // Set `bit` of `this`
  		  BN.prototype.setn = function setn (bit, val) {
  		    assert(typeof bit === 'number' && bit >= 0);

  		    var off = (bit / 26) | 0;
  		    var wbit = bit % 26;

  		    this._expand(off + 1);

  		    if (val) {
  		      this.words[off] = this.words[off] | (1 << wbit);
  		    } else {
  		      this.words[off] = this.words[off] & ~(1 << wbit);
  		    }

  		    return this._strip();
  		  };

  		  // Add `num` to `this` in-place
  		  BN.prototype.iadd = function iadd (num) {
  		    var r;

  		    // negative + positive
  		    if (this.negative !== 0 && num.negative === 0) {
  		      this.negative = 0;
  		      r = this.isub(num);
  		      this.negative ^= 1;
  		      return this._normSign();

  		    // positive + negative
  		    } else if (this.negative === 0 && num.negative !== 0) {
  		      num.negative = 0;
  		      r = this.isub(num);
  		      num.negative = 1;
  		      return r._normSign();
  		    }

  		    // a.length > b.length
  		    var a, b;
  		    if (this.length > num.length) {
  		      a = this;
  		      b = num;
  		    } else {
  		      a = num;
  		      b = this;
  		    }

  		    var carry = 0;
  		    for (var i = 0; i < b.length; i++) {
  		      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
  		      this.words[i] = r & 0x3ffffff;
  		      carry = r >>> 26;
  		    }
  		    for (; carry !== 0 && i < a.length; i++) {
  		      r = (a.words[i] | 0) + carry;
  		      this.words[i] = r & 0x3ffffff;
  		      carry = r >>> 26;
  		    }

  		    this.length = a.length;
  		    if (carry !== 0) {
  		      this.words[this.length] = carry;
  		      this.length++;
  		    // Copy the rest of the words
  		    } else if (a !== this) {
  		      for (; i < a.length; i++) {
  		        this.words[i] = a.words[i];
  		      }
  		    }

  		    return this;
  		  };

  		  // Add `num` to `this`
  		  BN.prototype.add = function add (num) {
  		    var res;
  		    if (num.negative !== 0 && this.negative === 0) {
  		      num.negative = 0;
  		      res = this.sub(num);
  		      num.negative ^= 1;
  		      return res;
  		    } else if (num.negative === 0 && this.negative !== 0) {
  		      this.negative = 0;
  		      res = num.sub(this);
  		      this.negative = 1;
  		      return res;
  		    }

  		    if (this.length > num.length) return this.clone().iadd(num);

  		    return num.clone().iadd(this);
  		  };

  		  // Subtract `num` from `this` in-place
  		  BN.prototype.isub = function isub (num) {
  		    // this - (-num) = this + num
  		    if (num.negative !== 0) {
  		      num.negative = 0;
  		      var r = this.iadd(num);
  		      num.negative = 1;
  		      return r._normSign();

  		    // -this - num = -(this + num)
  		    } else if (this.negative !== 0) {
  		      this.negative = 0;
  		      this.iadd(num);
  		      this.negative = 1;
  		      return this._normSign();
  		    }

  		    // At this point both numbers are positive
  		    var cmp = this.cmp(num);

  		    // Optimization - zeroify
  		    if (cmp === 0) {
  		      this.negative = 0;
  		      this.length = 1;
  		      this.words[0] = 0;
  		      return this;
  		    }

  		    // a > b
  		    var a, b;
  		    if (cmp > 0) {
  		      a = this;
  		      b = num;
  		    } else {
  		      a = num;
  		      b = this;
  		    }

  		    var carry = 0;
  		    for (var i = 0; i < b.length; i++) {
  		      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
  		      carry = r >> 26;
  		      this.words[i] = r & 0x3ffffff;
  		    }
  		    for (; carry !== 0 && i < a.length; i++) {
  		      r = (a.words[i] | 0) + carry;
  		      carry = r >> 26;
  		      this.words[i] = r & 0x3ffffff;
  		    }

  		    // Copy rest of the words
  		    if (carry === 0 && i < a.length && a !== this) {
  		      for (; i < a.length; i++) {
  		        this.words[i] = a.words[i];
  		      }
  		    }

  		    this.length = Math.max(this.length, i);

  		    if (a !== this) {
  		      this.negative = 1;
  		    }

  		    return this._strip();
  		  };

  		  // Subtract `num` from `this`
  		  BN.prototype.sub = function sub (num) {
  		    return this.clone().isub(num);
  		  };

  		  function smallMulTo (self, num, out) {
  		    out.negative = num.negative ^ self.negative;
  		    var len = (self.length + num.length) | 0;
  		    out.length = len;
  		    len = (len - 1) | 0;

  		    // Peel one iteration (compiler can't do it, because of code complexity)
  		    var a = self.words[0] | 0;
  		    var b = num.words[0] | 0;
  		    var r = a * b;

  		    var lo = r & 0x3ffffff;
  		    var carry = (r / 0x4000000) | 0;
  		    out.words[0] = lo;

  		    for (var k = 1; k < len; k++) {
  		      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
  		      // note that ncarry could be >= 0x3ffffff
  		      var ncarry = carry >>> 26;
  		      var rword = carry & 0x3ffffff;
  		      var maxJ = Math.min(k, num.length - 1);
  		      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
  		        var i = (k - j) | 0;
  		        a = self.words[i] | 0;
  		        b = num.words[j] | 0;
  		        r = a * b + rword;
  		        ncarry += (r / 0x4000000) | 0;
  		        rword = r & 0x3ffffff;
  		      }
  		      out.words[k] = rword | 0;
  		      carry = ncarry | 0;
  		    }
  		    if (carry !== 0) {
  		      out.words[k] = carry | 0;
  		    } else {
  		      out.length--;
  		    }

  		    return out._strip();
  		  }

  		  // TODO(indutny): it may be reasonable to omit it for users who don't need
  		  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  		  // multiplication (like elliptic secp256k1).
  		  var comb10MulTo = function comb10MulTo (self, num, out) {
  		    var a = self.words;
  		    var b = num.words;
  		    var o = out.words;
  		    var c = 0;
  		    var lo;
  		    var mid;
  		    var hi;
  		    var a0 = a[0] | 0;
  		    var al0 = a0 & 0x1fff;
  		    var ah0 = a0 >>> 13;
  		    var a1 = a[1] | 0;
  		    var al1 = a1 & 0x1fff;
  		    var ah1 = a1 >>> 13;
  		    var a2 = a[2] | 0;
  		    var al2 = a2 & 0x1fff;
  		    var ah2 = a2 >>> 13;
  		    var a3 = a[3] | 0;
  		    var al3 = a3 & 0x1fff;
  		    var ah3 = a3 >>> 13;
  		    var a4 = a[4] | 0;
  		    var al4 = a4 & 0x1fff;
  		    var ah4 = a4 >>> 13;
  		    var a5 = a[5] | 0;
  		    var al5 = a5 & 0x1fff;
  		    var ah5 = a5 >>> 13;
  		    var a6 = a[6] | 0;
  		    var al6 = a6 & 0x1fff;
  		    var ah6 = a6 >>> 13;
  		    var a7 = a[7] | 0;
  		    var al7 = a7 & 0x1fff;
  		    var ah7 = a7 >>> 13;
  		    var a8 = a[8] | 0;
  		    var al8 = a8 & 0x1fff;
  		    var ah8 = a8 >>> 13;
  		    var a9 = a[9] | 0;
  		    var al9 = a9 & 0x1fff;
  		    var ah9 = a9 >>> 13;
  		    var b0 = b[0] | 0;
  		    var bl0 = b0 & 0x1fff;
  		    var bh0 = b0 >>> 13;
  		    var b1 = b[1] | 0;
  		    var bl1 = b1 & 0x1fff;
  		    var bh1 = b1 >>> 13;
  		    var b2 = b[2] | 0;
  		    var bl2 = b2 & 0x1fff;
  		    var bh2 = b2 >>> 13;
  		    var b3 = b[3] | 0;
  		    var bl3 = b3 & 0x1fff;
  		    var bh3 = b3 >>> 13;
  		    var b4 = b[4] | 0;
  		    var bl4 = b4 & 0x1fff;
  		    var bh4 = b4 >>> 13;
  		    var b5 = b[5] | 0;
  		    var bl5 = b5 & 0x1fff;
  		    var bh5 = b5 >>> 13;
  		    var b6 = b[6] | 0;
  		    var bl6 = b6 & 0x1fff;
  		    var bh6 = b6 >>> 13;
  		    var b7 = b[7] | 0;
  		    var bl7 = b7 & 0x1fff;
  		    var bh7 = b7 >>> 13;
  		    var b8 = b[8] | 0;
  		    var bl8 = b8 & 0x1fff;
  		    var bh8 = b8 >>> 13;
  		    var b9 = b[9] | 0;
  		    var bl9 = b9 & 0x1fff;
  		    var bh9 = b9 >>> 13;

  		    out.negative = self.negative ^ num.negative;
  		    out.length = 19;
  		    /* k = 0 */
  		    lo = Math.imul(al0, bl0);
  		    mid = Math.imul(al0, bh0);
  		    mid = (mid + Math.imul(ah0, bl0)) | 0;
  		    hi = Math.imul(ah0, bh0);
  		    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  		    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
  		    w0 &= 0x3ffffff;
  		    /* k = 1 */
  		    lo = Math.imul(al1, bl0);
  		    mid = Math.imul(al1, bh0);
  		    mid = (mid + Math.imul(ah1, bl0)) | 0;
  		    hi = Math.imul(ah1, bh0);
  		    lo = (lo + Math.imul(al0, bl1)) | 0;
  		    mid = (mid + Math.imul(al0, bh1)) | 0;
  		    mid = (mid + Math.imul(ah0, bl1)) | 0;
  		    hi = (hi + Math.imul(ah0, bh1)) | 0;
  		    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  		    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
  		    w1 &= 0x3ffffff;
  		    /* k = 2 */
  		    lo = Math.imul(al2, bl0);
  		    mid = Math.imul(al2, bh0);
  		    mid = (mid + Math.imul(ah2, bl0)) | 0;
  		    hi = Math.imul(ah2, bh0);
  		    lo = (lo + Math.imul(al1, bl1)) | 0;
  		    mid = (mid + Math.imul(al1, bh1)) | 0;
  		    mid = (mid + Math.imul(ah1, bl1)) | 0;
  		    hi = (hi + Math.imul(ah1, bh1)) | 0;
  		    lo = (lo + Math.imul(al0, bl2)) | 0;
  		    mid = (mid + Math.imul(al0, bh2)) | 0;
  		    mid = (mid + Math.imul(ah0, bl2)) | 0;
  		    hi = (hi + Math.imul(ah0, bh2)) | 0;
  		    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  		    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
  		    w2 &= 0x3ffffff;
  		    /* k = 3 */
  		    lo = Math.imul(al3, bl0);
  		    mid = Math.imul(al3, bh0);
  		    mid = (mid + Math.imul(ah3, bl0)) | 0;
  		    hi = Math.imul(ah3, bh0);
  		    lo = (lo + Math.imul(al2, bl1)) | 0;
  		    mid = (mid + Math.imul(al2, bh1)) | 0;
  		    mid = (mid + Math.imul(ah2, bl1)) | 0;
  		    hi = (hi + Math.imul(ah2, bh1)) | 0;
  		    lo = (lo + Math.imul(al1, bl2)) | 0;
  		    mid = (mid + Math.imul(al1, bh2)) | 0;
  		    mid = (mid + Math.imul(ah1, bl2)) | 0;
  		    hi = (hi + Math.imul(ah1, bh2)) | 0;
  		    lo = (lo + Math.imul(al0, bl3)) | 0;
  		    mid = (mid + Math.imul(al0, bh3)) | 0;
  		    mid = (mid + Math.imul(ah0, bl3)) | 0;
  		    hi = (hi + Math.imul(ah0, bh3)) | 0;
  		    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  		    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
  		    w3 &= 0x3ffffff;
  		    /* k = 4 */
  		    lo = Math.imul(al4, bl0);
  		    mid = Math.imul(al4, bh0);
  		    mid = (mid + Math.imul(ah4, bl0)) | 0;
  		    hi = Math.imul(ah4, bh0);
  		    lo = (lo + Math.imul(al3, bl1)) | 0;
  		    mid = (mid + Math.imul(al3, bh1)) | 0;
  		    mid = (mid + Math.imul(ah3, bl1)) | 0;
  		    hi = (hi + Math.imul(ah3, bh1)) | 0;
  		    lo = (lo + Math.imul(al2, bl2)) | 0;
  		    mid = (mid + Math.imul(al2, bh2)) | 0;
  		    mid = (mid + Math.imul(ah2, bl2)) | 0;
  		    hi = (hi + Math.imul(ah2, bh2)) | 0;
  		    lo = (lo + Math.imul(al1, bl3)) | 0;
  		    mid = (mid + Math.imul(al1, bh3)) | 0;
  		    mid = (mid + Math.imul(ah1, bl3)) | 0;
  		    hi = (hi + Math.imul(ah1, bh3)) | 0;
  		    lo = (lo + Math.imul(al0, bl4)) | 0;
  		    mid = (mid + Math.imul(al0, bh4)) | 0;
  		    mid = (mid + Math.imul(ah0, bl4)) | 0;
  		    hi = (hi + Math.imul(ah0, bh4)) | 0;
  		    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  		    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
  		    w4 &= 0x3ffffff;
  		    /* k = 5 */
  		    lo = Math.imul(al5, bl0);
  		    mid = Math.imul(al5, bh0);
  		    mid = (mid + Math.imul(ah5, bl0)) | 0;
  		    hi = Math.imul(ah5, bh0);
  		    lo = (lo + Math.imul(al4, bl1)) | 0;
  		    mid = (mid + Math.imul(al4, bh1)) | 0;
  		    mid = (mid + Math.imul(ah4, bl1)) | 0;
  		    hi = (hi + Math.imul(ah4, bh1)) | 0;
  		    lo = (lo + Math.imul(al3, bl2)) | 0;
  		    mid = (mid + Math.imul(al3, bh2)) | 0;
  		    mid = (mid + Math.imul(ah3, bl2)) | 0;
  		    hi = (hi + Math.imul(ah3, bh2)) | 0;
  		    lo = (lo + Math.imul(al2, bl3)) | 0;
  		    mid = (mid + Math.imul(al2, bh3)) | 0;
  		    mid = (mid + Math.imul(ah2, bl3)) | 0;
  		    hi = (hi + Math.imul(ah2, bh3)) | 0;
  		    lo = (lo + Math.imul(al1, bl4)) | 0;
  		    mid = (mid + Math.imul(al1, bh4)) | 0;
  		    mid = (mid + Math.imul(ah1, bl4)) | 0;
  		    hi = (hi + Math.imul(ah1, bh4)) | 0;
  		    lo = (lo + Math.imul(al0, bl5)) | 0;
  		    mid = (mid + Math.imul(al0, bh5)) | 0;
  		    mid = (mid + Math.imul(ah0, bl5)) | 0;
  		    hi = (hi + Math.imul(ah0, bh5)) | 0;
  		    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  		    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
  		    w5 &= 0x3ffffff;
  		    /* k = 6 */
  		    lo = Math.imul(al6, bl0);
  		    mid = Math.imul(al6, bh0);
  		    mid = (mid + Math.imul(ah6, bl0)) | 0;
  		    hi = Math.imul(ah6, bh0);
  		    lo = (lo + Math.imul(al5, bl1)) | 0;
  		    mid = (mid + Math.imul(al5, bh1)) | 0;
  		    mid = (mid + Math.imul(ah5, bl1)) | 0;
  		    hi = (hi + Math.imul(ah5, bh1)) | 0;
  		    lo = (lo + Math.imul(al4, bl2)) | 0;
  		    mid = (mid + Math.imul(al4, bh2)) | 0;
  		    mid = (mid + Math.imul(ah4, bl2)) | 0;
  		    hi = (hi + Math.imul(ah4, bh2)) | 0;
  		    lo = (lo + Math.imul(al3, bl3)) | 0;
  		    mid = (mid + Math.imul(al3, bh3)) | 0;
  		    mid = (mid + Math.imul(ah3, bl3)) | 0;
  		    hi = (hi + Math.imul(ah3, bh3)) | 0;
  		    lo = (lo + Math.imul(al2, bl4)) | 0;
  		    mid = (mid + Math.imul(al2, bh4)) | 0;
  		    mid = (mid + Math.imul(ah2, bl4)) | 0;
  		    hi = (hi + Math.imul(ah2, bh4)) | 0;
  		    lo = (lo + Math.imul(al1, bl5)) | 0;
  		    mid = (mid + Math.imul(al1, bh5)) | 0;
  		    mid = (mid + Math.imul(ah1, bl5)) | 0;
  		    hi = (hi + Math.imul(ah1, bh5)) | 0;
  		    lo = (lo + Math.imul(al0, bl6)) | 0;
  		    mid = (mid + Math.imul(al0, bh6)) | 0;
  		    mid = (mid + Math.imul(ah0, bl6)) | 0;
  		    hi = (hi + Math.imul(ah0, bh6)) | 0;
  		    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  		    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
  		    w6 &= 0x3ffffff;
  		    /* k = 7 */
  		    lo = Math.imul(al7, bl0);
  		    mid = Math.imul(al7, bh0);
  		    mid = (mid + Math.imul(ah7, bl0)) | 0;
  		    hi = Math.imul(ah7, bh0);
  		    lo = (lo + Math.imul(al6, bl1)) | 0;
  		    mid = (mid + Math.imul(al6, bh1)) | 0;
  		    mid = (mid + Math.imul(ah6, bl1)) | 0;
  		    hi = (hi + Math.imul(ah6, bh1)) | 0;
  		    lo = (lo + Math.imul(al5, bl2)) | 0;
  		    mid = (mid + Math.imul(al5, bh2)) | 0;
  		    mid = (mid + Math.imul(ah5, bl2)) | 0;
  		    hi = (hi + Math.imul(ah5, bh2)) | 0;
  		    lo = (lo + Math.imul(al4, bl3)) | 0;
  		    mid = (mid + Math.imul(al4, bh3)) | 0;
  		    mid = (mid + Math.imul(ah4, bl3)) | 0;
  		    hi = (hi + Math.imul(ah4, bh3)) | 0;
  		    lo = (lo + Math.imul(al3, bl4)) | 0;
  		    mid = (mid + Math.imul(al3, bh4)) | 0;
  		    mid = (mid + Math.imul(ah3, bl4)) | 0;
  		    hi = (hi + Math.imul(ah3, bh4)) | 0;
  		    lo = (lo + Math.imul(al2, bl5)) | 0;
  		    mid = (mid + Math.imul(al2, bh5)) | 0;
  		    mid = (mid + Math.imul(ah2, bl5)) | 0;
  		    hi = (hi + Math.imul(ah2, bh5)) | 0;
  		    lo = (lo + Math.imul(al1, bl6)) | 0;
  		    mid = (mid + Math.imul(al1, bh6)) | 0;
  		    mid = (mid + Math.imul(ah1, bl6)) | 0;
  		    hi = (hi + Math.imul(ah1, bh6)) | 0;
  		    lo = (lo + Math.imul(al0, bl7)) | 0;
  		    mid = (mid + Math.imul(al0, bh7)) | 0;
  		    mid = (mid + Math.imul(ah0, bl7)) | 0;
  		    hi = (hi + Math.imul(ah0, bh7)) | 0;
  		    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  		    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
  		    w7 &= 0x3ffffff;
  		    /* k = 8 */
  		    lo = Math.imul(al8, bl0);
  		    mid = Math.imul(al8, bh0);
  		    mid = (mid + Math.imul(ah8, bl0)) | 0;
  		    hi = Math.imul(ah8, bh0);
  		    lo = (lo + Math.imul(al7, bl1)) | 0;
  		    mid = (mid + Math.imul(al7, bh1)) | 0;
  		    mid = (mid + Math.imul(ah7, bl1)) | 0;
  		    hi = (hi + Math.imul(ah7, bh1)) | 0;
  		    lo = (lo + Math.imul(al6, bl2)) | 0;
  		    mid = (mid + Math.imul(al6, bh2)) | 0;
  		    mid = (mid + Math.imul(ah6, bl2)) | 0;
  		    hi = (hi + Math.imul(ah6, bh2)) | 0;
  		    lo = (lo + Math.imul(al5, bl3)) | 0;
  		    mid = (mid + Math.imul(al5, bh3)) | 0;
  		    mid = (mid + Math.imul(ah5, bl3)) | 0;
  		    hi = (hi + Math.imul(ah5, bh3)) | 0;
  		    lo = (lo + Math.imul(al4, bl4)) | 0;
  		    mid = (mid + Math.imul(al4, bh4)) | 0;
  		    mid = (mid + Math.imul(ah4, bl4)) | 0;
  		    hi = (hi + Math.imul(ah4, bh4)) | 0;
  		    lo = (lo + Math.imul(al3, bl5)) | 0;
  		    mid = (mid + Math.imul(al3, bh5)) | 0;
  		    mid = (mid + Math.imul(ah3, bl5)) | 0;
  		    hi = (hi + Math.imul(ah3, bh5)) | 0;
  		    lo = (lo + Math.imul(al2, bl6)) | 0;
  		    mid = (mid + Math.imul(al2, bh6)) | 0;
  		    mid = (mid + Math.imul(ah2, bl6)) | 0;
  		    hi = (hi + Math.imul(ah2, bh6)) | 0;
  		    lo = (lo + Math.imul(al1, bl7)) | 0;
  		    mid = (mid + Math.imul(al1, bh7)) | 0;
  		    mid = (mid + Math.imul(ah1, bl7)) | 0;
  		    hi = (hi + Math.imul(ah1, bh7)) | 0;
  		    lo = (lo + Math.imul(al0, bl8)) | 0;
  		    mid = (mid + Math.imul(al0, bh8)) | 0;
  		    mid = (mid + Math.imul(ah0, bl8)) | 0;
  		    hi = (hi + Math.imul(ah0, bh8)) | 0;
  		    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  		    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
  		    w8 &= 0x3ffffff;
  		    /* k = 9 */
  		    lo = Math.imul(al9, bl0);
  		    mid = Math.imul(al9, bh0);
  		    mid = (mid + Math.imul(ah9, bl0)) | 0;
  		    hi = Math.imul(ah9, bh0);
  		    lo = (lo + Math.imul(al8, bl1)) | 0;
  		    mid = (mid + Math.imul(al8, bh1)) | 0;
  		    mid = (mid + Math.imul(ah8, bl1)) | 0;
  		    hi = (hi + Math.imul(ah8, bh1)) | 0;
  		    lo = (lo + Math.imul(al7, bl2)) | 0;
  		    mid = (mid + Math.imul(al7, bh2)) | 0;
  		    mid = (mid + Math.imul(ah7, bl2)) | 0;
  		    hi = (hi + Math.imul(ah7, bh2)) | 0;
  		    lo = (lo + Math.imul(al6, bl3)) | 0;
  		    mid = (mid + Math.imul(al6, bh3)) | 0;
  		    mid = (mid + Math.imul(ah6, bl3)) | 0;
  		    hi = (hi + Math.imul(ah6, bh3)) | 0;
  		    lo = (lo + Math.imul(al5, bl4)) | 0;
  		    mid = (mid + Math.imul(al5, bh4)) | 0;
  		    mid = (mid + Math.imul(ah5, bl4)) | 0;
  		    hi = (hi + Math.imul(ah5, bh4)) | 0;
  		    lo = (lo + Math.imul(al4, bl5)) | 0;
  		    mid = (mid + Math.imul(al4, bh5)) | 0;
  		    mid = (mid + Math.imul(ah4, bl5)) | 0;
  		    hi = (hi + Math.imul(ah4, bh5)) | 0;
  		    lo = (lo + Math.imul(al3, bl6)) | 0;
  		    mid = (mid + Math.imul(al3, bh6)) | 0;
  		    mid = (mid + Math.imul(ah3, bl6)) | 0;
  		    hi = (hi + Math.imul(ah3, bh6)) | 0;
  		    lo = (lo + Math.imul(al2, bl7)) | 0;
  		    mid = (mid + Math.imul(al2, bh7)) | 0;
  		    mid = (mid + Math.imul(ah2, bl7)) | 0;
  		    hi = (hi + Math.imul(ah2, bh7)) | 0;
  		    lo = (lo + Math.imul(al1, bl8)) | 0;
  		    mid = (mid + Math.imul(al1, bh8)) | 0;
  		    mid = (mid + Math.imul(ah1, bl8)) | 0;
  		    hi = (hi + Math.imul(ah1, bh8)) | 0;
  		    lo = (lo + Math.imul(al0, bl9)) | 0;
  		    mid = (mid + Math.imul(al0, bh9)) | 0;
  		    mid = (mid + Math.imul(ah0, bl9)) | 0;
  		    hi = (hi + Math.imul(ah0, bh9)) | 0;
  		    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  		    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
  		    w9 &= 0x3ffffff;
  		    /* k = 10 */
  		    lo = Math.imul(al9, bl1);
  		    mid = Math.imul(al9, bh1);
  		    mid = (mid + Math.imul(ah9, bl1)) | 0;
  		    hi = Math.imul(ah9, bh1);
  		    lo = (lo + Math.imul(al8, bl2)) | 0;
  		    mid = (mid + Math.imul(al8, bh2)) | 0;
  		    mid = (mid + Math.imul(ah8, bl2)) | 0;
  		    hi = (hi + Math.imul(ah8, bh2)) | 0;
  		    lo = (lo + Math.imul(al7, bl3)) | 0;
  		    mid = (mid + Math.imul(al7, bh3)) | 0;
  		    mid = (mid + Math.imul(ah7, bl3)) | 0;
  		    hi = (hi + Math.imul(ah7, bh3)) | 0;
  		    lo = (lo + Math.imul(al6, bl4)) | 0;
  		    mid = (mid + Math.imul(al6, bh4)) | 0;
  		    mid = (mid + Math.imul(ah6, bl4)) | 0;
  		    hi = (hi + Math.imul(ah6, bh4)) | 0;
  		    lo = (lo + Math.imul(al5, bl5)) | 0;
  		    mid = (mid + Math.imul(al5, bh5)) | 0;
  		    mid = (mid + Math.imul(ah5, bl5)) | 0;
  		    hi = (hi + Math.imul(ah5, bh5)) | 0;
  		    lo = (lo + Math.imul(al4, bl6)) | 0;
  		    mid = (mid + Math.imul(al4, bh6)) | 0;
  		    mid = (mid + Math.imul(ah4, bl6)) | 0;
  		    hi = (hi + Math.imul(ah4, bh6)) | 0;
  		    lo = (lo + Math.imul(al3, bl7)) | 0;
  		    mid = (mid + Math.imul(al3, bh7)) | 0;
  		    mid = (mid + Math.imul(ah3, bl7)) | 0;
  		    hi = (hi + Math.imul(ah3, bh7)) | 0;
  		    lo = (lo + Math.imul(al2, bl8)) | 0;
  		    mid = (mid + Math.imul(al2, bh8)) | 0;
  		    mid = (mid + Math.imul(ah2, bl8)) | 0;
  		    hi = (hi + Math.imul(ah2, bh8)) | 0;
  		    lo = (lo + Math.imul(al1, bl9)) | 0;
  		    mid = (mid + Math.imul(al1, bh9)) | 0;
  		    mid = (mid + Math.imul(ah1, bl9)) | 0;
  		    hi = (hi + Math.imul(ah1, bh9)) | 0;
  		    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  		    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
  		    w10 &= 0x3ffffff;
  		    /* k = 11 */
  		    lo = Math.imul(al9, bl2);
  		    mid = Math.imul(al9, bh2);
  		    mid = (mid + Math.imul(ah9, bl2)) | 0;
  		    hi = Math.imul(ah9, bh2);
  		    lo = (lo + Math.imul(al8, bl3)) | 0;
  		    mid = (mid + Math.imul(al8, bh3)) | 0;
  		    mid = (mid + Math.imul(ah8, bl3)) | 0;
  		    hi = (hi + Math.imul(ah8, bh3)) | 0;
  		    lo = (lo + Math.imul(al7, bl4)) | 0;
  		    mid = (mid + Math.imul(al7, bh4)) | 0;
  		    mid = (mid + Math.imul(ah7, bl4)) | 0;
  		    hi = (hi + Math.imul(ah7, bh4)) | 0;
  		    lo = (lo + Math.imul(al6, bl5)) | 0;
  		    mid = (mid + Math.imul(al6, bh5)) | 0;
  		    mid = (mid + Math.imul(ah6, bl5)) | 0;
  		    hi = (hi + Math.imul(ah6, bh5)) | 0;
  		    lo = (lo + Math.imul(al5, bl6)) | 0;
  		    mid = (mid + Math.imul(al5, bh6)) | 0;
  		    mid = (mid + Math.imul(ah5, bl6)) | 0;
  		    hi = (hi + Math.imul(ah5, bh6)) | 0;
  		    lo = (lo + Math.imul(al4, bl7)) | 0;
  		    mid = (mid + Math.imul(al4, bh7)) | 0;
  		    mid = (mid + Math.imul(ah4, bl7)) | 0;
  		    hi = (hi + Math.imul(ah4, bh7)) | 0;
  		    lo = (lo + Math.imul(al3, bl8)) | 0;
  		    mid = (mid + Math.imul(al3, bh8)) | 0;
  		    mid = (mid + Math.imul(ah3, bl8)) | 0;
  		    hi = (hi + Math.imul(ah3, bh8)) | 0;
  		    lo = (lo + Math.imul(al2, bl9)) | 0;
  		    mid = (mid + Math.imul(al2, bh9)) | 0;
  		    mid = (mid + Math.imul(ah2, bl9)) | 0;
  		    hi = (hi + Math.imul(ah2, bh9)) | 0;
  		    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  		    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
  		    w11 &= 0x3ffffff;
  		    /* k = 12 */
  		    lo = Math.imul(al9, bl3);
  		    mid = Math.imul(al9, bh3);
  		    mid = (mid + Math.imul(ah9, bl3)) | 0;
  		    hi = Math.imul(ah9, bh3);
  		    lo = (lo + Math.imul(al8, bl4)) | 0;
  		    mid = (mid + Math.imul(al8, bh4)) | 0;
  		    mid = (mid + Math.imul(ah8, bl4)) | 0;
  		    hi = (hi + Math.imul(ah8, bh4)) | 0;
  		    lo = (lo + Math.imul(al7, bl5)) | 0;
  		    mid = (mid + Math.imul(al7, bh5)) | 0;
  		    mid = (mid + Math.imul(ah7, bl5)) | 0;
  		    hi = (hi + Math.imul(ah7, bh5)) | 0;
  		    lo = (lo + Math.imul(al6, bl6)) | 0;
  		    mid = (mid + Math.imul(al6, bh6)) | 0;
  		    mid = (mid + Math.imul(ah6, bl6)) | 0;
  		    hi = (hi + Math.imul(ah6, bh6)) | 0;
  		    lo = (lo + Math.imul(al5, bl7)) | 0;
  		    mid = (mid + Math.imul(al5, bh7)) | 0;
  		    mid = (mid + Math.imul(ah5, bl7)) | 0;
  		    hi = (hi + Math.imul(ah5, bh7)) | 0;
  		    lo = (lo + Math.imul(al4, bl8)) | 0;
  		    mid = (mid + Math.imul(al4, bh8)) | 0;
  		    mid = (mid + Math.imul(ah4, bl8)) | 0;
  		    hi = (hi + Math.imul(ah4, bh8)) | 0;
  		    lo = (lo + Math.imul(al3, bl9)) | 0;
  		    mid = (mid + Math.imul(al3, bh9)) | 0;
  		    mid = (mid + Math.imul(ah3, bl9)) | 0;
  		    hi = (hi + Math.imul(ah3, bh9)) | 0;
  		    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  		    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
  		    w12 &= 0x3ffffff;
  		    /* k = 13 */
  		    lo = Math.imul(al9, bl4);
  		    mid = Math.imul(al9, bh4);
  		    mid = (mid + Math.imul(ah9, bl4)) | 0;
  		    hi = Math.imul(ah9, bh4);
  		    lo = (lo + Math.imul(al8, bl5)) | 0;
  		    mid = (mid + Math.imul(al8, bh5)) | 0;
  		    mid = (mid + Math.imul(ah8, bl5)) | 0;
  		    hi = (hi + Math.imul(ah8, bh5)) | 0;
  		    lo = (lo + Math.imul(al7, bl6)) | 0;
  		    mid = (mid + Math.imul(al7, bh6)) | 0;
  		    mid = (mid + Math.imul(ah7, bl6)) | 0;
  		    hi = (hi + Math.imul(ah7, bh6)) | 0;
  		    lo = (lo + Math.imul(al6, bl7)) | 0;
  		    mid = (mid + Math.imul(al6, bh7)) | 0;
  		    mid = (mid + Math.imul(ah6, bl7)) | 0;
  		    hi = (hi + Math.imul(ah6, bh7)) | 0;
  		    lo = (lo + Math.imul(al5, bl8)) | 0;
  		    mid = (mid + Math.imul(al5, bh8)) | 0;
  		    mid = (mid + Math.imul(ah5, bl8)) | 0;
  		    hi = (hi + Math.imul(ah5, bh8)) | 0;
  		    lo = (lo + Math.imul(al4, bl9)) | 0;
  		    mid = (mid + Math.imul(al4, bh9)) | 0;
  		    mid = (mid + Math.imul(ah4, bl9)) | 0;
  		    hi = (hi + Math.imul(ah4, bh9)) | 0;
  		    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  		    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
  		    w13 &= 0x3ffffff;
  		    /* k = 14 */
  		    lo = Math.imul(al9, bl5);
  		    mid = Math.imul(al9, bh5);
  		    mid = (mid + Math.imul(ah9, bl5)) | 0;
  		    hi = Math.imul(ah9, bh5);
  		    lo = (lo + Math.imul(al8, bl6)) | 0;
  		    mid = (mid + Math.imul(al8, bh6)) | 0;
  		    mid = (mid + Math.imul(ah8, bl6)) | 0;
  		    hi = (hi + Math.imul(ah8, bh6)) | 0;
  		    lo = (lo + Math.imul(al7, bl7)) | 0;
  		    mid = (mid + Math.imul(al7, bh7)) | 0;
  		    mid = (mid + Math.imul(ah7, bl7)) | 0;
  		    hi = (hi + Math.imul(ah7, bh7)) | 0;
  		    lo = (lo + Math.imul(al6, bl8)) | 0;
  		    mid = (mid + Math.imul(al6, bh8)) | 0;
  		    mid = (mid + Math.imul(ah6, bl8)) | 0;
  		    hi = (hi + Math.imul(ah6, bh8)) | 0;
  		    lo = (lo + Math.imul(al5, bl9)) | 0;
  		    mid = (mid + Math.imul(al5, bh9)) | 0;
  		    mid = (mid + Math.imul(ah5, bl9)) | 0;
  		    hi = (hi + Math.imul(ah5, bh9)) | 0;
  		    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  		    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
  		    w14 &= 0x3ffffff;
  		    /* k = 15 */
  		    lo = Math.imul(al9, bl6);
  		    mid = Math.imul(al9, bh6);
  		    mid = (mid + Math.imul(ah9, bl6)) | 0;
  		    hi = Math.imul(ah9, bh6);
  		    lo = (lo + Math.imul(al8, bl7)) | 0;
  		    mid = (mid + Math.imul(al8, bh7)) | 0;
  		    mid = (mid + Math.imul(ah8, bl7)) | 0;
  		    hi = (hi + Math.imul(ah8, bh7)) | 0;
  		    lo = (lo + Math.imul(al7, bl8)) | 0;
  		    mid = (mid + Math.imul(al7, bh8)) | 0;
  		    mid = (mid + Math.imul(ah7, bl8)) | 0;
  		    hi = (hi + Math.imul(ah7, bh8)) | 0;
  		    lo = (lo + Math.imul(al6, bl9)) | 0;
  		    mid = (mid + Math.imul(al6, bh9)) | 0;
  		    mid = (mid + Math.imul(ah6, bl9)) | 0;
  		    hi = (hi + Math.imul(ah6, bh9)) | 0;
  		    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  		    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
  		    w15 &= 0x3ffffff;
  		    /* k = 16 */
  		    lo = Math.imul(al9, bl7);
  		    mid = Math.imul(al9, bh7);
  		    mid = (mid + Math.imul(ah9, bl7)) | 0;
  		    hi = Math.imul(ah9, bh7);
  		    lo = (lo + Math.imul(al8, bl8)) | 0;
  		    mid = (mid + Math.imul(al8, bh8)) | 0;
  		    mid = (mid + Math.imul(ah8, bl8)) | 0;
  		    hi = (hi + Math.imul(ah8, bh8)) | 0;
  		    lo = (lo + Math.imul(al7, bl9)) | 0;
  		    mid = (mid + Math.imul(al7, bh9)) | 0;
  		    mid = (mid + Math.imul(ah7, bl9)) | 0;
  		    hi = (hi + Math.imul(ah7, bh9)) | 0;
  		    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  		    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
  		    w16 &= 0x3ffffff;
  		    /* k = 17 */
  		    lo = Math.imul(al9, bl8);
  		    mid = Math.imul(al9, bh8);
  		    mid = (mid + Math.imul(ah9, bl8)) | 0;
  		    hi = Math.imul(ah9, bh8);
  		    lo = (lo + Math.imul(al8, bl9)) | 0;
  		    mid = (mid + Math.imul(al8, bh9)) | 0;
  		    mid = (mid + Math.imul(ah8, bl9)) | 0;
  		    hi = (hi + Math.imul(ah8, bh9)) | 0;
  		    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  		    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
  		    w17 &= 0x3ffffff;
  		    /* k = 18 */
  		    lo = Math.imul(al9, bl9);
  		    mid = Math.imul(al9, bh9);
  		    mid = (mid + Math.imul(ah9, bl9)) | 0;
  		    hi = Math.imul(ah9, bh9);
  		    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  		    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
  		    w18 &= 0x3ffffff;
  		    o[0] = w0;
  		    o[1] = w1;
  		    o[2] = w2;
  		    o[3] = w3;
  		    o[4] = w4;
  		    o[5] = w5;
  		    o[6] = w6;
  		    o[7] = w7;
  		    o[8] = w8;
  		    o[9] = w9;
  		    o[10] = w10;
  		    o[11] = w11;
  		    o[12] = w12;
  		    o[13] = w13;
  		    o[14] = w14;
  		    o[15] = w15;
  		    o[16] = w16;
  		    o[17] = w17;
  		    o[18] = w18;
  		    if (c !== 0) {
  		      o[19] = c;
  		      out.length++;
  		    }
  		    return out;
  		  };

  		  // Polyfill comb
  		  if (!Math.imul) {
  		    comb10MulTo = smallMulTo;
  		  }

  		  function bigMulTo (self, num, out) {
  		    out.negative = num.negative ^ self.negative;
  		    out.length = self.length + num.length;

  		    var carry = 0;
  		    var hncarry = 0;
  		    for (var k = 0; k < out.length - 1; k++) {
  		      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
  		      // note that ncarry could be >= 0x3ffffff
  		      var ncarry = hncarry;
  		      hncarry = 0;
  		      var rword = carry & 0x3ffffff;
  		      var maxJ = Math.min(k, num.length - 1);
  		      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
  		        var i = k - j;
  		        var a = self.words[i] | 0;
  		        var b = num.words[j] | 0;
  		        var r = a * b;

  		        var lo = r & 0x3ffffff;
  		        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
  		        lo = (lo + rword) | 0;
  		        rword = lo & 0x3ffffff;
  		        ncarry = (ncarry + (lo >>> 26)) | 0;

  		        hncarry += ncarry >>> 26;
  		        ncarry &= 0x3ffffff;
  		      }
  		      out.words[k] = rword;
  		      carry = ncarry;
  		      ncarry = hncarry;
  		    }
  		    if (carry !== 0) {
  		      out.words[k] = carry;
  		    } else {
  		      out.length--;
  		    }

  		    return out._strip();
  		  }

  		  function jumboMulTo (self, num, out) {
  		    // Temporary disable, see https://github.com/indutny/bn.js/issues/211
  		    // var fftm = new FFTM();
  		    // return fftm.mulp(self, num, out);
  		    return bigMulTo(self, num, out);
  		  }

  		  BN.prototype.mulTo = function mulTo (num, out) {
  		    var res;
  		    var len = this.length + num.length;
  		    if (this.length === 10 && num.length === 10) {
  		      res = comb10MulTo(this, num, out);
  		    } else if (len < 63) {
  		      res = smallMulTo(this, num, out);
  		    } else if (len < 1024) {
  		      res = bigMulTo(this, num, out);
  		    } else {
  		      res = jumboMulTo(this, num, out);
  		    }

  		    return res;
  		  };

  		  // Multiply `this` by `num`
  		  BN.prototype.mul = function mul (num) {
  		    var out = new BN(null);
  		    out.words = new Array(this.length + num.length);
  		    return this.mulTo(num, out);
  		  };

  		  // Multiply employing FFT
  		  BN.prototype.mulf = function mulf (num) {
  		    var out = new BN(null);
  		    out.words = new Array(this.length + num.length);
  		    return jumboMulTo(this, num, out);
  		  };

  		  // In-place Multiplication
  		  BN.prototype.imul = function imul (num) {
  		    return this.clone().mulTo(num, this);
  		  };

  		  BN.prototype.imuln = function imuln (num) {
  		    var isNegNum = num < 0;
  		    if (isNegNum) num = -num;

  		    assert(typeof num === 'number');
  		    assert(num < 0x4000000);

  		    // Carry
  		    var carry = 0;
  		    for (var i = 0; i < this.length; i++) {
  		      var w = (this.words[i] | 0) * num;
  		      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
  		      carry >>= 26;
  		      carry += (w / 0x4000000) | 0;
  		      // NOTE: lo is 27bit maximum
  		      carry += lo >>> 26;
  		      this.words[i] = lo & 0x3ffffff;
  		    }

  		    if (carry !== 0) {
  		      this.words[i] = carry;
  		      this.length++;
  		    }

  		    return isNegNum ? this.ineg() : this;
  		  };

  		  BN.prototype.muln = function muln (num) {
  		    return this.clone().imuln(num);
  		  };

  		  // `this` * `this`
  		  BN.prototype.sqr = function sqr () {
  		    return this.mul(this);
  		  };

  		  // `this` * `this` in-place
  		  BN.prototype.isqr = function isqr () {
  		    return this.imul(this.clone());
  		  };

  		  // Math.pow(`this`, `num`)
  		  BN.prototype.pow = function pow (num) {
  		    var w = toBitArray(num);
  		    if (w.length === 0) return new BN(1);

  		    // Skip leading zeroes
  		    var res = this;
  		    for (var i = 0; i < w.length; i++, res = res.sqr()) {
  		      if (w[i] !== 0) break;
  		    }

  		    if (++i < w.length) {
  		      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
  		        if (w[i] === 0) continue;

  		        res = res.mul(q);
  		      }
  		    }

  		    return res;
  		  };

  		  // Shift-left in-place
  		  BN.prototype.iushln = function iushln (bits) {
  		    assert(typeof bits === 'number' && bits >= 0);
  		    var r = bits % 26;
  		    var s = (bits - r) / 26;
  		    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
  		    var i;

  		    if (r !== 0) {
  		      var carry = 0;

  		      for (i = 0; i < this.length; i++) {
  		        var newCarry = this.words[i] & carryMask;
  		        var c = ((this.words[i] | 0) - newCarry) << r;
  		        this.words[i] = c | carry;
  		        carry = newCarry >>> (26 - r);
  		      }

  		      if (carry) {
  		        this.words[i] = carry;
  		        this.length++;
  		      }
  		    }

  		    if (s !== 0) {
  		      for (i = this.length - 1; i >= 0; i--) {
  		        this.words[i + s] = this.words[i];
  		      }

  		      for (i = 0; i < s; i++) {
  		        this.words[i] = 0;
  		      }

  		      this.length += s;
  		    }

  		    return this._strip();
  		  };

  		  BN.prototype.ishln = function ishln (bits) {
  		    // TODO(indutny): implement me
  		    assert(this.negative === 0);
  		    return this.iushln(bits);
  		  };

  		  // Shift-right in-place
  		  // NOTE: `hint` is a lowest bit before trailing zeroes
  		  // NOTE: if `extended` is present - it will be filled with destroyed bits
  		  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
  		    assert(typeof bits === 'number' && bits >= 0);
  		    var h;
  		    if (hint) {
  		      h = (hint - (hint % 26)) / 26;
  		    } else {
  		      h = 0;
  		    }

  		    var r = bits % 26;
  		    var s = Math.min((bits - r) / 26, this.length);
  		    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
  		    var maskedWords = extended;

  		    h -= s;
  		    h = Math.max(0, h);

  		    // Extended mode, copy masked part
  		    if (maskedWords) {
  		      for (var i = 0; i < s; i++) {
  		        maskedWords.words[i] = this.words[i];
  		      }
  		      maskedWords.length = s;
  		    }

  		    if (s === 0) ; else if (this.length > s) {
  		      this.length -= s;
  		      for (i = 0; i < this.length; i++) {
  		        this.words[i] = this.words[i + s];
  		      }
  		    } else {
  		      this.words[0] = 0;
  		      this.length = 1;
  		    }

  		    var carry = 0;
  		    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
  		      var word = this.words[i] | 0;
  		      this.words[i] = (carry << (26 - r)) | (word >>> r);
  		      carry = word & mask;
  		    }

  		    // Push carried bits as a mask
  		    if (maskedWords && carry !== 0) {
  		      maskedWords.words[maskedWords.length++] = carry;
  		    }

  		    if (this.length === 0) {
  		      this.words[0] = 0;
  		      this.length = 1;
  		    }

  		    return this._strip();
  		  };

  		  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
  		    // TODO(indutny): implement me
  		    assert(this.negative === 0);
  		    return this.iushrn(bits, hint, extended);
  		  };

  		  // Shift-left
  		  BN.prototype.shln = function shln (bits) {
  		    return this.clone().ishln(bits);
  		  };

  		  BN.prototype.ushln = function ushln (bits) {
  		    return this.clone().iushln(bits);
  		  };

  		  // Shift-right
  		  BN.prototype.shrn = function shrn (bits) {
  		    return this.clone().ishrn(bits);
  		  };

  		  BN.prototype.ushrn = function ushrn (bits) {
  		    return this.clone().iushrn(bits);
  		  };

  		  // Test if n bit is set
  		  BN.prototype.testn = function testn (bit) {
  		    assert(typeof bit === 'number' && bit >= 0);
  		    var r = bit % 26;
  		    var s = (bit - r) / 26;
  		    var q = 1 << r;

  		    // Fast case: bit is much higher than all existing words
  		    if (this.length <= s) return false;

  		    // Check bit and return
  		    var w = this.words[s];

  		    return !!(w & q);
  		  };

  		  // Return only lowers bits of number (in-place)
  		  BN.prototype.imaskn = function imaskn (bits) {
  		    assert(typeof bits === 'number' && bits >= 0);
  		    var r = bits % 26;
  		    var s = (bits - r) / 26;

  		    assert(this.negative === 0, 'imaskn works only with positive numbers');

  		    if (this.length <= s) {
  		      return this;
  		    }

  		    if (r !== 0) {
  		      s++;
  		    }
  		    this.length = Math.min(s, this.length);

  		    if (r !== 0) {
  		      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
  		      this.words[this.length - 1] &= mask;
  		    }

  		    return this._strip();
  		  };

  		  // Return only lowers bits of number
  		  BN.prototype.maskn = function maskn (bits) {
  		    return this.clone().imaskn(bits);
  		  };

  		  // Add plain number `num` to `this`
  		  BN.prototype.iaddn = function iaddn (num) {
  		    assert(typeof num === 'number');
  		    assert(num < 0x4000000);
  		    if (num < 0) return this.isubn(-num);

  		    // Possible sign change
  		    if (this.negative !== 0) {
  		      if (this.length === 1 && (this.words[0] | 0) <= num) {
  		        this.words[0] = num - (this.words[0] | 0);
  		        this.negative = 0;
  		        return this;
  		      }

  		      this.negative = 0;
  		      this.isubn(num);
  		      this.negative = 1;
  		      return this;
  		    }

  		    // Add without checks
  		    return this._iaddn(num);
  		  };

  		  BN.prototype._iaddn = function _iaddn (num) {
  		    this.words[0] += num;

  		    // Carry
  		    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
  		      this.words[i] -= 0x4000000;
  		      if (i === this.length - 1) {
  		        this.words[i + 1] = 1;
  		      } else {
  		        this.words[i + 1]++;
  		      }
  		    }
  		    this.length = Math.max(this.length, i + 1);

  		    return this;
  		  };

  		  // Subtract plain number `num` from `this`
  		  BN.prototype.isubn = function isubn (num) {
  		    assert(typeof num === 'number');
  		    assert(num < 0x4000000);
  		    if (num < 0) return this.iaddn(-num);

  		    if (this.negative !== 0) {
  		      this.negative = 0;
  		      this.iaddn(num);
  		      this.negative = 1;
  		      return this;
  		    }

  		    this.words[0] -= num;

  		    if (this.length === 1 && this.words[0] < 0) {
  		      this.words[0] = -this.words[0];
  		      this.negative = 1;
  		    } else {
  		      // Carry
  		      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
  		        this.words[i] += 0x4000000;
  		        this.words[i + 1] -= 1;
  		      }
  		    }

  		    return this._strip();
  		  };

  		  BN.prototype.addn = function addn (num) {
  		    return this.clone().iaddn(num);
  		  };

  		  BN.prototype.subn = function subn (num) {
  		    return this.clone().isubn(num);
  		  };

  		  BN.prototype.iabs = function iabs () {
  		    this.negative = 0;

  		    return this;
  		  };

  		  BN.prototype.abs = function abs () {
  		    return this.clone().iabs();
  		  };

  		  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
  		    var len = num.length + shift;
  		    var i;

  		    this._expand(len);

  		    var w;
  		    var carry = 0;
  		    for (i = 0; i < num.length; i++) {
  		      w = (this.words[i + shift] | 0) + carry;
  		      var right = (num.words[i] | 0) * mul;
  		      w -= right & 0x3ffffff;
  		      carry = (w >> 26) - ((right / 0x4000000) | 0);
  		      this.words[i + shift] = w & 0x3ffffff;
  		    }
  		    for (; i < this.length - shift; i++) {
  		      w = (this.words[i + shift] | 0) + carry;
  		      carry = w >> 26;
  		      this.words[i + shift] = w & 0x3ffffff;
  		    }

  		    if (carry === 0) return this._strip();

  		    // Subtraction overflow
  		    assert(carry === -1);
  		    carry = 0;
  		    for (i = 0; i < this.length; i++) {
  		      w = -(this.words[i] | 0) + carry;
  		      carry = w >> 26;
  		      this.words[i] = w & 0x3ffffff;
  		    }
  		    this.negative = 1;

  		    return this._strip();
  		  };

  		  BN.prototype._wordDiv = function _wordDiv (num, mode) {
  		    var shift = this.length - num.length;

  		    var a = this.clone();
  		    var b = num;

  		    // Normalize
  		    var bhi = b.words[b.length - 1] | 0;
  		    var bhiBits = this._countBits(bhi);
  		    shift = 26 - bhiBits;
  		    if (shift !== 0) {
  		      b = b.ushln(shift);
  		      a.iushln(shift);
  		      bhi = b.words[b.length - 1] | 0;
  		    }

  		    // Initialize quotient
  		    var m = a.length - b.length;
  		    var q;

  		    if (mode !== 'mod') {
  		      q = new BN(null);
  		      q.length = m + 1;
  		      q.words = new Array(q.length);
  		      for (var i = 0; i < q.length; i++) {
  		        q.words[i] = 0;
  		      }
  		    }

  		    var diff = a.clone()._ishlnsubmul(b, 1, m);
  		    if (diff.negative === 0) {
  		      a = diff;
  		      if (q) {
  		        q.words[m] = 1;
  		      }
  		    }

  		    for (var j = m - 1; j >= 0; j--) {
  		      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
  		        (a.words[b.length + j - 1] | 0);

  		      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
  		      // (0x7ffffff)
  		      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

  		      a._ishlnsubmul(b, qj, j);
  		      while (a.negative !== 0) {
  		        qj--;
  		        a.negative = 0;
  		        a._ishlnsubmul(b, 1, j);
  		        if (!a.isZero()) {
  		          a.negative ^= 1;
  		        }
  		      }
  		      if (q) {
  		        q.words[j] = qj;
  		      }
  		    }
  		    if (q) {
  		      q._strip();
  		    }
  		    a._strip();

  		    // Denormalize
  		    if (mode !== 'div' && shift !== 0) {
  		      a.iushrn(shift);
  		    }

  		    return {
  		      div: q || null,
  		      mod: a
  		    };
  		  };

  		  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  		  //       to `div` to request div only, or be absent to
  		  //       request both div & mod
  		  //       2) `positive` is true if unsigned mod is requested
  		  BN.prototype.divmod = function divmod (num, mode, positive) {
  		    assert(!num.isZero());

  		    if (this.isZero()) {
  		      return {
  		        div: new BN(0),
  		        mod: new BN(0)
  		      };
  		    }

  		    var div, mod, res;
  		    if (this.negative !== 0 && num.negative === 0) {
  		      res = this.neg().divmod(num, mode);

  		      if (mode !== 'mod') {
  		        div = res.div.neg();
  		      }

  		      if (mode !== 'div') {
  		        mod = res.mod.neg();
  		        if (positive && mod.negative !== 0) {
  		          mod.iadd(num);
  		        }
  		      }

  		      return {
  		        div: div,
  		        mod: mod
  		      };
  		    }

  		    if (this.negative === 0 && num.negative !== 0) {
  		      res = this.divmod(num.neg(), mode);

  		      if (mode !== 'mod') {
  		        div = res.div.neg();
  		      }

  		      return {
  		        div: div,
  		        mod: res.mod
  		      };
  		    }

  		    if ((this.negative & num.negative) !== 0) {
  		      res = this.neg().divmod(num.neg(), mode);

  		      if (mode !== 'div') {
  		        mod = res.mod.neg();
  		        if (positive && mod.negative !== 0) {
  		          mod.isub(num);
  		        }
  		      }

  		      return {
  		        div: res.div,
  		        mod: mod
  		      };
  		    }

  		    // Both numbers are positive at this point

  		    // Strip both numbers to approximate shift value
  		    if (num.length > this.length || this.cmp(num) < 0) {
  		      return {
  		        div: new BN(0),
  		        mod: this
  		      };
  		    }

  		    // Very short reduction
  		    if (num.length === 1) {
  		      if (mode === 'div') {
  		        return {
  		          div: this.divn(num.words[0]),
  		          mod: null
  		        };
  		      }

  		      if (mode === 'mod') {
  		        return {
  		          div: null,
  		          mod: new BN(this.modrn(num.words[0]))
  		        };
  		      }

  		      return {
  		        div: this.divn(num.words[0]),
  		        mod: new BN(this.modrn(num.words[0]))
  		      };
  		    }

  		    return this._wordDiv(num, mode);
  		  };

  		  // Find `this` / `num`
  		  BN.prototype.div = function div (num) {
  		    return this.divmod(num, 'div', false).div;
  		  };

  		  // Find `this` % `num`
  		  BN.prototype.mod = function mod (num) {
  		    return this.divmod(num, 'mod', false).mod;
  		  };

  		  BN.prototype.umod = function umod (num) {
  		    return this.divmod(num, 'mod', true).mod;
  		  };

  		  // Find Round(`this` / `num`)
  		  BN.prototype.divRound = function divRound (num) {
  		    var dm = this.divmod(num);

  		    // Fast case - exact division
  		    if (dm.mod.isZero()) return dm.div;

  		    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

  		    var half = num.ushrn(1);
  		    var r2 = num.andln(1);
  		    var cmp = mod.cmp(half);

  		    // Round down
  		    if (cmp < 0 || (r2 === 1 && cmp === 0)) return dm.div;

  		    // Round up
  		    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  		  };

  		  BN.prototype.modrn = function modrn (num) {
  		    var isNegNum = num < 0;
  		    if (isNegNum) num = -num;

  		    assert(num <= 0x3ffffff);
  		    var p = (1 << 26) % num;

  		    var acc = 0;
  		    for (var i = this.length - 1; i >= 0; i--) {
  		      acc = (p * acc + (this.words[i] | 0)) % num;
  		    }

  		    return isNegNum ? -acc : acc;
  		  };

  		  // WARNING: DEPRECATED
  		  BN.prototype.modn = function modn (num) {
  		    return this.modrn(num);
  		  };

  		  // In-place division by number
  		  BN.prototype.idivn = function idivn (num) {
  		    var isNegNum = num < 0;
  		    if (isNegNum) num = -num;

  		    assert(num <= 0x3ffffff);

  		    var carry = 0;
  		    for (var i = this.length - 1; i >= 0; i--) {
  		      var w = (this.words[i] | 0) + carry * 0x4000000;
  		      this.words[i] = (w / num) | 0;
  		      carry = w % num;
  		    }

  		    this._strip();
  		    return isNegNum ? this.ineg() : this;
  		  };

  		  BN.prototype.divn = function divn (num) {
  		    return this.clone().idivn(num);
  		  };

  		  BN.prototype.egcd = function egcd (p) {
  		    assert(p.negative === 0);
  		    assert(!p.isZero());

  		    var x = this;
  		    var y = p.clone();

  		    if (x.negative !== 0) {
  		      x = x.umod(p);
  		    } else {
  		      x = x.clone();
  		    }

  		    // A * x + B * y = x
  		    var A = new BN(1);
  		    var B = new BN(0);

  		    // C * x + D * y = y
  		    var C = new BN(0);
  		    var D = new BN(1);

  		    var g = 0;

  		    while (x.isEven() && y.isEven()) {
  		      x.iushrn(1);
  		      y.iushrn(1);
  		      ++g;
  		    }

  		    var yp = y.clone();
  		    var xp = x.clone();

  		    while (!x.isZero()) {
  		      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
  		      if (i > 0) {
  		        x.iushrn(i);
  		        while (i-- > 0) {
  		          if (A.isOdd() || B.isOdd()) {
  		            A.iadd(yp);
  		            B.isub(xp);
  		          }

  		          A.iushrn(1);
  		          B.iushrn(1);
  		        }
  		      }

  		      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
  		      if (j > 0) {
  		        y.iushrn(j);
  		        while (j-- > 0) {
  		          if (C.isOdd() || D.isOdd()) {
  		            C.iadd(yp);
  		            D.isub(xp);
  		          }

  		          C.iushrn(1);
  		          D.iushrn(1);
  		        }
  		      }

  		      if (x.cmp(y) >= 0) {
  		        x.isub(y);
  		        A.isub(C);
  		        B.isub(D);
  		      } else {
  		        y.isub(x);
  		        C.isub(A);
  		        D.isub(B);
  		      }
  		    }

  		    return {
  		      a: C,
  		      b: D,
  		      gcd: y.iushln(g)
  		    };
  		  };

  		  // This is reduced incarnation of the binary EEA
  		  // above, designated to invert members of the
  		  // _prime_ fields F(p) at a maximal speed
  		  BN.prototype._invmp = function _invmp (p) {
  		    assert(p.negative === 0);
  		    assert(!p.isZero());

  		    var a = this;
  		    var b = p.clone();

  		    if (a.negative !== 0) {
  		      a = a.umod(p);
  		    } else {
  		      a = a.clone();
  		    }

  		    var x1 = new BN(1);
  		    var x2 = new BN(0);

  		    var delta = b.clone();

  		    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
  		      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
  		      if (i > 0) {
  		        a.iushrn(i);
  		        while (i-- > 0) {
  		          if (x1.isOdd()) {
  		            x1.iadd(delta);
  		          }

  		          x1.iushrn(1);
  		        }
  		      }

  		      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
  		      if (j > 0) {
  		        b.iushrn(j);
  		        while (j-- > 0) {
  		          if (x2.isOdd()) {
  		            x2.iadd(delta);
  		          }

  		          x2.iushrn(1);
  		        }
  		      }

  		      if (a.cmp(b) >= 0) {
  		        a.isub(b);
  		        x1.isub(x2);
  		      } else {
  		        b.isub(a);
  		        x2.isub(x1);
  		      }
  		    }

  		    var res;
  		    if (a.cmpn(1) === 0) {
  		      res = x1;
  		    } else {
  		      res = x2;
  		    }

  		    if (res.cmpn(0) < 0) {
  		      res.iadd(p);
  		    }

  		    return res;
  		  };

  		  BN.prototype.gcd = function gcd (num) {
  		    if (this.isZero()) return num.abs();
  		    if (num.isZero()) return this.abs();

  		    var a = this.clone();
  		    var b = num.clone();
  		    a.negative = 0;
  		    b.negative = 0;

  		    // Remove common factor of two
  		    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
  		      a.iushrn(1);
  		      b.iushrn(1);
  		    }

  		    do {
  		      while (a.isEven()) {
  		        a.iushrn(1);
  		      }
  		      while (b.isEven()) {
  		        b.iushrn(1);
  		      }

  		      var r = a.cmp(b);
  		      if (r < 0) {
  		        // Swap `a` and `b` to make `a` always bigger than `b`
  		        var t = a;
  		        a = b;
  		        b = t;
  		      } else if (r === 0 || b.cmpn(1) === 0) {
  		        break;
  		      }

  		      a.isub(b);
  		    } while (true);

  		    return b.iushln(shift);
  		  };

  		  // Invert number in the field F(num)
  		  BN.prototype.invm = function invm (num) {
  		    return this.egcd(num).a.umod(num);
  		  };

  		  BN.prototype.isEven = function isEven () {
  		    return (this.words[0] & 1) === 0;
  		  };

  		  BN.prototype.isOdd = function isOdd () {
  		    return (this.words[0] & 1) === 1;
  		  };

  		  // And first word and num
  		  BN.prototype.andln = function andln (num) {
  		    return this.words[0] & num;
  		  };

  		  // Increment at the bit position in-line
  		  BN.prototype.bincn = function bincn (bit) {
  		    assert(typeof bit === 'number');
  		    var r = bit % 26;
  		    var s = (bit - r) / 26;
  		    var q = 1 << r;

  		    // Fast case: bit is much higher than all existing words
  		    if (this.length <= s) {
  		      this._expand(s + 1);
  		      this.words[s] |= q;
  		      return this;
  		    }

  		    // Add bit and propagate, if needed
  		    var carry = q;
  		    for (var i = s; carry !== 0 && i < this.length; i++) {
  		      var w = this.words[i] | 0;
  		      w += carry;
  		      carry = w >>> 26;
  		      w &= 0x3ffffff;
  		      this.words[i] = w;
  		    }
  		    if (carry !== 0) {
  		      this.words[i] = carry;
  		      this.length++;
  		    }
  		    return this;
  		  };

  		  BN.prototype.isZero = function isZero () {
  		    return this.length === 1 && this.words[0] === 0;
  		  };

  		  BN.prototype.cmpn = function cmpn (num) {
  		    var negative = num < 0;

  		    if (this.negative !== 0 && !negative) return -1;
  		    if (this.negative === 0 && negative) return 1;

  		    this._strip();

  		    var res;
  		    if (this.length > 1) {
  		      res = 1;
  		    } else {
  		      if (negative) {
  		        num = -num;
  		      }

  		      assert(num <= 0x3ffffff, 'Number is too big');

  		      var w = this.words[0] | 0;
  		      res = w === num ? 0 : w < num ? -1 : 1;
  		    }
  		    if (this.negative !== 0) return -res | 0;
  		    return res;
  		  };

  		  // Compare two numbers and return:
  		  // 1 - if `this` > `num`
  		  // 0 - if `this` == `num`
  		  // -1 - if `this` < `num`
  		  BN.prototype.cmp = function cmp (num) {
  		    if (this.negative !== 0 && num.negative === 0) return -1;
  		    if (this.negative === 0 && num.negative !== 0) return 1;

  		    var res = this.ucmp(num);
  		    if (this.negative !== 0) return -res | 0;
  		    return res;
  		  };

  		  // Unsigned comparison
  		  BN.prototype.ucmp = function ucmp (num) {
  		    // At this point both numbers have the same sign
  		    if (this.length > num.length) return 1;
  		    if (this.length < num.length) return -1;

  		    var res = 0;
  		    for (var i = this.length - 1; i >= 0; i--) {
  		      var a = this.words[i] | 0;
  		      var b = num.words[i] | 0;

  		      if (a === b) continue;
  		      if (a < b) {
  		        res = -1;
  		      } else if (a > b) {
  		        res = 1;
  		      }
  		      break;
  		    }
  		    return res;
  		  };

  		  BN.prototype.gtn = function gtn (num) {
  		    return this.cmpn(num) === 1;
  		  };

  		  BN.prototype.gt = function gt (num) {
  		    return this.cmp(num) === 1;
  		  };

  		  BN.prototype.gten = function gten (num) {
  		    return this.cmpn(num) >= 0;
  		  };

  		  BN.prototype.gte = function gte (num) {
  		    return this.cmp(num) >= 0;
  		  };

  		  BN.prototype.ltn = function ltn (num) {
  		    return this.cmpn(num) === -1;
  		  };

  		  BN.prototype.lt = function lt (num) {
  		    return this.cmp(num) === -1;
  		  };

  		  BN.prototype.lten = function lten (num) {
  		    return this.cmpn(num) <= 0;
  		  };

  		  BN.prototype.lte = function lte (num) {
  		    return this.cmp(num) <= 0;
  		  };

  		  BN.prototype.eqn = function eqn (num) {
  		    return this.cmpn(num) === 0;
  		  };

  		  BN.prototype.eq = function eq (num) {
  		    return this.cmp(num) === 0;
  		  };

  		  //
  		  // A reduce context, could be using montgomery or something better, depending
  		  // on the `m` itself.
  		  //
  		  BN.red = function red (num) {
  		    return new Red(num);
  		  };

  		  BN.prototype.toRed = function toRed (ctx) {
  		    assert(!this.red, 'Already a number in reduction context');
  		    assert(this.negative === 0, 'red works only with positives');
  		    return ctx.convertTo(this)._forceRed(ctx);
  		  };

  		  BN.prototype.fromRed = function fromRed () {
  		    assert(this.red, 'fromRed works only with numbers in reduction context');
  		    return this.red.convertFrom(this);
  		  };

  		  BN.prototype._forceRed = function _forceRed (ctx) {
  		    this.red = ctx;
  		    return this;
  		  };

  		  BN.prototype.forceRed = function forceRed (ctx) {
  		    assert(!this.red, 'Already a number in reduction context');
  		    return this._forceRed(ctx);
  		  };

  		  BN.prototype.redAdd = function redAdd (num) {
  		    assert(this.red, 'redAdd works only with red numbers');
  		    return this.red.add(this, num);
  		  };

  		  BN.prototype.redIAdd = function redIAdd (num) {
  		    assert(this.red, 'redIAdd works only with red numbers');
  		    return this.red.iadd(this, num);
  		  };

  		  BN.prototype.redSub = function redSub (num) {
  		    assert(this.red, 'redSub works only with red numbers');
  		    return this.red.sub(this, num);
  		  };

  		  BN.prototype.redISub = function redISub (num) {
  		    assert(this.red, 'redISub works only with red numbers');
  		    return this.red.isub(this, num);
  		  };

  		  BN.prototype.redShl = function redShl (num) {
  		    assert(this.red, 'redShl works only with red numbers');
  		    return this.red.shl(this, num);
  		  };

  		  BN.prototype.redMul = function redMul (num) {
  		    assert(this.red, 'redMul works only with red numbers');
  		    this.red._verify2(this, num);
  		    return this.red.mul(this, num);
  		  };

  		  BN.prototype.redIMul = function redIMul (num) {
  		    assert(this.red, 'redMul works only with red numbers');
  		    this.red._verify2(this, num);
  		    return this.red.imul(this, num);
  		  };

  		  BN.prototype.redSqr = function redSqr () {
  		    assert(this.red, 'redSqr works only with red numbers');
  		    this.red._verify1(this);
  		    return this.red.sqr(this);
  		  };

  		  BN.prototype.redISqr = function redISqr () {
  		    assert(this.red, 'redISqr works only with red numbers');
  		    this.red._verify1(this);
  		    return this.red.isqr(this);
  		  };

  		  // Square root over p
  		  BN.prototype.redSqrt = function redSqrt () {
  		    assert(this.red, 'redSqrt works only with red numbers');
  		    this.red._verify1(this);
  		    return this.red.sqrt(this);
  		  };

  		  BN.prototype.redInvm = function redInvm () {
  		    assert(this.red, 'redInvm works only with red numbers');
  		    this.red._verify1(this);
  		    return this.red.invm(this);
  		  };

  		  // Return negative clone of `this` % `red modulo`
  		  BN.prototype.redNeg = function redNeg () {
  		    assert(this.red, 'redNeg works only with red numbers');
  		    this.red._verify1(this);
  		    return this.red.neg(this);
  		  };

  		  BN.prototype.redPow = function redPow (num) {
  		    assert(this.red && !num.red, 'redPow(normalNum)');
  		    this.red._verify1(this);
  		    return this.red.pow(this, num);
  		  };

  		  // Prime numbers with efficient reduction
  		  var primes = {
  		    k256: null,
  		    p224: null,
  		    p192: null,
  		    p25519: null
  		  };

  		  // Pseudo-Mersenne prime
  		  function MPrime (name, p) {
  		    // P = 2 ^ N - K
  		    this.name = name;
  		    this.p = new BN(p, 16);
  		    this.n = this.p.bitLength();
  		    this.k = new BN(1).iushln(this.n).isub(this.p);

  		    this.tmp = this._tmp();
  		  }

  		  MPrime.prototype._tmp = function _tmp () {
  		    var tmp = new BN(null);
  		    tmp.words = new Array(Math.ceil(this.n / 13));
  		    return tmp;
  		  };

  		  MPrime.prototype.ireduce = function ireduce (num) {
  		    // Assumes that `num` is less than `P^2`
  		    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
  		    var r = num;
  		    var rlen;

  		    do {
  		      this.split(r, this.tmp);
  		      r = this.imulK(r);
  		      r = r.iadd(this.tmp);
  		      rlen = r.bitLength();
  		    } while (rlen > this.n);

  		    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
  		    if (cmp === 0) {
  		      r.words[0] = 0;
  		      r.length = 1;
  		    } else if (cmp > 0) {
  		      r.isub(this.p);
  		    } else {
  		      if (r.strip !== undefined) {
  		        // r is a BN v4 instance
  		        r.strip();
  		      } else {
  		        // r is a BN v5 instance
  		        r._strip();
  		      }
  		    }

  		    return r;
  		  };

  		  MPrime.prototype.split = function split (input, out) {
  		    input.iushrn(this.n, 0, out);
  		  };

  		  MPrime.prototype.imulK = function imulK (num) {
  		    return num.imul(this.k);
  		  };

  		  function K256 () {
  		    MPrime.call(
  		      this,
  		      'k256',
  		      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  		  }
  		  inherits(K256, MPrime);

  		  K256.prototype.split = function split (input, output) {
  		    // 256 = 9 * 26 + 22
  		    var mask = 0x3fffff;

  		    var outLen = Math.min(input.length, 9);
  		    for (var i = 0; i < outLen; i++) {
  		      output.words[i] = input.words[i];
  		    }
  		    output.length = outLen;

  		    if (input.length <= 9) {
  		      input.words[0] = 0;
  		      input.length = 1;
  		      return;
  		    }

  		    // Shift by 9 limbs
  		    var prev = input.words[9];
  		    output.words[output.length++] = prev & mask;

  		    for (i = 10; i < input.length; i++) {
  		      var next = input.words[i] | 0;
  		      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
  		      prev = next;
  		    }
  		    prev >>>= 22;
  		    input.words[i - 10] = prev;
  		    if (prev === 0 && input.length > 10) {
  		      input.length -= 10;
  		    } else {
  		      input.length -= 9;
  		    }
  		  };

  		  K256.prototype.imulK = function imulK (num) {
  		    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
  		    num.words[num.length] = 0;
  		    num.words[num.length + 1] = 0;
  		    num.length += 2;

  		    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
  		    var lo = 0;
  		    for (var i = 0; i < num.length; i++) {
  		      var w = num.words[i] | 0;
  		      lo += w * 0x3d1;
  		      num.words[i] = lo & 0x3ffffff;
  		      lo = w * 0x40 + ((lo / 0x4000000) | 0);
  		    }

  		    // Fast length reduction
  		    if (num.words[num.length - 1] === 0) {
  		      num.length--;
  		      if (num.words[num.length - 1] === 0) {
  		        num.length--;
  		      }
  		    }
  		    return num;
  		  };

  		  function P224 () {
  		    MPrime.call(
  		      this,
  		      'p224',
  		      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  		  }
  		  inherits(P224, MPrime);

  		  function P192 () {
  		    MPrime.call(
  		      this,
  		      'p192',
  		      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  		  }
  		  inherits(P192, MPrime);

  		  function P25519 () {
  		    // 2 ^ 255 - 19
  		    MPrime.call(
  		      this,
  		      '25519',
  		      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  		  }
  		  inherits(P25519, MPrime);

  		  P25519.prototype.imulK = function imulK (num) {
  		    // K = 0x13
  		    var carry = 0;
  		    for (var i = 0; i < num.length; i++) {
  		      var hi = (num.words[i] | 0) * 0x13 + carry;
  		      var lo = hi & 0x3ffffff;
  		      hi >>>= 26;

  		      num.words[i] = lo;
  		      carry = hi;
  		    }
  		    if (carry !== 0) {
  		      num.words[num.length++] = carry;
  		    }
  		    return num;
  		  };

  		  // Exported mostly for testing purposes, use plain name instead
  		  BN._prime = function prime (name) {
  		    // Cached version of prime
  		    if (primes[name]) return primes[name];

  		    var prime;
  		    if (name === 'k256') {
  		      prime = new K256();
  		    } else if (name === 'p224') {
  		      prime = new P224();
  		    } else if (name === 'p192') {
  		      prime = new P192();
  		    } else if (name === 'p25519') {
  		      prime = new P25519();
  		    } else {
  		      throw new Error('Unknown prime ' + name);
  		    }
  		    primes[name] = prime;

  		    return prime;
  		  };

  		  //
  		  // Base reduction engine
  		  //
  		  function Red (m) {
  		    if (typeof m === 'string') {
  		      var prime = BN._prime(m);
  		      this.m = prime.p;
  		      this.prime = prime;
  		    } else {
  		      assert(m.gtn(1), 'modulus must be greater than 1');
  		      this.m = m;
  		      this.prime = null;
  		    }
  		  }

  		  Red.prototype._verify1 = function _verify1 (a) {
  		    assert(a.negative === 0, 'red works only with positives');
  		    assert(a.red, 'red works only with red numbers');
  		  };

  		  Red.prototype._verify2 = function _verify2 (a, b) {
  		    assert((a.negative | b.negative) === 0, 'red works only with positives');
  		    assert(a.red && a.red === b.red,
  		      'red works only with red numbers');
  		  };

  		  Red.prototype.imod = function imod (a) {
  		    if (this.prime) return this.prime.ireduce(a)._forceRed(this);

  		    move(a, a.umod(this.m)._forceRed(this));
  		    return a;
  		  };

  		  Red.prototype.neg = function neg (a) {
  		    if (a.isZero()) {
  		      return a.clone();
  		    }

  		    return this.m.sub(a)._forceRed(this);
  		  };

  		  Red.prototype.add = function add (a, b) {
  		    this._verify2(a, b);

  		    var res = a.add(b);
  		    if (res.cmp(this.m) >= 0) {
  		      res.isub(this.m);
  		    }
  		    return res._forceRed(this);
  		  };

  		  Red.prototype.iadd = function iadd (a, b) {
  		    this._verify2(a, b);

  		    var res = a.iadd(b);
  		    if (res.cmp(this.m) >= 0) {
  		      res.isub(this.m);
  		    }
  		    return res;
  		  };

  		  Red.prototype.sub = function sub (a, b) {
  		    this._verify2(a, b);

  		    var res = a.sub(b);
  		    if (res.cmpn(0) < 0) {
  		      res.iadd(this.m);
  		    }
  		    return res._forceRed(this);
  		  };

  		  Red.prototype.isub = function isub (a, b) {
  		    this._verify2(a, b);

  		    var res = a.isub(b);
  		    if (res.cmpn(0) < 0) {
  		      res.iadd(this.m);
  		    }
  		    return res;
  		  };

  		  Red.prototype.shl = function shl (a, num) {
  		    this._verify1(a);
  		    return this.imod(a.ushln(num));
  		  };

  		  Red.prototype.imul = function imul (a, b) {
  		    this._verify2(a, b);
  		    return this.imod(a.imul(b));
  		  };

  		  Red.prototype.mul = function mul (a, b) {
  		    this._verify2(a, b);
  		    return this.imod(a.mul(b));
  		  };

  		  Red.prototype.isqr = function isqr (a) {
  		    return this.imul(a, a.clone());
  		  };

  		  Red.prototype.sqr = function sqr (a) {
  		    return this.mul(a, a);
  		  };

  		  Red.prototype.sqrt = function sqrt (a) {
  		    if (a.isZero()) return a.clone();

  		    var mod3 = this.m.andln(3);
  		    assert(mod3 % 2 === 1);

  		    // Fast case
  		    if (mod3 === 3) {
  		      var pow = this.m.add(new BN(1)).iushrn(2);
  		      return this.pow(a, pow);
  		    }

  		    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
  		    //
  		    // Find Q and S, that Q * 2 ^ S = (P - 1)
  		    var q = this.m.subn(1);
  		    var s = 0;
  		    while (!q.isZero() && q.andln(1) === 0) {
  		      s++;
  		      q.iushrn(1);
  		    }
  		    assert(!q.isZero());

  		    var one = new BN(1).toRed(this);
  		    var nOne = one.redNeg();

  		    // Find quadratic non-residue
  		    // NOTE: Max is such because of generalized Riemann hypothesis.
  		    var lpow = this.m.subn(1).iushrn(1);
  		    var z = this.m.bitLength();
  		    z = new BN(2 * z * z).toRed(this);

  		    while (this.pow(z, lpow).cmp(nOne) !== 0) {
  		      z.redIAdd(nOne);
  		    }

  		    var c = this.pow(z, q);
  		    var r = this.pow(a, q.addn(1).iushrn(1));
  		    var t = this.pow(a, q);
  		    var m = s;
  		    while (t.cmp(one) !== 0) {
  		      var tmp = t;
  		      for (var i = 0; tmp.cmp(one) !== 0; i++) {
  		        tmp = tmp.redSqr();
  		      }
  		      assert(i < m);
  		      var b = this.pow(c, new BN(1).iushln(m - i - 1));

  		      r = r.redMul(b);
  		      c = b.redSqr();
  		      t = t.redMul(c);
  		      m = i;
  		    }

  		    return r;
  		  };

  		  Red.prototype.invm = function invm (a) {
  		    var inv = a._invmp(this.m);
  		    if (inv.negative !== 0) {
  		      inv.negative = 0;
  		      return this.imod(inv).redNeg();
  		    } else {
  		      return this.imod(inv);
  		    }
  		  };

  		  Red.prototype.pow = function pow (a, num) {
  		    if (num.isZero()) return new BN(1).toRed(this);
  		    if (num.cmpn(1) === 0) return a.clone();

  		    var windowSize = 4;
  		    var wnd = new Array(1 << windowSize);
  		    wnd[0] = new BN(1).toRed(this);
  		    wnd[1] = a;
  		    for (var i = 2; i < wnd.length; i++) {
  		      wnd[i] = this.mul(wnd[i - 1], a);
  		    }

  		    var res = wnd[0];
  		    var current = 0;
  		    var currentLen = 0;
  		    var start = num.bitLength() % 26;
  		    if (start === 0) {
  		      start = 26;
  		    }

  		    for (i = num.length - 1; i >= 0; i--) {
  		      var word = num.words[i];
  		      for (var j = start - 1; j >= 0; j--) {
  		        var bit = (word >> j) & 1;
  		        if (res !== wnd[0]) {
  		          res = this.sqr(res);
  		        }

  		        if (bit === 0 && current === 0) {
  		          currentLen = 0;
  		          continue;
  		        }

  		        current <<= 1;
  		        current |= bit;
  		        currentLen++;
  		        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

  		        res = this.mul(res, wnd[current]);
  		        currentLen = 0;
  		        current = 0;
  		      }
  		      start = 26;
  		    }

  		    return res;
  		  };

  		  Red.prototype.convertTo = function convertTo (num) {
  		    var r = num.umod(this.m);

  		    return r === num ? r.clone() : r;
  		  };

  		  Red.prototype.convertFrom = function convertFrom (num) {
  		    var res = num.clone();
  		    res.red = null;
  		    return res;
  		  };

  		  //
  		  // Montgomery method engine
  		  //

  		  BN.mont = function mont (num) {
  		    return new Mont(num);
  		  };

  		  function Mont (m) {
  		    Red.call(this, m);

  		    this.shift = this.m.bitLength();
  		    if (this.shift % 26 !== 0) {
  		      this.shift += 26 - (this.shift % 26);
  		    }

  		    this.r = new BN(1).iushln(this.shift);
  		    this.r2 = this.imod(this.r.sqr());
  		    this.rinv = this.r._invmp(this.m);

  		    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
  		    this.minv = this.minv.umod(this.r);
  		    this.minv = this.r.sub(this.minv);
  		  }
  		  inherits(Mont, Red);

  		  Mont.prototype.convertTo = function convertTo (num) {
  		    return this.imod(num.ushln(this.shift));
  		  };

  		  Mont.prototype.convertFrom = function convertFrom (num) {
  		    var r = this.imod(num.mul(this.rinv));
  		    r.red = null;
  		    return r;
  		  };

  		  Mont.prototype.imul = function imul (a, b) {
  		    if (a.isZero() || b.isZero()) {
  		      a.words[0] = 0;
  		      a.length = 1;
  		      return a;
  		    }

  		    var t = a.imul(b);
  		    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
  		    var u = t.isub(c).iushrn(this.shift);
  		    var res = u;

  		    if (u.cmp(this.m) >= 0) {
  		      res = u.isub(this.m);
  		    } else if (u.cmpn(0) < 0) {
  		      res = u.iadd(this.m);
  		    }

  		    return res._forceRed(this);
  		  };

  		  Mont.prototype.mul = function mul (a, b) {
  		    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

  		    var t = a.mul(b);
  		    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
  		    var u = t.isub(c).iushrn(this.shift);
  		    var res = u;
  		    if (u.cmp(this.m) >= 0) {
  		      res = u.isub(this.m);
  		    } else if (u.cmpn(0) < 0) {
  		      res = u.iadd(this.m);
  		    }

  		    return res._forceRed(this);
  		  };

  		  Mont.prototype.invm = function invm (a) {
  		    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
  		    var res = this.imod(a._invmp(this.m).mul(this.r2));
  		    return res._forceRed(this);
  		  };
  		})(module, bn); 
  	} (bn$1));
  	return bn$1.exports;
  }

  var bnExports = requireBn();
  var _BN = /*@__PURE__*/getDefaultExportFromCjs(bnExports);

  const version$4 = "bignumber/5.8.0";

  var BN = _BN.BN;
  const logger$7 = new Logger$1(version$4);
  const _constructorGuard$1 = {};
  const MAX_SAFE = 0x1fffffffffffff;
  // Only warn about passing 10 into radix once
  let _warnedToStringRadix = false;
  class BigNumber {
      constructor(constructorGuard, hex) {
          if (constructorGuard !== _constructorGuard$1) {
              logger$7.throwError("cannot call constructor directly; use BigNumber.from", Logger$1.errors.UNSUPPORTED_OPERATION, {
                  operation: "new (BigNumber)"
              });
          }
          this._hex = hex;
          this._isBigNumber = true;
          Object.freeze(this);
      }
      fromTwos(value) {
          return toBigNumber(toBN(this).fromTwos(value));
      }
      toTwos(value) {
          return toBigNumber(toBN(this).toTwos(value));
      }
      abs() {
          if (this._hex[0] === "-") {
              return BigNumber.from(this._hex.substring(1));
          }
          return this;
      }
      add(other) {
          return toBigNumber(toBN(this).add(toBN(other)));
      }
      sub(other) {
          return toBigNumber(toBN(this).sub(toBN(other)));
      }
      div(other) {
          const o = BigNumber.from(other);
          if (o.isZero()) {
              throwFault("division-by-zero", "div");
          }
          return toBigNumber(toBN(this).div(toBN(other)));
      }
      mul(other) {
          return toBigNumber(toBN(this).mul(toBN(other)));
      }
      mod(other) {
          const value = toBN(other);
          if (value.isNeg()) {
              throwFault("division-by-zero", "mod");
          }
          return toBigNumber(toBN(this).umod(value));
      }
      pow(other) {
          const value = toBN(other);
          if (value.isNeg()) {
              throwFault("negative-power", "pow");
          }
          return toBigNumber(toBN(this).pow(value));
      }
      and(other) {
          const value = toBN(other);
          if (this.isNegative() || value.isNeg()) {
              throwFault("unbound-bitwise-result", "and");
          }
          return toBigNumber(toBN(this).and(value));
      }
      or(other) {
          const value = toBN(other);
          if (this.isNegative() || value.isNeg()) {
              throwFault("unbound-bitwise-result", "or");
          }
          return toBigNumber(toBN(this).or(value));
      }
      xor(other) {
          const value = toBN(other);
          if (this.isNegative() || value.isNeg()) {
              throwFault("unbound-bitwise-result", "xor");
          }
          return toBigNumber(toBN(this).xor(value));
      }
      mask(value) {
          if (this.isNegative() || value < 0) {
              throwFault("negative-width", "mask");
          }
          return toBigNumber(toBN(this).maskn(value));
      }
      shl(value) {
          if (this.isNegative() || value < 0) {
              throwFault("negative-width", "shl");
          }
          return toBigNumber(toBN(this).shln(value));
      }
      shr(value) {
          if (this.isNegative() || value < 0) {
              throwFault("negative-width", "shr");
          }
          return toBigNumber(toBN(this).shrn(value));
      }
      eq(other) {
          return toBN(this).eq(toBN(other));
      }
      lt(other) {
          return toBN(this).lt(toBN(other));
      }
      lte(other) {
          return toBN(this).lte(toBN(other));
      }
      gt(other) {
          return toBN(this).gt(toBN(other));
      }
      gte(other) {
          return toBN(this).gte(toBN(other));
      }
      isNegative() {
          return (this._hex[0] === "-");
      }
      isZero() {
          return toBN(this).isZero();
      }
      toNumber() {
          try {
              return toBN(this).toNumber();
          }
          catch (error) {
              throwFault("overflow", "toNumber", this.toString());
          }
          return null;
      }
      toBigInt() {
          try {
              return BigInt(this.toString());
          }
          catch (e) { }
          return logger$7.throwError("this platform does not support BigInt", Logger$1.errors.UNSUPPORTED_OPERATION, {
              value: this.toString()
          });
      }
      toString() {
          // Lots of people expect this, which we do not support, so check (See: #889)
          if (arguments.length > 0) {
              if (arguments[0] === 10) {
                  if (!_warnedToStringRadix) {
                      _warnedToStringRadix = true;
                      logger$7.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
                  }
              }
              else if (arguments[0] === 16) {
                  logger$7.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger$1.errors.UNEXPECTED_ARGUMENT, {});
              }
              else {
                  logger$7.throwError("BigNumber.toString does not accept parameters", Logger$1.errors.UNEXPECTED_ARGUMENT, {});
              }
          }
          return toBN(this).toString(10);
      }
      toHexString() {
          return this._hex;
      }
      toJSON(key) {
          return { type: "BigNumber", hex: this.toHexString() };
      }
      static from(value) {
          if (value instanceof BigNumber) {
              return value;
          }
          if (typeof (value) === "string") {
              if (value.match(/^-?0x[0-9a-f]+$/i)) {
                  return new BigNumber(_constructorGuard$1, toHex(value));
              }
              if (value.match(/^-?[0-9]+$/)) {
                  return new BigNumber(_constructorGuard$1, toHex(new BN(value)));
              }
              return logger$7.throwArgumentError("invalid BigNumber string", "value", value);
          }
          if (typeof (value) === "number") {
              if (value % 1) {
                  throwFault("underflow", "BigNumber.from", value);
              }
              if (value >= MAX_SAFE || value <= -9007199254740991) {
                  throwFault("overflow", "BigNumber.from", value);
              }
              return BigNumber.from(String(value));
          }
          const anyValue = value;
          if (typeof (anyValue) === "bigint") {
              return BigNumber.from(anyValue.toString());
          }
          if (isBytes(anyValue)) {
              return BigNumber.from(hexlify(anyValue));
          }
          if (anyValue) {
              // Hexable interface (takes priority)
              if (anyValue.toHexString) {
                  const hex = anyValue.toHexString();
                  if (typeof (hex) === "string") {
                      return BigNumber.from(hex);
                  }
              }
              else {
                  // For now, handle legacy JSON-ified values (goes away in v6)
                  let hex = anyValue._hex;
                  // New-form JSON
                  if (hex == null && anyValue.type === "BigNumber") {
                      hex = anyValue.hex;
                  }
                  if (typeof (hex) === "string") {
                      if (isHexString(hex) || (hex[0] === "-" && isHexString(hex.substring(1)))) {
                          return BigNumber.from(hex);
                      }
                  }
              }
          }
          return logger$7.throwArgumentError("invalid BigNumber value", "value", value);
      }
      static isBigNumber(value) {
          return !!(value && value._isBigNumber);
      }
  }
  // Normalize the hex string
  function toHex(value) {
      // For BN, call on the hex string
      if (typeof (value) !== "string") {
          return toHex(value.toString(16));
      }
      // If negative, prepend the negative sign to the normalized positive value
      if (value[0] === "-") {
          // Strip off the negative sign
          value = value.substring(1);
          // Cannot have multiple negative signs (e.g. "--0x04")
          if (value[0] === "-") {
              logger$7.throwArgumentError("invalid hex", "value", value);
          }
          // Call toHex on the positive component
          value = toHex(value);
          // Do not allow "-0x00"
          if (value === "0x00") {
              return value;
          }
          // Negate the value
          return "-" + value;
      }
      // Add a "0x" prefix if missing
      if (value.substring(0, 2) !== "0x") {
          value = "0x" + value;
      }
      // Normalize zero
      if (value === "0x") {
          return "0x00";
      }
      // Make the string even length
      if (value.length % 2) {
          value = "0x0" + value.substring(2);
      }
      // Trim to smallest even-length string
      while (value.length > 4 && value.substring(0, 4) === "0x00") {
          value = "0x" + value.substring(4);
      }
      return value;
  }
  function toBigNumber(value) {
      return BigNumber.from(toHex(value));
  }
  function toBN(value) {
      const hex = BigNumber.from(value).toHexString();
      if (hex[0] === "-") {
          return (new BN("-" + hex.substring(3), 16));
      }
      return new BN(hex.substring(2), 16);
  }
  function throwFault(fault, operation, value) {
      const params = { fault: fault, operation: operation };
      if (value != null) {
          params.value = value;
      }
      return logger$7.throwError(fault, Logger$1.errors.NUMERIC_FAULT, params);
  }
  // value should have no prefix
  function _base36To16(value) {
      return (new BN(value, 36)).toString(16);
  }

  (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
      function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  };
  function defineReadOnly(object, name, value) {
      Object.defineProperty(object, name, {
          enumerable: true,
          value: value,
          writable: false,
      });
  }

  const version$3 = "abi/5.8.0";

  const logger$6 = new Logger$1(version$3);
  const _constructorGuard = {};
  let ModifiersBytes = { calldata: true, memory: true, storage: true };
  let ModifiersNest = { calldata: true, memory: true };
  function checkModifier(type, name) {
      if (type === "bytes" || type === "string") {
          if (ModifiersBytes[name]) {
              return true;
          }
      }
      else if (type === "address") {
          if (name === "payable") {
              return true;
          }
      }
      else if (type.indexOf("[") >= 0 || type === "tuple") {
          if (ModifiersNest[name]) {
              return true;
          }
      }
      if (ModifiersBytes[name] || name === "payable") {
          logger$6.throwArgumentError("invalid modifier", "name", name);
      }
      return false;
  }
  // @TODO: Make sure that children of an indexed tuple are marked with a null indexed
  function parseParamType(param, allowIndexed) {
      let originalParam = param;
      function throwError(i) {
          logger$6.throwArgumentError(`unexpected character at position ${i}`, "param", param);
      }
      param = param.replace(/\s/g, " ");
      function newNode(parent) {
          let node = { type: "", name: "", parent: parent, state: { allowType: true } };
          if (allowIndexed) {
              node.indexed = false;
          }
          return node;
      }
      let parent = { type: "", name: "", state: { allowType: true } };
      let node = parent;
      for (let i = 0; i < param.length; i++) {
          let c = param[i];
          switch (c) {
              case "(":
                  if (node.state.allowType && node.type === "") {
                      node.type = "tuple";
                  }
                  else if (!node.state.allowParams) {
                      throwError(i);
                  }
                  node.state.allowType = false;
                  node.type = verifyType(node.type);
                  node.components = [newNode(node)];
                  node = node.components[0];
                  break;
              case ")":
                  delete node.state;
                  if (node.name === "indexed") {
                      if (!allowIndexed) {
                          throwError(i);
                      }
                      node.indexed = true;
                      node.name = "";
                  }
                  if (checkModifier(node.type, node.name)) {
                      node.name = "";
                  }
                  node.type = verifyType(node.type);
                  let child = node;
                  node = node.parent;
                  if (!node) {
                      throwError(i);
                  }
                  delete child.parent;
                  node.state.allowParams = false;
                  node.state.allowName = true;
                  node.state.allowArray = true;
                  break;
              case ",":
                  delete node.state;
                  if (node.name === "indexed") {
                      if (!allowIndexed) {
                          throwError(i);
                      }
                      node.indexed = true;
                      node.name = "";
                  }
                  if (checkModifier(node.type, node.name)) {
                      node.name = "";
                  }
                  node.type = verifyType(node.type);
                  let sibling = newNode(node.parent);
                  //{ type: "", name: "", parent: node.parent, state: { allowType: true } };
                  node.parent.components.push(sibling);
                  delete node.parent;
                  node = sibling;
                  break;
              // Hit a space...
              case " ":
                  // If reading type, the type is done and may read a param or name
                  if (node.state.allowType) {
                      if (node.type !== "") {
                          node.type = verifyType(node.type);
                          delete node.state.allowType;
                          node.state.allowName = true;
                          node.state.allowParams = true;
                      }
                  }
                  // If reading name, the name is done
                  if (node.state.allowName) {
                      if (node.name !== "") {
                          if (node.name === "indexed") {
                              if (!allowIndexed) {
                                  throwError(i);
                              }
                              if (node.indexed) {
                                  throwError(i);
                              }
                              node.indexed = true;
                              node.name = "";
                          }
                          else if (checkModifier(node.type, node.name)) {
                              node.name = "";
                          }
                          else {
                              node.state.allowName = false;
                          }
                      }
                  }
                  break;
              case "[":
                  if (!node.state.allowArray) {
                      throwError(i);
                  }
                  node.type += c;
                  node.state.allowArray = false;
                  node.state.allowName = false;
                  node.state.readArray = true;
                  break;
              case "]":
                  if (!node.state.readArray) {
                      throwError(i);
                  }
                  node.type += c;
                  node.state.readArray = false;
                  node.state.allowArray = true;
                  node.state.allowName = true;
                  break;
              default:
                  if (node.state.allowType) {
                      node.type += c;
                      node.state.allowParams = true;
                      node.state.allowArray = true;
                  }
                  else if (node.state.allowName) {
                      node.name += c;
                      delete node.state.allowArray;
                  }
                  else if (node.state.readArray) {
                      node.type += c;
                  }
                  else {
                      throwError(i);
                  }
          }
      }
      if (node.parent) {
          logger$6.throwArgumentError("unexpected eof", "param", param);
      }
      delete parent.state;
      if (node.name === "indexed") {
          if (!allowIndexed) {
              throwError(originalParam.length - 7);
          }
          if (node.indexed) {
              throwError(originalParam.length - 7);
          }
          node.indexed = true;
          node.name = "";
      }
      else if (checkModifier(node.type, node.name)) {
          node.name = "";
      }
      parent.type = verifyType(parent.type);
      return parent;
  }
  function populate(object, params) {
      for (let key in params) {
          defineReadOnly(object, key, params[key]);
      }
  }
  const FormatTypes = Object.freeze({
      // Bare formatting, as is needed for computing a sighash of an event or function
      sighash: "sighash",
      // Human-Readable with Minimal spacing and without names (compact human-readable)
      minimal: "minimal",
      // Human-Readable with nice spacing, including all names
      full: "full",
      // JSON-format a la Solidity
      json: "json"
  });
  const paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/);
  class ParamType {
      constructor(constructorGuard, params) {
          if (constructorGuard !== _constructorGuard) {
              logger$6.throwError("use fromString", Logger$1.errors.UNSUPPORTED_OPERATION, {
                  operation: "new ParamType()"
              });
          }
          populate(this, params);
          let match = this.type.match(paramTypeArray);
          if (match) {
              populate(this, {
                  arrayLength: parseInt(match[2] || "-1"),
                  arrayChildren: ParamType.fromObject({
                      type: match[1],
                      components: this.components
                  }),
                  baseType: "array"
              });
          }
          else {
              populate(this, {
                  arrayLength: null,
                  arrayChildren: null,
                  baseType: ((this.components != null) ? "tuple" : this.type)
              });
          }
          this._isParamType = true;
          Object.freeze(this);
      }
      // Format the parameter fragment
      //   - sighash: "(uint256,address)"
      //   - minimal: "tuple(uint256,address) indexed"
      //   - full:    "tuple(uint256 foo, address bar) indexed baz"
      format(format) {
          if (!format) {
              format = FormatTypes.sighash;
          }
          if (!FormatTypes[format]) {
              logger$6.throwArgumentError("invalid format type", "format", format);
          }
          if (format === FormatTypes.json) {
              let result = {
                  type: ((this.baseType === "tuple") ? "tuple" : this.type),
                  name: (this.name || undefined)
              };
              if (typeof (this.indexed) === "boolean") {
                  result.indexed = this.indexed;
              }
              if (this.components) {
                  result.components = this.components.map((comp) => JSON.parse(comp.format(format)));
              }
              return JSON.stringify(result);
          }
          let result = "";
          // Array
          if (this.baseType === "array") {
              result += this.arrayChildren.format(format);
              result += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]";
          }
          else {
              if (this.baseType === "tuple") {
                  if (format !== FormatTypes.sighash) {
                      result += this.type;
                  }
                  result += "(" + this.components.map((comp) => comp.format(format)).join((format === FormatTypes.full) ? ", " : ",") + ")";
              }
              else {
                  result += this.type;
              }
          }
          if (format !== FormatTypes.sighash) {
              if (this.indexed === true) {
                  result += " indexed";
              }
              if (format === FormatTypes.full && this.name) {
                  result += " " + this.name;
              }
          }
          return result;
      }
      static from(value, allowIndexed) {
          if (typeof (value) === "string") {
              return ParamType.fromString(value, allowIndexed);
          }
          return ParamType.fromObject(value);
      }
      static fromObject(value) {
          if (ParamType.isParamType(value)) {
              return value;
          }
          return new ParamType(_constructorGuard, {
              name: (value.name || null),
              type: verifyType(value.type),
              indexed: ((value.indexed == null) ? null : !!value.indexed),
              components: (value.components ? value.components.map(ParamType.fromObject) : null)
          });
      }
      static fromString(value, allowIndexed) {
          function ParamTypify(node) {
              return ParamType.fromObject({
                  name: node.name,
                  type: node.type,
                  indexed: node.indexed,
                  components: node.components
              });
          }
          return ParamTypify(parseParamType(value, !!allowIndexed));
      }
      static isParamType(value) {
          return !!(value != null && value._isParamType);
      }
  }
  function verifyType(type) {
      // These need to be transformed to their full description
      if (type.match(/^uint($|[^1-9])/)) {
          type = "uint256" + type.substring(4);
      }
      else if (type.match(/^int($|[^1-9])/)) {
          type = "int256" + type.substring(3);
      }
      // @TODO: more verification
      return type;
  }

  const logger$5 = new Logger$1(version$3);
  class Coder {
      constructor(name, type, localName, dynamic) {
          // @TODO: defineReadOnly these
          this.name = name;
          this.type = type;
          this.localName = localName;
          this.dynamic = dynamic;
      }
      _throwError(message, value) {
          logger$5.throwArgumentError(message, this.localName, value);
      }
  }
  class Writer {
      constructor(wordSize) {
          defineReadOnly(this, "wordSize", wordSize || 32);
          this._data = [];
          this._dataLength = 0;
          this._padding = new Uint8Array(wordSize);
      }
      get data() {
          return hexConcat(this._data);
      }
      get length() { return this._dataLength; }
      _writeData(data) {
          this._data.push(data);
          this._dataLength += data.length;
          return data.length;
      }
      appendWriter(writer) {
          return this._writeData(concat(writer._data));
      }
      // Arrayish items; padded on the right to wordSize
      writeBytes(value) {
          let bytes = arrayify(value);
          const paddingOffset = bytes.length % this.wordSize;
          if (paddingOffset) {
              bytes = concat([bytes, this._padding.slice(paddingOffset)]);
          }
          return this._writeData(bytes);
      }
      _getValue(value) {
          let bytes = arrayify(BigNumber.from(value));
          if (bytes.length > this.wordSize) {
              logger$5.throwError("value out-of-bounds", Logger$1.errors.BUFFER_OVERRUN, {
                  length: this.wordSize,
                  offset: bytes.length
              });
          }
          if (bytes.length % this.wordSize) {
              bytes = concat([this._padding.slice(bytes.length % this.wordSize), bytes]);
          }
          return bytes;
      }
      // BigNumberish items; padded on the left to wordSize
      writeValue(value) {
          return this._writeData(this._getValue(value));
      }
      writeUpdatableValue() {
          const offset = this._data.length;
          this._data.push(this._padding);
          this._dataLength += this.wordSize;
          return (value) => {
              this._data[offset] = this._getValue(value);
          };
      }
  }
  class Reader {
      constructor(data, wordSize, coerceFunc, allowLoose) {
          defineReadOnly(this, "_data", arrayify(data));
          defineReadOnly(this, "wordSize", wordSize || 32);
          defineReadOnly(this, "_coerceFunc", coerceFunc);
          defineReadOnly(this, "allowLoose", allowLoose);
          this._offset = 0;
      }
      get data() { return hexlify(this._data); }
      get consumed() { return this._offset; }
      // The default Coerce function
      static coerce(name, value) {
          let match = name.match("^u?int([0-9]+)$");
          if (match && parseInt(match[1]) <= 48) {
              value = value.toNumber();
          }
          return value;
      }
      coerce(name, value) {
          if (this._coerceFunc) {
              return this._coerceFunc(name, value);
          }
          return Reader.coerce(name, value);
      }
      _peekBytes(offset, length, loose) {
          let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;
          if (this._offset + alignedLength > this._data.length) {
              if (this.allowLoose && loose && this._offset + length <= this._data.length) {
                  alignedLength = length;
              }
              else {
                  logger$5.throwError("data out-of-bounds", Logger$1.errors.BUFFER_OVERRUN, {
                      length: this._data.length,
                      offset: this._offset + alignedLength
                  });
              }
          }
          return this._data.slice(this._offset, this._offset + alignedLength);
      }
      subReader(offset) {
          return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);
      }
      readBytes(length, loose) {
          let bytes = this._peekBytes(0, length, !!loose);
          this._offset += bytes.length;
          // @TODO: Make sure the length..end bytes are all 0?
          return bytes.slice(0, length);
      }
      readValue() {
          return BigNumber.from(this.readBytes(this.wordSize));
      }
  }

  var sha3$1 = {exports: {}};

  /**
   * [js-sha3]{@link https://github.com/emn178/js-sha3}
   *
   * @version 0.8.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2015-2018
   * @license MIT
   */

  var hasRequiredSha3;

  function requireSha3 () {
  	if (hasRequiredSha3) return sha3$1.exports;
  	hasRequiredSha3 = 1;
  	(function (module) {
  		/*jslint bitwise: true */
  		(function () {

  		  var INPUT_ERROR = 'input is invalid type';
  		  var FINALIZE_ERROR = 'finalize already called';
  		  var WINDOW = typeof window === 'object';
  		  var root = WINDOW ? window : {};
  		  if (root.JS_SHA3_NO_WINDOW) {
  		    WINDOW = false;
  		  }
  		  var WEB_WORKER = !WINDOW && typeof self === 'object';
  		  var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;
  		  if (NODE_JS) {
  		    root = commonjsGlobal;
  		  } else if (WEB_WORKER) {
  		    root = self;
  		  }
  		  var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && 'object' === 'object' && module.exports;
  		  var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';
  		  var HEX_CHARS = '0123456789abcdef'.split('');
  		  var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
  		  var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
  		  var KECCAK_PADDING = [1, 256, 65536, 16777216];
  		  var PADDING = [6, 1536, 393216, 100663296];
  		  var SHIFT = [0, 8, 16, 24];
  		  var RC = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649,
  		    0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0,
  		    2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771,
  		    2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648,
  		    2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
  		  var BITS = [224, 256, 384, 512];
  		  var SHAKE_BITS = [128, 256];
  		  var OUTPUT_TYPES = ['hex', 'buffer', 'arrayBuffer', 'array', 'digest'];
  		  var CSHAKE_BYTEPAD = {
  		    '128': 168,
  		    '256': 136
  		  };

  		  if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
  		    Array.isArray = function (obj) {
  		      return Object.prototype.toString.call(obj) === '[object Array]';
  		    };
  		  }

  		  if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
  		    ArrayBuffer.isView = function (obj) {
  		      return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;
  		    };
  		  }

  		  var createOutputMethod = function (bits, padding, outputType) {
  		    return function (message) {
  		      return new Keccak(bits, padding, bits).update(message)[outputType]();
  		    };
  		  };

  		  var createShakeOutputMethod = function (bits, padding, outputType) {
  		    return function (message, outputBits) {
  		      return new Keccak(bits, padding, outputBits).update(message)[outputType]();
  		    };
  		  };

  		  var createCshakeOutputMethod = function (bits, padding, outputType) {
  		    return function (message, outputBits, n, s) {
  		      return methods['cshake' + bits].update(message, outputBits, n, s)[outputType]();
  		    };
  		  };

  		  var createKmacOutputMethod = function (bits, padding, outputType) {
  		    return function (key, message, outputBits, s) {
  		      return methods['kmac' + bits].update(key, message, outputBits, s)[outputType]();
  		    };
  		  };

  		  var createOutputMethods = function (method, createMethod, bits, padding) {
  		    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
  		      var type = OUTPUT_TYPES[i];
  		      method[type] = createMethod(bits, padding, type);
  		    }
  		    return method;
  		  };

  		  var createMethod = function (bits, padding) {
  		    var method = createOutputMethod(bits, padding, 'hex');
  		    method.create = function () {
  		      return new Keccak(bits, padding, bits);
  		    };
  		    method.update = function (message) {
  		      return method.create().update(message);
  		    };
  		    return createOutputMethods(method, createOutputMethod, bits, padding);
  		  };

  		  var createShakeMethod = function (bits, padding) {
  		    var method = createShakeOutputMethod(bits, padding, 'hex');
  		    method.create = function (outputBits) {
  		      return new Keccak(bits, padding, outputBits);
  		    };
  		    method.update = function (message, outputBits) {
  		      return method.create(outputBits).update(message);
  		    };
  		    return createOutputMethods(method, createShakeOutputMethod, bits, padding);
  		  };

  		  var createCshakeMethod = function (bits, padding) {
  		    var w = CSHAKE_BYTEPAD[bits];
  		    var method = createCshakeOutputMethod(bits, padding, 'hex');
  		    method.create = function (outputBits, n, s) {
  		      if (!n && !s) {
  		        return methods['shake' + bits].create(outputBits);
  		      } else {
  		        return new Keccak(bits, padding, outputBits).bytepad([n, s], w);
  		      }
  		    };
  		    method.update = function (message, outputBits, n, s) {
  		      return method.create(outputBits, n, s).update(message);
  		    };
  		    return createOutputMethods(method, createCshakeOutputMethod, bits, padding);
  		  };

  		  var createKmacMethod = function (bits, padding) {
  		    var w = CSHAKE_BYTEPAD[bits];
  		    var method = createKmacOutputMethod(bits, padding, 'hex');
  		    method.create = function (key, outputBits, s) {
  		      return new Kmac(bits, padding, outputBits).bytepad(['KMAC', s], w).bytepad([key], w);
  		    };
  		    method.update = function (key, message, outputBits, s) {
  		      return method.create(key, outputBits, s).update(message);
  		    };
  		    return createOutputMethods(method, createKmacOutputMethod, bits, padding);
  		  };

  		  var algorithms = [
  		    { name: 'keccak', padding: KECCAK_PADDING, bits: BITS, createMethod: createMethod },
  		    { name: 'sha3', padding: PADDING, bits: BITS, createMethod: createMethod },
  		    { name: 'shake', padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
  		    { name: 'cshake', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
  		    { name: 'kmac', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
  		  ];

  		  var methods = {}, methodNames = [];

  		  for (var i = 0; i < algorithms.length; ++i) {
  		    var algorithm = algorithms[i];
  		    var bits = algorithm.bits;
  		    for (var j = 0; j < bits.length; ++j) {
  		      var methodName = algorithm.name + '_' + bits[j];
  		      methodNames.push(methodName);
  		      methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
  		      if (algorithm.name !== 'sha3') {
  		        var newMethodName = algorithm.name + bits[j];
  		        methodNames.push(newMethodName);
  		        methods[newMethodName] = methods[methodName];
  		      }
  		    }
  		  }

  		  function Keccak(bits, padding, outputBits) {
  		    this.blocks = [];
  		    this.s = [];
  		    this.padding = padding;
  		    this.outputBits = outputBits;
  		    this.reset = true;
  		    this.finalized = false;
  		    this.block = 0;
  		    this.start = 0;
  		    this.blockCount = (1600 - (bits << 1)) >> 5;
  		    this.byteCount = this.blockCount << 2;
  		    this.outputBlocks = outputBits >> 5;
  		    this.extraBytes = (outputBits & 31) >> 3;

  		    for (var i = 0; i < 50; ++i) {
  		      this.s[i] = 0;
  		    }
  		  }

  		  Keccak.prototype.update = function (message) {
  		    if (this.finalized) {
  		      throw new Error(FINALIZE_ERROR);
  		    }
  		    var notString, type = typeof message;
  		    if (type !== 'string') {
  		      if (type === 'object') {
  		        if (message === null) {
  		          throw new Error(INPUT_ERROR);
  		        } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
  		          message = new Uint8Array(message);
  		        } else if (!Array.isArray(message)) {
  		          if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
  		            throw new Error(INPUT_ERROR);
  		          }
  		        }
  		      } else {
  		        throw new Error(INPUT_ERROR);
  		      }
  		      notString = true;
  		    }
  		    var blocks = this.blocks, byteCount = this.byteCount, length = message.length,
  		      blockCount = this.blockCount, index = 0, s = this.s, i, code;

  		    while (index < length) {
  		      if (this.reset) {
  		        this.reset = false;
  		        blocks[0] = this.block;
  		        for (i = 1; i < blockCount + 1; ++i) {
  		          blocks[i] = 0;
  		        }
  		      }
  		      if (notString) {
  		        for (i = this.start; index < length && i < byteCount; ++index) {
  		          blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
  		        }
  		      } else {
  		        for (i = this.start; index < length && i < byteCount; ++index) {
  		          code = message.charCodeAt(index);
  		          if (code < 0x80) {
  		            blocks[i >> 2] |= code << SHIFT[i++ & 3];
  		          } else if (code < 0x800) {
  		            blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
  		            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
  		          } else if (code < 0xd800 || code >= 0xe000) {
  		            blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
  		            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
  		            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
  		          } else {
  		            code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));
  		            blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
  		            blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
  		            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
  		            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
  		          }
  		        }
  		      }
  		      this.lastByteIndex = i;
  		      if (i >= byteCount) {
  		        this.start = i - byteCount;
  		        this.block = blocks[blockCount];
  		        for (i = 0; i < blockCount; ++i) {
  		          s[i] ^= blocks[i];
  		        }
  		        f(s);
  		        this.reset = true;
  		      } else {
  		        this.start = i;
  		      }
  		    }
  		    return this;
  		  };

  		  Keccak.prototype.encode = function (x, right) {
  		    var o = x & 255, n = 1;
  		    var bytes = [o];
  		    x = x >> 8;
  		    o = x & 255;
  		    while (o > 0) {
  		      bytes.unshift(o);
  		      x = x >> 8;
  		      o = x & 255;
  		      ++n;
  		    }
  		    if (right) {
  		      bytes.push(n);
  		    } else {
  		      bytes.unshift(n);
  		    }
  		    this.update(bytes);
  		    return bytes.length;
  		  };

  		  Keccak.prototype.encodeString = function (str) {
  		    var notString, type = typeof str;
  		    if (type !== 'string') {
  		      if (type === 'object') {
  		        if (str === null) {
  		          throw new Error(INPUT_ERROR);
  		        } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
  		          str = new Uint8Array(str);
  		        } else if (!Array.isArray(str)) {
  		          if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
  		            throw new Error(INPUT_ERROR);
  		          }
  		        }
  		      } else {
  		        throw new Error(INPUT_ERROR);
  		      }
  		      notString = true;
  		    }
  		    var bytes = 0, length = str.length;
  		    if (notString) {
  		      bytes = length;
  		    } else {
  		      for (var i = 0; i < str.length; ++i) {
  		        var code = str.charCodeAt(i);
  		        if (code < 0x80) {
  		          bytes += 1;
  		        } else if (code < 0x800) {
  		          bytes += 2;
  		        } else if (code < 0xd800 || code >= 0xe000) {
  		          bytes += 3;
  		        } else {
  		          code = 0x10000 + (((code & 0x3ff) << 10) | (str.charCodeAt(++i) & 0x3ff));
  		          bytes += 4;
  		        }
  		      }
  		    }
  		    bytes += this.encode(bytes * 8);
  		    this.update(str);
  		    return bytes;
  		  };

  		  Keccak.prototype.bytepad = function (strs, w) {
  		    var bytes = this.encode(w);
  		    for (var i = 0; i < strs.length; ++i) {
  		      bytes += this.encodeString(strs[i]);
  		    }
  		    var paddingBytes = w - bytes % w;
  		    var zeros = [];
  		    zeros.length = paddingBytes;
  		    this.update(zeros);
  		    return this;
  		  };

  		  Keccak.prototype.finalize = function () {
  		    if (this.finalized) {
  		      return;
  		    }
  		    this.finalized = true;
  		    var blocks = this.blocks, i = this.lastByteIndex, blockCount = this.blockCount, s = this.s;
  		    blocks[i >> 2] |= this.padding[i & 3];
  		    if (this.lastByteIndex === this.byteCount) {
  		      blocks[0] = blocks[blockCount];
  		      for (i = 1; i < blockCount + 1; ++i) {
  		        blocks[i] = 0;
  		      }
  		    }
  		    blocks[blockCount - 1] |= 0x80000000;
  		    for (i = 0; i < blockCount; ++i) {
  		      s[i] ^= blocks[i];
  		    }
  		    f(s);
  		  };

  		  Keccak.prototype.toString = Keccak.prototype.hex = function () {
  		    this.finalize();

  		    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
  		      extraBytes = this.extraBytes, i = 0, j = 0;
  		    var hex = '', block;
  		    while (j < outputBlocks) {
  		      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
  		        block = s[i];
  		        hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F] +
  		          HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F] +
  		          HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F] +
  		          HEX_CHARS[(block >> 28) & 0x0F] + HEX_CHARS[(block >> 24) & 0x0F];
  		      }
  		      if (j % blockCount === 0) {
  		        f(s);
  		        i = 0;
  		      }
  		    }
  		    if (extraBytes) {
  		      block = s[i];
  		      hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F];
  		      if (extraBytes > 1) {
  		        hex += HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F];
  		      }
  		      if (extraBytes > 2) {
  		        hex += HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F];
  		      }
  		    }
  		    return hex;
  		  };

  		  Keccak.prototype.arrayBuffer = function () {
  		    this.finalize();

  		    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
  		      extraBytes = this.extraBytes, i = 0, j = 0;
  		    var bytes = this.outputBits >> 3;
  		    var buffer;
  		    if (extraBytes) {
  		      buffer = new ArrayBuffer((outputBlocks + 1) << 2);
  		    } else {
  		      buffer = new ArrayBuffer(bytes);
  		    }
  		    var array = new Uint32Array(buffer);
  		    while (j < outputBlocks) {
  		      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
  		        array[j] = s[i];
  		      }
  		      if (j % blockCount === 0) {
  		        f(s);
  		      }
  		    }
  		    if (extraBytes) {
  		      array[i] = s[i];
  		      buffer = buffer.slice(0, bytes);
  		    }
  		    return buffer;
  		  };

  		  Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;

  		  Keccak.prototype.digest = Keccak.prototype.array = function () {
  		    this.finalize();

  		    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
  		      extraBytes = this.extraBytes, i = 0, j = 0;
  		    var array = [], offset, block;
  		    while (j < outputBlocks) {
  		      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
  		        offset = j << 2;
  		        block = s[i];
  		        array[offset] = block & 0xFF;
  		        array[offset + 1] = (block >> 8) & 0xFF;
  		        array[offset + 2] = (block >> 16) & 0xFF;
  		        array[offset + 3] = (block >> 24) & 0xFF;
  		      }
  		      if (j % blockCount === 0) {
  		        f(s);
  		      }
  		    }
  		    if (extraBytes) {
  		      offset = j << 2;
  		      block = s[i];
  		      array[offset] = block & 0xFF;
  		      if (extraBytes > 1) {
  		        array[offset + 1] = (block >> 8) & 0xFF;
  		      }
  		      if (extraBytes > 2) {
  		        array[offset + 2] = (block >> 16) & 0xFF;
  		      }
  		    }
  		    return array;
  		  };

  		  function Kmac(bits, padding, outputBits) {
  		    Keccak.call(this, bits, padding, outputBits);
  		  }

  		  Kmac.prototype = new Keccak();

  		  Kmac.prototype.finalize = function () {
  		    this.encode(this.outputBits, true);
  		    return Keccak.prototype.finalize.call(this);
  		  };

  		  var f = function (s) {
  		    var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9,
  		      b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17,
  		      b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33,
  		      b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
  		    for (n = 0; n < 48; n += 2) {
  		      c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
  		      c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
  		      c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
  		      c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
  		      c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
  		      c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
  		      c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
  		      c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
  		      c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
  		      c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];

  		      h = c8 ^ ((c2 << 1) | (c3 >>> 31));
  		      l = c9 ^ ((c3 << 1) | (c2 >>> 31));
  		      s[0] ^= h;
  		      s[1] ^= l;
  		      s[10] ^= h;
  		      s[11] ^= l;
  		      s[20] ^= h;
  		      s[21] ^= l;
  		      s[30] ^= h;
  		      s[31] ^= l;
  		      s[40] ^= h;
  		      s[41] ^= l;
  		      h = c0 ^ ((c4 << 1) | (c5 >>> 31));
  		      l = c1 ^ ((c5 << 1) | (c4 >>> 31));
  		      s[2] ^= h;
  		      s[3] ^= l;
  		      s[12] ^= h;
  		      s[13] ^= l;
  		      s[22] ^= h;
  		      s[23] ^= l;
  		      s[32] ^= h;
  		      s[33] ^= l;
  		      s[42] ^= h;
  		      s[43] ^= l;
  		      h = c2 ^ ((c6 << 1) | (c7 >>> 31));
  		      l = c3 ^ ((c7 << 1) | (c6 >>> 31));
  		      s[4] ^= h;
  		      s[5] ^= l;
  		      s[14] ^= h;
  		      s[15] ^= l;
  		      s[24] ^= h;
  		      s[25] ^= l;
  		      s[34] ^= h;
  		      s[35] ^= l;
  		      s[44] ^= h;
  		      s[45] ^= l;
  		      h = c4 ^ ((c8 << 1) | (c9 >>> 31));
  		      l = c5 ^ ((c9 << 1) | (c8 >>> 31));
  		      s[6] ^= h;
  		      s[7] ^= l;
  		      s[16] ^= h;
  		      s[17] ^= l;
  		      s[26] ^= h;
  		      s[27] ^= l;
  		      s[36] ^= h;
  		      s[37] ^= l;
  		      s[46] ^= h;
  		      s[47] ^= l;
  		      h = c6 ^ ((c0 << 1) | (c1 >>> 31));
  		      l = c7 ^ ((c1 << 1) | (c0 >>> 31));
  		      s[8] ^= h;
  		      s[9] ^= l;
  		      s[18] ^= h;
  		      s[19] ^= l;
  		      s[28] ^= h;
  		      s[29] ^= l;
  		      s[38] ^= h;
  		      s[39] ^= l;
  		      s[48] ^= h;
  		      s[49] ^= l;

  		      b0 = s[0];
  		      b1 = s[1];
  		      b32 = (s[11] << 4) | (s[10] >>> 28);
  		      b33 = (s[10] << 4) | (s[11] >>> 28);
  		      b14 = (s[20] << 3) | (s[21] >>> 29);
  		      b15 = (s[21] << 3) | (s[20] >>> 29);
  		      b46 = (s[31] << 9) | (s[30] >>> 23);
  		      b47 = (s[30] << 9) | (s[31] >>> 23);
  		      b28 = (s[40] << 18) | (s[41] >>> 14);
  		      b29 = (s[41] << 18) | (s[40] >>> 14);
  		      b20 = (s[2] << 1) | (s[3] >>> 31);
  		      b21 = (s[3] << 1) | (s[2] >>> 31);
  		      b2 = (s[13] << 12) | (s[12] >>> 20);
  		      b3 = (s[12] << 12) | (s[13] >>> 20);
  		      b34 = (s[22] << 10) | (s[23] >>> 22);
  		      b35 = (s[23] << 10) | (s[22] >>> 22);
  		      b16 = (s[33] << 13) | (s[32] >>> 19);
  		      b17 = (s[32] << 13) | (s[33] >>> 19);
  		      b48 = (s[42] << 2) | (s[43] >>> 30);
  		      b49 = (s[43] << 2) | (s[42] >>> 30);
  		      b40 = (s[5] << 30) | (s[4] >>> 2);
  		      b41 = (s[4] << 30) | (s[5] >>> 2);
  		      b22 = (s[14] << 6) | (s[15] >>> 26);
  		      b23 = (s[15] << 6) | (s[14] >>> 26);
  		      b4 = (s[25] << 11) | (s[24] >>> 21);
  		      b5 = (s[24] << 11) | (s[25] >>> 21);
  		      b36 = (s[34] << 15) | (s[35] >>> 17);
  		      b37 = (s[35] << 15) | (s[34] >>> 17);
  		      b18 = (s[45] << 29) | (s[44] >>> 3);
  		      b19 = (s[44] << 29) | (s[45] >>> 3);
  		      b10 = (s[6] << 28) | (s[7] >>> 4);
  		      b11 = (s[7] << 28) | (s[6] >>> 4);
  		      b42 = (s[17] << 23) | (s[16] >>> 9);
  		      b43 = (s[16] << 23) | (s[17] >>> 9);
  		      b24 = (s[26] << 25) | (s[27] >>> 7);
  		      b25 = (s[27] << 25) | (s[26] >>> 7);
  		      b6 = (s[36] << 21) | (s[37] >>> 11);
  		      b7 = (s[37] << 21) | (s[36] >>> 11);
  		      b38 = (s[47] << 24) | (s[46] >>> 8);
  		      b39 = (s[46] << 24) | (s[47] >>> 8);
  		      b30 = (s[8] << 27) | (s[9] >>> 5);
  		      b31 = (s[9] << 27) | (s[8] >>> 5);
  		      b12 = (s[18] << 20) | (s[19] >>> 12);
  		      b13 = (s[19] << 20) | (s[18] >>> 12);
  		      b44 = (s[29] << 7) | (s[28] >>> 25);
  		      b45 = (s[28] << 7) | (s[29] >>> 25);
  		      b26 = (s[38] << 8) | (s[39] >>> 24);
  		      b27 = (s[39] << 8) | (s[38] >>> 24);
  		      b8 = (s[48] << 14) | (s[49] >>> 18);
  		      b9 = (s[49] << 14) | (s[48] >>> 18);

  		      s[0] = b0 ^ (~b2 & b4);
  		      s[1] = b1 ^ (~b3 & b5);
  		      s[10] = b10 ^ (~b12 & b14);
  		      s[11] = b11 ^ (~b13 & b15);
  		      s[20] = b20 ^ (~b22 & b24);
  		      s[21] = b21 ^ (~b23 & b25);
  		      s[30] = b30 ^ (~b32 & b34);
  		      s[31] = b31 ^ (~b33 & b35);
  		      s[40] = b40 ^ (~b42 & b44);
  		      s[41] = b41 ^ (~b43 & b45);
  		      s[2] = b2 ^ (~b4 & b6);
  		      s[3] = b3 ^ (~b5 & b7);
  		      s[12] = b12 ^ (~b14 & b16);
  		      s[13] = b13 ^ (~b15 & b17);
  		      s[22] = b22 ^ (~b24 & b26);
  		      s[23] = b23 ^ (~b25 & b27);
  		      s[32] = b32 ^ (~b34 & b36);
  		      s[33] = b33 ^ (~b35 & b37);
  		      s[42] = b42 ^ (~b44 & b46);
  		      s[43] = b43 ^ (~b45 & b47);
  		      s[4] = b4 ^ (~b6 & b8);
  		      s[5] = b5 ^ (~b7 & b9);
  		      s[14] = b14 ^ (~b16 & b18);
  		      s[15] = b15 ^ (~b17 & b19);
  		      s[24] = b24 ^ (~b26 & b28);
  		      s[25] = b25 ^ (~b27 & b29);
  		      s[34] = b34 ^ (~b36 & b38);
  		      s[35] = b35 ^ (~b37 & b39);
  		      s[44] = b44 ^ (~b46 & b48);
  		      s[45] = b45 ^ (~b47 & b49);
  		      s[6] = b6 ^ (~b8 & b0);
  		      s[7] = b7 ^ (~b9 & b1);
  		      s[16] = b16 ^ (~b18 & b10);
  		      s[17] = b17 ^ (~b19 & b11);
  		      s[26] = b26 ^ (~b28 & b20);
  		      s[27] = b27 ^ (~b29 & b21);
  		      s[36] = b36 ^ (~b38 & b30);
  		      s[37] = b37 ^ (~b39 & b31);
  		      s[46] = b46 ^ (~b48 & b40);
  		      s[47] = b47 ^ (~b49 & b41);
  		      s[8] = b8 ^ (~b0 & b2);
  		      s[9] = b9 ^ (~b1 & b3);
  		      s[18] = b18 ^ (~b10 & b12);
  		      s[19] = b19 ^ (~b11 & b13);
  		      s[28] = b28 ^ (~b20 & b22);
  		      s[29] = b29 ^ (~b21 & b23);
  		      s[38] = b38 ^ (~b30 & b32);
  		      s[39] = b39 ^ (~b31 & b33);
  		      s[48] = b48 ^ (~b40 & b42);
  		      s[49] = b49 ^ (~b41 & b43);

  		      s[0] ^= RC[n];
  		      s[1] ^= RC[n + 1];
  		    }
  		  };

  		  if (COMMON_JS) {
  		    module.exports = methods;
  		  } else {
  		    for (i = 0; i < methodNames.length; ++i) {
  		      root[methodNames[i]] = methods[methodNames[i]];
  		    }
  		  }
  		})(); 
  	} (sha3$1));
  	return sha3$1.exports;
  }

  var sha3Exports = requireSha3();
  var sha3 = /*@__PURE__*/getDefaultExportFromCjs(sha3Exports);

  function keccak256$1(data) {
      return '0x' + sha3.keccak_256(arrayify(data));
  }

  const version$2 = "rlp/5.8.0";

  const logger$4 = new Logger$1(version$2);
  function arrayifyInteger(value) {
      const result = [];
      while (value) {
          result.unshift(value & 0xff);
          value >>= 8;
      }
      return result;
  }
  function unarrayifyInteger(data, offset, length) {
      let result = 0;
      for (let i = 0; i < length; i++) {
          result = (result * 256) + data[offset + i];
      }
      return result;
  }
  function _encode(object) {
      if (Array.isArray(object)) {
          let payload = [];
          object.forEach(function (child) {
              payload = payload.concat(_encode(child));
          });
          if (payload.length <= 55) {
              payload.unshift(0xc0 + payload.length);
              return payload;
          }
          const length = arrayifyInteger(payload.length);
          length.unshift(0xf7 + length.length);
          return length.concat(payload);
      }
      if (!isBytesLike(object)) {
          logger$4.throwArgumentError("RLP object must be BytesLike", "object", object);
      }
      const data = Array.prototype.slice.call(arrayify(object));
      if (data.length === 1 && data[0] <= 0x7f) {
          return data;
      }
      else if (data.length <= 55) {
          data.unshift(0x80 + data.length);
          return data;
      }
      const length = arrayifyInteger(data.length);
      length.unshift(0xb7 + length.length);
      return length.concat(data);
  }
  function encode(object) {
      return hexlify(_encode(object));
  }
  function _decodeChildren(data, offset, childOffset, length) {
      const result = [];
      while (childOffset < offset + 1 + length) {
          const decoded = _decode(data, childOffset);
          result.push(decoded.result);
          childOffset += decoded.consumed;
          if (childOffset > offset + 1 + length) {
              logger$4.throwError("child data too short", Logger$1.errors.BUFFER_OVERRUN, {});
          }
      }
      return { consumed: (1 + length), result: result };
  }
  // returns { consumed: number, result: Object }
  function _decode(data, offset) {
      if (data.length === 0) {
          logger$4.throwError("data too short", Logger$1.errors.BUFFER_OVERRUN, {});
      }
      // Array with extra length prefix
      if (data[offset] >= 0xf8) {
          const lengthLength = data[offset] - 0xf7;
          if (offset + 1 + lengthLength > data.length) {
              logger$4.throwError("data short segment too short", Logger$1.errors.BUFFER_OVERRUN, {});
          }
          const length = unarrayifyInteger(data, offset + 1, lengthLength);
          if (offset + 1 + lengthLength + length > data.length) {
              logger$4.throwError("data long segment too short", Logger$1.errors.BUFFER_OVERRUN, {});
          }
          return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);
      }
      else if (data[offset] >= 0xc0) {
          const length = data[offset] - 0xc0;
          if (offset + 1 + length > data.length) {
              logger$4.throwError("data array too short", Logger$1.errors.BUFFER_OVERRUN, {});
          }
          return _decodeChildren(data, offset, offset + 1, length);
      }
      else if (data[offset] >= 0xb8) {
          const lengthLength = data[offset] - 0xb7;
          if (offset + 1 + lengthLength > data.length) {
              logger$4.throwError("data array too short", Logger$1.errors.BUFFER_OVERRUN, {});
          }
          const length = unarrayifyInteger(data, offset + 1, lengthLength);
          if (offset + 1 + lengthLength + length > data.length) {
              logger$4.throwError("data array too short", Logger$1.errors.BUFFER_OVERRUN, {});
          }
          const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));
          return { consumed: (1 + lengthLength + length), result: result };
      }
      else if (data[offset] >= 0x80) {
          const length = data[offset] - 0x80;
          if (offset + 1 + length > data.length) {
              logger$4.throwError("data too short", Logger$1.errors.BUFFER_OVERRUN, {});
          }
          const result = hexlify(data.slice(offset + 1, offset + 1 + length));
          return { consumed: (1 + length), result: result };
      }
      return { consumed: 1, result: hexlify(data[offset]) };
  }
  function decode(data) {
      const bytes = arrayify(data);
      const decoded = _decode(bytes, 0);
      if (decoded.consumed !== bytes.length) {
          logger$4.throwArgumentError("invalid rlp data", "data", data);
      }
      return decoded.result;
  }

  const version$1 = "address/5.8.0";

  const logger$3 = new Logger$1(version$1);
  function getChecksumAddress(address) {
      if (!isHexString(address, 20)) {
          logger$3.throwArgumentError("invalid address", "address", address);
      }
      address = address.toLowerCase();
      const chars = address.substring(2).split("");
      const expanded = new Uint8Array(40);
      for (let i = 0; i < 40; i++) {
          expanded[i] = chars[i].charCodeAt(0);
      }
      const hashed = arrayify(keccak256$1(expanded));
      for (let i = 0; i < 40; i += 2) {
          if ((hashed[i >> 1] >> 4) >= 8) {
              chars[i] = chars[i].toUpperCase();
          }
          if ((hashed[i >> 1] & 0x0f) >= 8) {
              chars[i + 1] = chars[i + 1].toUpperCase();
          }
      }
      return "0x" + chars.join("");
  }
  // Shims for environments that are missing some required constants and functions
  const MAX_SAFE_INTEGER = 0x1fffffffffffff;
  function log10(x) {
      if (Math.log10) {
          return Math.log10(x);
      }
      return Math.log(x) / Math.LN10;
  }
  // See: https://en.wikipedia.org/wiki/International_Bank_Account_Number
  // Create lookup table
  const ibanLookup = {};
  for (let i = 0; i < 10; i++) {
      ibanLookup[String(i)] = String(i);
  }
  for (let i = 0; i < 26; i++) {
      ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);
  }
  // How many decimal digits can we process? (for 64-bit float, this is 15)
  const safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));
  function ibanChecksum(address) {
      address = address.toUpperCase();
      address = address.substring(4) + address.substring(0, 2) + "00";
      let expanded = address.split("").map((c) => { return ibanLookup[c]; }).join("");
      // Javascript can handle integers safely up to 15 (decimal) digits
      while (expanded.length >= safeDigits) {
          let block = expanded.substring(0, safeDigits);
          expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
      }
      let checksum = String(98 - (parseInt(expanded, 10) % 97));
      while (checksum.length < 2) {
          checksum = "0" + checksum;
      }
      return checksum;
  }
  function getAddress(address) {
      let result = null;
      if (typeof (address) !== "string") {
          logger$3.throwArgumentError("invalid address", "address", address);
      }
      if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
          // Missing the 0x prefix
          if (address.substring(0, 2) !== "0x") {
              address = "0x" + address;
          }
          result = getChecksumAddress(address);
          // It is a checksummed address with a bad checksum
          if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
              logger$3.throwArgumentError("bad address checksum", "address", address);
          }
          // Maybe ICAP? (we only support direct mode)
      }
      else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
          // It is an ICAP address with a bad checksum
          if (address.substring(2, 4) !== ibanChecksum(address)) {
              logger$3.throwArgumentError("bad icap checksum", "address", address);
          }
          result = _base36To16(address.substring(4));
          while (result.length < 40) {
              result = "0" + result;
          }
          result = getChecksumAddress("0x" + result);
      }
      else {
          logger$3.throwArgumentError("invalid address", "address", address);
      }
      return result;
  }

  class AddressCoder extends Coder {
      constructor(localName) {
          super("address", "address", localName, false);
      }
      defaultValue() {
          return "0x0000000000000000000000000000000000000000";
      }
      encode(writer, value) {
          try {
              value = getAddress(value);
          }
          catch (error) {
              this._throwError(error.message, value);
          }
          return writer.writeValue(value);
      }
      decode(reader) {
          return getAddress(hexZeroPad(reader.readValue().toHexString(), 20));
      }
  }

  // Clones the functionality of an existing Coder, but without a localName
  class AnonymousCoder extends Coder {
      constructor(coder) {
          super(coder.name, coder.type, undefined, coder.dynamic);
          this.coder = coder;
      }
      defaultValue() {
          return this.coder.defaultValue();
      }
      encode(writer, value) {
          return this.coder.encode(writer, value);
      }
      decode(reader) {
          return this.coder.decode(reader);
      }
  }

  const logger$2 = new Logger$1(version$3);
  function pack(writer, coders, values) {
      let arrayValues = null;
      if (Array.isArray(values)) {
          arrayValues = values;
      }
      else if (values && typeof (values) === "object") {
          let unique = {};
          arrayValues = coders.map((coder) => {
              const name = coder.localName;
              if (!name) {
                  logger$2.throwError("cannot encode object for signature with missing names", Logger$1.errors.INVALID_ARGUMENT, {
                      argument: "values",
                      coder: coder,
                      value: values
                  });
              }
              if (unique[name]) {
                  logger$2.throwError("cannot encode object for signature with duplicate names", Logger$1.errors.INVALID_ARGUMENT, {
                      argument: "values",
                      coder: coder,
                      value: values
                  });
              }
              unique[name] = true;
              return values[name];
          });
      }
      else {
          logger$2.throwArgumentError("invalid tuple value", "tuple", values);
      }
      if (coders.length !== arrayValues.length) {
          logger$2.throwArgumentError("types/value length mismatch", "tuple", values);
      }
      let staticWriter = new Writer(writer.wordSize);
      let dynamicWriter = new Writer(writer.wordSize);
      let updateFuncs = [];
      coders.forEach((coder, index) => {
          let value = arrayValues[index];
          if (coder.dynamic) {
              // Get current dynamic offset (for the future pointer)
              let dynamicOffset = dynamicWriter.length;
              // Encode the dynamic value into the dynamicWriter
              coder.encode(dynamicWriter, value);
              // Prepare to populate the correct offset once we are done
              let updateFunc = staticWriter.writeUpdatableValue();
              updateFuncs.push((baseOffset) => {
                  updateFunc(baseOffset + dynamicOffset);
              });
          }
          else {
              coder.encode(staticWriter, value);
          }
      });
      // Backfill all the dynamic offsets, now that we know the static length
      updateFuncs.forEach((func) => { func(staticWriter.length); });
      let length = writer.appendWriter(staticWriter);
      length += writer.appendWriter(dynamicWriter);
      return length;
  }
  function unpack(reader, coders) {
      let values = [];
      // A reader anchored to this base
      let baseReader = reader.subReader(0);
      coders.forEach((coder) => {
          let value = null;
          if (coder.dynamic) {
              let offset = reader.readValue();
              let offsetReader = baseReader.subReader(offset.toNumber());
              try {
                  value = coder.decode(offsetReader);
              }
              catch (error) {
                  // Cannot recover from this
                  if (error.code === Logger$1.errors.BUFFER_OVERRUN) {
                      throw error;
                  }
                  value = error;
                  value.baseType = coder.name;
                  value.name = coder.localName;
                  value.type = coder.type;
              }
          }
          else {
              try {
                  value = coder.decode(reader);
              }
              catch (error) {
                  // Cannot recover from this
                  if (error.code === Logger$1.errors.BUFFER_OVERRUN) {
                      throw error;
                  }
                  value = error;
                  value.baseType = coder.name;
                  value.name = coder.localName;
                  value.type = coder.type;
              }
          }
          if (value != undefined) {
              values.push(value);
          }
      });
      // We only output named properties for uniquely named coders
      const uniqueNames = coders.reduce((accum, coder) => {
          const name = coder.localName;
          if (name) {
              if (!accum[name]) {
                  accum[name] = 0;
              }
              accum[name]++;
          }
          return accum;
      }, {});
      // Add any named parameters (i.e. tuples)
      coders.forEach((coder, index) => {
          let name = coder.localName;
          if (!name || uniqueNames[name] !== 1) {
              return;
          }
          if (name === "length") {
              name = "_length";
          }
          if (values[name] != null) {
              return;
          }
          const value = values[index];
          if (value instanceof Error) {
              Object.defineProperty(values, name, {
                  enumerable: true,
                  get: () => { throw value; }
              });
          }
          else {
              values[name] = value;
          }
      });
      for (let i = 0; i < values.length; i++) {
          const value = values[i];
          if (value instanceof Error) {
              Object.defineProperty(values, i, {
                  enumerable: true,
                  get: () => { throw value; }
              });
          }
      }
      return Object.freeze(values);
  }
  class ArrayCoder extends Coder {
      constructor(coder, length, localName) {
          const type = (coder.type + "[" + (length >= 0 ? length : "") + "]");
          const dynamic = (length === -1 || coder.dynamic);
          super("array", type, localName, dynamic);
          this.coder = coder;
          this.length = length;
      }
      defaultValue() {
          // Verifies the child coder is valid (even if the array is dynamic or 0-length)
          const defaultChild = this.coder.defaultValue();
          const result = [];
          for (let i = 0; i < this.length; i++) {
              result.push(defaultChild);
          }
          return result;
      }
      encode(writer, value) {
          if (!Array.isArray(value)) {
              this._throwError("expected array value", value);
          }
          let count = this.length;
          if (count === -1) {
              count = value.length;
              writer.writeValue(value.length);
          }
          logger$2.checkArgumentCount(value.length, count, "coder array" + (this.localName ? (" " + this.localName) : ""));
          let coders = [];
          for (let i = 0; i < value.length; i++) {
              coders.push(this.coder);
          }
          return pack(writer, coders, value);
      }
      decode(reader) {
          let count = this.length;
          if (count === -1) {
              count = reader.readValue().toNumber();
              // Check that there is *roughly* enough data to ensure
              // stray random data is not being read as a length. Each
              // slot requires at least 32 bytes for their value (or 32
              // bytes as a link to the data). This could use a much
              // tighter bound, but we are erroring on the side of safety.
              if (count * 32 > reader._data.length) {
                  logger$2.throwError("insufficient data length", Logger$1.errors.BUFFER_OVERRUN, {
                      length: reader._data.length,
                      count: count
                  });
              }
          }
          let coders = [];
          for (let i = 0; i < count; i++) {
              coders.push(new AnonymousCoder(this.coder));
          }
          return reader.coerce(this.name, unpack(reader, coders));
      }
  }

  class BooleanCoder extends Coder {
      constructor(localName) {
          super("bool", "bool", localName, false);
      }
      defaultValue() {
          return false;
      }
      encode(writer, value) {
          return writer.writeValue(value ? 1 : 0);
      }
      decode(reader) {
          return reader.coerce(this.type, !reader.readValue().isZero());
      }
  }

  class DynamicBytesCoder extends Coder {
      constructor(type, localName) {
          super(type, type, localName, true);
      }
      defaultValue() {
          return "0x";
      }
      encode(writer, value) {
          value = arrayify(value);
          let length = writer.writeValue(value.length);
          length += writer.writeBytes(value);
          return length;
      }
      decode(reader) {
          return reader.readBytes(reader.readValue().toNumber(), true);
      }
  }
  class BytesCoder extends DynamicBytesCoder {
      constructor(localName) {
          super("bytes", localName);
      }
      decode(reader) {
          return reader.coerce(this.name, hexlify(super.decode(reader)));
      }
  }

  // @TODO: Merge this with bytes
  class FixedBytesCoder extends Coder {
      constructor(size, localName) {
          let name = "bytes" + String(size);
          super(name, name, localName, false);
          this.size = size;
      }
      defaultValue() {
          return ("0x0000000000000000000000000000000000000000000000000000000000000000").substring(0, 2 + this.size * 2);
      }
      encode(writer, value) {
          let data = arrayify(value);
          if (data.length !== this.size) {
              this._throwError("incorrect data length", value);
          }
          return writer.writeBytes(data);
      }
      decode(reader) {
          return reader.coerce(this.name, hexlify(reader.readBytes(this.size)));
      }
  }

  class NullCoder extends Coder {
      constructor(localName) {
          super("null", "", localName, false);
      }
      defaultValue() {
          return null;
      }
      encode(writer, value) {
          if (value != null) {
              this._throwError("not null", value);
          }
          return writer.writeBytes([]);
      }
      decode(reader) {
          reader.readBytes(0);
          return reader.coerce(this.name, null);
      }
  }

  const NegativeOne = ( /*#__PURE__*/BigNumber.from(-1));
  const Zero = ( /*#__PURE__*/BigNumber.from(0));
  const One = ( /*#__PURE__*/BigNumber.from(1));
  const MaxUint256 = ( /*#__PURE__*/BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"));

  class NumberCoder extends Coder {
      constructor(size, signed, localName) {
          const name = ((signed ? "int" : "uint") + (size * 8));
          super(name, name, localName, false);
          this.size = size;
          this.signed = signed;
      }
      defaultValue() {
          return 0;
      }
      encode(writer, value) {
          let v = BigNumber.from(value);
          // Check bounds are safe for encoding
          let maxUintValue = MaxUint256.mask(writer.wordSize * 8);
          if (this.signed) {
              let bounds = maxUintValue.mask(this.size * 8 - 1);
              if (v.gt(bounds) || v.lt(bounds.add(One).mul(NegativeOne))) {
                  this._throwError("value out-of-bounds", value);
              }
          }
          else if (v.lt(Zero) || v.gt(maxUintValue.mask(this.size * 8))) {
              this._throwError("value out-of-bounds", value);
          }
          v = v.toTwos(this.size * 8).mask(this.size * 8);
          if (this.signed) {
              v = v.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);
          }
          return writer.writeValue(v);
      }
      decode(reader) {
          let value = reader.readValue().mask(this.size * 8);
          if (this.signed) {
              value = value.fromTwos(this.size * 8);
          }
          return reader.coerce(this.name, value);
      }
  }

  const version = "strings/5.8.0";

  const logger$1 = new Logger$1(version);
  ///////////////////////////////
  var UnicodeNormalizationForm;
  (function (UnicodeNormalizationForm) {
      UnicodeNormalizationForm["current"] = "";
      UnicodeNormalizationForm["NFC"] = "NFC";
      UnicodeNormalizationForm["NFD"] = "NFD";
      UnicodeNormalizationForm["NFKC"] = "NFKC";
      UnicodeNormalizationForm["NFKD"] = "NFKD";
  })(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));
  var Utf8ErrorReason;
  (function (Utf8ErrorReason) {
      // A continuation byte was present where there was nothing to continue
      // - offset = the index the codepoint began in
      Utf8ErrorReason["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
      // An invalid (non-continuation) byte to start a UTF-8 codepoint was found
      // - offset = the index the codepoint began in
      Utf8ErrorReason["BAD_PREFIX"] = "bad codepoint prefix";
      // The string is too short to process the expected codepoint
      // - offset = the index the codepoint began in
      Utf8ErrorReason["OVERRUN"] = "string overrun";
      // A missing continuation byte was expected but not found
      // - offset = the index the continuation byte was expected at
      Utf8ErrorReason["MISSING_CONTINUE"] = "missing continuation byte";
      // The computed code point is outside the range for UTF-8
      // - offset       = start of this codepoint
      // - badCodepoint = the computed codepoint; outside the UTF-8 range
      Utf8ErrorReason["OUT_OF_RANGE"] = "out of UTF-8 range";
      // UTF-8 strings may not contain UTF-16 surrogate pairs
      // - offset       = start of this codepoint
      // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range
      Utf8ErrorReason["UTF16_SURROGATE"] = "UTF-16 surrogate";
      // The string is an overlong representation
      // - offset       = start of this codepoint
      // - badCodepoint = the computed codepoint; already bounds checked
      Utf8ErrorReason["OVERLONG"] = "overlong representation";
  })(Utf8ErrorReason || (Utf8ErrorReason = {}));
  function errorFunc(reason, offset, bytes, output, badCodepoint) {
      return logger$1.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
  }
  function ignoreFunc(reason, offset, bytes, output, badCodepoint) {
      // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes
      if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
          let i = 0;
          for (let o = offset + 1; o < bytes.length; o++) {
              if (bytes[o] >> 6 !== 0x02) {
                  break;
              }
              i++;
          }
          return i;
      }
      // This byte runs us past the end of the string, so just jump to the end
      // (but the first byte was read already read and therefore skipped)
      if (reason === Utf8ErrorReason.OVERRUN) {
          return bytes.length - offset - 1;
      }
      // Nothing to skip
      return 0;
  }
  function replaceFunc(reason, offset, bytes, output, badCodepoint) {
      // Overlong representations are otherwise "valid" code points; just non-deistingtished
      if (reason === Utf8ErrorReason.OVERLONG) {
          output.push(badCodepoint);
          return 0;
      }
      // Put the replacement character into the output
      output.push(0xfffd);
      // Otherwise, process as if ignoring errors
      return ignoreFunc(reason, offset, bytes);
  }
  // Common error handing strategies
  const Utf8ErrorFuncs = Object.freeze({
      error: errorFunc,
      ignore: ignoreFunc,
      replace: replaceFunc
  });
  // http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499
  function getUtf8CodePoints(bytes, onError) {
      if (onError == null) {
          onError = Utf8ErrorFuncs.error;
      }
      bytes = arrayify(bytes);
      const result = [];
      let i = 0;
      // Invalid bytes are ignored
      while (i < bytes.length) {
          const c = bytes[i++];
          // 0xxx xxxx
          if (c >> 7 === 0) {
              result.push(c);
              continue;
          }
          // Multibyte; how many bytes left for this character?
          let extraLength = null;
          let overlongMask = null;
          // 110x xxxx 10xx xxxx
          if ((c & 0xe0) === 0xc0) {
              extraLength = 1;
              overlongMask = 0x7f;
              // 1110 xxxx 10xx xxxx 10xx xxxx
          }
          else if ((c & 0xf0) === 0xe0) {
              extraLength = 2;
              overlongMask = 0x7ff;
              // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx
          }
          else if ((c & 0xf8) === 0xf0) {
              extraLength = 3;
              overlongMask = 0xffff;
          }
          else {
              if ((c & 0xc0) === 0x80) {
                  i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);
              }
              else {
                  i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);
              }
              continue;
          }
          // Do we have enough bytes in our data?
          if (i - 1 + extraLength >= bytes.length) {
              i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);
              continue;
          }
          // Remove the length prefix from the char
          let res = c & ((1 << (8 - extraLength - 1)) - 1);
          for (let j = 0; j < extraLength; j++) {
              let nextChar = bytes[i];
              // Invalid continuation byte
              if ((nextChar & 0xc0) != 0x80) {
                  i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);
                  res = null;
                  break;
              }
              res = (res << 6) | (nextChar & 0x3f);
              i++;
          }
          // See above loop for invalid continuation byte
          if (res === null) {
              continue;
          }
          // Maximum code point
          if (res > 0x10ffff) {
              i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);
              continue;
          }
          // Reserved for UTF-16 surrogate halves
          if (res >= 0xd800 && res <= 0xdfff) {
              i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);
              continue;
          }
          // Check for overlong sequences (more bytes than needed)
          if (res <= overlongMask) {
              i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);
              continue;
          }
          result.push(res);
      }
      return result;
  }
  // http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array
  function toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {
      if (form != UnicodeNormalizationForm.current) {
          logger$1.checkNormalize();
          str = str.normalize(form);
      }
      let result = [];
      for (let i = 0; i < str.length; i++) {
          const c = str.charCodeAt(i);
          if (c < 0x80) {
              result.push(c);
          }
          else if (c < 0x800) {
              result.push((c >> 6) | 0xc0);
              result.push((c & 0x3f) | 0x80);
          }
          else if ((c & 0xfc00) == 0xd800) {
              i++;
              const c2 = str.charCodeAt(i);
              if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {
                  throw new Error("invalid utf-8 string");
              }
              // Surrogate Pair
              const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);
              result.push((pair >> 18) | 0xf0);
              result.push(((pair >> 12) & 0x3f) | 0x80);
              result.push(((pair >> 6) & 0x3f) | 0x80);
              result.push((pair & 0x3f) | 0x80);
          }
          else {
              result.push((c >> 12) | 0xe0);
              result.push(((c >> 6) & 0x3f) | 0x80);
              result.push((c & 0x3f) | 0x80);
          }
      }
      return arrayify(result);
  }
  function _toUtf8String(codePoints) {
      return codePoints.map((codePoint) => {
          if (codePoint <= 0xffff) {
              return String.fromCharCode(codePoint);
          }
          codePoint -= 0x10000;
          return String.fromCharCode((((codePoint >> 10) & 0x3ff) + 0xd800), ((codePoint & 0x3ff) + 0xdc00));
      }).join("");
  }
  function toUtf8String(bytes, onError) {
      return _toUtf8String(getUtf8CodePoints(bytes, onError));
  }

  class StringCoder extends DynamicBytesCoder {
      constructor(localName) {
          super("string", localName);
      }
      defaultValue() {
          return "";
      }
      encode(writer, value) {
          return super.encode(writer, toUtf8Bytes(value));
      }
      decode(reader) {
          return toUtf8String(super.decode(reader));
      }
  }

  class TupleCoder extends Coder {
      constructor(coders, localName) {
          let dynamic = false;
          const types = [];
          coders.forEach((coder) => {
              if (coder.dynamic) {
                  dynamic = true;
              }
              types.push(coder.type);
          });
          const type = ("tuple(" + types.join(",") + ")");
          super("tuple", type, localName, dynamic);
          this.coders = coders;
      }
      defaultValue() {
          const values = [];
          this.coders.forEach((coder) => {
              values.push(coder.defaultValue());
          });
          // We only output named properties for uniquely named coders
          const uniqueNames = this.coders.reduce((accum, coder) => {
              const name = coder.localName;
              if (name) {
                  if (!accum[name]) {
                      accum[name] = 0;
                  }
                  accum[name]++;
              }
              return accum;
          }, {});
          // Add named values
          this.coders.forEach((coder, index) => {
              let name = coder.localName;
              if (!name || uniqueNames[name] !== 1) {
                  return;
              }
              if (name === "length") {
                  name = "_length";
              }
              if (values[name] != null) {
                  return;
              }
              values[name] = values[index];
          });
          return Object.freeze(values);
      }
      encode(writer, value) {
          return pack(writer, this.coders, value);
      }
      decode(reader) {
          return reader.coerce(this.name, unpack(reader, this.coders));
      }
  }

  const logger = new Logger$1(version$3);
  const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
  const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
  class AbiCoder {
      constructor(coerceFunc) {
          defineReadOnly(this, "coerceFunc", coerceFunc || null);
      }
      _getCoder(param) {
          switch (param.baseType) {
              case "address":
                  return new AddressCoder(param.name);
              case "bool":
                  return new BooleanCoder(param.name);
              case "string":
                  return new StringCoder(param.name);
              case "bytes":
                  return new BytesCoder(param.name);
              case "array":
                  return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);
              case "tuple":
                  return new TupleCoder((param.components || []).map((component) => {
                      return this._getCoder(component);
                  }), param.name);
              case "":
                  return new NullCoder(param.name);
          }
          // u?int[0-9]*
          let match = param.type.match(paramTypeNumber);
          if (match) {
              let size = parseInt(match[2] || "256");
              if (size === 0 || size > 256 || (size % 8) !== 0) {
                  logger.throwArgumentError("invalid " + match[1] + " bit length", "param", param);
              }
              return new NumberCoder(size / 8, (match[1] === "int"), param.name);
          }
          // bytes[0-9]+
          match = param.type.match(paramTypeBytes);
          if (match) {
              let size = parseInt(match[1]);
              if (size === 0 || size > 32) {
                  logger.throwArgumentError("invalid bytes length", "param", param);
              }
              return new FixedBytesCoder(size, param.name);
          }
          return logger.throwArgumentError("invalid type", "type", param.type);
      }
      _getWordSize() { return 32; }
      _getReader(data, allowLoose) {
          return new Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);
      }
      _getWriter() {
          return new Writer(this._getWordSize());
      }
      getDefaultValue(types) {
          const coders = types.map((type) => this._getCoder(ParamType.from(type)));
          const coder = new TupleCoder(coders, "_");
          return coder.defaultValue();
      }
      encode(types, values) {
          if (types.length !== values.length) {
              logger.throwError("types/values length mismatch", Logger$1.errors.INVALID_ARGUMENT, {
                  count: { types: types.length, values: values.length },
                  value: { types: types, values: values }
              });
          }
          const coders = types.map((type) => this._getCoder(ParamType.from(type)));
          const coder = (new TupleCoder(coders, "_"));
          const writer = this._getWriter();
          coder.encode(writer, values);
          return writer.data;
      }
      decode(types, data, loose) {
          const coders = types.map((type) => this._getCoder(ParamType.from(type)));
          const coder = new TupleCoder(coders, "_");
          return coder.decode(this._getReader(arrayify(data), loose));
      }
  }
  const defaultAbiCoder = new AbiCoder();

  // SPDX-License-Identifier: Apache-2.0

  const { proto: proto$6 } = HieroProto;

  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.IContractNonceInfo} HieroProto.proto.IContractNonceInfo
   * @typedef {import("@hashgraph/proto").proto.IContractID} HieroProto.proto.IContractID
   * @typedef {object} ContractNonceInfoJSON
   * @property {string} contractId
   * @property {number} nonce
   */

  /**
   * Info about a contract account's nonce value.
   * A nonce of a contract is only incremented when that contract creates another contract.
   */
  class ContractNonceInfo {
      /**
       * @param {object} props
       * @param {ContractId} props.contractId
       * @param {Long} props.nonce
       */
      constructor(props) {
          /**
           * Id of the contract
           *
           * @readonly
           */
          this.contractId = props.contractId;

          /**
           * The current value of the contract account's nonce property
           *
           * @readonly
           */
          this.nonce = props.nonce;

          Object.freeze(this);
      }

      /**
       *  Extract the contractNonce from the protobuf.
       *
       * @internal
       * @param {HieroProto.proto.IContractNonceInfo} contractNonceInfo the protobuf
       * @returns {ContractNonceInfo} the contract object
       */
      static _fromProtobuf(contractNonceInfo) {
          return new ContractNonceInfo({
              contractId: ContractId._fromProtobuf(
                  /** @type {HieroProto.proto.IContractID} */ (
                      contractNonceInfo.contractId
                  ),
              ),
              nonce:
                  contractNonceInfo.nonce != null
                      ? contractNonceInfo.nonce
                      : Long.ZERO,
          });
      }

      /**
       * Build the protobuf
       *
       * @internal
       * @returns {HieroProto.proto.IContractNonceInfo} the protobuf representation
       */
      _toProtobuf() {
          return {
              contractId: this.contractId._toProtobuf(),
              nonce: this.nonce,
          };
      }

      /**
       * Extract the contractNonce from a byte array.
       *
       * @param {Uint8Array} bytes the byte array
       * @returns {ContractNonceInfo} the extracted contract nonce info
       */
      static fromBytes(bytes) {
          return ContractNonceInfo._fromProtobuf(
              proto$6.ContractNonceInfo.decode(bytes),
          );
      }

      /**
       * Create a byte array representation.
       *
       * @returns {Uint8Array} the byte array representation
       */
      toBytes() {
          return proto$6.ContractNonceInfo.encode(this._toProtobuf()).finish();
      }

      /**
       * Create a JSON representation.
       *
       * @returns {ContractNonceInfoJSON} the JSON representation
       */
      toJSON() {
          return {
              contractId: this.contractId.toString(),
              nonce: this.nonce.toNumber(),
          };
      }

      /**
       * @returns {string}
       */
      toString() {
          return JSON.stringify(this.toJSON());
      }

      /**
       * @param {this} other
       * @returns {boolean}
       */
      equals(other) {
          return (
              this.contractId.equals(other.contractId) &&
              this.nonce.eq(other.nonce)
          );
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {import("./ContractStateChange.js").default} ContractStateChange
   */

  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.IContractFunctionResult} HieroProto.proto.IContractFunctionResult
   * @typedef {import("@hashgraph/proto").proto.IContractID} HieroProto.proto.IContractID
   */

  /**
   * The result returned by a call to a smart contract function. This is part of the response to
   * a ContractCallLocal query, and is in the record for a ContractCall or ContractCreateInstance
   * transaction. The ContractCreateInstance transaction record has the results of the call to
   * the constructor.
   */
  class ContractFunctionResult {
      /**
       * Constructor isn't part of the stable API
       *
       * @param {object} result
       * @param {boolean} result._createResult
       * @param {?ContractId} result.contractId
       * @param {?string} result.errorMessage
       * @param {Uint8Array} result.bloom
       * @param {Long} result.gasUsed
       * @param {ContractLogInfo[]} result.logs
       * @param {ContractId[]} result.createdContractIds
       * @param {Uint8Array | null} result.evmAddress
       * @param {Uint8Array} result.bytes
       * @param {Long} result.gas
       * @param {Long} result.amount
       * @param {Uint8Array} result.functionParameters
       * @param {?AccountId} result.senderAccountId
       * @param {ContractStateChange[]} result.stateChanges
       * @param {ContractNonceInfo[]} result.contractNonces
       * @param {Long | null} result.signerNonce
       */
      constructor(result) {
          /**
           * Determines if this result came from `record.contractCreateResult` if true
           * or `record.contractCallResult` if false
           */
          this._createResult = result._createResult;

          /**
           * The smart contract instance whose function was called.
           */
          this.contractId = result.contractId;

          this.bytes = result.bytes;

          /**
           * Message In case there was an error during smart contract execution.
           */
          this.errorMessage = result.errorMessage;

          /**
           * Bloom filter for record
           */
          this.bloom = result.bloom;

          /**
           * Units of gas used  to execute contract.
           */
          this.gasUsed = result.gasUsed;

          /**
           * The log info for events returned by the function.
           */
          this.logs = result.logs;

          /**
           * @deprecated the list of smart contracts that were created by the function call.
           *
           * The created ids will now _also_ be externalized through internal transaction
           * records, where each record has its alias field populated with the new contract's
           * EVM address. (This is needed for contracts created with CREATE2, since
           * there is no longer a simple relationship between the new contract's 0.0.X id
           * and its Solidity address.)
           */
          // eslint-disable-next-line deprecation/deprecation
          this.createdContractIds = result.createdContractIds;

          this.evmAddress = result.evmAddress;

          /**
           * @deprecated - Use mirror node for contract traceability instead
           */
          // eslint-disable-next-line deprecation/deprecation
          this.stateChanges = result.stateChanges;

          /**
           * The amount of gas available for the call, aka the gasLimit.
           */
          this.gas = result.gas;

          /**
           * Number of tinybars sent (the function must be payable if this is nonzero).
           */
          this.amount = result.amount;

          /**
           * The parameters passed into the contract call.
           */
          this.functionParameters = result.functionParameters;

          /**
           * The account that is the "sender." If not present it is the accountId from the transactionId.
           *
           * This field should only be populated when the paired TransactionBody in the record stream is not a
           * ContractCreateTransactionBody or a ContractCallTransactionBody.
           */
          this.senderAccountId = result.senderAccountId;

          /**
           * A list of updated contract account nonces containing the new nonce value for each contract account.
           * This is always empty in a ContractCallLocalResponse#ContractFunctionResult message, since no internal creations can happen in a static EVM call.
           */
          this.contractNonces = result.contractNonces;

          /**
           * If not null this field specifies what the value of the signer account nonce is post transaction execution.
           * For transactions that don't update the signer nonce (like HAPI ContractCall and ContractCreate transactions) this field should be null.
           */
          this.signerNonce = result.signerNonce;
      }

      /**
       * @param {HieroProto.proto.IContractFunctionResult} result
       * @param {boolean} _createResult
       * @returns {ContractFunctionResult}
       */
      static _fromProtobuf(result, _createResult) {
          const contractId = /** @type {HieroProto.proto.IContractID | null} */ (
              result.contractID
          );
          const gasUsed = /** @type {Long} */ (result.gasUsed);
          const gas = /** @type {Long} */ (result.gas ? result.gas : -1);
          const amount = /** @type {Long} */ (result.amount ? result.amount : -1);

          return new ContractFunctionResult({
              _createResult,
              bytes: /** @type {Uint8Array} */ (result.contractCallResult),
              contractId:
                  contractId != null
                      ? ContractId._fromProtobuf(contractId)
                      : null,
              errorMessage:
                  result.errorMessage != null ? result.errorMessage : null,
              bloom: /** @type {Uint8Array} */ (result.bloom),
              gasUsed:
                  gasUsed instanceof Long ? gasUsed : Long.fromValue(gasUsed),
              logs: (result.logInfo != null ? result.logInfo : []).map((info) =>
                  ContractLogInfo._fromProtobuf(info),
              ),
              createdContractIds: (result.createdContractIDs != null
                  ? result.createdContractIDs
                  : []
              ).map((contractId) => ContractId._fromProtobuf(contractId)),
              evmAddress:
                  result.evmAddress != null &&
                  Object.hasOwn(result.evmAddress, "value") &&
                  result.evmAddress.value != null
                      ? result.evmAddress.value
                      : null,
              stateChanges: [],
              gas: gas instanceof Long ? gas : Long.fromValue(gas),
              amount: amount instanceof Long ? amount : Long.fromValue(amount),
              functionParameters: /** @type {Uint8Array} */ (
                  result.functionParameters
              ),
              senderAccountId:
                  result.senderId != null
                      ? AccountId._fromProtobuf(result.senderId)
                      : null,
              contractNonces: (result.contractNonces != null
                  ? result.contractNonces
                  : []
              ).map((contractNonce) =>
                  ContractNonceInfo._fromProtobuf(contractNonce),
              ),
              signerNonce:
                  result.signerNonce != null
                      ? Object.hasOwn(result.signerNonce, "value")
                          ? result.signerNonce.value || null
                          : null
                      : null,
          });
      }

      /**
       * @returns {Uint8Array}
       */
      asBytes() {
          return this.bytes;
      }

      /**
       * @param {number} [index]
       * @returns {string}
       */
      getString(index) {
          return decode$1(this.getBytes(index));
      }

      /**
       * @private
       * @param {number} [index]
       * @returns {Uint8Array}
       */
      getBytes(index) {
          // Len should never be larger than Number.MAX
          // index * 32 is the position of the lenth
          // (index + 1) * 32 onward to (index + 1) * 32 + len will be the elements of the array
          // Arrays in solidity cannot be longer than 1024:
          // https://solidity.readthedocs.io/en/v0.4.21/introduction-to-smart-contracts.html
          const offset = this.getInt32(index);
          const len = safeView(this.bytes).getInt32(offset + 28);

          return this.bytes.subarray(offset + 32, offset + 32 + len);
      }

      /**
       * @param {number} [index]
       * @returns {Uint8Array}
       */
      getBytes32(index) {
          return this.bytes.subarray(
              (index != null ? index : 0) * 32,
              (index != null ? index : 0) * 32 + 32,
          );
      }

      /**
       * @param {number} [index]
       * @returns {boolean}
       */
      getBool(index) {
          return this.bytes[(index != null ? index : 0) * 32 + 31] !== 0;
      }

      /**
       * @param {number} [index]
       * @returns {number}
       */
      getInt8(index) {
          const position = (index != null ? index : 0) * 32 + 31;
          return safeView(this.bytes).getInt8(position);
      }

      /**
       * @param {number} [index]
       * @returns {number}
       */
      getUint8(index) {
          return this.bytes[(index != null ? index : 0) * 32 + 31];
      }

      /**
       * @param {number} [index]
       * @returns {number}
       */
      getInt16(index) {
          // .getInt32() interprets as big-endian
          // Using DataView instead of Uint32Array because the latter interprets
          // using platform endianness which is little-endian on x86
          const position = (index != null ? index : 0) * 32 + 28;
          return safeView(this.bytes).getInt32(position);
      }

      /**
       * @param {number} [index]
       * @returns {number}
       */
      getUint16(index) {
          // .getUint32() interprets as big-endian
          // Using DataView instead of Uint32Array because the latter interprets
          // using platform endianness which is little-endian on x86
          const position = (index != null ? index : 0) * 32 + 28;
          return safeView(this.bytes).getUint32(position);
      }

      /**
       * @param {number} [index]
       * @returns {number}
       */
      getInt24(index) {
          // .getInt32() interprets as big-endian
          // Using DataView instead of Uint32Array because the latter interprets
          // using platform endianness which is little-endian on x86
          const position = (index != null ? index : 0) * 32 + 28;
          return safeView(this.bytes).getInt32(position);
      }

      /**
       * @param {number} [index]
       * @returns {number}
       */
      getUint24(index) {
          // .getUint32() interprets as big-endian
          // Using DataView instead of Uint32Array because the latter interprets
          // using platform endianness which is little-endian on x86
          const position = (index != null ? index : 0) * 32 + 28;
          return safeView(this.bytes).getUint32(position);
      }

      /**
       * @param {number} [index]
       * @returns {number}
       */
      getInt32(index) {
          // .getInt32() interprets as big-endian
          // Using DataView instead of Uint32Array because the latter interprets
          // using platform endianness which is little-endian on x86
          const position = (index != null ? index : 0) * 32 + 28;
          return safeView(this.bytes).getInt32(position);
      }

      /**
       * @param {number} [index]
       * @returns {number}
       */
      getUint32(index) {
          // .getUint32() interprets as big-endian
          // Using DataView instead of Uint32Array because the latter interprets
          // using platform endianness which is little-endian on x86
          const position = (index != null ? index : 0) * 32 + 28;
          return safeView(this.bytes).getUint32(position);
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getInt40(index) {
          const result = defaultAbiCoder.decode(
              ["int40"],
              this._getBytes32(index != null ? index : 0),
          );
          return new BigNumber$1(result.toString());
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getUint40(index) {
          return new BigNumber$1(
              encode$5(this._getBytes32(index).subarray(27, 32)),
              16,
          );
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getInt48(index) {
          const result = defaultAbiCoder.decode(
              ["int48"],
              this._getBytes32(index != null ? index : 0),
          );
          return new BigNumber$1(result.toString());
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getUint48(index) {
          return new BigNumber$1(
              encode$5(this._getBytes32(index).subarray(26, 32)),
              16,
          );
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getInt56(index) {
          const result = defaultAbiCoder.decode(
              ["int56"],
              this._getBytes32(index != null ? index : 0),
          );
          return new BigNumber$1(result.toString());
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getUint56(index) {
          return new BigNumber$1(
              encode$5(this._getBytes32(index).subarray(25, 32)),
              16,
          );
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getInt64(index) {
          const result = defaultAbiCoder.decode(
              ["int64"],
              this._getBytes32(index != null ? index : 0),
          );
          return new BigNumber$1(result.toString());
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getUint64(index) {
          return new BigNumber$1(
              encode$5(this._getBytes32(index).subarray(24, 32)),
              16,
          );
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getInt72(index) {
          const result = defaultAbiCoder.decode(
              ["int72"],
              this._getBytes32(index != null ? index : 0),
          );
          return new BigNumber$1(result.toString());
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getUint72(index) {
          return new BigNumber$1(
              encode$5(this._getBytes32(index).subarray(23, 32)),
              16,
          );
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getInt80(index) {
          const result = defaultAbiCoder.decode(
              ["int80"],
              this._getBytes32(index != null ? index : 0),
          );
          return new BigNumber$1(result.toString());
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getUint80(index) {
          return new BigNumber$1(
              encode$5(this._getBytes32(index).subarray(22, 32)),
              16,
          );
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getInt88(index) {
          const result = defaultAbiCoder.decode(
              ["int88"],
              this._getBytes32(index != null ? index : 0),
          );
          return new BigNumber$1(result.toString());
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getUint88(index) {
          return new BigNumber$1(
              encode$5(this._getBytes32(index).subarray(21, 32)),
              16,
          );
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getInt96(index) {
          const result = defaultAbiCoder.decode(
              ["int96"],
              this._getBytes32(index != null ? index : 0),
          );
          return new BigNumber$1(result.toString());
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getUint96(index) {
          return new BigNumber$1(
              encode$5(this._getBytes32(index).subarray(20, 32)),
              16,
          );
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getInt104(index) {
          const result = defaultAbiCoder.decode(
              ["int104"],
              this._getBytes32(index != null ? index : 0),
          );
          return new BigNumber$1(result.toString());
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getUint104(index) {
          return new BigNumber$1(
              encode$5(this._getBytes32(index).subarray(19, 32)),
              16,
          );
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getInt112(index) {
          const result = defaultAbiCoder.decode(
              ["int112"],
              this._getBytes32(index != null ? index : 0),
          );
          return new BigNumber$1(result.toString());
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getUint112(index) {
          return new BigNumber$1(
              encode$5(this._getBytes32(index).subarray(18, 32)),
              16,
          );
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getInt120(index) {
          const result = defaultAbiCoder.decode(
              ["int120"],
              this._getBytes32(index != null ? index : 0),
          );
          return new BigNumber$1(result.toString());
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getUint120(index) {
          return new BigNumber$1(
              encode$5(this._getBytes32(index).subarray(17, 32)),
              16,
          );
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getInt128(index) {
          const result = defaultAbiCoder.decode(
              ["int128"],
              this._getBytes32(index != null ? index : 0),
          );
          return new BigNumber$1(result.toString());
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getUint128(index) {
          return new BigNumber$1(
              encode$5(this._getBytes32(index).subarray(16, 32)),
              16,
          );
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getInt136(index) {
          const result = defaultAbiCoder.decode(
              ["int136"],
              this._getBytes32(index != null ? index : 0),
          );
          return new BigNumber$1(result.toString());
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getUint136(index) {
          return new BigNumber$1(
              encode$5(this._getBytes32(index).subarray(15, 32)),
              16,
          );
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getInt144(index) {
          const result = defaultAbiCoder.decode(
              ["int144"],
              this._getBytes32(index != null ? index : 0),
          );
          return new BigNumber$1(result.toString());
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getUint144(index) {
          return new BigNumber$1(
              encode$5(this._getBytes32(index).subarray(14, 32)),
              16,
          );
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getInt152(index) {
          const result = defaultAbiCoder.decode(
              ["int152"],
              this._getBytes32(index != null ? index : 0),
          );
          return new BigNumber$1(result.toString());
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getUint152(index) {
          return new BigNumber$1(
              encode$5(this._getBytes32(index).subarray(13, 32)),
              16,
          );
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getInt160(index) {
          const result = defaultAbiCoder.decode(
              ["int160"],
              this._getBytes32(index != null ? index : 0),
          );
          return new BigNumber$1(result.toString());
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getUint160(index) {
          return new BigNumber$1(
              encode$5(this._getBytes32(index).subarray(12, 32)),
              16,
          );
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getInt168(index) {
          const result = defaultAbiCoder.decode(
              ["int168"],
              this._getBytes32(index != null ? index : 0),
          );
          return new BigNumber$1(result.toString());
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getUint168(index) {
          return new BigNumber$1(
              encode$5(this._getBytes32(index).subarray(11, 32)),
              16,
          );
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getInt176(index) {
          const result = defaultAbiCoder.decode(
              ["int176"],
              this._getBytes32(index != null ? index : 0),
          );
          return new BigNumber$1(result.toString());
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getUint176(index) {
          return new BigNumber$1(
              encode$5(this._getBytes32(index).subarray(10, 32)),
              16,
          );
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getInt184(index) {
          const result = defaultAbiCoder.decode(
              ["int184"],
              this._getBytes32(index != null ? index : 0),
          );
          return new BigNumber$1(result.toString());
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getUint184(index) {
          return new BigNumber$1(
              encode$5(this._getBytes32(index).subarray(9, 32)),
              16,
          );
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getInt192(index) {
          const result = defaultAbiCoder.decode(
              ["int192"],
              this._getBytes32(index != null ? index : 0),
          );
          return new BigNumber$1(result.toString());
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getUint192(index) {
          return new BigNumber$1(
              encode$5(this._getBytes32(index).subarray(8, 32)),
              16,
          );
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getInt200(index) {
          const result = defaultAbiCoder.decode(
              ["int200"],
              this._getBytes32(index != null ? index : 0),
          );
          return new BigNumber$1(result.toString());
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getUint200(index) {
          return new BigNumber$1(
              encode$5(this._getBytes32(index).subarray(7, 32)),
              16,
          );
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getInt208(index) {
          const result = defaultAbiCoder.decode(
              ["int208"],
              this._getBytes32(index != null ? index : 0),
          );
          return new BigNumber$1(result.toString());
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getUint208(index) {
          return new BigNumber$1(
              encode$5(this._getBytes32(index).subarray(6, 32)),
              16,
          );
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getInt216(index) {
          const result = defaultAbiCoder.decode(
              ["int216"],
              this._getBytes32(index != null ? index : 0),
          );
          return new BigNumber$1(result.toString());
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getUint216(index) {
          return new BigNumber$1(
              encode$5(this._getBytes32(index).subarray(5, 32)),
              16,
          );
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getInt224(index) {
          const result = defaultAbiCoder.decode(
              ["int224"],
              this._getBytes32(index != null ? index : 0),
          );
          return new BigNumber$1(result.toString());
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getUint224(index) {
          return new BigNumber$1(
              encode$5(this._getBytes32(index).subarray(4, 32)),
              16,
          );
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getInt232(index) {
          const result = defaultAbiCoder.decode(
              ["int232"],
              this._getBytes32(index != null ? index : 0),
          );
          return new BigNumber$1(result.toString());
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getUint232(index) {
          return new BigNumber$1(
              encode$5(this._getBytes32(index).subarray(3, 32)),
              16,
          );
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getInt240(index) {
          const result = defaultAbiCoder.decode(
              ["int240"],
              this._getBytes32(index != null ? index : 0),
          );
          return new BigNumber$1(result.toString());
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getUint240(index) {
          return new BigNumber$1(
              encode$5(this._getBytes32(index).subarray(2, 32)),
              16,
          );
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getInt248(index) {
          const result = defaultAbiCoder.decode(
              ["int248"],
              this._getBytes32(index != null ? index : 0),
          );
          return new BigNumber$1(result.toString());
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getUint248(index) {
          return new BigNumber$1(
              encode$5(this._getBytes32(index).subarray(1, 32)),
              16,
          );
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getInt256(index) {
          const result = defaultAbiCoder.decode(
              ["int256"],
              this._getBytes32(index != null ? index : 0),
          );
          return new BigNumber$1(result.toString());
      }

      /**
       * @param {number} [index]
       * @returns {BigNumber}
       */
      getUint256(index) {
          return new BigNumber$1(encode$5(this._getBytes32(index)), 16);
      }

      /**
       * @param {number} [index]
       * @returns {string}
       */
      getAddress(index) {
          return encode$5(
              this.bytes.subarray(
                  (index != null ? index : 0) * 32 + 12,
                  (index != null ? index : 0) * 32 + 32,
              ),
          );
      }

      /**
       * @description Decode the data according to the array of types, each of which may be a string or ParamType.
       * @param {Array<string | ParamType>} types
       * @returns {string | any}
       */
      getResult(types) {
          return defaultAbiCoder.decode(types, this.bytes);
      }

      /**
       * @param {number} [index]
       * @returns {Uint8Array}
       */
      _getBytes32(index) {
          return this.bytes.subarray(
              (index != null ? index : 0) * 32,
              (index != null ? index : 0) * 32 + 32,
          );
      }

      /**
       * @returns {HieroProto.proto.IContractFunctionResult}
       */
      _toProtobuf() {
          return {
              contractID:
                  this.contractId != null ? this.contractId._toProtobuf() : null,
              contractCallResult: this.bytes,
              errorMessage: this.errorMessage,
              bloom: this.bloom,
              gasUsed: this.gasUsed,
              logInfo: this.logs.map((log) => log._toProtobuf()),
              // eslint-disable-next-line deprecation/deprecation
              createdContractIDs: this.createdContractIds.map((id) =>
                  id._toProtobuf(),
              ),
              evmAddress:
                  this.evmAddress != null
                      ? {
                            value: this.evmAddress,
                        }
                      : null,
              gas: this.gas,
              amount: this.amount,
              functionParameters: this.functionParameters,
              senderId:
                  this.senderAccountId != null
                      ? this.senderAccountId._toProtobuf()
                      : null,
              contractNonces: this.contractNonces.map((contractNonce) =>
                  contractNonce._toProtobuf(),
              ),
              signerNonce:
                  this.signerNonce != null
                      ? {
                            value: this.signerNonce,
                        }
                      : null,
          };
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @augments {ObjectMap<AccountId, Long>}
   */
  class TokenTransferAccountMap extends ObjectMap {
      constructor() {
          super((s) => AccountId.fromString(s));
      }

      toJSON() {
          const obj = {};

          this._map.forEach((value, key) => {
              // @ts-ignore
              obj[key] = value.toString();
          });

          return obj;
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITokenTransferList} HieroProto.proto.ITokenTransferList
   * @typedef {import("@hashgraph/proto").proto.IAccountAmount} HieroProto.proto.IAccountAmount
   * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
   * @typedef {import("@hashgraph/proto").proto.IAccountID} HieroProto.proto.IAccountID
   */

  /**
   * @typedef {import("bignumber.js").default} BigNumber
   */

  /**
   * @augments {ObjectMap<TokenId, TokenTransferAccountMap>}
   */
  class TokenTransferMap extends ObjectMap {
      constructor() {
          super((s) => TokenId.fromString(s));
      }

      /**
       * @internal
       * @param {TokenId} tokenId
       * @param {AccountId} accountId
       * @param {Long | number | BigNumber | bigint} amount
       */
      __set(tokenId, accountId, amount) {
          const token = tokenId.toString();

          let _map = this._map.get(token);
          if (_map == null) {
              _map = new TokenTransferAccountMap();
              this._map.set(token, _map);
              this.__map.set(tokenId, _map);
          }

          _map._set(accountId, convertAmountToLong(amount));
      }

      /**
       * @param {HieroProto.proto.ITokenTransferList[]} transfers
       * @returns {TokenTransferMap}
       */
      static _fromProtobuf(transfers) {
          const tokenTransfersMap = new TokenTransferMap();

          for (const transfer of transfers) {
              const token = TokenId._fromProtobuf(
                  /** @type {HieroProto.proto.ITokenID} */ (transfer.token),
              );

              for (const aa of transfer.transfers != null
                  ? transfer.transfers
                  : []) {
                  const account = AccountId._fromProtobuf(
                      /** @type {HieroProto.proto.IAccountID} */ (aa.accountID),
                  );

                  tokenTransfersMap.__set(
                      token,
                      account,
                      /** @type {Long} */ (aa.amount),
                  );
              }
          }

          return tokenTransfersMap;
      }

      /**
       * @returns {HieroProto.proto.ITokenTransferList[]}
       */
      _toProtobuf() {
          /** @type {HieroProto.proto.ITokenTransferList[]} */
          const tokenTransferList = [];

          for (const [tokenId, value] of this) {
              /** @type {HieroProto.proto.IAccountAmount[]} */
              const transfers = [];

              for (const [accountId, amount] of value) {
                  transfers.push({
                      accountID: accountId._toProtobuf(),
                      amount: amount,
                  });
              }

              tokenTransferList.push({
                  token: tokenId._toProtobuf(),
                  transfers: transfers,
              });
          }

          return tokenTransferList;
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITokenTransferList} HieroProto.proto.ITokenTransferList
   * @typedef {import("@hashgraph/proto").proto.INftTransfer} HieroProto.proto.INftTransfer
   * @typedef {import("@hashgraph/proto").proto.IAccountAmount} HieroProto.proto.IAccountAmount
   * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
   * @typedef {import("@hashgraph/proto").proto.IAccountID} HieroProto.proto.IAccountID
   */

  /**
   * @typedef {object} NftTransfer
   * @property {AccountId} sender
   * @property {AccountId} recipient
   * @property {Long} serial
   * @property {boolean} isApproved
   */

  /**
   * @augments {ObjectMap<TokenId, NftTransfer[]>}
   */
  class TokenNftTransferMap extends ObjectMap {
      constructor() {
          super((s) => TokenId.fromString(s));
      }

      /**
       * @internal
       * @param {TokenId} tokenId
       * @param {NftTransfer} nftTransfer
       */
      __set(tokenId, nftTransfer) {
          const token = tokenId.toString();

          let _map = this._map.get(token);
          if (_map == null) {
              _map = [];
              this._map.set(token, _map);
              this.__map.set(tokenId, _map);
          }

          _map.push(nftTransfer);
      }

      /**
       * @param {HieroProto.proto.ITokenTransferList[]} transfers
       * @returns {TokenNftTransferMap}
       */
      static _fromProtobuf(transfers) {
          const tokenTransfersMap = new TokenNftTransferMap();

          for (const transfer of transfers) {
              const token = TokenId._fromProtobuf(
                  /** @type {HieroProto.proto.ITokenID} */ (transfer.token),
              );

              for (const aa of transfer.nftTransfers != null
                  ? transfer.nftTransfers
                  : []) {
                  const sender = AccountId._fromProtobuf(
                      /** @type {HieroProto.proto.IAccountID} */ (
                          aa.senderAccountID
                      ),
                  );
                  const recipient = AccountId._fromProtobuf(
                      /** @type {HieroProto.proto.IAccountID} */ (
                          aa.receiverAccountID
                      ),
                  );

                  tokenTransfersMap.__set(token, {
                      sender,
                      recipient,
                      serial: Long.fromValue(
                          /** @type {Long} */ (aa.serialNumber),
                      ),
                      isApproved: false,
                  });
              }
          }

          return tokenTransfersMap;
      }

      /**
       * @returns {HieroProto.proto.ITokenTransferList[]}
       */
      _toProtobuf() {
          /** @type {HieroProto.proto.ITokenTransferList[]} */
          const tokenTransferList = [];

          for (const [tokenId, value] of this) {
              /** @type {HieroProto.proto.INftTransfer[]} */
              const transfers = [];

              for (const transfer of value) {
                  transfers.push({
                      senderAccountID: transfer.sender._toProtobuf(),
                      receiverAccountID: transfer.recipient._toProtobuf(),
                      serialNumber: transfer.serial,
                  });
              }

              tokenTransferList.push({
                  token: tokenId._toProtobuf(),
                  nftTransfers: transfers,
              });
          }

          return tokenTransferList;
      }

      toJSON() {
          const obj = {};

          this._map.forEach((value, key) => {
              // @ts-ignore
              obj[key] = value.map((nftTransfer) => ({
                  sender: nftTransfer.sender.toString(),
                  recipient: nftTransfer.recipient.toString(),
                  serial: nftTransfer.serial,
                  isApproved: nftTransfer.isApproved,
              }));
          });

          return obj;
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {import("bignumber.js").default} BigNumber
   */

  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.IAssessedCustomFee} HieroProto.proto.IAssessedCustomFee
   */

  /**
   * @typedef {object} AssessedCustomFeeJSON
   * @property {?string} feeCollectorAccountId
   * @property {?string} tokenId
   * @property {?string} amount
   * @property {string[]} payerAccountIds
   */

  /**
   * Represents an assessed custom fee that has been evaluated and attached to a transaction.
   * This includes details about who collects the fee, which token the fee is paid in,
   * the amount of the fee, and which accounts are responsible for paying it.
   */
  class AssessedCustomFee {
      /**
       * @param {object} props
       * @param {AccountId | string} [props.feeCollectorAccountId]
       * @param {TokenId | string} [props.tokenId]
       * @param {Long | number | BigNumber | bigint} [props.amount]
       * @param {AccountId[]} [props.payerAccountIds]
       */
      constructor(props = {}) {
          /**
           * @type {?AccountId}
           */
          this._feeCollectorAccountId = null;

          if (props.feeCollectorAccountId != null) {
              this.setFeeCollectorAccountId(props.feeCollectorAccountId);
          }

          /**
           * @type {?TokenId}
           */
          this._tokenId = null;

          if (props.tokenId != null) {
              this.setTokenId(props.tokenId);
          }

          /**
           * @type {?Long}
           */
          this._amount = null;

          if (props.amount != null) {
              this.setAmount(props.amount);
          }

          /**
           * @type {?AccountId[]}
           */
          this._payerAccountIds = null;

          if (props.payerAccountIds != null) {
              this.setPayerAccountIds(props.payerAccountIds);
          }
      }

      /**
       * @returns {?AccountId}
       */
      get feeCollectorAccountId() {
          return this._feeCollectorAccountId;
      }

      /**
       * @param {AccountId | string} feeCollectorAccountId
       * @returns {this}
       */
      setFeeCollectorAccountId(feeCollectorAccountId) {
          this._feeCollectorAccountId =
              typeof feeCollectorAccountId === "string"
                  ? AccountId.fromString(feeCollectorAccountId)
                  : feeCollectorAccountId;
          return this;
      }

      /**
       * @returns {?TokenId}
       */
      get tokenId() {
          return this._tokenId;
      }

      /**
       * @param {TokenId | string} tokenId
       * @returns {this}
       */
      setTokenId(tokenId) {
          this._tokenId =
              typeof tokenId === "string" ? TokenId.fromString(tokenId) : tokenId;
          return this;
      }

      /**
       * @returns {?Long}
       */
      get amount() {
          return this._amount;
      }

      /**
       * @param {Long | number | BigNumber | bigint} amount
       * @returns {AssessedCustomFee}
       */
      setAmount(amount) {
          this._amount = convertAmountToLong(amount);
          return this;
      }

      /**
       * @returns {?AccountId[]}
       */
      get payerAccountIds() {
          return this._payerAccountIds;
      }

      /**
       * @param {AccountId[]} payerAccountIds
       * @returns {AssessedCustomFee}
       */
      setPayerAccountIds(payerAccountIds) {
          this._payerAccountIds = payerAccountIds;
          return this;
      }

      /**
       * @internal
       * @param {HieroProto.proto.IAssessedCustomFee} fee
       * @returns {AssessedCustomFee}
       */
      static _fromProtobuf(fee) {
          return new AssessedCustomFee({
              feeCollectorAccountId:
                  fee.feeCollectorAccountId != null
                      ? AccountId._fromProtobuf(fee.feeCollectorAccountId)
                      : undefined,
              tokenId:
                  fee.tokenId != null
                      ? TokenId._fromProtobuf(fee.tokenId)
                      : undefined,
              amount: fee.amount != null ? fee.amount : undefined,
              payerAccountIds:
                  fee.effectivePayerAccountId != null
                      ? fee.effectivePayerAccountId.map((id) =>
                            AccountId._fromProtobuf(id),
                        )
                      : undefined,
          });
      }

      /**
       * @internal
       * @abstract
       * @returns {HieroProto.proto.IAssessedCustomFee}
       */
      _toProtobuf() {
          return {
              feeCollectorAccountId:
                  this.feeCollectorAccountId != null
                      ? this.feeCollectorAccountId._toProtobuf()
                      : null,
              tokenId: this._tokenId != null ? this._tokenId._toProtobuf() : null,
              amount: this._amount,
              effectivePayerAccountId:
                  this._payerAccountIds != null
                      ? this._payerAccountIds.map((id) => id._toProtobuf())
                      : null,
          };
      }

      /**
       * @returns {AssessedCustomFeeJSON}
       */
      toJSON() {
          return {
              feeCollectorAccountId:
                  this.feeCollectorAccountId?.toString() || null,
              tokenId: this._tokenId?.toString() || null,
              amount: this._amount?.toString() || null,
              payerAccountIds:
                  this._payerAccountIds?.map((id) => id.toString()) || [],
          };
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITokenAssociation} HieroProto.proto.ITokenAssociation
   */

  /**
   * @typedef {object} TokenAssociationJSON
   * @property {?string} accountId
   * @property {?string} tokenId
   */

  class TokenAssociation {
      /**
       * @param {object} props
       * @param {AccountId | string} [props.accountId]
       * @param {TokenId | string} [props.tokenId]
       */
      constructor(props = {}) {
          /**
           * @type {?AccountId}
           */
          this._accountId = null;

          if (props.accountId != null) {
              this.setAccountId(props.accountId);
          }

          /**
           * @type {?TokenId}
           */
          this._tokenId = null;

          if (props.tokenId != null) {
              this.setTokenId(props.tokenId);
          }

          this._defaultMaxTransactionFee = new Hbar(5);
      }

      /**
       * @returns {?AccountId}
       */
      get accountId() {
          return this._accountId;
      }

      /**
       * @param {AccountId | string} accountId
       * @returns {this}
       */
      setAccountId(accountId) {
          this._accountId =
              typeof accountId === "string"
                  ? AccountId.fromString(accountId)
                  : accountId;
          return this;
      }

      /**
       * @returns {?TokenId}
       */
      get tokenId() {
          return this._tokenId;
      }

      /**
       * @param {TokenId | string} tokenId
       * @returns {this}
       */
      setTokenId(tokenId) {
          this._tokenId =
              typeof tokenId === "string" ? TokenId.fromString(tokenId) : tokenId;
          return this;
      }

      /**
       * @internal
       * @abstract
       * @param {HieroProto.proto.ITokenAssociation} association
       * @returns {TokenAssociation}
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      static _fromProtobuf(association) {
          return new TokenAssociation({
              accountId:
                  association.accountId != null
                      ? AccountId._fromProtobuf(association.accountId)
                      : undefined,
              tokenId:
                  association.tokenId != null
                      ? TokenId._fromProtobuf(association.tokenId)
                      : undefined,
          });
      }

      /**
       * @internal
       * @abstract
       * @returns {HieroProto.proto.ITokenAssociation}
       */
      _toProtobuf() {
          return {
              accountId:
                  this._accountId != null
                      ? this._accountId._toProtobuf()
                      : undefined,
              tokenId:
                  this._tokenId != null ? this._tokenId._toProtobuf() : undefined,
          };
      }

      /**
       * @returns {TokenAssociationJSON}
       */
      toJSON() {
          return {
              accountId: this._accountId?.toString() || null,
              tokenId: this._tokenId?.toString() || null,
          };
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITokenTransferList} HieroProto.proto.ITokenTransferList
   * @typedef {import("@hashgraph/proto").proto.IAccountAmount} HieroProto.proto.IAccountAmount
   * @typedef {import("@hashgraph/proto").proto.IAccountID} HieroProto.proto.IAccountID
   * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
   */

  /**
   * @typedef {import("bignumber.js").default} BigNumber
   */

  /**
   * @typedef {object} TokenTransferJSON
   * @property {string} tokenId
   * @property {string} accountId
   * @property {?number} expectedDecimals
   * @property {string} amount
   * @property {boolean} isApproved
   */

  /**
   * An account, and the amount that it sends or receives during a cryptocurrency tokentransfer.
   */
  class TokenTransfer {
      /**
       * @internal
       * @param {object} props
       * @param {TokenId | string} props.tokenId
       * @param {AccountId | string} props.accountId
       * @param {number | null} props.expectedDecimals
       * @param {Long | number | BigNumber | bigint} props.amount
       * @param {boolean} props.isApproved
       */
      constructor(props) {
          /**
           * The Token ID that sends or receives cryptocurrency.
           *
           * @readonly
           */
          this.tokenId =
              props.tokenId instanceof TokenId
                  ? props.tokenId
                  : TokenId.fromString(props.tokenId);

          /**
           * The Account ID that sends or receives cryptocurrency.
           *
           * @readonly
           */
          this.accountId =
              props.accountId instanceof AccountId
                  ? props.accountId
                  : AccountId.fromString(props.accountId);

          this.expectedDecimals = props.expectedDecimals;
          this.amount = convertAmountToLong(props.amount);
          this.isApproved = props.isApproved;
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITokenTransferList[]} tokenTransfers
       * @returns {TokenTransfer[]}
       */
      static _fromProtobuf(tokenTransfers) {
          const transfers = [];

          for (const tokenTransfer of tokenTransfers) {
              const tokenId = TokenId._fromProtobuf(
                  /** @type {HieroProto.proto.ITokenID} */ (tokenTransfer.token),
              );
              const expectedDecimals =
                  tokenTransfer.expectedDecimals != null
                      ? Object.hasOwn(tokenTransfer.expectedDecimals, "value")
                          ? tokenTransfer.expectedDecimals.value
                          : null
                      : null;

              for (const transfer of tokenTransfer.transfers != null
                  ? tokenTransfer.transfers
                  : []) {
                  transfers.push(
                      new TokenTransfer({
                          tokenId,
                          accountId: AccountId._fromProtobuf(
                              /** @type {HieroProto.proto.IAccountID} */ (
                                  transfer.accountID
                              ),
                          ),
                          expectedDecimals: expectedDecimals || null,
                          amount:
                              transfer.amount != null
                                  ? transfer.amount
                                  : Long.ZERO,
                          isApproved: transfer.isApproval == true,
                      }),
                  );
              }
          }

          return transfers;
      }

      /**
       * @internal
       * @returns {HieroProto.proto.IAccountAmount}
       */
      _toProtobuf() {
          return {
              accountID: this.accountId._toProtobuf(),
              amount: this.amount,
              isApproval: this.isApproved,
          };
      }

      /**
       * @returns {TokenTransferJSON}
       */
      toJSON() {
          return {
              tokenId: this.tokenId.toString(),
              accountId: this.accountId.toString(),
              expectedDecimals: this.expectedDecimals,
              amount: this.amount.toString(),
              isApproved: this.isApproved,
          };
      }

      /**
       * @returns {string}
       */
      toString() {
          return JSON.stringify(this.toJSON());
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * The ID for a crypto-currency token on Hedera.
   *
   * @augments {EntityId<HieroProto.proto.INftID>}
   */
  class NftId {
      /**
       * @param {TokenId} token
       * @param {number | Long} serial
       */
      constructor(token, serial) {
          this.tokenId = token;
          this.serial =
              typeof serial === "number" ? Long.fromNumber(serial) : serial;

          Object.freeze(this);
      }

      /**
       * @param {string} text
       * @returns {NftId}
       */
      static fromString(text) {
          const strings =
              text.split("/").length > 1 ? text.split("/") : text.split("@");

          for (const string of strings) {
              if (string === "") {
                  throw new Error(
                      "invalid format for NftId: use [token]/[serial] or [token]@[serial]",
                  );
              }
          }

          const token = TokenId.fromString(strings[0]);
          const serial = Long.fromString(strings[1]);

          return new NftId(token, serial);
      }

      /**
       * @internal
       * @param {HieroProto.proto.INftID} id
       * @returns {NftId}
       */
      static _fromProtobuf(id) {
          return new NftId(
              TokenId._fromProtobuf(
                  /** @type {HieroProto.proto.ITokenID} */ (id.token_ID),
              ),
              id.serialNumber != null ? id.serialNumber : Long.ZERO,
          );
      }

      /**
       * @param {Uint8Array} bytes
       * @returns {NftId}
       */
      static fromBytes(bytes) {
          return NftId._fromProtobuf(libExports.proto.NftID.decode(bytes));
      }

      /**
       * @internal
       * @returns {HieroProto.proto.INftID}
       */
      _toProtobuf() {
          return {
              token_ID: this.tokenId._toProtobuf(),
              serialNumber: Long.fromValue(
                  this.serial !== undefined ? this.serial : 0,
              ),
          };
      }

      /**
       * @returns {string}
       */
      toString() {
          return `${this.tokenId.toString()}/${this.serial.toString()}`;
      }

      /**
       * @returns {Uint8Array}
       */
      toBytes() {
          return libExports.proto.NftID.encode(this._toProtobuf()).finish();
      }
  }

  // SPDX-License-Identifier: Apache-2.0
  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.PendingAirdropId} HieroProto.proto.PendingAirdropId
   */


  /**
   * Represents the identifier for a pending airdrop in the Hedera network.
   *
   * A PendingAirdropId contains information about a pending token or NFT airdrop,
   * including the sender, receiver, and the token or NFT being airdropped. This class
   * is used to track and identify specific airdrops in the system.
   */
  class PendingAirdropId {
      /**
       *
       * @param {object} props
       * @param {AccountId} [props.senderId]
       * @param {AccountId} [props.receiverId]
       * @param {TokenId?} [props.tokenId]
       * @param {NftId?} [props.nftId]
       */
      constructor(props = {}) {
          this._senderId = null;
          this._receiverId = null;
          this._tokenId = null;
          this._nftId = null;

          if (props.receiverId) {
              this._receiverId = props.receiverId;
          }
          if (props.senderId) {
              this._senderId = props.senderId;
          }
          if (props.tokenId) {
              this._tokenId = new TokenId(props.tokenId);
          } else if (props.nftId) {
              this._nftId = new NftId(props.nftId?.tokenId, props.nftId?.serial);
          }
      }

      /**
       * @param {HieroProto.proto.PendingAirdropId} pb
       * @returns {PendingAirdropId}
       */
      static fromBytes(pb) {
          if (pb.senderId == null) {
              throw new Error("senderId is required");
          }

          if (pb.receiverId == null) {
              throw new Error("receiverId is required");
          }

          if (pb.fungibleTokenType == null && pb.nonFungibleToken == null) {
              throw new Error(
                  "Either fungibleTokenType or nonFungibleToken is required",
              );
          }

          return new PendingAirdropId({
              senderId: AccountId._fromProtobuf(pb.senderId),
              receiverId: AccountId._fromProtobuf(pb.receiverId),
              nftId:
                  pb.nonFungibleToken != null
                      ? NftId._fromProtobuf(pb.nonFungibleToken)
                      : null,
              tokenId:
                  pb.fungibleTokenType != null
                      ? TokenId._fromProtobuf(pb.fungibleTokenType)
                      : null,
          });
      }

      /**
       *
       * @param {AccountId} senderId
       * @returns {this}
       */
      setSenderid(senderId) {
          this._senderId = senderId;
          return this;
      }

      /**
       * @param {AccountId} receiverId
       * @returns {this}
       */
      setReceiverId(receiverId) {
          this._receiverId = receiverId;
          return this;
      }

      /**
       * @param {TokenId} tokenId
       * @returns {this}
       */
      setTokenId(tokenId) {
          this._nftId = null;
          this._tokenId = tokenId;
          return this;
      }

      /**
       * @param {NftId} nftId
       * @returns {this}
       */
      setNftId(nftId) {
          this._tokenId = null;
          this._nftId = nftId;
          return this;
      }

      /**
       * @returns {?AccountId}
       */
      get senderId() {
          return this._senderId;
      }

      /**
       * @returns {?AccountId}
       */
      get receiverId() {
          return this._receiverId;
      }

      /**
       * @returns {?TokenId}
       */
      get tokenId() {
          return this._tokenId;
      }

      /**
       * @returns {?NftId}
       */
      get nftId() {
          return this._nftId;
      }

      /**
       *  @returns {HieroProto.proto.PendingAirdropId}
       */
      toBytes() {
          return {
              senderId: this.senderId?._toProtobuf(),
              receiverId: this._receiverId?._toProtobuf(),
              fungibleTokenType: this._tokenId?._toProtobuf(),
              nonFungibleToken: this._nftId?._toProtobuf(),
          };
      }
  }

  // SPDX-License-Identifier: Apache-2.0
  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.PendingAirdropRecord} HieroProto.proto.PendingAirdropRecord
   */


  /**
   * @typedef {import("bignumber.js").default} BigNumber
   */

  class PendingAirdropRecord {
      /**
       * @param {object} props
       * @param {PendingAirdropId} props.airdropId
       * @param {Long | number | BigNumber | bigint} props.amount
       */
      constructor(props) {
          this.airdropId = props.airdropId;
          this.amount = convertAmountToLong(props.amount);
      }

      /**
       * @returns {HieroProto.proto.PendingAirdropRecord}
       */
      toBytes() {
          return {
              pendingAirdropId: this.airdropId.toBytes(),
              pendingAirdropValue: {
                  amount: this.amount,
              },
          };
      }

      /**
       * @param {HieroProto.proto.PendingAirdropRecord} pb
       * @returns {PendingAirdropRecord}
       */
      static fromBytes(pb) {
          if (pb.pendingAirdropId == null) {
              throw new Error("pendingAirdropId is required");
          }

          const airdropId = PendingAirdropId.fromBytes(pb.pendingAirdropId);
          const amount = pb.pendingAirdropValue?.amount;

          return new PendingAirdropRecord({
              airdropId: airdropId,
              amount: amount ? amount : Long.ZERO,
          });
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {import("../token/TokenId.js").default} TokenId
   * @typedef {import("../token/TokenTransfer.js").TokenTransferJSON} TokenTransferJSON
   * @typedef {import("../account/HbarAllowance.js").default} HbarAllowance
   * @typedef {import("../account/TokenAllowance.js").default} TokenAllowance
   * @typedef {import("../account/TokenNftAllowance.js").default} TokenNftAllowance
   * @typedef {import("./TransactionReceipt.js").TransactionReceiptJSON} TransactionReceiptJSON
   * @typedef {import("../Transfer.js").TransferJSON} TransferJSON
   */

  /**
   * @typedef {object} TransactionRecordJSON
   * @property {TransactionReceiptJSON} receipt
   * @property {?string} transactionHash
   * @property {Date} consensusTimestamp
   * @property {string} transactionId
   * @property {string} transactionMemo
   * @property {string} transactionFee
   * @property {TransferJSON[]} transfers
   * @property {TokenTransferMap} tokenTransfers
   * @property {TokenTransferJSON[]} tokenTransfersList
   * @property {?string} scheduleRef
   * @property {AssessedCustomFee[]} assessedCustomFees
   * @property {TokenNftTransferMap} nftTransfers
   * @property {TokenAssocation[]} automaticTokenAssociations
   * @property {Date | null} parentConsensusTimestamp
   * @property {?string} aliasKey
   * @property {TransactionRecord[]} duplicates
   * @property {TransactionRecord[]} children
   * @property {?string} ethereumHash
   * @property {Transfer[]} paidStakingRewards
   * @property {?string} prngBytes
   * @property {?number} prngNumber
   * @property {?string} evmAddress
   */

  /**
   * Either the record of processing the first consensus transaction with the given id whose
   * status was neither <tt>INVALID_NODE_ACCOUNT</tt> nor <tt>INVALID_PAYER_SIGNATURE</tt>;
   * <b>or</b>, if no such record exists, the record of processing the first transaction to reach
   * consensus with the given transaction id.
   */
  class TransactionRecord {
      /**
       * @private
       * @param {object} props
       * @param {ContractFunctionResult} [props.contractFunctionResult]
       * @param {TransactionReceipt} props.receipt
       * @param {Uint8Array} props.transactionHash
       * @param {Timestamp} props.consensusTimestamp
       * @param {TransactionId} props.transactionId
       * @param {string} props.transactionMemo
       * @param {Hbar} props.transactionFee
       * @param {Transfer[]} props.transfers
       * @param {TokenTransferMap} props.tokenTransfers
       * @param {TokenTransfer[]} props.tokenTransfersList
       * @param {?ScheduleId} props.scheduleRef
       * @param {AssessedCustomFee[]} props.assessedCustomFees
       * @param {TokenNftTransferMap} props.nftTransfers
       * @param {TokenAssocation[]} props.automaticTokenAssociations
       * @param {Timestamp | null} props.parentConsensusTimestamp
       * @param {PublicKey | null} props.aliasKey
       * @param {TransactionRecord[]} props.duplicates
       * @param {TransactionRecord[]} props.children
       * @param {HbarAllowance[]} props.hbarAllowanceAdjustments
       * @param {TokenAllowance[]} props.tokenAllowanceAdjustments
       * @param {TokenNftAllowance[]} props.nftAllowanceAdjustments
       * @param {?Uint8Array} props.ethereumHash
       * @param {Transfer[]} props.paidStakingRewards
       * @param {?Uint8Array} props.prngBytes
       * @param {?number} props.prngNumber
       * @param {?EvmAddress} props.evmAddress
       * @param {PendingAirdropRecord[]} props.newPendingAirdrops
       */
      constructor(props) {
          /**
           * The status (reach consensus, or failed, or is unknown) and the ID of
           * any new account/file/instance created.
           *
           * @readonly
           */
          this.receipt = props.receipt;

          /**
           * The hash of the Transaction that executed (not the hash of any Transaction that failed
           * for having a duplicate TransactionID).
           *
           * @readonly
           */
          this.transactionHash = props.transactionHash;

          /**
           * The consensus timestamp (or null if didn't reach consensus yet).
           *
           * @readonly
           */
          this.consensusTimestamp = props.consensusTimestamp;

          /**
           * The ID of the transaction this record represents.
           *
           * @readonly
           */
          this.transactionId = props.transactionId;

          /**
           * The memo that was submitted as part of the transaction (max 100 bytes).
           *
           * @readonly
           */
          this.transactionMemo = props.transactionMemo;

          /**
           * The actual transaction fee charged,
           * not the original transactionFee value from TransactionBody.
           *
           * @readonly
           */
          this.transactionFee = props.transactionFee;

          /**
           * All hbar transfers as a result of this transaction, such as fees, or transfers performed
           * by the transaction, or by a smart contract it calls, or by the creation of threshold
           * records that it triggers.
           *
           * @readonly
           */
          this.transfers = props.transfers;

          /**
           * Record of the value returned by the smart contract function or constructor.
           *
           * @readonly
           */
          this.contractFunctionResult =
              props.contractFunctionResult != null
                  ? props.contractFunctionResult
                  : null;

          /**
           * All the token transfers from this account
           *
           * @readonly
           */
          this.tokenTransfers = props.tokenTransfers;

          /**
           * All the token transfers from this account
           *
           * @readonly
           */
          this.tokenTransfersList = props.tokenTransfersList;

          /**
           * Reference to the scheduled transaction ID that this transaction record represent
           *
           * @readonly
           */
          this.scheduleRef = props.scheduleRef;

          /**
           * All custom fees that were assessed during a CryptoTransfer, and must be paid if the
           * transaction status resolved to SUCCESS
           *
           * @readonly
           */
          this.assessedCustomFees = props.assessedCustomFees;

          /** @readonly */
          this.nftTransfers = props.nftTransfers;

          /**
           * All token associations implicitly created while handling this transaction
           *
           * @readonly
           */
          this.automaticTokenAssociations = props.automaticTokenAssociations;

          /**
           * In the record of an internal transaction, the consensus timestamp of the user
           * transaction that spawned it.
           *
           * @readonly
           */
          this.parentConsensusTimestamp = props.parentConsensusTimestamp;

          /**
           * In the record of an internal CryptoCreate transaction triggered by a user
           * transaction with a (previously unused) alias, the new account's alias.
           *
           * @readonly
           */
          this.aliasKey = props.aliasKey;

          /**
           * The records of processing all consensus transaction with the same id as the distinguished
           * record above, in chronological order.
           *
           * @readonly
           */
          this.duplicates = props.duplicates;

          /**
           * The records of processing all child transaction spawned by the transaction with the given
           * top-level id, in consensus order. Always empty if the top-level status is UNKNOWN.
           *
           * @readonly
           */
          this.children = props.children;

          /**
           * @deprecated
           * @readonly
           */
          // eslint-disable-next-line deprecation/deprecation
          this.hbarAllowanceAdjustments = props.hbarAllowanceAdjustments;

          /**
           * @deprecated
           * @readonly
           */
          // eslint-disable-next-line deprecation/deprecation
          this.tokenAllowanceAdjustments = props.tokenAllowanceAdjustments;

          /**
           * @deprecated
           * @readonly
           */
          // eslint-disable-next-line deprecation/deprecation
          this.nftAllowanceAdjustments = props.nftAllowanceAdjustments;

          /**
           * The keccak256 hash of the ethereumData. This field will only be populated for
           * EthereumTransaction.
           *
           * @readonly
           */
          this.ethereumHash = props.ethereumHash;

          /**
           * List of accounts with the corresponding staking rewards paid as a result of a transaction.
           *
           * @readonly
           */
          this.paidStakingRewards = props.paidStakingRewards;

          /**
           * In the record of a PRNG transaction with no output range, a pseudorandom 384-bit string.
           *
           * @readonly
           */
          this.prngBytes = props.prngBytes;

          /**
           * In the record of a PRNG transaction with an output range, the output of a PRNG whose input was a 384-bit string.
           *
           * @readonly
           */
          this.prngNumber = props.prngNumber;

          /**
           * The new default EVM address of the account created by this transaction.
           * This field is populated only when the EVM address is not specified in the related transaction body.
           *
           * @readonly
           */
          this.evmAddress = props.evmAddress;

          /**
           * The new default EVM address of the account created by this transaction.
           * This field is populated only when the EVM address is not specified in the related transaction body.
           *
           * @readonly
           */
          this.newPendingAirdrops = props.newPendingAirdrops;

          Object.freeze(this);
      }

      /**
       * @internal
       * @returns {HieroProto.proto.ITransactionGetRecordResponse}
       */
      _toProtobuf() {
          const tokenTransfers = this.tokenTransfers._toProtobuf();
          const nftTransfers = this.nftTransfers._toProtobuf();

          const tokenTransferLists = [];

          for (const tokenTransfer of tokenTransfers) {
              for (const nftTransfer of nftTransfers) {
                  if (
                      tokenTransfer.token != null &&
                      nftTransfer.token != null &&
                      tokenTransfer.token.shardNum ===
                          nftTransfer.token.shardNum &&
                      tokenTransfer.token.realmNum ===
                          nftTransfer.token.realmNum &&
                      tokenTransfer.token.tokenNum === nftTransfer.token.tokenNum
                  ) {
                      tokenTransferLists.push({
                          token: tokenTransfer.token,
                          transfers: tokenTransfer.transfers,
                          nftTransfers: tokenTransfer.nftTransfers,
                      });
                  } else {
                      tokenTransferLists.push(tokenTransfer);
                      tokenTransferLists.push(nftTransfer);
                  }
              }
          }

          const duplicates = this.duplicates.map(
              (record) =>
                  /** @type {HieroProto.proto.ITransactionRecord} */ (
                      record._toProtobuf().transactionRecord
                  ),
          );
          const children = this.children.map(
              (record) =>
                  /** @type {HieroProto.proto.ITransactionRecord} */ (
                      record._toProtobuf().transactionRecord
                  ),
          );

          return {
              duplicateTransactionRecords: duplicates,
              childTransactionRecords: children,
              transactionRecord: {
                  receipt: this.receipt._toProtobuf().receipt,

                  transactionHash:
                      this.transactionHash != null ? this.transactionHash : null,
                  consensusTimestamp:
                      this.consensusTimestamp != null
                          ? this.consensusTimestamp._toProtobuf()
                          : null,
                  transactionID:
                      this.transactionId != null
                          ? this.transactionId._toProtobuf()
                          : null,
                  memo:
                      this.transactionMemo != null ? this.transactionMemo : null,

                  transactionFee:
                      this.transactionFee != null
                          ? this.transactionFee.toTinybars()
                          : null,

                  contractCallResult:
                      this.contractFunctionResult != null &&
                      !this.contractFunctionResult._createResult
                          ? this.contractFunctionResult._toProtobuf()
                          : null,

                  contractCreateResult:
                      this.contractFunctionResult != null &&
                      this.contractFunctionResult._createResult
                          ? this.contractFunctionResult._toProtobuf()
                          : null,

                  transferList:
                      this.transfers != null
                          ? {
                                accountAmounts: this.transfers.map((transfer) =>
                                    transfer._toProtobuf(),
                                ),
                            }
                          : null,
                  tokenTransferLists,
                  scheduleRef:
                      this.scheduleRef != null
                          ? this.scheduleRef._toProtobuf()
                          : null,
                  assessedCustomFees: this.assessedCustomFees.map((fee) =>
                      fee._toProtobuf(),
                  ),
                  automaticTokenAssociations: this.automaticTokenAssociations.map(
                      (association) => association._toProtobuf(),
                  ),
                  parentConsensusTimestamp:
                      this.parentConsensusTimestamp != null
                          ? this.parentConsensusTimestamp._toProtobuf()
                          : null,
                  alias:
                      this.aliasKey != null
                          ? libExports.proto.Key.encode(
                                this.aliasKey._toProtobufKey(),
                            ).finish()
                          : null,
                  ethereumHash: this.ethereumHash,

                  paidStakingRewards: this.paidStakingRewards.map((transfer) =>
                      transfer._toProtobuf(),
                  ),

                  prngBytes: this.prngBytes,
                  prngNumber: this.prngNumber != null ? this.prngNumber : null,
                  evmAddress:
                      this.evmAddress != null ? this.evmAddress.toBytes() : null,
                  newPendingAirdrops: this.newPendingAirdrops.map((airdrop) =>
                      airdrop.toBytes(),
                  ),
              },
          };
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransactionGetRecordResponse} response
       * @returns {TransactionRecord}
       */
      static _fromProtobuf(response) {
          const record = /** @type {HieroProto.proto.ITransactionRecord} */ (
              response.transactionRecord
          );

          let aliasKey =
              record.alias != null && record.alias.length > 0
                  ? Key._fromProtobufKey(
                        libExports.proto.Key.decode(record.alias),
                    )
                  : null;

          if (!(aliasKey instanceof PublicKey)) {
              aliasKey = null;
          }

          const children =
              response.childTransactionRecords != null
                  ? response.childTransactionRecords.map((child) =>
                        TransactionRecord._fromProtobuf({
                            transactionRecord: child,
                        }),
                    )
                  : [];

          const duplicates =
              response.duplicateTransactionRecords != null
                  ? response.duplicateTransactionRecords.map((duplicate) =>
                        TransactionRecord._fromProtobuf({
                            transactionRecord: duplicate,
                        }),
                    )
                  : [];

          const contractFunctionResult =
              record.contractCallResult != null
                  ? ContractFunctionResult._fromProtobuf(
                        record.contractCallResult,
                        false,
                    )
                  : record.contractCreateResult != null
                  ? ContractFunctionResult._fromProtobuf(
                        record.contractCreateResult,
                        true,
                    )
                  : undefined;

          const newPendingAirdrops =
              record.newPendingAirdrops != null
                  ? record.newPendingAirdrops.map((airdrop) =>
                        PendingAirdropRecord.fromBytes(airdrop),
                    )
                  : [];

          return new TransactionRecord({
              receipt: TransactionReceipt._fromProtobuf({
                  receipt: /** @type {HieroProto.proto.ITransactionReceipt} */ (
                      record.receipt
                  ),
              }),
              transactionHash:
                  record.transactionHash != null
                      ? record.transactionHash
                      : new Uint8Array(),
              consensusTimestamp: Timestamp._fromProtobuf(
                  /** @type {HieroProto.proto.ITimestamp} */
                  (record.consensusTimestamp),
              ),
              transactionId: TransactionId._fromProtobuf(
                  /** @type {HieroProto.proto.ITransactionID} */ (
                      record.transactionID
                  ),
              ),
              transactionMemo: record.memo != null ? record.memo : "",
              transactionFee: Hbar.fromTinybars(
                  record.transactionFee != null ? record.transactionFee : 0,
              ),
              transfers: Transfer._fromProtobuf(
                  record.transferList != null
                      ? record.transferList.accountAmounts != null
                          ? record.transferList.accountAmounts
                          : []
                      : [],
              ),
              contractFunctionResult,
              tokenTransfers: TokenTransferMap._fromProtobuf(
                  record.tokenTransferLists != null
                      ? record.tokenTransferLists
                      : [],
              ),
              tokenTransfersList: TokenTransfer._fromProtobuf(
                  record.tokenTransferLists != null
                      ? record.tokenTransferLists
                      : [],
              ),
              scheduleRef:
                  record.scheduleRef != null
                      ? ScheduleId._fromProtobuf(record.scheduleRef)
                      : null,
              assessedCustomFees:
                  record.assessedCustomFees != null
                      ? record.assessedCustomFees.map((fee) =>
                            AssessedCustomFee._fromProtobuf(fee),
                        )
                      : [],
              nftTransfers: TokenNftTransferMap._fromProtobuf(
                  record.tokenTransferLists != null
                      ? record.tokenTransferLists
                      : [],
              ),
              automaticTokenAssociations:
                  record.automaticTokenAssociations != null
                      ? record.automaticTokenAssociations.map((association) =>
                            TokenAssociation._fromProtobuf(association),
                        )
                      : [],
              parentConsensusTimestamp:
                  record.parentConsensusTimestamp != null
                      ? Timestamp._fromProtobuf(record.parentConsensusTimestamp)
                      : null,
              aliasKey,
              duplicates,
              children,
              hbarAllowanceAdjustments: [],
              tokenAllowanceAdjustments: [],
              nftAllowanceAdjustments: [],
              ethereumHash:
                  record.ethereumHash != null ? record.ethereumHash : null,
              paidStakingRewards:
                  record.paidStakingRewards != null
                      ? Transfer._fromProtobuf(record.paidStakingRewards)
                      : [],
              prngBytes: record.prngBytes != null ? record.prngBytes : null,
              prngNumber: record.prngNumber != null ? record.prngNumber : null,
              evmAddress:
                  record.evmAddress != null
                      ? EvmAddress.fromBytes(record.evmAddress)
                      : null,
              newPendingAirdrops: newPendingAirdrops,
          });
      }

      /**
       * @param {Uint8Array} bytes
       * @returns {TransactionRecord}
       */
      static fromBytes(bytes) {
          return TransactionRecord._fromProtobuf(
              libExports.proto.TransactionGetRecordResponse.decode(bytes),
          );
      }

      /**
       * @returns {Uint8Array}
       */
      toBytes() {
          return libExports.proto.TransactionGetRecordResponse.encode(
              this._toProtobuf(),
          ).finish();
      }

      /**
       * @returns {TransactionRecordJSON}
       */
      toJSON() {
          return {
              receipt: this.receipt.toJSON(),
              transactionHash: encode$5(this.transactionHash),
              consensusTimestamp: this.consensusTimestamp.toDate(),
              transactionId: this.transactionId.toString(),
              transactionMemo: this.transactionMemo,
              transactionFee: this.transactionFee.toTinybars().toString(),
              transfers: this.transfers.map((transfer) => transfer.toJSON()),
              tokenTransfers: this.tokenTransfers,
              tokenTransfersList: this.tokenTransfersList.map((transfer) =>
                  transfer.toJSON(),
              ),
              scheduleRef: this.scheduleRef?.toString() || null,
              assessedCustomFees: this.assessedCustomFees,
              nftTransfers: this.nftTransfers,
              automaticTokenAssociations: this.automaticTokenAssociations,
              parentConsensusTimestamp:
                  this.parentConsensusTimestamp?.toDate() || null,
              aliasKey: this.aliasKey?.toString() || null,
              duplicates: this.duplicates,
              children: this.children,
              ethereumHash:
                  this.ethereumHash != null
                      ? encode$5(this.ethereumHash)
                      : null,
              paidStakingRewards: this.paidStakingRewards,
              prngBytes:
                  this.prngBytes != null ? encode$5(this.prngBytes) : null,
              prngNumber: this.prngNumber,
              evmAddress: this.evmAddress?.toString() || null,
          };
      }

      /**
       * @returns {string}
       */
      toString() {
          return JSON.stringify(this.toJSON());
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {import("./Status.js").default} Status
   * @typedef {import("./transaction/TransactionId.js").default} TransactionId
   * @typedef {import("./transaction/TransactionRecord").default} TransactionRecord
   */

  class RecordStatusError extends StatusError {
      /**
       * @param {object} props
       * @param {TransactionRecord} props.transactionRecord
       * @param {Status} props.status
       * @param {TransactionId} props.transactionId
       */
      constructor(props) {
          super(
              props,
              `Record for transaction ${props.transactionId.toString()} contained error status ${props.status.toString()}`,
          );

          /**
           * @type {TransactionRecord}
           * @readonly
           */
          this.transactionRecord = props.transactionRecord;
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  const { proto: proto$5 } = HieroProto;

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("../account/AccountId.js").default} AccountId
   */

  /**
   * Get the record for a transaction.
   * <p>
   * If the transaction requested a record, then the record lasts for one hour, and a state proof is available for it.
   * If the transaction created an account, file, or smart contract instance, then the record will contain the ID for
   * what it created. If the transaction called a smart contract function, then the record contains the result of
   * that call. If the transaction was a cryptocurrency transfer, then the record includes the TransferList
   * which gives the details of that transfer. If the transaction didn't return anything that should be
   * in the record, then the results field will be set to nothing.
   * @augments {Query<TransactionRecord>}
   */
  class TransactionRecordQuery extends Query {
      /**
       * @param {object} [props]
       * @param {TransactionId} [props.transactionId]
       * @param {boolean} [props.includeChildren]
       * @param {boolean} [props.includeDuplicates]
       * @param {boolean} [props.validateReceiptStatus]
       */
      constructor(props = {}) {
          super();

          /**
           * @private
           * @type {?TransactionId}
           */
          this._transactionId = null;

          /**
           * @private
           * @type {?boolean}
           */
          this._includeChildren = null;

          /**
           * @private
           * @type {?boolean}
           */
          this._includeDuplicates = null;

          this._validateReceiptStatus = true;

          if (props.transactionId != null) {
              this.setTransactionId(props.transactionId);
          }

          if (props.includeChildren != null) {
              this.setIncludeChildren(props.includeChildren);
          }

          if (props.includeDuplicates != null) {
              this.setIncludeDuplicates(props.includeDuplicates);
          }

          if (props.validateReceiptStatus != null) {
              this.setValidateReceiptStatus(props.validateReceiptStatus);
          }
      }

      /**
       * @returns {?TransactionId}
       */
      get transactionId() {
          return this._transactionId;
      }

      /**
       * @internal
       * @param {HieroProto.proto.IQuery} query
       * @returns {TransactionRecordQuery}
       */
      static _fromProtobuf(query) {
          const record =
              /** @type {HieroProto.proto.ITransactionGetRecordQuery} */ (
                  query.transactionGetRecord
              );

          return new TransactionRecordQuery({
              transactionId: record.transactionID
                  ? TransactionId._fromProtobuf(record.transactionID)
                  : undefined,
              includeChildren:
                  record.includeChildRecords != null
                      ? record.includeChildRecords
                      : undefined,
              includeDuplicates:
                  record.includeDuplicates != null
                      ? record.includeDuplicates
                      : undefined,
          });
      }

      /**
       * Set the transaction ID for which the record is being requested.
       *
       * @param {TransactionId | string} transactionId
       * @returns {TransactionRecordQuery}
       */
      setTransactionId(transactionId) {
          this._transactionId =
              typeof transactionId === "string"
                  ? TransactionId.fromString(transactionId)
                  : transactionId.clone();

          return this;
      }

      /**
       * @param {boolean} includeChildren
       * @returns {TransactionRecordQuery}
       */
      setIncludeChildren(includeChildren) {
          this._includeChildren = includeChildren;
          return this;
      }

      /**
       * @returns {boolean}
       */
      get includeChildren() {
          return this._includeChildren != null ? this._includeChildren : false;
      }

      /**
       * @param {boolean} includeDuplicates
       * @returns {TransactionRecordQuery}
       */
      setIncludeDuplicates(includeDuplicates) {
          this._duplicates = includeDuplicates;
          return this;
      }

      /**
       * @returns {boolean}
       */
      get includeDuplicates() {
          return this._duplicates != null ? this._duplicates : false;
      }

      /**
       * @param {boolean} validateReceiptStatus
       * @returns {this}
       */
      setValidateReceiptStatus(validateReceiptStatus) {
          this._validateReceiptStatus = validateReceiptStatus;
          return this;
      }

      /**
       * @returns {boolean}
       */
      get validateReceiptStatus() {
          return this._validateReceiptStatus;
      }

      /**
       * @override
       * @internal
       * @param {HieroProto.proto.IQuery} request
       * @param {HieroProto.proto.IResponse} response
       * @returns {[Status, ExecutionState]}
       */
      _shouldRetry(request, response) {
          const { nodeTransactionPrecheckCode } =
              this._mapResponseHeader(response);

          let status = Status._fromCode(
              nodeTransactionPrecheckCode != null
                  ? nodeTransactionPrecheckCode
                  : proto$5.ResponseCodeEnum.OK,
          );

          if (this._logger) {
              this._logger.debug(
                  `[${this._getLogId()}] received node precheck status ${status.toString()}`,
              );
          }

          switch (status) {
              case Status.Busy:
              case Status.Unknown:
              case Status.ReceiptNotFound:
              case Status.RecordNotFound:
              case Status.PlatformNotActive:
                  return [status, ExecutionState.Retry];

              case Status.Ok:
                  break;

              default:
                  return [status, ExecutionState.Error];
          }

          const transactionGetRecord =
              /** @type {HieroProto.proto.ITransactionGetRecordResponse} */ (
                  response.transactionGetRecord
              );
          const header = /** @type {HieroProto.proto.IResponseHeader} */ (
              transactionGetRecord.header
          );

          if (header.responseType === libExports.proto.ResponseType.COST_ANSWER) {
              return [status, ExecutionState.Finished];
          }

          const record = /** @type {HieroProto.proto.ITransactionRecord} */ (
              transactionGetRecord.transactionRecord
          );
          const receipt = /** @type {HieroProto.proto.ITransactionReceipt} */ (
              record.receipt
          );
          const receiptStatusCode =
              /** @type {HieroProto.proto.ResponseCodeEnum} */ (receipt.status);
          status = Status._fromCode(receiptStatusCode);

          if (this._logger) {
              this._logger.debug(
                  `[${this._getLogId()}] received record's receipt ${status.toString()}`,
              );
          }

          switch (status) {
              case Status.Ok:
              case Status.Busy:
              case Status.Unknown:
              case Status.ReceiptNotFound:
              case Status.RecordNotFound:
                  return [status, ExecutionState.Retry];

              case Status.Success:
                  return [status, ExecutionState.Finished];

              default:
                  return [
                      status,
                      this._validateReceiptStatus
                          ? ExecutionState.Error
                          : ExecutionState.Finished,
                  ];
          }
      }

      /**
       * @override
       * @internal
       * @param {HieroProto.proto.IQuery} request
       * @param {HieroProto.proto.IResponse} response
       * @param {AccountId} nodeId
       * @returns {Error}
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _mapStatusError(request, response, nodeId) {
          const { nodeTransactionPrecheckCode } =
              this._mapResponseHeader(response);

          let status = Status._fromCode(
              nodeTransactionPrecheckCode != null
                  ? nodeTransactionPrecheckCode
                  : proto$5.ResponseCodeEnum.OK,
          );
          switch (status) {
              case Status.Ok:
                  // Do nothing
                  break;

              case Status.ContractRevertExecuted:
                  return new RecordStatusError({
                      status,
                      transactionId: this._getTransactionId(),
                      transactionRecord: TransactionRecord._fromProtobuf({
                          transactionRecord:
                              // @ts-ignore
                              response.transactionGetRecord.transactionRecord,
                      }),
                  });

              default:
                  return new PrecheckStatusError({
                      nodeId,
                      status,
                      transactionId: this._getTransactionId(),
                      contractFunctionResult: null,
                  });
          }

          const transactionGetRecord =
              /** @type {HieroProto.proto.ITransactionGetRecordResponse} */ (
                  response.transactionGetRecord
              );
          const record = /** @type {HieroProto.proto.ITransactionRecord} */ (
              transactionGetRecord.transactionRecord
          );
          const receipt = /** @type {HieroProto.proto.ITransactionReceipt} */ (
              record.receipt
          );
          const receiptStatusError =
              /** @type {HieroProto.proto.ResponseCodeEnum} */ (receipt.status);

          status = Status._fromCode(receiptStatusError);

          switch (status) {
              case Status.ContractRevertExecuted:
                  return new RecordStatusError({
                      status,
                      transactionId: this._getTransactionId(),
                      transactionRecord: TransactionRecord._fromProtobuf({
                          transactionRecord:
                              // @ts-ignore
                              response.transactionGetRecord.transactionRecord,
                      }),
                  });

              default:
                  return new ReceiptStatusError({
                      status,
                      transactionId: this._getTransactionId(),
                      transactionReceipt: TransactionReceipt._fromProtobuf({
                          receipt,
                      }),
                  });
          }
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          if (
              this._transactionId != null &&
              this._transactionId.accountId != null
          ) {
              this._transactionId.accountId.validateChecksum(client);
          }
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.IQuery} request
       * @returns {Promise<HieroProto.proto.IResponse>}
       */
      _execute(channel, request) {
          return channel.crypto.getTxRecordByTxID(request);
      }

      /**
       * @override
       * @override
       * @internal
       * @param {HieroProto.proto.IResponse} response
       * @returns {HieroProto.proto.IResponseHeader}
       */
      _mapResponseHeader(response) {
          const transactionGetRecord =
              /** @type {HieroProto.proto.ITransactionGetRecordResponse} */ (
                  response.transactionGetRecord
              );
          return /** @type {HieroProto.proto.IResponseHeader} */ (
              transactionGetRecord.header
          );
      }

      /**
       * @override
       * @internal
       * @param {HieroProto.proto.IResponse} response
       * @param {AccountId} nodeAccountId
       * @param {HieroProto.proto.IQuery} request
       * @returns {Promise<TransactionRecord>}
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _mapResponse(response, nodeAccountId, request) {
          const record =
              /** @type {HieroProto.proto.ITransactionGetRecordResponse} */ (
                  response.transactionGetRecord
              );
          return Promise.resolve(TransactionRecord._fromProtobuf(record));
      }

      /**
       * @override
       * @internal
       * @param {HieroProto.proto.IQueryHeader} header
       * @returns {HieroProto.proto.IQuery}
       */
      _onMakeRequest(header) {
          return {
              transactionGetRecord: {
                  header,
                  transactionID:
                      this._transactionId != null
                          ? this._transactionId._toProtobuf()
                          : null,
                  includeChildRecords: this._includeChildren,
                  includeDuplicates: this._includeDuplicates,
              },
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp =
              this._paymentTransactionId != null &&
              this._paymentTransactionId.validStart != null
                  ? this._paymentTransactionId.validStart
                  : this._timestamp;

          return `TransactionRecordQuery:${timestamp.toString()}`;
      }
  }

  QUERY_REGISTRY.set(
      "transactionGetRecord",
      // eslint-disable-next-line @typescript-eslint/unbound-method
      TransactionRecordQuery._fromProtobuf,
  );

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("./Transaction.js").default} Transaction
   * @typedef {import("./TransactionReceipt.js").default} TransactionReceipt
   * @typedef {import("./TransactionRecord.js").default} TransactionRecord
   * @typedef {import("../Signer.js").Signer} Signer
   * @typedef {import("../logger/Logger.js").default} Logger
   */

  /**
   * @typedef {object} TransactionResponseJSON
   * @property {string} nodeId
   * @property {string} transactionHash
   * @property {string} transactionId
   */

  /**
   * When the client sends the node a transaction of any kind, the node
   * replies with this, which simply says that the transaction passed
   * the pre-check (so the node will submit it to the network) or it failed
   * (so it won't). To learn the consensus result, the client should later
   * obtain a receipt (free), or can buy a more detailed record (not free).
   * <br>
   * See <a href="https://docs.hedera.com/guides/docs/hedera-api/miscellaneous/transactionresponse">Hedera Documentation</a>
   */
  class TransactionResponse {
      /**
       * @internal
       * @param {object} props
       * @param {AccountId} props.nodeId
       * @param {Uint8Array} props.transactionHash
       * @param {TransactionId} props.transactionId
       * @param {Transaction} [props.transaction]
       * @param {Logger | null} [props.logger]
       */
      constructor(props) {
          /** @readonly */
          this.nodeId = props.nodeId;

          /** @readonly */
          this.transactionHash = props.transactionHash;

          this.transactionId = props.transactionId;

          this.transaction = props.transaction;

          this.logger = props.logger;
      }

      /**
       * @param {TransactionResponseJSON} json
       * @returns {TransactionResponse}
       */
      static fromJSON(json) {
          return new TransactionResponse({
              nodeId: AccountId.fromString(json.nodeId),
              transactionHash: decode$8(json.transactionHash),
              transactionId: TransactionId.fromString(json.transactionId),
          });
      }

      /**
       * @param {Client} client
       * @returns {Promise<TransactionReceipt>}
       */
      async getReceipt(client) {
          let receipt;
          try {
              receipt = await this.getReceiptQuery().execute(client);
          } catch (err) {
              if (
                  err instanceof ReceiptStatusError &&
                  err.status === Status.ThrottledAtConsensus
              ) {
                  this.logger?.info("Transaction throttled at consensus");
                  // need to reset the transaction to its initial state before retrying
                  return this._retryTransaction(client);
              }
              throw err;
          }

          if (
              receipt.status !== Status.Success &&
              receipt.status !== Status.FeeScheduleFilePartUploaded
          ) {
              throw new ReceiptStatusError({
                  transactionReceipt: receipt,
                  status: receipt.status,
                  transactionId: this.transactionId,
              });
          }

          return receipt;
      }

      /**
       * getRecord is calling getReceipt and in case the receipt status code is not OK, only the receipt is returned.
       *
       * @param {Client} client
       * @returns {Promise<TransactionRecord>}
       */
      async getRecord(client) {
          await this.getReceipt(client);

          return this.getRecordQuery().execute(client);
      }

      /**
       * getVerboseRecord is calling getReceipt and in case the receipt status code is not OK, the record is returned.
       *
       * @param {Client} client
       * @returns {Promise<TransactionRecord>}
       */
      async getVerboseRecord(client) {
          try {
              // The receipt needs to be called in order to wait for transaction to be included in the consensus. Otherwise we are going to get "DUPLICATE_TRANSACTION".
              await this.getReceiptQuery().execute(client);
              return this.getRecordQuery().execute(client);
          } catch (e) {
              return this.getRecordQuery().execute(client);
          }
      }

      /**
       * @param {Signer} signer
       * @returns {Promise<TransactionReceipt>}
       */
      async getReceiptWithSigner(signer) {
          const receipt = await this.getReceiptQuery().executeWithSigner(signer);

          if (receipt.status !== Status.Success) {
              throw new ReceiptStatusError({
                  transactionReceipt: receipt,
                  status: receipt.status,
                  transactionId: this.transactionId,
              });
          }

          return receipt;
      }

      /**
       * @param {Signer} signer
       * @returns {Promise<TransactionRecord>}
       */
      async getRecordWithSigner(signer) {
          await this.getReceiptWithSigner(signer);

          return this.getRecordQuery().executeWithSigner(signer);
      }

      /**
       * @returns {TransactionReceiptQuery}
       */
      getReceiptQuery() {
          return new TransactionReceiptQuery()
              .setTransactionId(this.transactionId)
              .setNodeAccountIds([this.nodeId]);
      }

      /**
       * @returns {TransactionRecordQuery}
       */
      getRecordQuery() {
          return new TransactionRecordQuery()
              .setTransactionId(this.transactionId)
              .setNodeAccountIds([this.nodeId]);
      }

      /**
       * @returns {TransactionResponseJSON}
       */
      toJSON() {
          return {
              nodeId: this.nodeId.toString(),
              transactionHash: encode$5(this.transactionHash),
              transactionId: this.transactionId.toString(),
          };
      }

      /**
       *
       * @param {Client} client
       * @returns {Promise<TransactionReceipt>}
       */
      async _retryTransaction(client) {
          if (!this.transaction) {
              throw new Error(
                  "If you retry transaction you should have the transaction set",
              );
          }

          if (
              client.operatorAccountId?.toString() !==
              this.transaction.transactionId?.accountId?.toString()
          ) {
              throw new Error(
                  "Retry mechanism is not supported when tx id is not generated by the operator account",
              );
          }

          if (client.operatorAccountId === null) {
              throw new Error("Operator account is not set");
          }

          const MAX_RETRIES = 5;
          const MAX_BACKOFF = 16000;
          let BACKOFF = 250; // milliseconds

          for (let i = 0; i < MAX_RETRIES; i++) {
              this.logger?.trace(`Transaction throttled, retry attempt ${i}`);
              this.transaction?._resetTransaction(client);
              if (
                  this.transaction == null ||
                  this.transaction.transactionId == null
              ) {
                  throw new Error(
                      "Transaction or Transaction ID is null after reset",
                  );
              }
              // need to set the transactionId again in case we are doing getRecord afterwards
              this.transactionId = this.transaction.transactionId;
              if (i > 0) {
                  // Wait with exponential backoff before retrying
                  await wait(Math.min(BACKOFF, MAX_BACKOFF));
                  BACKOFF *= 2; // Double the backoff for next retry
              }

              try {
                  this.transaction._resetTransaction(client);
                  const resp = await this.transaction.execute(client);

                  const receipt = await new TransactionReceiptQuery()
                      .setTransactionId(resp.transactionId)
                      .setNodeAccountIds([resp.nodeId])
                      .execute(client);

                  if (receipt.status !== Status.ThrottledAtConsensus) {
                      this.logger?.info(
                          `Transaction throttle retry succeeded after attempt ${i}`,
                      );
                      return receipt;
                  }
              } catch (err) {
                  if (
                      err instanceof ReceiptStatusError &&
                      err.status === Status.ThrottledAtConsensus
                  ) {
                      this.logger?.info("Transaction throttled at consensus");
                      // Continue to next retry on error
                      continue;
                  }
                  this.logger?.error(
                      `An error occurred after throttle retry: ${
                        err instanceof Error ? err.message : String(err)
                    }`,
                  );
                  throw err;
              }
          }

          this.logger?.error(
              "Transaction throttle retry failed after maximum attempts",
          );
          throw new Error("Transaction retry failed after maximum attempts");
      }

      /**
       * @returns {string}
       */
      toString() {
          return JSON.stringify(this.toJSON());
      }
  }

  // SPDX-License-Identifier: Apache-2.0

  /**
   * @param {Uint8Array} data
   * @returns {Promise<Uint8Array>}
   */
  async function digest(data) {
      // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest
      // This will be executed in a browser environment so the crypto object should be available if its
      // in secure context.
      // eslint-disable-next-line n/no-unsupported-features/node-builtins
      return new Uint8Array(await window.crypto.subtle.digest("SHA-384", data));
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   */

  /**
   * @augments {ObjectMap<AccountId, Uint8Array>}
   */
  class TransactionHashMap extends ObjectMap {
      constructor() {
          super((s) => AccountId.fromString(s));
      }

      /**
       * @param {import("./Transaction.js").default} transaction
       * @returns {Promise<TransactionHashMap>}
       */
      static async _fromTransaction(transaction) {
          const hashes = new TransactionHashMap();

          for (let i = 0; i < transaction._nodeAccountIds.length; i++) {
              const nodeAccountId = transaction._nodeAccountIds.list[i];
              const tx = /** @type {HieroProto.proto.ITransaction} */ (
                  transaction._transactions.get(i)
              );
              const hash = await digest(
                  /** @type {Uint8Array} */ (tx.signedTransactionBytes),
              );

              hashes._set(nodeAccountId, hash);
          }

          return hashes;
      }
  }

  /**
   * @deprecated
   * @augments {ObjectMap<PublicKey, Uint8Array>}
   */
  class NodeAccountIdSignatureMap extends ObjectMap {
      constructor() {
          super((s) => PublicKey.fromString(s));
      }

      /**
       * @param {import("@hashgraph/proto").proto.ISignatureMap} sigMap
       * @returns {NodeAccountIdSignatureMap}
       */
      static _fromTransactionSigMap(sigMap) {
          // eslint-disable-next-line deprecation/deprecation
          const signatures = new NodeAccountIdSignatureMap();
          const sigPairs = sigMap.sigPair != null ? sigMap.sigPair : [];

          for (const sigPair of sigPairs) {
              if (sigPair.pubKeyPrefix != null) {
                  if (sigPair.ed25519 != null) {
                      signatures._set(
                          PublicKey.fromBytesED25519(sigPair.pubKeyPrefix),
                          sigPair.ed25519,
                      );
                  } else if (sigPair.ECDSASecp256k1 != null) {
                      signatures._set(
                          PublicKey.fromBytesECDSA(sigPair.pubKeyPrefix),

                          sigPair.ECDSASecp256k1,
                      );
                  }
              }
          }

          return signatures;
      }
  }

  /* eslint-disable deprecation/deprecation */

  /**
   * @deprecated
   * @augments {ObjectMap<AccountId, NodeAccountIdSignatureMapLegacy>}
   */
  class SignatureMap extends ObjectMap {
      constructor() {
          super((s) => AccountId.fromString(s));
      }

      /**
       * @param {import("./Transaction.js").default} transaction
       * @returns {SignatureMap}
       */
      static _fromTransaction(transaction) {
          const signatures = new SignatureMap();

          for (let i = 0; i < transaction._nodeAccountIds.length; i++) {
              const sigMap = transaction._signedTransactions.get(i).sigMap;

              if (sigMap != null) {
                  signatures._set(
                      transaction._nodeAccountIds.list[i],
                      NodeAccountIdSignatureMap._fromTransactionSigMap(
                          sigMap,
                      ),
                  );
              }
          }

          return signatures;
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ICustomFee} HieroProto.proto.ICustomFee
   */

  class CustomFee {
      /**
       * @param {object} props
       * @param {AccountId | string} [props.feeCollectorAccountId]
       * @param {boolean} [props.allCollectorsAreExempt]
       */
      constructor(props = {}) {
          /**
           * @type {?AccountId}
           */
          this._feeCollectorAccountId = null;

          this._allCollectorsAreExempt = false;

          if (props.feeCollectorAccountId != null) {
              this.setFeeCollectorAccountId(props.feeCollectorAccountId);
          }

          if (props.allCollectorsAreExempt != null) {
              this.setAllCollectorsAreExempt(props.allCollectorsAreExempt);
          }
      }

      /**
       * @returns {?AccountId}
       */
      get feeCollectorAccountId() {
          return this._feeCollectorAccountId;
      }

      /**
       * @param {AccountId | string} feeCollectorAccountId
       * @returns {this}
       */
      setFeeCollectorAccountId(feeCollectorAccountId) {
          this._feeCollectorAccountId =
              typeof feeCollectorAccountId === "string"
                  ? AccountId.fromString(feeCollectorAccountId)
                  : feeCollectorAccountId;
          return this;
      }

      /**
       * @returns {boolean}
       */
      get allCollectorsAreExempt() {
          return this._allCollectorsAreExempt;
      }

      /**
       * @param {boolean} allCollectorsAreExempt
       * @returns {this}
       */
      setAllCollectorsAreExempt(allCollectorsAreExempt) {
          this._allCollectorsAreExempt = allCollectorsAreExempt;
          return this;
      }

      /**
       * @internal
       * @abstract
       * @param {HieroProto.proto.ICustomFee} info
       * @returns {CustomFee}
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      static _fromProtobuf(info) {
          throw new Error("not implemented");
      }

      /**
       * @internal
       * @abstract
       * @returns {HieroProto.proto.ICustomFee}
       */
      _toProtobuf() {
          throw new Error("not implemented");
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {import("bignumber.js").default} BigNumber
   */

  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ICustomFee} HieroProto.proto.ICustomFee
   * @typedef {import("@hashgraph/proto").proto.IFixedFee} HieroProto.proto.IFixedFee
   * @typedef {import("@hashgraph/proto").proto.IFixedCustomFee} HieroProto.proto.IFixedCustomFee
   */

  class CustomFixedFee extends CustomFee {
      /**
       * @param {object} props
       * @param {AccountId | string} [props.feeCollectorAccountId]
       * @param {boolean} [props.allCollectorsAreExempt]
       * @param {TokenId | string} [props.denominatingTokenId]
       * @param {Long | number | BigNumber | bigint} [props.amount]
       */
      constructor(props = {}) {
          super(props);

          /**
           * @type {?TokenId}
           */
          this._denominatingTokenId = null;

          if (props.denominatingTokenId != null) {
              this.setDenominatingTokenId(props.denominatingTokenId);
          }

          /**
           * @type {?Long}
           */
          this._amount = null;

          if (props.amount != null) {
              this.setAmount(props.amount);
          }
      }

      /**
       * @param {Hbar} amount
       * @returns {CustomFixedFee}
       */
      setHbarAmount(amount) {
          this._amount = amount.toTinybars();
          this._denominatingTokenId = null;
          return this;
      }

      /**
       * @returns {TokenId | Hbar | null}
       */
      get hbarAmount() {
          return this._denominatingTokenId != null
              ? null
              : Hbar.fromTinybars(this._amount != null ? this._amount : 0);
      }

      /**
       * @returns {CustomFixedFee}
       */
      setDenominatingTokenToSameToken() {
          this._denominatingTokenId = new TokenId(0, 0, 0);
          return this;
      }

      /**
       * @returns {?TokenId}
       */
      get denominatingTokenId() {
          return this._denominatingTokenId;
      }

      /**
       * @param {TokenId | string} denominatingTokenId
       * @returns {CustomFixedFee}
       */
      setDenominatingTokenId(denominatingTokenId) {
          this._denominatingTokenId =
              typeof denominatingTokenId === "string"
                  ? TokenId.fromString(denominatingTokenId)
                  : denominatingTokenId;
          return this;
      }

      /**
       * @returns {?Long}
       */
      get amount() {
          return this._amount;
      }

      /**
       * @param {Long | number | BigNumber | bigint} amount
       * @returns {CustomFixedFee}
       */
      setAmount(amount) {
          this._amount = convertAmountToLong(amount);
          return this;
      }

      /**
       * @internal
       * @override
       * @param {HieroProto.proto.ICustomFee} info
       * @returns {CustomFixedFee}
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      static _fromProtobuf(info) {
          const fee = /** @type {HieroProto.proto.IFixedFee} */ (info.fixedFee);

          return new CustomFixedFee({
              feeCollectorAccountId:
                  info.feeCollectorAccountId != null
                      ? AccountId._fromProtobuf(info.feeCollectorAccountId)
                      : undefined,
              allCollectorsAreExempt:
                  info.allCollectorsAreExempt != null
                      ? info.allCollectorsAreExempt
                      : undefined,
              denominatingTokenId:
                  fee.denominatingTokenId != null
                      ? TokenId._fromProtobuf(fee.denominatingTokenId)
                      : undefined,
              amount: fee.amount != null ? fee.amount : undefined,
          });
      }

      /**
       * @internal
       * @abstract
       * @returns {HieroProto.proto.ICustomFee}
       */
      _toProtobuf() {
          return {
              feeCollectorAccountId:
                  this.feeCollectorAccountId != null
                      ? this.feeCollectorAccountId._toProtobuf()
                      : null,
              allCollectorsAreExempt: this.allCollectorsAreExempt,
              fixedFee: {
                  denominatingTokenId:
                      this._denominatingTokenId != null
                          ? this._denominatingTokenId._toProtobuf()
                          : null,
                  amount: this._amount,
              },
          };
      }

      /**
       * @internal
       * @abstract
       * @returns {HieroProto.proto.IFixedCustomFee}
       */
      _toTopicFeeProtobuf() {
          return {
              feeCollectorAccountId:
                  this.feeCollectorAccountId != null
                      ? this.feeCollectorAccountId._toProtobuf()
                      : null,
              fixedFee: {
                  denominatingTokenId:
                      this._denominatingTokenId != null
                          ? this._denominatingTokenId._toProtobuf()
                          : null,
                  amount: this._amount,
              },
          };
      }
  }

  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.IFixedFee} HieroProto.proto.IFixedFee
   * @typedef {import("@hashgraph/proto").proto.ICustomFeeLimit} HieroProto.proto.ICustomFeeLimit
   */

  class CustomFeeLimit {
      /**
       *
       * @param {object} props
       * @param {?AccountId | string} [props.accountId]
       * @param {?CustomFixedFee[]} [props.fees]
       */
      constructor(props = {}) {
          /**
           * @type {?AccountId}
           */
          this._accountId = null;

          if (props.accountId) {
              this.setAccountId(props.accountId);
          }

          /**
           * @type {?CustomFixedFee[]}
           */
          this._fees = null;

          if (props.fees) {
              this.setFees(props.fees);
          }
      }

      /**
       * @static
       * @param {HieroProto.proto.ICustomFeeLimit} customFeeLimit
       * @returns {CustomFeeLimit}
       */
      static _fromProtobuf(customFeeLimit) {
          return new CustomFeeLimit({
              accountId:
                  customFeeLimit.accountId != null
                      ? AccountId._fromProtobuf(customFeeLimit.accountId)
                      : null,
              fees:
                  customFeeLimit.fees != null
                      ? customFeeLimit.fees.map((fixedFee) => {
                            return CustomFixedFee._fromProtobuf({
                                fixedFee: fixedFee,
                            });
                        })
                      : null,
          });
      }

      /**
       * @returns {?AccountId}
       */
      getAccountId() {
          return this._accountId;
      }

      /**
       *
       * @param {AccountId | string} accountId
       * @returns {this}
       */
      setAccountId(accountId) {
          if (accountId instanceof AccountId) {
              this._accountId = accountId;
          } else {
              this._accountId = AccountId.fromString(accountId);
          }
          return this;
      }

      /**
       * @returns {?CustomFixedFee[]}
       */
      getFees() {
          return this._fees;
      }

      /**
       *
       * @param {CustomFixedFee[]} fees
       * @returns {this}
       */
      setFees(fees) {
          this._fees = fees;

          return this;
      }

      /**
       *
       * @returns {HieroProto.proto.ICustomFeeLimit}
       */
      _toProtobuf() {
          /** @type {HieroProto.proto.IFixedFee[]} */
          const protoFixedFees = [];

          if (this._fees != null) {
              this._fees.forEach((fixedFee) => {
                  const fixedFeeProto = fixedFee._toProtobuf();
                  if (fixedFeeProto.fixedFee != null) {
                      protoFixedFees.push(fixedFeeProto.fixedFee);
                  }
              });
          }

          return {
              accountId:
                  this._accountId != null ? this._accountId._toProtobuf() : null,
              fees: protoFixedFees,
          };
      }
  }

  /**
   * @typedef {import("../account/AccountId").default} AccountId
   * @typedef {import("../transaction/TransactionId").default} TransactionId
   */

  /**
   * Represents a transaction body that is ready for signing, associated with a specific node account and transaction identifier.
   * @property {AccountId} nodeAccountId - The account ID of the node.
   * @property {TransactionId} transactionId - The transactionId of the transaction, (when dealing with a chunked transaction, this is the transactionId of the chunk).
   * @property {Uint8Array} signableTransactionBodyBytes - The transaction body bytes ready for signing.
   */
  class SignableNodeTransactionBodyBytes {
      /**
       * Creates a new instance of NodeSignableTransaction.
       *
       * @param {AccountId} nodeAccountId - The account ID of the node.
       * @param {TransactionId} transactionId - The transactionId of the transaction.
       * @param {Uint8Array} signableTransactionBodyBytes - The transaction body bytes ready for signing.
       */
      constructor(nodeAccountId, transactionId, signableTransactionBodyBytes) {
          /**
           * The node account identifier associated with the transaction.
           * @type {AccountId}
           */
          this.nodeAccountId = nodeAccountId;

          /**
           * The transactionId identifier.
           * Note: When dealing with a chunked transaction, this is the transactionId of the chunk.
           * @type {TransactionId}
           */
          this.transactionId = transactionId;

          /**
           * The bytes of the transaction body, ready to be signed.
           * @type {Uint8Array}
           */
          this.signableTransactionBodyBytes = signableTransactionBodyBytes;
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {import("bignumber.js").default} BigNumber
   */

  /**
   * @typedef {import("../schedule/ScheduleCreateTransaction.js").default} ScheduleCreateTransaction
   * @typedef {import("../PrivateKey.js").default} PrivateKey
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("../Signer.js").Signer} Signer
   */

  // 90 days (in seconds)
  const DEFAULT_AUTO_RENEW_PERIOD = Long.fromValue(7776000);

  // maximum value of i64 (so there is never a record generated)
  const DEFAULT_RECORD_THRESHOLD = Hbar.fromTinybars(
      Long.fromString("9223372036854775807"),
  );

  /**
   * Node account ID used for batch transactions
   * @type {AccountId}
   */
  // @ts-ignore
  const NODE_ACCOUNT_BATCH_ID = new AccountId(0, 0, 0);

  // 120 seconds
  const DEFAULT_TRANSACTION_VALID_DURATION = 120;

  // The default message chunk size in bytes when splitting a given message.
  // This value can be overriden using `setChunkSize` when preparing to submit a messsage via `TopicMessageSubmitTransaction`.
  const CHUNK_SIZE = 1024;

  /**
   * @type {Map<NonNullable<HieroProto.proto.TransactionBody["data"]>, (transactions: HieroProto.proto.ITransaction[], signedTransactions: HieroProto.proto.ISignedTransaction[], transactionIds: TransactionId[], nodeIds: AccountId[], bodies: HieroProto.proto.TransactionBody[]) => Transaction>}
   */
  const TRANSACTION_REGISTRY = new Map();

  /**
   * Base class for all transactions that may be submitted to Hedera.
   *
   * @abstract
   * @augments {Executable<HieroProto.proto.ITransaction, HieroProto.proto.ITransactionResponse, TransactionResponse>}
   */
  class Transaction extends Executable {
      // A SDK transaction is composed of multiple, raw protobuf transactions.
      // These should be functionally identical, with the exception of pointing to
      // different nodes.

      // When retrying a transaction after a network error or retry-able
      // status response, we try a different transaction and thus a different node.

      constructor() {
          super();

          /**
           * List of proto transactions that have been built from this SDK
           * transaction.
           *
           * This is a 2-D array built into one, meaning to
           * get to the next row you'd index into this array `row * rowLength + column`
           * where `rowLength` is `nodeAccountIds.length`
           *
           * @internal
           * @type {List<HieroProto.proto.ITransaction | null>}
           */
          this._transactions = new List();

          /**
           * List of proto transactions that have been built from this SDK
           * transaction.
           *
           * This is a 2-D array built into one, meaning to
           * get to the next row you'd index into this array `row * rowLength + column`
           * where `rowLength` is `nodeAccountIds.length`
           *
           * @internal
           * @type {List<HieroProto.proto.ISignedTransaction>}
           */
          this._signedTransactions = new List();

          /**
           * Set of public keys (as string) who have signed this transaction so
           * we do not allow them to sign it again.
           *
           * @internal
           * @type {Set<string>}
           */
          this._signerPublicKeys = new Set();

          /**
           * The transaction valid duration
           *
           * @private
           * @type {number}
           */
          this._transactionValidDuration = DEFAULT_TRANSACTION_VALID_DURATION;

          /**
           * The default max transaction fee for this particular transaction type.
           * Most transactions use the default of 2 Hbars, but some requests such
           * as `TokenCreateTransaction` need to use a different default value.
           *
           * @protected
           * @type {Hbar}
           */
          this._defaultMaxTransactionFee = new Hbar(2);

          /**
           * The maximum custom fee that the user is willing to pay for the message. If left empty, the user is willing to pay any custom fee.
           * If used with a transaction type that does not support custom fee limits, the transaction will fail.
           * @type {CustomFeeLimit[]}
           */
          this._customFeeLimits = [];

          /**
           * The max transaction fee on the request. This field is what users are able
           * to set, not the `defaultMaxTransactionFee`. The purpose of this field is
           * to allow us to determine if the user set the field explicitly, or if we're
           * using the default max transation fee for the request.
           *
           * @private
           * @type {Hbar | null}
           */
          this._maxTransactionFee = null;

          /**
           * The transaction's memo
           *
           * @private
           * @type {string}
           */
          this._transactionMemo = "";

          /**
           * The list of transaction IDs. This list will almost always be of length 1.
           * The only time this list will be a different length is for chunked transactions.
           * The only two chunked transactions supported right now are `FileAppendTransaction`
           * and `TopicMessageSubmitTransaction`
           *
           * @protected
           * @type {List<TransactionId>}
           */
          this._transactionIds = new List();

          /**
           * A list of public keys that will be added to the requests signatures
           *
           * @private
           * @type {PublicKey[]}
           */
          this._publicKeys = [];

          /**
           * The list of signing function 1-1 with `_publicKeys` which sign the request.
           * The reason this list allows `null` is because if we go from bytes into
           * a transaction, then we know the public key, but we don't have the signing function.
           *
           * @private
           * @type {(((message: Uint8Array) => Promise<Uint8Array>) | null)[]}
           */
          this._transactionSigners = [];

          /**
           * Determine if we should regenerate transaction IDs when we receive `TRANSACITON_EXPIRED`
           *
           * @private
           * @type {?boolean}
           */
          this._regenerateTransactionId = null;

          /**
           * The key used to sign the batch transaction
           *
           * @private
           * @type {Key | null}
           */
          this._batchKey = null;

          /**
           * Whether the transaction is throttled
           *
           * @private
           * @type {boolean}
           */
          this._isThrottled = false;
      }

      /**
       * Deserialize a transaction from bytes. The bytes can either be a `proto.Transaction` or
       * `proto.TransactionList`.
       *
       * @param {Uint8Array} bytes
       * @returns {Transaction}
       */
      static fromBytes(bytes) {
          /** @type {HieroProto.proto.ISignedTransaction[]} */
          const signedTransactions = [];

          /** @type {TransactionId[]} */
          const transactionIds = [];

          /** @type {AccountId[]} */
          const nodeIds = [];

          /** @type {string[]} */
          const transactionIdStrings = [];

          /** @type {string[]} */
          const nodeIdStrings = [];

          /** @type {HieroProto.proto.TransactionBody[]} */
          const bodies = [];

          const list =
              libExports.proto.TransactionList.decode(bytes).transactionList;

          // If the list is of length 0, then teh bytes provided were not a
          // `proto.TransactionList`
          //
          // FIXME: We should also check to make sure the bytes length is greater than
          // 0 otherwise this check is wrong?
          if (list.length === 0) {
              const transaction = libExports.proto.Transaction.decode(bytes);

              // We support `Transaction.signedTransactionBytes` and
              // `Transaction.bodyBytes` + `Transaction.sigMap`. If the bytes represent the
              // latter, convert them into `signedTransactionBytes`
              if (transaction.signedTransactionBytes.length !== 0) {
                  list.push(transaction);
              } else {
                  list.push({
                      signedTransactionBytes:
                          libExports.proto.SignedTransaction.encode({
                              sigMap: transaction.sigMap,
                              bodyBytes: transaction.bodyBytes,
                          }).finish(),
                  });
              }
          }

          // This loop is responsible for fill out the `signedTransactions`, `transactionIds`,
          // `nodeIds`, and `bodies` variables.
          for (const transaction of list) {
              // The `bodyBytes` or `signedTransactionBytes` should not be null
              if (
                  transaction.bodyBytes == null &&
                  transaction.signedTransactionBytes == null
              ) {
                  throw new Error(
                      "bodyBytes and signedTransactionBytes are null",
                  );
              }

              if (transaction.bodyBytes && transaction.bodyBytes.length != 0) {
                  // Decode a transaction
                  const body = libExports.proto.TransactionBody.decode(
                      transaction.bodyBytes,
                  );

                  // Make sure the transaction ID within the body is set
                  if (body.transactionID != null) {
                      const transactionId = TransactionId._fromProtobuf(
                          /** @type {HieroProto.proto.ITransactionID} */ (
                              body.transactionID
                          ),
                      );

                      // If we haven't already seen this transaction ID in the list, add it
                      if (
                          !transactionIdStrings.includes(transactionId.toString())
                      ) {
                          transactionIds.push(transactionId);
                          transactionIdStrings.push(transactionId.toString());
                      }
                  }

                  // Make sure the node account ID within the body is set
                  if (body.nodeAccountID != null) {
                      const nodeAccountId = AccountId._fromProtobuf(
                          /** @type {HieroProto.proto.IAccountID} */ (
                              body.nodeAccountID
                          ),
                      );

                      // If we haven't already seen this node account ID in the list, add it
                      if (!nodeIdStrings.includes(nodeAccountId.toString())) {
                          nodeIds.push(nodeAccountId);
                          nodeIdStrings.push(nodeAccountId.toString());
                      }
                  }

                  // Make sure the body is set
                  if (body.data == null) {
                      throw new Error(
                          "(BUG) body.data was not set in the protobuf",
                      );
                  }

                  bodies.push(body);
              }

              if (
                  transaction.signedTransactionBytes &&
                  transaction.signedTransactionBytes.length != 0
              ) {
                  // Decode a signed transaction
                  const signedTransaction =
                      libExports.proto.SignedTransaction.decode(
                          transaction.signedTransactionBytes,
                      );

                  signedTransactions.push(signedTransaction);

                  // Decode a transaction body
                  const body = libExports.proto.TransactionBody.decode(
                      signedTransaction.bodyBytes,
                  );

                  // Make sure the transaction ID within the body is set
                  if (body.transactionID != null) {
                      const transactionId = TransactionId._fromProtobuf(
                          /** @type {HieroProto.proto.ITransactionID} */ (
                              body.transactionID
                          ),
                      );

                      // If we haven't already seen this transaction ID in the list, add it
                      if (
                          !transactionIdStrings.includes(transactionId.toString())
                      ) {
                          transactionIds.push(transactionId);
                          transactionIdStrings.push(transactionId.toString());
                      }
                  }

                  // Make sure the node account ID within the body is set
                  if (body.nodeAccountID != null) {
                      const nodeAccountId = AccountId._fromProtobuf(
                          /** @type {HieroProto.proto.IAccountID} */ (
                              body.nodeAccountID
                          ),
                      );

                      // If we haven't already seen this node account ID in the list, add it
                      if (!nodeIdStrings.includes(nodeAccountId.toString())) {
                          nodeIds.push(nodeAccountId);
                          nodeIdStrings.push(nodeAccountId.toString());
                      }
                  }

                  // Make sure the body is set
                  if (body.data == null) {
                      throw new Error(
                          "(BUG) body.data was not set in the protobuf",
                      );
                  }

                  bodies.push(body);
              }
          }

          // FIXME: We should have a length check before we access `0` since that would error
          const body = bodies[0];

          // We should have at least more than one body
          if (body == null || body.data == null) {
              throw new Error(
                  "No transaction found in bytes or failed to decode TransactionBody",
              );
          }

          // Use the registry to call the right transaction's `fromProtobuf` method based
          // on the `body.data` string
          const fromProtobuf = TRANSACTION_REGISTRY.get(body.data); //NOSONAR

          // If we forgot to update the registry we should error
          if (fromProtobuf == null) {
              throw new Error(
                  `(BUG) Transaction.fromBytes() not implemented for type ${body.data}`,
              );
          }

          // That the specific transaction type from protobuf implementation and pass in all the
          // information we've gathered.
          return fromProtobuf(
              list,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * Convert this transaction a `ScheduleCreateTransaction`
       *
       * @returns {ScheduleCreateTransaction}
       */
      schedule() {
          this._requireNotFrozen();

          if (SCHEDULE_CREATE_TRANSACTION.length != 1) {
              throw new Error(
                  "ScheduleCreateTransaction has not been loaded yet",
              );
          }

          return SCHEDULE_CREATE_TRANSACTION[0]()._setScheduledTransaction(this);
      }

      /**
       * @description Batchify method is used to mark a transaction as part of a batch transaction or make it so-called inner transaction.
       * The Transaction will be frozen and signed by the operator of the client.
       *
       * @param {import("../client/Client.js").default<Channel, *>} client
       * @param {Key} batchKey
       * @returns {Promise<this>}
       */
      async batchify(client, batchKey) {
          this._requireNotFrozen();
          this.setBatchKey(batchKey);
          return await this.signWithOperator(client);
      }

      /**
       * This method is called by each `*Transaction._fromProtobuf()` method. It does
       * all the finalization before the user gets hold of a complete `Transaction`
       *
       * @template {Transaction} TransactionT
       * @param {TransactionT} transaction
       * @param {HieroProto.proto.ITransaction[]} transactions
       * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {HieroProto.proto.ITransactionBody[]} bodies
       * @returns {TransactionT}
       */
      static _fromProtobufTransactions(
          transaction,
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];

          // "row" of the 2-D `bodies` array has all the same contents except for `nodeAccountID`
          for (let i = 0; i < transactionIds.length; i++) {
              for (let j = 0; j < nodeIds.length - 1; j++) {
                  if (
                      !compare$1(
                          bodies[i * nodeIds.length + j],
                          bodies[i * nodeIds.length + j + 1],
                          // eslint-disable-next-line ie11/no-collection-args
                          new Set(["nodeAccountID"]),
                      )
                  ) {
                      throw new Error("failed to validate transaction bodies");
                  }
              }
          }

          // Remove node account IDs of 0
          // _IIRC_ this was initial due to some funny behavior with `ScheduleCreateTransaction`
          // We may be able to remove this.
          const zero = new AccountId(0);
          for (let i = 0; i < nodeIds.length; i++) {
              if (nodeIds[i].equals(zero)) {
                  nodeIds.splice(i--, 1);
              }
          }

          // Set the transactions accordingly, but don't lock the list because transactions can
          // be regenerated if more signatures are added
          transaction._transactions.setList(transactions);

          // Set the signed transactions accordingly. Although, they
          // can be manipulated if for instance more signatures are added
          transaction._signedTransactions.setList(signedTransactions);

          // Set the transaction IDs accordingly
          transaction._transactionIds.setList(transactionIds);

          // Set the node account IDs accordingly
          transaction._nodeAccountIds.setList(nodeIds);

          // Make sure to update the rest of the fields
          transaction._transactionValidDuration =
              body.transactionValidDuration != null &&
              body.transactionValidDuration.seconds != null
                  ? Long.fromValue(body.transactionValidDuration.seconds).toInt()
                  : DEFAULT_TRANSACTION_VALID_DURATION;
          transaction._maxTransactionFee =
              body.transactionFee != null &&
              body.transactionFee > new Long(0, 0, true)
                  ? Hbar.fromTinybars(body.transactionFee)
                  : null;
          transaction._customFeeLimits =
              body.maxCustomFees != null
                  ? body.maxCustomFees?.map((fee) =>
                        CustomFeeLimit._fromProtobuf(fee),
                    )
                  : [];
          transaction._batchKey =
              body.batchKey != null ? Key._fromProtobufKey(body?.batchKey) : null;

          transaction._transactionMemo = body.memo != null ? body.memo : "";

          // Loop over a single row of `signedTransactions` and add all the public
          // keys to the `signerPublicKeys` set, and `publicKeys` list with
          // `null` in the `transactionSigners` at the same index.
          for (let i = 0; i < nodeIds.length; i++) {
              const tx = signedTransactions[i] || transactions[i];
              if (tx.sigMap != null && tx.sigMap.sigPair != null) {
                  for (const sigPair of tx.sigMap.sigPair) {
                      transaction._signerPublicKeys.add(
                          encode$5(
                              /** @type {Uint8Array} */ (sigPair.pubKeyPrefix),
                          ),
                      );

                      transaction._publicKeys.push(
                          PublicKey.fromBytes(
                              /** @type {Uint8Array} */ (sigPair.pubKeyPrefix),
                          ),
                      );
                      transaction._transactionSigners.push(null);
                  }
              }
          }

          return transaction;
      }

      /**
       * Set the node account IDs
       *
       * @override
       * @param {AccountId[]} nodeIds
       * @returns {this}
       */
      setNodeAccountIds(nodeIds) {
          // The reason we overwrite this method is simply because we need to call `requireNotFrozen()`
          // Now that I think of it, we could just add an abstract method `setterPrerequiest()` which
          // by default does nothing, and `Executable` can call. Then we'd only need to overwrite that
          // method once.
          this._requireNotFrozen();
          super.setNodeAccountIds(nodeIds);
          return this;
      }

      /**
       * Get the transaction valid duration
       *
       * @returns {number}
       */
      get transactionValidDuration() {
          return this._transactionValidDuration;
      }

      /**
       *  Protobuf encoding has specific rules about how data is serialized
       *  Different fields take different amounts of space depending on their values
       *  The actual wire format size can only be determined after encoding
       *
       * @returns {Promise<number>}
       */
      get size() {
          this._requireFrozen();
          return this._makeRequestAsync().then(
              (request) =>
                  libExports.proto.Transaction.encode(request).finish().length,
          );
      }

      /**
       * Get the transaction body size
       * Protobuf encoding has specific rules about how data is serialized
       * Different fields take different amounts of space depending on their values
       * The actual wire format size can only be determined after encoding
       *
       * @returns {number}
       */
      get bodySize() {
          const body = this._makeTransactionBody(AccountId.fromString("0.0.0"));

          return libExports.proto.TransactionBody.encode(body).finish().length;
      }

      /**
       * Sets the duration (in seconds) that this transaction is valid for.
       *
       * This is defaulted to 120 seconds (from the time its executed).
       *
       * @param {number} validDuration
       * @returns {this}
       */
      setTransactionValidDuration(validDuration) {
          this._requireNotFrozen();
          this._transactionValidDuration = validDuration;

          return this;
      }

      /**
       * Get the max transaction fee
       *
       * @returns {?Hbar}
       */
      get maxTransactionFee() {
          return this._maxTransactionFee;
      }

      /**
       * Set the maximum transaction fee the operator (paying account)
       * is willing to pay.
       *
       * @param {number | string | Long | BigNumber | Hbar} maxTransactionFee
       * @returns {this}
       */
      setMaxTransactionFee(maxTransactionFee) {
          this._requireNotFrozen();
          this._maxTransactionFee =
              maxTransactionFee instanceof Hbar
                  ? maxTransactionFee
                  : new Hbar(maxTransactionFee);

          return this;
      }

      /**
       * Is transaction ID regeneration enabled
       *
       * @returns {?boolean}
       */
      get regenerateTransactionId() {
          return this._regenerateTransactionId;
      }

      /**
       * Set the maximum transaction fee the operator (paying account)
       * is willing to pay.
       *
       * @param {boolean} regenerateTransactionId
       * @returns {this}
       */
      setRegenerateTransactionId(regenerateTransactionId) {
          this._requireNotFrozen();
          this._regenerateTransactionId = regenerateTransactionId;

          return this;
      }

      /**
       * Get the transaction memo
       *
       * @returns {string}
       */
      get transactionMemo() {
          return this._transactionMemo;
      }

      /**
       * Set a note or description to be recorded in the transaction
       * record (maximum length of 100 bytes).
       *
       * @param {string} transactionMemo
       * @returns {this}
       */
      setTransactionMemo(transactionMemo) {
          this._requireNotFrozen();
          this._transactionMemo = transactionMemo;

          return this;
      }

      /**
       * Get the curent transaction ID
       *
       * @returns {?TransactionId}
       */
      get transactionId() {
          if (this._transactionIds.isEmpty) {
              return null;
          }

          // If a user calls `.transactionId` that means we need to use that transaction ID
          // and **not** regenerate it. To do this, we simply lock the transaction ID list.
          //
          // This may be a little conffusing since a user can enable transaction ID regenration
          // explicity, but if they call `.transactionId` then we will not regenerate transaction
          // IDs.
          this._transactionIds.setLocked();

          return this._transactionIds.current;
      }

      /**
       * Set the ID for this transaction.
       *
       * The transaction ID includes the operator's account ( the account paying the transaction
       * fee). If two transactions have the same transaction ID, they won't both have an effect. One
       * will complete normally and the other will fail with a duplicate transaction status.
       *
       * Normally, you should not use this method. Just before a transaction is executed, a
       * transaction ID will be generated from the operator on the client.
       *
       * @param {TransactionId} transactionId
       * @returns {this}
       */
      setTransactionId(transactionId) {
          this._requireNotFrozen();
          this._transactionIds.setList([transactionId]).setLocked();

          return this;
      }

      /**
       * How many chunk sizes are expected
       * @abstract
       * @internal
       * @returns {number}
       */
      getRequiredChunks() {
          return 1;
      }

      /**
       * Get the body sizes for all chunks in a Chunked transaction.
       * For transactions with multiple chunks (like large topic message submissions),
       * this returns an array containing the size of each chunk's transaction body.
       * The size is calculated by encoding the transaction body to protobuf format.
       *
       * @returns {number[]} An array of body sizes, where each element represents
       * the size in bytes of a chunk's transaction body
       *
       */
      get bodySizeAllChunks() {
          const bodySizes = [];

          // Store sizes for each chunk
          for (let i = 0; i < this.getRequiredChunks(); i++) {
              // Set index directly
              this._transactionIds.index = i;
              // Use super.bodySize to access the base class implementation
              bodySizes.push(this.bodySize);
          }
          // Restore to initial index
          this._transactionIds.index = 0;
          return bodySizes;
      }

      /**
       * Sign the transaction with the private key
       * **NOTE**: This is a thin wrapper around `.signWith()`
       *
       * @param {PrivateKey} privateKey
       * @returns {Promise<this>}
       */
      sign(privateKey) {
          return this.signWith(privateKey.publicKey, (message) =>
              Promise.resolve(privateKey.sign(message)),
          );
      }

      /**
       * Sign the transaction with the public key and signer function
       *
       * If sign on demand is enabled no signing will be done immediately, instead
       * the private key signing function and public key are saved to be used when
       * a user calls an exit condition method (not sure what a better name for this is)
       * such as `toBytes[Async]()`, `getTransactionHash[PerNode]()` or `execute()`.
       *
       * @param {PublicKey} publicKey
       * @param {(message: Uint8Array) => Promise<Uint8Array>} transactionSigner
       * @returns {Promise<this>}
       */
      async signWith(publicKey, transactionSigner) {
          // If signing on demand is disabled, we need to make sure
          // the request is frozen
          if (!this._signOnDemand) {
              this._requireFrozen();
          }
          const publicKeyData = publicKey.toBytesRaw();

          // note: this omits the DER prefix on purpose because Hedera doesn't
          // support that in the protobuf. this means that we would fail
          // to re-inflate [this._signerPublicKeys] during [fromBytes] if we used DER
          // prefixes here
          const publicKeyHex = encode$5(publicKeyData);

          if (this._signerPublicKeys.has(publicKeyHex)) {
              // this public key has already signed this transaction
              return this;
          }

          // If we add a new signer, then we need to re-create all transactions
          this._transactions.clear();

          // Save the current public key so we don't attempt to sign twice
          this._signerPublicKeys.add(publicKeyHex);

          this._publicKeys.push(publicKey);
          this._transactionSigners.push(transactionSigner);
          if (this._signOnDemand) {
              return this;
          }

          // If we get here, signing on demand is disabled, this means the transaction
          // is frozen and we need to sign all the transactions immediately. If we're
          // signing all the transactions immediately, we need to lock the node account IDs
          // and transaction IDs.
          // Now that I think of it, this code should likely exist in `freezeWith()`?
          this._transactionIds.setLocked();
          this._nodeAccountIds.setLocked();

          // Sign each signed transatcion
          for (const signedTransaction of this._signedTransactions.list) {
              const bodyBytes = /** @type {Uint8Array} */ (
                  signedTransaction.bodyBytes
              );
              const signature = await transactionSigner(bodyBytes);

              if (signedTransaction.sigMap == null) {
                  signedTransaction.sigMap = {};
              }

              if (signedTransaction.sigMap.sigPair == null) {
                  signedTransaction.sigMap.sigPair = [];
              }

              signedTransaction.sigMap.sigPair.push(
                  publicKey._toProtobufSignature(signature),
              );
          }

          return this;
      }

      /**
       * Sign the transaction with the client operator. This is a thin wrapper
       * around `.signWith()`
       *
       * **NOTE**: If client does not have an operator set, this method will throw
       *
       * @param {import("../client/Client.js").default<Channel, *>} client
       * @returns {Promise<this>}
       */
      signWithOperator(client) {
          const operator = client._operator;

          if (operator == null) {
              throw new Error(
                  "`client` must have an operator to sign with the operator",
              );
          }

          if (!this._isFrozen()) {
              this.freezeWith(client);
          }

          return this.signWith(operator.publicKey, operator.transactionSigner);
      }

      /**
       * Resets the transaction to its initial state
       * @param {Client} client
       */
      _resetTransaction(client) {
          if (!client.operatorAccountId) {
              throw new Error("Client must have an operator account ID");
          }

          this.logger?.info("Resetting transaction id and resigning");
          const newTxId = TransactionId.generate(client.operatorAccountId);
          this._transactionIds.clear();
          this._signedTransactions.clear();
          this._transactionIds.setList([newTxId]);
          this._isThrottled = true;
      }
      /**
       * @deprecated - Using uint8array and uint8array[] as signaturemap is deprecated,
       * use SignatureMap insted.
       * @overload
       * @param { PublicKey } publicKey
       * @param { Uint8Array | Uint8Array[] } signatureMap
       * @returns {this}
       */

      /**
       * @overload
       * @param {PublicKey} publicKey
       * @param { SignatureMap } signatureMap
       * @returns {this}
       */

      /**
       * Add a signature explicitly
       *
       * @param {PublicKey} publicKey
       * @param {SignatureMap | Uint8Array |Uint8Array[]} signatureMap
       * @returns {this}
       */
      addSignature(publicKey, signatureMap) {
          if (!(signatureMap instanceof SignatureMap$1)) {
              return this._addSignatureLegacy(publicKey, signatureMap);
          }

          // If the transaction isn't frozen, freeze it.
          if (!this.isFrozen()) {
              this.freeze();
          }

          const publicKeyData = publicKey.toBytesRaw();
          const publicKeyHex = encode$5(publicKeyData);

          if (this._signerPublicKeys.has(publicKeyHex)) {
              // this public key has already signed this transaction
              return this;
          }

          // If we add a new signer, then we need to re-create all transactions
          this._transactions.clear();

          // Locking the transaction IDs and node account IDs is necessary for consistency
          // between before and after execution
          this._transactionIds.setLocked();
          this._nodeAccountIds.setLocked();
          this._signedTransactions.setLocked();

          // Add the signature to the signed transaction list
          for (let index = 0; index < this._signedTransactions.length; index++) {
              const signedTransaction = this._signedTransactions.get(index);
              if (signedTransaction.sigMap == null) {
                  signedTransaction.sigMap = {};
              }

              if (signedTransaction.sigMap.sigPair == null) {
                  signedTransaction.sigMap.sigPair = [];
              }

              if (signedTransaction.bodyBytes) {
                  const { transactionID, nodeAccountID } =
                      libExports.proto.TransactionBody.decode(
                          signedTransaction.bodyBytes,
                      );

                  if (!transactionID || !nodeAccountID) {
                      throw new Error(
                          "Transaction ID or Node Account ID not found in the signed transaction",
                      );
                  }

                  const transactionId =
                      TransactionId._fromProtobuf(transactionID);
                  const nodeAccountId = AccountId._fromProtobuf(nodeAccountID);

                  const nodeSignatures = signatureMap.get(nodeAccountId);
                  const transactionSignatures =
                      nodeSignatures?.get(transactionId);
                  const signature = transactionSignatures?.get(publicKey);

                  if (!signature) {
                      throw new Error(
                          "Signature not found for the transaction and public key",
                      );
                  }
                  const sigPair = publicKey._toProtobufSignature(signature);
                  signedTransaction.sigMap?.sigPair?.push(sigPair);
              }
          }

          this._signerPublicKeys.add(publicKeyHex);
          this._publicKeys.push(publicKey);
          this._transactionSigners.push(null);

          return this;
      }

      /**
       * Add a signature explicitly
       * This method supports both single and multiple signatures. A single signature will be applied to all transactions,
       *
       * While an array of signatures must correspond to each transaction individually.
       *
       * @param {PublicKey} publicKey
       * @param {Uint8Array | Uint8Array[]} signature
       * @returns {this}
       */
      _addSignatureLegacy(publicKey, signature) {
          const isSingleSignature = signature instanceof Uint8Array;

          const isArraySignature = Array.isArray(signature);

          if (this.getRequiredChunks() > 1) {
              throw new Error(
                  "Add signature is not supported for chunked transactions",
              );
          }

          // Check if it is a single signature with NOT exactly one transaction

          if (isSingleSignature && this._signedTransactions.length !== 1) {
              throw new Error(
                  "Signature array must match the number of transactions",
              );
          }

          // Check if it's an array but the array length doesn't match the number of transactions

          if (
              isArraySignature &&
              signature.length !== this._signedTransactions.length
          ) {
              throw new Error(
                  "Signature array must match the number of transactions",
              );
          }

          // If the transaction isn't frozen, freeze it.
          if (!this.isFrozen()) {
              this.freeze();
          }

          const publicKeyData = publicKey.toBytesRaw();
          const publicKeyHex = encode$5(publicKeyData);

          if (this._signerPublicKeys.has(publicKeyHex)) {
              // this public key has already signed this transaction
              return this;
          }

          // If we add a new signer, then we need to re-create all transactions
          this._transactions.clear();

          // Locking the transaction IDs and node account IDs is necessary for consistency
          // between before and after execution
          this._transactionIds.setLocked();
          this._nodeAccountIds.setLocked();
          this._signedTransactions.setLocked();
          const signatureArray = isSingleSignature ? [signature] : signature;

          // Add the signature to the signed transaction list
          for (let index = 0; index < this._signedTransactions.length; index++) {
              const signedTransaction = this._signedTransactions.get(index);
              if (signedTransaction.sigMap == null) {
                  signedTransaction.sigMap = {};
              }

              if (signedTransaction.sigMap.sigPair == null) {
                  signedTransaction.sigMap.sigPair = [];
              }

              signedTransaction.sigMap.sigPair.push(
                  publicKey._toProtobufSignature(signatureArray[index]),
              );
          }

          this._signerPublicKeys.add(publicKeyHex);
          this._publicKeys.push(publicKey);
          this._transactionSigners.push(null);

          return this;
      }

      /**
       * Get the current signatures on the request
       * **NOTE**: Does NOT support sign on demand
       * @returns {SignatureMapLegacy}
       */
      getSignaturesLegacy() {
          // If a user is attempting to get signatures for a transaction, then the
          // transaction must be frozen.
          this._requireFrozen();
          // Sign on demand must be disabled because this is the non-async version and
          // signing requires awaiting callbacks.
          this._requireNotSignOnDemand();
          // Build all the transactions
          this._buildAllTransactions();
          // Lock transaction IDs, and node account IDs
          this._transactionIds.setLocked();
          this._nodeAccountIds.setLocked();
          // Construct a signature map from this transaction
          // eslint-disable-next-line deprecation/deprecation
          return SignatureMap._fromTransaction(this);
      }

      /**
       * This method removes all signatures from the transaction based on the public key provided.
       *
       * @param {PublicKey} publicKey - The public key associated with the signature to remove.
       * @returns {Uint8Array[]} The removed signatures.
       */
      removeSignature(publicKey) {
          if (!this.isFrozen()) {
              this.freeze();
          }

          const publicKeyData = publicKey.toBytesRaw();
          const publicKeyHex = encode$5(publicKeyData);

          if (!this._signerPublicKeys.has(publicKeyHex)) {
              throw new Error("The public key has not signed this transaction");
          }

          /** @type {Uint8Array[]} */
          const removedSignatures = [];

          // Iterate over the signed transactions and remove matching signatures
          for (const transaction of this._signedTransactions.list) {
              const removedSignaturesFromTransaction =
                  this._removeSignaturesFromTransaction(
                      transaction,
                      publicKeyHex,
                  );

              removedSignatures.push(...removedSignaturesFromTransaction);
          }

          // Remove the public key from internal tracking if no signatures remain
          this._signerPublicKeys.delete(publicKeyHex);
          this._publicKeys = this._publicKeys.filter(
              (key) => !key.equals(publicKey),
          );

          // Update transaction signers array
          this._transactionSigners.pop();

          return removedSignatures;
      }

      /**
       * This method clears all signatures from the transaction and returns them in a specific format.
       *
       * It will call collectSignatures to get the removed signatures, then clear all signatures
       * from the internal tracking.
       *
       * @returns { Map<PublicKey, Uint8Array[] | Uint8Array> } The removed signatures in the specified format.
       */
      removeAllSignatures() {
          if (!this.isFrozen()) {
              this.freeze();
          }

          const removedSignatures = this._collectSignaturesByPublicKey();

          // Iterate over the signed transactions and clear all signatures
          for (const transaction of this._signedTransactions.list) {
              if (transaction.sigMap && transaction.sigMap.sigPair) {
                  // Clear all signature pairs from the transaction's signature map
                  transaction.sigMap.sigPair = [];
              }
          }

          // Clear the internal tracking of signer public keys and other relevant arrays
          this._signerPublicKeys.clear();
          this._publicKeys = [];
          this._transactionSigners = [];

          return removedSignatures;
      }

      /**
       * @deprecated - Use the legacy=flag instead to use the modern approach
       * @overload
       * @param {true} legacy
       * @returns {SignatureMapLegacy}
       */

      /**
       * @overload
       * @param {false} [legacy]
       * @returns {SignatureMap}
       */

      /**
       * Get the current signatures on the request
       *
       * **NOTE**: Does NOT support sign on demand
       * @param {boolean} [legacy]
       * @returns {SignatureMap | SignatureMapLegacy}
       */
      getSignatures(legacy) {
          if (legacy) {
              return this.getSignaturesLegacy();
          }
          // If a user is attempting to get signatures for a transaction, then the
          // transaction must be frozen.
          this._requireFrozen();

          // Sign on demand must be disabled because this is the non-async version and
          // signing requires awaiting callbacks.
          this._requireNotSignOnDemand();

          // Build all the transactions
          this._buildAllTransactions();

          // Lock transaction IDs, and node account IDs
          this._transactionIds.setLocked();
          this._nodeAccountIds.setLocked();

          // Construct a signature map from this transaction
          return SignatureMap$1._fromTransaction(this);
      }

      /**
       * Get the current signatures on the request
       *
       * **NOTE**: Supports sign on demand
       *
       * @returns {Promise<SignatureMap>}
       */
      async getSignaturesAsync() {
          // If sign on demand is enabled, we don't need to care about being frozen
          // since we can just regenerate and resign later if some field of the transaction
          // changes.

          // Locking the transaction IDs and node account IDs is necessary for consistency
          // between before and after execution
          this._transactionIds.setLocked();
          this._nodeAccountIds.setLocked();

          // Build all transactions, and sign them
          await this._buildAllTransactionsAsync();

          // Lock transaction IDs, and node account IDs
          this._transactions.setLocked();
          this._signedTransactions.setLocked();

          // Construct a signature map from this transaction
          return SignatureMap$1._fromTransaction(this);
      }

      /**
       * Not sure why this is called `setTransactionId()` when it doesn't set anything...
       * FIXME: Remove this?
       */
      _setTransactionId() {
          if (this._operatorAccountId == null && this._transactionIds.isEmpty) {
              throw new Error(
                  "`transactionId` must be set or `client` must be provided with `freezeWith`",
              );
          }
      }

      /**
       * Set the node account IDs using the client
       *
       * @param {?import("../client/Client.js").default<Channel, *>} client
       */
      _setNodeAccountIds(client) {
          if (!this._nodeAccountIds.isEmpty) {
              return;
          }

          if (client == null) {
              throw new Error(
                  "`nodeAccountId` must be set or `client` must be provided with `freezeWith`",
              );
          }

          this._nodeAccountIds.setList(
              client._network.getNodeAccountIdsForExecute(),
          );
      }

      /**
       * Apply maxNodesPerTransaction limit to an already frozen transaction.
       * This trims the node list to the first N nodes while preserving existing signatures.
       *
       * Note: This method assumes the caller has already verified that trimming is needed.
       *
       * @private
       * @param {import("../client/Client.js").default<Channel, *>} client
       */
      _applyMaxNodesPerTransactionLimit(client) {
          const maxNodes = client.maxNodesPerTransaction;

          if (maxNodes <= 0 || this._nodeAccountIds.length <= maxNodes) {
              return;
          }

          if (this._logger) {
              this._logger.debug(
                  `Trimming frozen transaction from ${this._nodeAccountIds.length} nodes to ${maxNodes} nodes based on maxNodesPerTransaction setting`,
              );
          }

          // Trim the node account IDs to the first N nodes
          const trimmedNodeIds = this._nodeAccountIds.list.slice(0, maxNodes);

          // Trim the signed transactions to match the trimmed node list
          // Each chunk has transactions for all nodes, so we need to trim each chunk
          const nodeCount = this._nodeAccountIds.length;
          const chunkCount = this._transactionIds.length;
          const trimmedSignedTransactions = [];

          for (let chunkIndex = 0; chunkIndex < chunkCount; chunkIndex++) {
              const chunkStart = chunkIndex * nodeCount;

              // Add the first maxNodes transactions from this chunk
              for (let nodeIndex = 0; nodeIndex < maxNodes; nodeIndex++) {
                  const transactionIndex = chunkStart + nodeIndex;
                  if (transactionIndex < this._signedTransactions.length) {
                      trimmedSignedTransactions.push(
                          this._signedTransactions.get(transactionIndex),
                      );
                  }
              }
          }

          // Clear and rebuild the transactions list since it's derived from signed transactions
          this._transactions.clear();

          // Update the node account IDs (we need to unlock, update, and relock)
          this._nodeAccountIds.locked = false;

          this._nodeAccountIds.setList(trimmedNodeIds);

          this._nodeAccountIds.locked = true;

          // Update the signed transactions
          this._signedTransactions.setList(trimmedSignedTransactions);
      }

      /**
       * @description Set the key that will sign the batch of which this Transaction is a part of.
       * @param {Key} batchKey
       * @returns {this}
       */
      setBatchKey(batchKey) {
          this._requireNotFrozen();
          this._batchKey = batchKey;
          return this;
      }

      /**
       * @description Get the key that will sign the batch of which this Transaction is a part of.
       * @returns {Key | null | undefined}
       */
      get batchKey() {
          return this._batchKey;
      }

      /**
       * Returns a List of SignableNodeTransactionBodyBytes for each node the transaction is intended for.
       * These are the canonical bytes that must be signed externally (e.g., via HSM).
       *
       * @returns {SignableNodeTransactionBodyBytes[]}
       */
      get signableNodeBodyBytesList() {
          this._requireFrozen();

          return this._signedTransactions.list.map((signedTransaction) => {
              if (!signedTransaction.bodyBytes) {
                  throw new Error("Missing bodyBytes in signed transaction.");
              }

              const body = libExports.proto.TransactionBody.decode(
                  signedTransaction.bodyBytes,
              );

              if (!body.nodeAccountID) {
                  throw new Error("Missing nodeAccountID in transaction body.");
              }

              const nodeAccountId = AccountId._fromProtobuf(body.nodeAccountID);
              if (!body.transactionID) {
                  throw new Error("Missing transactionID in transaction body.");
              }

              const transactionId = TransactionId._fromProtobuf(
                  body.transactionID,
              );

              return new SignableNodeTransactionBodyBytes(
                  nodeAccountId,
                  transactionId,
                  signedTransaction.bodyBytes,
              );
          });
      }

      /**
       * Build all the signed transactions from the node account IDs
       *
       * @private
       */
      _buildSignedTransactions() {
          if (this._signedTransactions.locked) {
              return;
          }

          this._signedTransactions.setList(
              this._nodeAccountIds.list.map((nodeId) =>
                  this._makeSignedTransaction(nodeId),
              ),
          );
      }

      /**
       * Build all the signed transactions from the node account IDs
       *
       * @internal
       */
      _buildIncompleteTransactions() {
          if (this._nodeAccountIds.length == 0) {
              this._transactions.setList([this._makeSignedTransaction(null)]);
          } else {
              // In case the node account ids are set
              this._transactions.setList(
                  this._nodeAccountIds.list.map((nodeId) =>
                      this._makeSignedTransaction(nodeId),
                  ),
              );
          }
      }

      /**
       * Freeze this transaction from future modification to prepare for
       * signing or serialization.
       *
       * @returns {this}
       */
      freeze() {
          return this.freezeWith(null);
      }

      /**
       * @param {?AccountId} accountId
       */
      _freezeWithAccountId(accountId) {
          if (this._operatorAccountId == null) {
              this._operatorAccountId = accountId;
          }
      }

      /**
       * Freeze this transaction from further modification to prepare for
       * signing or serialization.
       *
       * Will use the `Client`, if available, to generate a default Transaction ID and select 1/3
       * nodes to prepare this transaction for.
       *
       * @param {?import("../client/Client.js").default<Channel, *>} client
       * @returns {this}
       */
      freezeWith(client) {
          // Set sign on demand based on client
          this._signOnDemand = client != null ? client.signOnDemand : false;

          // Save the operator
          this._operator = client != null ? client._operator : null;
          this._freezeWithAccountId(
              client != null ? client.operatorAccountId : null,
          );

          // Set max transaction fee to either `this._maxTransactionFee`,
          // `client._defaultMaxTransactionFee`, or `this._defaultMaxTransactionFee`
          // in that priority order depending on if `this._maxTransactionFee` has
          // been set or if `client._defaultMaxTransactionFee` has been set.
          this._maxTransactionFee =
              this._maxTransactionFee == null
                  ? client != null && client.defaultMaxTransactionFee != null
                      ? client.defaultMaxTransactionFee
                      : this._defaultMaxTransactionFee
                  : this._maxTransactionFee;

          // Determine if transaction ID generation should be enabled.
          this._regenerateTransactionId =
              client != null && this._regenerateTransactionId == null
                  ? client.defaultRegenerateTransactionId
                  : this._regenerateTransactionId;

          // Set the node account IDs via client
          if (this.batchKey) {
              this._nodeAccountIds.setList([NODE_ACCOUNT_BATCH_ID]);
          } else {
              this._setNodeAccountIds(client);
          }

          // Make sure a transaction ID or operator is set.
          this._setTransactionId();

          // If a client was not provided, we need to make sure the transaction ID already set
          // validates aginst the client.
          if (client != null) {
              for (const transactionId of this._transactionIds.list) {
                  if (transactionId.accountId != null) {
                      transactionId.accountId.validateChecksum(client);
                  }
              }
          }

          // Build a list of transaction IDs so that if a user calls `.transactionId` they'll
          // get a value, but if they dont' we'll just regenerate transaction IDs during execution
          this._buildNewTransactionIdList();

          // If sign on demand is disabled we need to build out all the signed transactions
          if (!this._signOnDemand) {
              this._buildSignedTransactions();
          }

          return this;
      }

      /**
       * Sign the transaction using a signer
       *
       * This is part of the signature provider feature
       *
       * @param {Signer} signer
       * @returns {Promise<this>}
       */
      async signWithSigner(signer) {
          await signer.signTransaction(this);
          return this;
      }

      /**
       * Freeze the transaction using a signer
       *
       * This is part of the signature provider feature.
       *
       * @param {Signer} signer
       * @returns {Promise<this>}
       */
      async freezeWithSigner(signer) {
          await signer.populateTransaction(this);
          this.freeze();
          return this;
      }

      /**
       * Serialize the request into bytes. This will encode all the transactions
       * into a `proto.TransactionList` and return the encoded protobuf.
       *
       * **NOTE**: Does not support sign on demand
       *
       * @returns {Uint8Array}
       */
      toBytes() {
          // Sign on demand must be disabled because this is the non-async version and
          // signing requires awaiting callbacks.
          this._requireNotSignOnDemand();

          if (this._isFrozen()) {
              // Locking the transaction IDs and node account IDs is necessary for consistency
              // between before and after execution
              this._transactionIds.setLocked();
              this._nodeAccountIds.setLocked();

              // Build all the transactions without signing
              this._buildAllTransactions();
          } else {
              this._buildIncompleteTransactions();
          }

          // Construct and encode the transaction list
          return libExports.proto.TransactionList.encode({
              transactionList: /** @type {HieroProto.proto.ITransaction[]} */ (
                  this._transactions.list
              ),
          }).finish();
      }

      /**
       * Serialize the transaction into bytes
       *
       * **NOTE**: Supports sign on demand
       *
       * @returns {Promise<Uint8Array>}
       */
      async toBytesAsync() {
          // If sign on demand is enabled, we don't need to care about being frozen
          // since we can just regenerate and resign later if some field of the transaction
          // changes.

          // Locking the transaction IDs and node account IDs is necessary for consistency
          // between before and after execution
          this._transactionIds.setLocked();
          this._nodeAccountIds.setLocked();

          // Build all transactions, and sign them
          await this._buildAllTransactionsAsync();

          // Lock transaction IDs, and node account IDs
          this._transactions.setLocked();
          this._signedTransactions.setLocked();

          // Construct and encode the transaction list
          return libExports.proto.TransactionList.encode({
              transactionList: /** @type {HieroProto.proto.ITransaction[]} */ (
                  this._transactions.list
              ),
          }).finish();
      }

      /**
       * Get the transaction hash
       *
       * @returns {Promise<Uint8Array>}
       */
      async getTransactionHash() {
          this._requireFrozen();

          // Locking the transaction IDs and node account IDs is necessary for consistency
          // between before and after execution
          this._transactionIds.setLocked();
          this._nodeAccountIds.setLocked();

          await this._buildAllTransactionsAsync();

          this._transactions.setLocked();
          this._signedTransactions.setLocked();

          return digest(
              /** @type {Uint8Array} */ (
                  /** @type {HieroProto.proto.ITransaction} */ (
                      this._transactions.get(0)
                  ).signedTransactionBytes
              ),
          );
      }

      /**
       * Get all the transaction hashes
       *
       * @returns {Promise<TransactionHashMap>}
       */
      async getTransactionHashPerNode() {
          this._requireFrozen();

          // Locking the transaction IDs and node account IDs is necessary for consistency
          // between before and after execution
          this._transactionIds.setLocked();
          this._nodeAccountIds.setLocked();

          await this._buildAllTransactionsAsync();

          return await TransactionHashMap._fromTransaction(this);
      }

      /**
       * Is transaction frozen
       *
       * @returns {boolean}
       */
      isFrozen() {
          return this._signedTransactions.length > 0;
      }

      /**
       * Get the current transaction ID, and make sure it's not null
       *
       * @protected
       * @returns {TransactionId}
       */
      _getTransactionId() {
          const transactionId = this.transactionId;
          if (transactionId == null) {
              throw new Error(
                  "transaction must have been frozen before getting the transaction ID, try calling `freeze`",
              );
          }
          return transactionId;
      }

      /**
       * @param {Client} client
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars,@typescript-eslint/no-empty-function
      _validateChecksums(client) {
          // Do nothing
      }

      /**
       * Before we proceed execution, we need to do a couple checks
       *
       * @override
       * @protected
       * @param {import("../client/Client.js").default<Channel, *>} client
       * @returns {Promise<void>}
       */
      async _beforeExecute(client) {
          // Assign the account IDs to which the transaction should be sent.
          this.transactionNodeIds = Object.values(client.network).map(
              (accountNodeId) => accountNodeId.toString(),
          );

          if (this._logger) {
              this._logger.info(
                  `Network used: ${client._network.networkName}`, // eslint-disable-line @typescript-eslint/restrict-template-expressions
              );
          }

          // Make sure we're frozen
          if (!this._isFrozen()) {
              this.freezeWith(client);
          }

          // Apply maxNodesPerTransaction limit to already frozen transaction
          // This allows changing the node count even after freezing while preserving signatures
          this._applyMaxNodesPerTransactionLimit(client);

          // Valid checksums if the option is enabled
          if (client.isAutoValidateChecksumsEnabled()) {
              this._validateChecksums(client);
          }

          // Set the operator if the client has one and the current operator is nullish
          if (this._operator == null || this._operator == undefined) {
              this._operator = client != null ? client._operator : null;
          }

          if (
              this._operatorAccountId == null ||
              this._operatorAccountId == undefined
          ) {
              this._operatorAccountId =
                  client != null && client._operator != null
                      ? client._operator.accountId
                      : null;
          }

          // If the client has an operator, sign this request with the operator
          if (this._operator != null) {
              await this.signWith(
                  this._operator.publicKey,
                  this._operator.transactionSigner,
              );
          }
      }

      /**
       * Construct a protobuf transaction
       *
       * @override
       * @internal
       * @returns {Promise<HieroProto.proto.ITransaction>}
       */
      async _makeRequestAsync() {
          // The index for the transaction
          const index =
              this._transactionIds.index * this._nodeAccountIds.length +
              this._nodeAccountIds.index;

          // If sign on demand is disabled we need to simply build that transaction
          // and return the result, without signing
          if (!this._signOnDemand && !this._isThrottled) {
              this._buildTransaction(index);
              return /** @type {HieroProto.proto.ITransaction} */ (
                  this._transactions.get(index)
              );
          }

          // Build and sign a transaction
          return await this._buildTransactionAsync();
      }

      /**
       * Sign a `proto.SignedTransaction` with all the keys
       *
       * @private
       * @returns {Promise<HieroProto.proto.ISignedTransaction>}
       */
      async _signTransaction() {
          const signedTransaction = this._makeSignedTransaction(
              this._nodeAccountIds.next,
          );

          const bodyBytes = /** @type {Uint8Array} */ (
              signedTransaction.bodyBytes
          );

          for (let j = 0; j < this._publicKeys.length; j++) {
              const publicKey = this._publicKeys[j];
              const transactionSigner = this._transactionSigners[j];

              if (transactionSigner == null) {
                  continue;
              }

              const signature = await transactionSigner(bodyBytes);

              if (signedTransaction.sigMap == null) {
                  signedTransaction.sigMap = {};
              }

              if (signedTransaction.sigMap.sigPair == null) {
                  signedTransaction.sigMap.sigPair = [];
              }

              signedTransaction.sigMap.sigPair.push(
                  publicKey._toProtobufSignature(signature),
              );
          }

          return signedTransaction;
      }

      /**
       * Construct a new transaction ID at the current index
       *
       * @private
       */
      _buildNewTransactionIdList() {
          if (this._transactionIds.locked || this._operatorAccountId == null) {
              return;
          }

          const transactionId = TransactionId.withValidStart(
              this._operatorAccountId,
              Timestamp.generate(),
          );

          this._transactionIds.set(this._transactionIds.index, transactionId);
      }

      /**
       * Build each signed transaction in a loop
       *
       * @internal
       */
      _buildAllTransactions() {
          for (let i = 0; i < this._signedTransactions.length; i++) {
              this._buildTransaction(i);
          }
      }

      /**
       * Build and and sign each transaction in a loop
       *
       * This method is primary used in the exist condition methods
       * which are not `execute()`, e.g. `toBytesAsync()` and `getSignaturesAsync()`
       *
       * @private
       */
      async _buildAllTransactionsAsync() {
          if (!this._signOnDemand) {
              this._buildAllTransactions();
              return;
          }

          this._buildSignedTransactions();

          if (this._transactions.locked) {
              return;
          }

          for (let i = 0; i < this._signedTransactions.length; i++) {
              this._transactions.push(await this._buildTransactionAsync());
          }
      }

      /**
       * Build a transaction at a particular index
       *
       * @internal
       * @param {number} index
       */
      _buildTransaction(index) {
          if (this._transactions.length < index) {
              for (let i = this._transactions.length; i < index; i++) {
                  this._transactions.push(null);
              }
          }

          // In case when an incomplete transaction is created, serialized and
          // deserialized,and then the transaction being frozen, the copy of the
          // incomplete transaction must be updated in order to be prepared for execution
          if (this._transactions.list[index] != null) {
              this._transactions.set(index, {
                  signedTransactionBytes:
                      libExports.proto.SignedTransaction.encode(
                          this._signedTransactions.get(index),
                      ).finish(),
              });
          }

          this._transactions.setIfAbsent(index, () => {
              return {
                  signedTransactionBytes:
                      libExports.proto.SignedTransaction.encode(
                          this._signedTransactions.get(index),
                      ).finish(),
              };
          });
      }

      /**
       * Build a trransaction using the current index, where the current
       * index is determined by `this._nodeAccountIds.index` and
       * `this._transactionIds.index`
       *
       * @private
       * @returns {Promise<HieroProto.proto.ITransaction>}
       */
      async _buildTransactionAsync() {
          return {
              signedTransactionBytes: libExports.proto.SignedTransaction.encode(
                  await this._signTransaction(),
              ).finish(),
          };
      }

      /**
       * Determine what execution state we're in.
       *
       * @override
       * @internal
       * @param {HieroProto.proto.ITransaction} request
       * @param {HieroProto.proto.ITransactionResponse} response
       * @returns {[Status, ExecutionState]}
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _shouldRetry(request, response) {
          const { nodeTransactionPrecheckCode } = response;

          // Get the node precheck code, and convert it into an SDK `Status`
          const status = Status._fromCode(
              nodeTransactionPrecheckCode != null
                  ? nodeTransactionPrecheckCode
                  : libExports.proto.ResponseCodeEnum.OK,
          );

          if (this._logger) {
              this._logger.debug(
                  `[${this._getLogId()}] received status ${status.toString()}`,
              );
              this._logger.info(
                  `SDK Transaction Status Response: ${status.toString()}`,
              );
          }

          // Based on the status what execution state are we in
          switch (status) {
              case Status.Busy:
              case Status.Unknown:
              case Status.PlatformTransactionNotCreated:
              case Status.PlatformNotActive:
                  return [status, ExecutionState.Retry];
              case Status.Ok:
                  return [status, ExecutionState.Finished];
              case Status.TransactionExpired:
                  if (
                      this._transactionIds.locked ||
                      (this._regenerateTransactionId != null &&
                          !this._regenerateTransactionId)
                  ) {
                      return [status, ExecutionState.Error];
                  } else {
                      this._buildNewTransactionIdList();
                      return [status, ExecutionState.Retry];
                  }
              default:
                  return [status, ExecutionState.Error];
          }
      }

      /**
       * Map the request and response into a precheck status error
       *
       * @override
       * @internal
       * @param {HieroProto.proto.ITransaction} request
       * @param {HieroProto.proto.ITransactionResponse} response
       * @param {AccountId} nodeId
       * @returns {Error}
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _mapStatusError(request, response, nodeId) {
          const { nodeTransactionPrecheckCode } = response;

          const status = Status._fromCode(
              nodeTransactionPrecheckCode != null
                  ? nodeTransactionPrecheckCode
                  : libExports.proto.ResponseCodeEnum.OK,
          );
          if (this._logger) {
              this._logger.info(
                  // @ts-ignore
                  `Transaction Error Info: ${status.toString()}, ${this.transactionId.toString()}`, // eslint-disable-line @typescript-eslint/restrict-template-expressions
              );
          }

          return new PrecheckStatusError({
              nodeId,
              status,
              transactionId: this._getTransactionId(),
              contractFunctionResult: null,
          });
      }

      /**
       * Map the request, response, and node account ID into a `TransactionResponse`
       *
       * @override
       * @protected
       * @param {HieroProto.proto.ITransactionResponse} response
       * @param {AccountId} nodeId
       * @param {HieroProto.proto.ITransaction} request
       * @returns {Promise<TransactionResponse>}
       */
      async _mapResponse(response, nodeId, request) {
          const transactionHash = await digest(
              /** @type {Uint8Array} */ (request.signedTransactionBytes),
          );
          const transactionId = this._getTransactionId();

          this._transactionIds.advance();
          if (this._logger) {
              this._logger.info(
                  `Transaction Info: ${JSON.stringify(
                    new TransactionResponse({
                        nodeId,
                        transactionHash,
                        transactionId,
                        logger: this._logger,
                    }).toJSON(),
                )}`,
              );
          }

          return new TransactionResponse({
              nodeId,
              transactionHash,
              transactionId,
              transaction: this,
              logger: this._logger,
          });
      }

      /**
       * Make a signed transaction given a node account ID
       *
       * @internal
       * @param {?AccountId} nodeId
       * @returns {HieroProto.proto.ISignedTransaction}
       */
      _makeSignedTransaction(nodeId) {
          const body = this._makeTransactionBody(nodeId);
          if (this._logger) {
              this._logger.info(`Transaction Body: ${JSON.stringify(body)}`);
          }
          const bodyBytes =
              libExports.proto.TransactionBody.encode(body).finish();

          return {
              sigMap: {
                  sigPair: [],
              },
              bodyBytes,
          };
      }

      /**
       * @override
       * @returns {boolean}
       */
      isBatchedAndNotBatchTransaction() {
          return (
              this.batchKey != null &&
              this._getTransactionDataCase() != "atomicBatch"
          );
      }

      /**
       * Make a protobuf transaction body
       *
       * @private
       * @param {?AccountId} nodeId
       * @returns {HieroProto.proto.ITransactionBody}
       */
      _makeTransactionBody(nodeId) {
          return {
              [this._getTransactionDataCase()]: this._makeTransactionData(),
              transactionFee:
                  this._maxTransactionFee != null
                      ? this._maxTransactionFee.toTinybars()
                      : null,
              memo: this._transactionMemo,
              transactionID:
                  this._transactionIds.current != null
                      ? this._transactionIds.current._toProtobuf()
                      : null,
              nodeAccountID: nodeId != null ? nodeId._toProtobuf() : null,
              transactionValidDuration: {
                  seconds: Long.fromNumber(this._transactionValidDuration),
              },
              maxCustomFees:
                  this._customFeeLimits != null
                      ? this._customFeeLimits.map((maxCustomFee) =>
                            maxCustomFee._toProtobuf(),
                        )
                      : null,
              batchKey: this.batchKey?._toProtobufKey(),
          };
      }

      /**
       * This method returns a key for the `data` field in a transaction body.
       * Each transaction overwrite this to make sure when we build the transaction body
       * we set the right data field.
       *
       * @abstract
       * @protected
       * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          throw new Error("not implemented");
      }

      /**
       * Make a scheduled transaction body
       * FIXME: Should really call this `makeScheduledTransactionBody` to be consistent
       *
       * @internal
       * @returns {HieroProto.proto.ISchedulableTransactionBody}
       */
      _getScheduledTransactionBody() {
          return {
              memo: this.transactionMemo,
              transactionFee:
                  this._maxTransactionFee == null
                      ? this._defaultMaxTransactionFee.toTinybars()
                      : this._maxTransactionFee.toTinybars(),
              maxCustomFees:
                  this._customFeeLimits != null
                      ? this._customFeeLimits.map((maxCustomFee) =>
                            maxCustomFee._toProtobuf(),
                        )
                      : null,
              [this._getTransactionDataCase()]: this._makeTransactionData(),
          };
      }

      /**
       * Make the transaction body data.
       *
       * @abstract
       * @protected
       * @returns {object}
       */
      _makeTransactionData() {
          throw new Error("not implemented");
      }

      /**
       * FIXME: Why do we have `isFrozen` and `_isFrozen()`?
       *
       * @protected
       * @returns {boolean}
       */
      _isFrozen() {
          return this._signOnDemand || this._signedTransactions.length > 0;
      }

      /**
       * Require the transaction to NOT be frozen
       *
       * @internal
       */
      _requireNotFrozen() {
          if (this._isFrozen()) {
              throw new Error(
                  "transaction is immutable; it has at least one signature or has been explicitly frozen",
              );
          }
      }

      /**
       * Require the transaction to have sign on demand disabled
       *
       * @internal
       */
      _requireNotSignOnDemand() {
          if (this._signOnDemand) {
              throw new Error(
                  "Please use `toBytesAsync()` if `signOnDemand` is enabled",
              );
          }
      }

      /**
       * Require the transaction to be frozen
       *
       * @internal
       */
      _requireFrozen() {
          if (!this._isFrozen()) {
              throw new Error(
                  "transaction must have been frozen before calculating the hash will be stable, try calling `freeze`",
              );
          }
      }

      /**
       * Require the transaction to have a single node account ID set
       *
       * @internal
       * @protected
       */
      _requireOneNodeAccountId() {
          if (this._nodeAccountIds.length != 1) {
              throw "transaction did not have exactly one node ID set";
          }
      }

      /**
       * @param {HieroProto.proto.Transaction} request
       * @returns {Uint8Array}
       */
      _requestToBytes(request) {
          return libExports.proto.Transaction.encode(request).finish();
      }

      /**
       * @param {HieroProto.proto.TransactionResponse} response
       * @returns {Uint8Array}
       */
      _responseToBytes(response) {
          return libExports.proto.TransactionResponse.encode(response).finish();
      }

      /**
       * Removes all signatures from a transaction and collects the removed signatures.
       *
       * @param {HieroProto.proto.ISignedTransaction} transaction - The transaction object to process.
       * @param {string} publicKeyHex - The hexadecimal representation of the public key.
       * @returns {Uint8Array[]} An array of removed signatures.
       */
      _removeSignaturesFromTransaction(transaction, publicKeyHex) {
          /** @type {Uint8Array[]} */
          const removedSignatures = [];

          if (!transaction.sigMap || !transaction.sigMap.sigPair) {
              return [];
          }

          transaction.sigMap.sigPair = transaction.sigMap.sigPair.filter(
              (sigPair) => {
                  const shouldRemove = this._shouldRemoveSignature(
                      sigPair,
                      publicKeyHex,
                  );
                  const signature = sigPair.ed25519 ?? sigPair.ECDSASecp256k1;

                  if (shouldRemove && signature) {
                      removedSignatures.push(signature);
                  }

                  return !shouldRemove;
              },
          );

          return removedSignatures;
      }

      /**
       * Determines whether a signature should be removed based on the provided public key.
       *
       * @param {HieroProto.proto.ISignaturePair} sigPair - The signature pair object that contains
       *        the public key prefix and signature to be evaluated.
       * @param {string} publicKeyHex - The hexadecimal representation of the public key to compare against.
       * @returns {boolean} `true` if the public key prefix in the signature pair matches the provided public key,
       *          indicating that the signature should be removed; otherwise, `false`.
       */
      _shouldRemoveSignature = (sigPair, publicKeyHex) => {
          const sigPairPublicKeyHex = encode$5(
              sigPair?.pubKeyPrefix || new Uint8Array(),
          );

          const matchesPublicKey = sigPairPublicKeyHex === publicKeyHex;

          return matchesPublicKey;
      };

      /**
       * Collects all signatures from signed transactions and returns them in a format keyed by PublicKey.
       *
       * @returns { Map<PublicKey, Uint8Array[]> } The collected signatures keyed by PublicKey.
       */
      _collectSignaturesByPublicKey() {
          /** @type {  Map<PublicKey, Uint8Array[]>} */
          const collectedSignatures = new Map();
          /** @type { Record<string, PublicKey> } */
          const publicKeyMap = {}; // Map to hold string representation of the PublicKey object

          // Iterate over the signed transactions and collect signatures
          for (const transaction of this._signedTransactions.list) {
              if (!(transaction.sigMap && transaction.sigMap.sigPair)) {
                  return new Map();
              }

              // Collect the signatures
              for (const sigPair of transaction.sigMap.sigPair) {
                  const signature = sigPair.ed25519 ?? sigPair.ECDSASecp256k1;

                  if (!signature || !sigPair.pubKeyPrefix) {
                      return new Map();
                  }

                  const publicKeyStr = encode$5(sigPair.pubKeyPrefix);
                  let publicKeyObj = publicKeyMap[publicKeyStr];

                  // If the PublicKey instance for this string representation doesn't exist, create and store it
                  if (!publicKeyObj) {
                      publicKeyObj = PublicKey.fromString(publicKeyStr);
                      publicKeyMap[publicKeyStr] = publicKeyObj;
                  }

                  // Initialize the structure for this publicKey if it doesn't exist
                  if (!collectedSignatures.has(publicKeyObj)) {
                      collectedSignatures.set(publicKeyObj, []);
                  }

                  const existingSignatures =
                      collectedSignatures.get(publicKeyObj);

                  // Add the signature to the corresponding public key
                  if (existingSignatures) {
                      existingSignatures.push(signature);
                  }
              }
          }

          return collectedSignatures;
      }
  }

  /**
   * This is essentially a registry/cache for a callback that creates a `ScheduleCreateTransaction`
   *
   * @type {(() => ScheduleCreateTransaction)[]}
   */
  const SCHEDULE_CREATE_TRANSACTION = [];

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITokenTransferList} HieroProto.proto.ITokenTransferList
   * @typedef {import("@hashgraph/proto").proto.IAccountAmount} HieroProto.proto.IAccountAmount
   * @typedef {import("@hashgraph/proto").proto.INftTransfer} HieroProto.proto.INftTransfer
   * @typedef {import("@hashgraph/proto").proto.IAccountID} HieroProto.proto.IAccountID
   * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
   */

  /**
   * @typedef {import("bignumber.js").default} BigNumber
   */

  /**
   * An account, and the amount that it sends or receives during a cryptocurrency tokentransfer.
   */
  class TokenNftTransfer {
      /**
       * @internal
       * @param {object} props
       * @param {TokenId | string} props.tokenId
       * @param {AccountId | string} props.senderAccountId
       * @param {AccountId | string} props.receiverAccountId
       * @param {Long | number} props.serialNumber
       * @param {boolean} props.isApproved
       */
      constructor(props) {
          /**
           * The Token ID that sends or receives cryptocurrency.
           */
          this.tokenId =
              props.tokenId instanceof TokenId
                  ? props.tokenId
                  : TokenId.fromString(props.tokenId);

          /**
           * The Account ID that sends or receives cryptocurrency.
           */
          this.senderAccountId =
              props.senderAccountId instanceof AccountId
                  ? props.senderAccountId
                  : AccountId.fromString(props.senderAccountId);

          /**
           * The Account ID that sends or receives cryptocurrency.
           */
          this.receiverAccountId =
              props.receiverAccountId instanceof AccountId
                  ? props.receiverAccountId
                  : AccountId.fromString(props.receiverAccountId);

          this.serialNumber = Long.fromValue(props.serialNumber);
          this.isApproved = props.isApproved;
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITokenTransferList[]} tokenTransfers
       * @returns {TokenNftTransfer[]}
       */
      static _fromProtobuf(tokenTransfers) {
          const transfers = [];

          for (const tokenTransfer of tokenTransfers) {
              const tokenId = TokenId._fromProtobuf(
                  /** @type {HieroProto.proto.ITokenID} */ (tokenTransfer.token),
              );
              for (const transfer of tokenTransfer.nftTransfers != null
                  ? tokenTransfer.nftTransfers
                  : []) {
                  transfers.push(
                      new TokenNftTransfer({
                          tokenId,
                          senderAccountId: AccountId._fromProtobuf(
                              /** @type {HieroProto.proto.IAccountID} */ (
                                  transfer.senderAccountID
                              ),
                          ),
                          receiverAccountId: AccountId._fromProtobuf(
                              /** @type {HieroProto.proto.IAccountID} */ (
                                  transfer.receiverAccountID
                              ),
                          ),
                          serialNumber:
                              transfer.serialNumber != null
                                  ? transfer.serialNumber
                                  : Long.ZERO,
                          isApproved: transfer.isApproval == true,
                      }),
                  );
              }
          }

          return transfers;
      }

      /**
       * @internal
       * @returns {HieroProto.proto.INftTransfer}
       */
      _toProtobuf() {
          return {
              senderAccountID: this.senderAccountId._toProtobuf(),
              receiverAccountID: this.receiverAccountId._toProtobuf(),
              serialNumber: this.serialNumber,
              isApproval: this.isApproved,
          };
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITokenBalance} HieroProto.proto.ITokenBalance
   * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
   */

  /**
   * @augments {ObjectMap<TokenId, number | null>}
   */
  class NullableTokenDecimalMap extends ObjectMap {
      constructor() {
          super((s) => TokenId.fromString(s));
      }
  }

  // SPDX-License-Identifier: Apache-2.0

  /**
   * @typedef {import("bignumber.js").default} BigNumber
   */

  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITokenAirdropTransactionBody} HieroProto.proto.ITokenAirdropTransactionBody
   */

  /**
   * @typedef {object} TransferTokensInput
   * @property {TokenId | string} tokenId
   * @property {AccountId | string} accountId
   * @property {Long | number | BigNumber | bigint} amount
   */

  /**
   * @typedef {object} TransferNftInput
   * @property {TokenId | string} tokenId
   * @property {AccountId | string} sender
   * @property {AccountId | string} recipient
   * @property {Long | number} serial
   */

  class AbstractTokenTransferTransaction extends Transaction {
      /**
       * @param {object} [props]
       * @param {(TransferTokensInput)[]} [props.tokenTransfers]
       * @param {(TransferNftInput)[]} [props.nftTransfers]
       */
      constructor(props = {}) {
          super();

          /**
           * @protected
           * @type {TokenTransfer[]}
           */
          this._tokenTransfers = [];

          /**
           * @protected
           * @type {TokenNftTransfer[]}
           */
          this._nftTransfers = [];

          for (const transfer of props.tokenTransfers != null
              ? props.tokenTransfers
              : []) {
              this.addTokenTransfer(
                  transfer.tokenId,
                  transfer.accountId,
                  transfer.amount,
              );
          }

          for (const transfer of props.nftTransfers != null
              ? props.nftTransfers
              : []) {
              this.addNftTransfer(
                  transfer.tokenId,
                  transfer.serial,
                  transfer.sender,
                  transfer.recipient,
              );
          }
      }

      /**
       * @param {NftId | TokenId | string} tokenIdOrNftId
       * @param {AccountId | string | Long | number} senderAccountIdOrSerialNumber
       * @param {AccountId | string} receiverAccountIdOrSenderAccountId
       * @param {(AccountId | string)=} receiver
       * @returns {this}
       */
      addNftTransfer(
          tokenIdOrNftId,
          senderAccountIdOrSerialNumber,
          receiverAccountIdOrSenderAccountId,
          receiver,
      ) {
          return this._addNftTransfer(
              false,
              tokenIdOrNftId,
              senderAccountIdOrSerialNumber,
              receiverAccountIdOrSenderAccountId,
              receiver,
          );
      }

      /**
       * @param {TokenId | string} tokenId
       * @param {AccountId | string} accountId
       * @param {number | Long | BigNumber | bigint} amount
       * @param {boolean} isApproved
       * @param {number | null} expectedDecimals
       * @returns {this}
       */
      _addTokenTransfer(
          tokenId,
          accountId,
          amount,
          isApproved,
          expectedDecimals,
      ) {
          this._requireNotFrozen();

          const token =
              tokenId instanceof TokenId ? tokenId : TokenId.fromString(tokenId);
          const account =
              accountId instanceof AccountId
                  ? accountId
                  : AccountId.fromString(accountId);
          const value = convertAmountToLong(amount);

          for (const tokenTransfer of this._tokenTransfers) {
              if (
                  tokenTransfer.tokenId.compare(token) === 0 &&
                  tokenTransfer.accountId.compare(account) === 0
              ) {
                  tokenTransfer.amount = tokenTransfer.amount.add(value);
                  tokenTransfer.expectedDecimals = expectedDecimals;
                  return this;
              }
          }

          this._tokenTransfers.push(
              new TokenTransfer({
                  tokenId,
                  accountId,
                  expectedDecimals: expectedDecimals,
                  amount,
                  isApproved,
              }),
          );

          return this;
      }

      /**
       * @param {TokenId | string} tokenId
       * @param {AccountId | string} accountId
       * @param {number | Long | BigNumber | bigint} amount
       * @returns {this}
       */
      addTokenTransfer(tokenId, accountId, amount) {
          return this._addTokenTransfer(tokenId, accountId, amount, false, null);
      }

      /**
       * @param {boolean} isApproved
       * @param {NftId | TokenId | string} tokenIdOrNftId
       * @param {AccountId | string | Long | number} senderAccountIdOrSerialNumber
       * @param {AccountId | string} receiverAccountIdOrSenderAccountId
       * @param {(AccountId | string)=} receiver
       * @returns {this}
       */
      _addNftTransfer(
          isApproved,
          tokenIdOrNftId,
          senderAccountIdOrSerialNumber,
          receiverAccountIdOrSenderAccountId,
          receiver,
      ) {
          this._requireNotFrozen();

          let nftId;
          let senderAccountId;
          let receiverAccountId;

          if (tokenIdOrNftId instanceof NftId) {
              nftId = tokenIdOrNftId;
              senderAccountId =
                  typeof senderAccountIdOrSerialNumber === "string"
                      ? AccountId.fromString(senderAccountIdOrSerialNumber)
                      : /** @type {AccountId} */ (senderAccountIdOrSerialNumber);
              receiverAccountId =
                  typeof receiverAccountIdOrSenderAccountId === "string"
                      ? AccountId.fromString(receiverAccountIdOrSenderAccountId)
                      : /** @type {AccountId} */ (
                            receiverAccountIdOrSenderAccountId
                        );
          } else if (tokenIdOrNftId instanceof TokenId) {
              nftId = new NftId(
                  tokenIdOrNftId,
                  /** @type {Long} */ (senderAccountIdOrSerialNumber),
              );
              senderAccountId =
                  typeof receiverAccountIdOrSenderAccountId === "string"
                      ? AccountId.fromString(receiverAccountIdOrSenderAccountId)
                      : /** @type {AccountId} */ (
                            receiverAccountIdOrSenderAccountId
                        );
              receiverAccountId =
                  typeof receiver === "string"
                      ? AccountId.fromString(receiver)
                      : /** @type {AccountId} */ (receiver);
          } else {
              try {
                  nftId = NftId.fromString(tokenIdOrNftId);
                  senderAccountId =
                      typeof senderAccountIdOrSerialNumber === "string"
                          ? AccountId.fromString(senderAccountIdOrSerialNumber)
                          : /** @type {AccountId} */ (
                                senderAccountIdOrSerialNumber
                            );
                  receiverAccountId =
                      typeof receiverAccountIdOrSenderAccountId === "string"
                          ? AccountId.fromString(
                                receiverAccountIdOrSenderAccountId,
                            )
                          : /** @type {AccountId} */ (
                                receiverAccountIdOrSenderAccountId
                            );
              } catch (_) {
                  const tokenId = TokenId.fromString(tokenIdOrNftId);
                  nftId = new NftId(
                      tokenId,
                      /** @type {Long} */ (senderAccountIdOrSerialNumber),
                  );
                  senderAccountId =
                      typeof receiverAccountIdOrSenderAccountId === "string"
                          ? AccountId.fromString(
                                receiverAccountIdOrSenderAccountId,
                            )
                          : /** @type {AccountId} */ (
                                receiverAccountIdOrSenderAccountId
                            );
                  receiverAccountId =
                      typeof receiver === "string"
                          ? AccountId.fromString(receiver)
                          : /** @type {AccountId} */ (receiver);
              }
          }

          for (const nftTransfer of this._nftTransfers) {
              if (
                  nftTransfer.tokenId.compare(nftId.tokenId) === 0 &&
                  nftTransfer.serialNumber.compare(nftId.serial) === 0
              ) {
                  nftTransfer.senderAccountId = senderAccountId;
                  nftTransfer.receiverAccountId = receiverAccountId;
                  return this;
              }
          }

          this._nftTransfers.push(
              new TokenNftTransfer({
                  tokenId: nftId.tokenId,
                  serialNumber: nftId.serial,
                  senderAccountId,
                  receiverAccountId,
                  isApproved,
              }),
          );

          return this;
      }

      /**
       * @param {NftId | TokenId | string} tokenIdOrNftId
       * @param {AccountId | string | Long | number} senderAccountIdOrSerialNumber
       * @param {AccountId | string} receiverAccountIdOrSenderAccountId
       * @param {(AccountId | string)=} receiver
       * @returns {this}
       */
      addApprovedNftTransfer(
          tokenIdOrNftId,
          senderAccountIdOrSerialNumber,
          receiverAccountIdOrSenderAccountId,
          receiver,
      ) {
          return this._addNftTransfer(
              true,
              tokenIdOrNftId,
              senderAccountIdOrSerialNumber,
              receiverAccountIdOrSenderAccountId,
              receiver,
          );
      }

      /**
       * @param {TokenId | string} tokenId
       * @param {AccountId | string} accountId
       * @param {number | Long | BigNumber | bigint} amount
       * @returns {this}
       */
      addApprovedTokenTransfer(tokenId, accountId, amount) {
          return this._addTokenTransfer(tokenId, accountId, amount, true, null);
      }

      /**
       * @param {TokenId | string} tokenId
       * @param {AccountId | string} accountId
       * @param {number | Long | BigNumber | bigint} amount
       * @param {number} decimals
       * @returns {this}
       */
      addTokenTransferWithDecimals(tokenId, accountId, amount, decimals) {
          this._requireNotFrozen();

          const token =
              tokenId instanceof TokenId ? tokenId : TokenId.fromString(tokenId);
          const account =
              accountId instanceof AccountId
                  ? accountId
                  : AccountId.fromString(accountId);
          const value = convertAmountToLong(amount);

          let found = false;

          for (const tokenTransfer of this._tokenTransfers) {
              if (tokenTransfer.tokenId.compare(token) === 0) {
                  if (
                      tokenTransfer.expectedDecimals != null &&
                      tokenTransfer.expectedDecimals !== decimals
                  ) {
                      throw new Error("expected decimals mis-match");
                  } else {
                      tokenTransfer.expectedDecimals = decimals;
                  }

                  if (tokenTransfer.accountId.compare(account) === 0) {
                      tokenTransfer.amount = tokenTransfer.amount.add(value);
                      tokenTransfer.expectedDecimals = decimals;
                      found = true;
                  }
              }
          }

          if (found) {
              return this;
          }

          this._tokenTransfers.push(
              new TokenTransfer({
                  tokenId,
                  accountId,
                  expectedDecimals: decimals,
                  amount,
                  isApproved: false,
              }),
          );

          return this;
      }

      /**
       * @returns {NullableTokenDecimalMap}
       */
      get tokenIdDecimals() {
          const map = new NullableTokenDecimalMap();

          for (const transfer of this._tokenTransfers) {
              map._set(transfer.tokenId, transfer.expectedDecimals);
          }

          return map;
      }

      /**
       * @returns {TokenNftTransferMap}
       */
      get nftTransfers() {
          const map = new TokenNftTransferMap();

          for (const transfer of this._nftTransfers) {
              const transferList = map.get(transfer.tokenId);

              const nftTransfer = {
                  sender: transfer.senderAccountId,
                  recipient: transfer.receiverAccountId,
                  serial: transfer.serialNumber,
                  isApproved: transfer.isApproved,
              };

              if (transferList != null) {
                  transferList.push(nftTransfer);
              } else {
                  map._set(transfer.tokenId, [nftTransfer]);
              }
          }

          return map;
      }

      /**
       * @returns {TokenTransferMap}
       */
      get tokenTransfers() {
          const map = new TokenTransferMap();

          for (const transfer of this._tokenTransfers) {
              let transferMap = map.get(transfer.tokenId);

              if (transferMap != null) {
                  transferMap._set(transfer.accountId, transfer.amount);
              } else {
                  transferMap = new TokenTransferAccountMap();
                  transferMap._set(transfer.accountId, transfer.amount);
                  map._set(transfer.tokenId, transferMap);
              }
          }

          return map;
      }

      /**
       * @override
       * @protected
       * @returns {HieroProto.proto.ITokenAirdropTransactionBody}
       */
      _makeTransactionData() {
          /** @type {{tokenId: TokenId; expectedDecimals: number | null; transfers: TokenTransfer[]; nftTransfers: TokenNftTransfer[];}[]} */
          const tokenTransferList = [];

          this._tokenTransfers.sort((a, b) => {
              const compare = a.tokenId.compare(b.tokenId);

              if (compare !== 0) {
                  return compare;
              }

              return a.accountId.compare(b.accountId);
          });

          this._nftTransfers.sort((a, b) => {
              const senderComparision = a.senderAccountId.compare(
                  b.senderAccountId,
              );
              if (senderComparision != 0) {
                  return senderComparision;
              }

              const recipientComparision = a.receiverAccountId.compare(
                  b.receiverAccountId,
              );
              if (recipientComparision != 0) {
                  return recipientComparision;
              }

              return a.serialNumber.compare(b.serialNumber);
          });

          let i = 0;
          let j = 0;
          while (
              i < this._tokenTransfers.length ||
              j < this._nftTransfers.length
          ) {
              if (
                  i < this._tokenTransfers.length &&
                  j < this._nftTransfers.length
              ) {
                  const iTokenId = this._tokenTransfers[i].tokenId;
                  const jTokenId = this._nftTransfers[j].tokenId;

                  const last =
                      tokenTransferList.length > 0
                          ? tokenTransferList[tokenTransferList.length - 1]
                          : null;
                  const lastTokenId = last != null ? last.tokenId : null;

                  if (
                      last != null &&
                      lastTokenId != null &&
                      lastTokenId.compare(iTokenId) === 0
                  ) {
                      last.transfers.push(this._tokenTransfers[i++]);
                      continue;
                  }

                  if (
                      last != null &&
                      lastTokenId != null &&
                      lastTokenId.compare(jTokenId) === 0
                  ) {
                      last.nftTransfers.push(this._nftTransfers[j++]);
                      continue;
                  }

                  const result = iTokenId.compare(jTokenId);

                  if (result === 0) {
                      tokenTransferList.push({
                          tokenId: iTokenId,
                          expectedDecimals:
                              this._tokenTransfers[i].expectedDecimals,
                          transfers: [this._tokenTransfers[i++]],
                          nftTransfers: [this._nftTransfers[j++]],
                      });
                  } else if (result < 0) {
                      tokenTransferList.push({
                          tokenId: iTokenId,
                          expectedDecimals:
                              this._tokenTransfers[i].expectedDecimals,
                          transfers: [this._tokenTransfers[i++]],
                          nftTransfers: [],
                      });
                  } else {
                      tokenTransferList.push({
                          tokenId: jTokenId,
                          expectedDecimals: null,
                          transfers: [],
                          nftTransfers: [this._nftTransfers[j++]],
                      });
                  }
              } else if (i < this._tokenTransfers.length) {
                  const iTokenId = this._tokenTransfers[i].tokenId;

                  let last;
                  for (const transfer of tokenTransferList) {
                      if (transfer.tokenId.compare(iTokenId) === 0) {
                          last = transfer;
                      }
                  }
                  const lastTokenId = last != null ? last.tokenId : null;

                  if (
                      last != null &&
                      lastTokenId != null &&
                      lastTokenId.compare(iTokenId) === 0
                  ) {
                      last.transfers.push(this._tokenTransfers[i++]);
                      continue;
                  }

                  tokenTransferList.push({
                      tokenId: iTokenId,
                      expectedDecimals: this._tokenTransfers[i].expectedDecimals,
                      transfers: [this._tokenTransfers[i++]],
                      nftTransfers: [],
                  });
              } else if (j < this._nftTransfers.length) {
                  const jTokenId = this._nftTransfers[j].tokenId;

                  let last;
                  for (const transfer of tokenTransferList) {
                      if (transfer.tokenId.compare(jTokenId) === 0) {
                          last = transfer;
                      }
                  }
                  const lastTokenId = last != null ? last.tokenId : null;

                  if (
                      last != null &&
                      lastTokenId != null &&
                      lastTokenId.compare(jTokenId) === 0
                  ) {
                      last.nftTransfers.push(this._nftTransfers[j++]);
                      continue;
                  }

                  tokenTransferList.push({
                      tokenId: jTokenId,
                      expectedDecimals: null,
                      transfers: [],
                      nftTransfers: [this._nftTransfers[j++]],
                  });
              }
          }

          return {
              tokenTransfers: tokenTransferList.map((tokenTransfer) => {
                  return {
                      token: tokenTransfer.tokenId._toProtobuf(),
                      expectedDecimals:
                          tokenTransfer.expectedDecimals != null
                              ? { value: tokenTransfer.expectedDecimals }
                              : null,
                      transfers: tokenTransfer.transfers.map((transfer) =>
                          transfer._toProtobuf(),
                      ),
                      nftTransfers: tokenTransfer.nftTransfers.map((transfer) =>
                          transfer._toProtobuf(),
                      ),
                  };
              }),
          };
      }
  }

  // SPDX-License-Identifier: Apache-2.0

  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITokenAirdropTransactionBody} HieroProto.proto.ITokenAirdropTransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   * @typedef {import("@hashgraph/proto").proto.TransactionID} HieroProto.proto.TransactionID
   * @typedef {import("@hashgraph/proto").proto.AccountID} HieroProto.proto.AccountID
   * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   * @typedef {import("../account/AccountId.js").default} AccountId
   * @typedef {import("./NftId.js").default} NftId
   * @typedef {import("./TokenId.js").default} TokenId
   * @typedef {import("bignumber.js").default} BigNumber
   */

  /**
   * Airdrop one or more tokens to one or more accounts.
   *
   * ### Effects
   * This distributes tokens from the balance of one or more sending account(s)
   * to the balance of one or more recipient accounts. Accounts MAY receive the
   * tokens in one of four ways.
   *
   *  - An account already associated to the token to be distributed SHALL
   *    receive the airdropped tokens immediately to the recipient account
   *    balance.<br/>
   *    The fee for this transfer SHALL include the transfer, the airdrop fee,
   *    and any custom fees.
   *  - An account with available automatic association slots SHALL be
   *    automatically associated to the token, and SHALL immediately receive
   *    the airdropped tokens to the recipient account balance.<br/>
   *    The fee for this transfer SHALL include the transfer, the association,
   *    the cost to renew that association once, the airdrop fee, and
   *    any custom fees.
   *  - An account with "receiver signature required" set SHALL have a
   *    "Pending Airdrop" created and must claim that airdrop with a
   *    `claimAirdrop` transaction.<br/>
   *    The fee for this transfer SHALL include the transfer, the association,
   *    the cost to renew that association once, the airdrop fee, and
   *    any custom fees.<br/>
   *    If the pending airdrop is not claimed immediately, the `sender` SHALL
   *    pay the cost to renew the token association, and the cost to maintain
   *    the pending airdrop, until the pending airdrop is claimed or cancelled.
   *  - An account with no available automatic association slots SHALL have a
   *    "Pending Airdrop" created and must claim that airdrop with a
   *    `claimAirdrop` transaction.<br/>
   *    The fee for this transfer SHALL include the transfer, the association,
   *    the cost to renew that association once, the airdrop fee, and any custom
   *    fees.<br/>
   *    If the pending airdrop is not claimed immediately, the `sender` SHALL
   *    pay the cost to renew the token association, and the cost to maintain
   *    the pending airdrop, until the pending airdrop is claimed or cancelled.
   *
   * If an airdrop would create a pending airdrop for a fungible/common token,
   * and a pending airdrop for the same sender, receiver, and token already
   * exists, the existing pending airdrop SHALL be updated to add the new
   * amount to the existing airdrop, rather than creating
   * a new pending airdrop.<br/>
   * Any airdrop that completes immediately SHALL be irreversible. Any airdrop
   * that results in a "Pending Airdrop" MAY be canceled via a `cancelAirdrop`
   * transaction.<br/>
   * All transfer fees (including custom fees and royalties), as well as the
   * rent cost for the first auto-renewal period for any automatic-association
   * slot occupied by the airdropped tokens, SHALL be charged to the account
   * paying for this transaction.<br/>
   */
  class TokenAirdropTransaction extends AbstractTokenTransferTransaction {
      /**
       * @param {object} props
       * @param {TokenTransfer[]} [props.tokenTransfers]
       * @param {NftTransfer[]} [props.nftTransfers]
       */
      constructor(props = {}) {
          super();

          if (props.tokenTransfers != null) {
              for (const tokenTransfer of props.tokenTransfers) {
                  this._addTokenTransfer(
                      tokenTransfer.tokenId,
                      tokenTransfer.accountId,
                      tokenTransfer.amount,
                      tokenTransfer.isApproved,
                      tokenTransfer.expectedDecimals,
                  );
              }
          }
          /**
           * @private
           * @type {NftTransfer[]}
           */
          this._nftTransfers = [];
          if (props.nftTransfers != null) {
              for (const nftTransfer of props.nftTransfers) {
                  this._addNftTransfer(
                      nftTransfer.isApproved,
                      nftTransfer.tokenId,
                      nftTransfer.serialNumber,
                      nftTransfer.senderAccountId,
                      nftTransfer.receiverAccountId,
                  );
              }
          }
      }

      /**
       *
       * @param {TokenId} tokenId
       * @param {AccountId} accountId
       * @param {Long | number | BigNumber | bigint} amount
       * @param {number} expectedDecimals
       * @returns {this}
       */
      addApprovedTokenTransferWithDecimals(
          tokenId,
          accountId,
          amount,
          expectedDecimals,
      ) {
          this._requireNotFrozen();
          this._addTokenTransfer(
              tokenId,
              accountId,
              amount,
              true,
              expectedDecimals,
          );
          return this;
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransaction[]} transactions
       * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {HieroProto.proto.ITransactionBody[]} bodies
       * @returns {TokenAirdropTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];
          const tokenAirdrop =
              /** @type {HieroProto.proto.ITokenAirdropTransactionBody} */ (
                  body.tokenAirdrop
              );

          const tokenTransfers = TokenTransfer._fromProtobuf(
              tokenAirdrop.tokenTransfers ?? [],
          );
          const nftTransfers = TokenNftTransfer._fromProtobuf(
              tokenAirdrop.tokenTransfers ?? [],
          );

          return Transaction._fromProtobufTransactions(
              new TokenAirdropTransaction({
                  nftTransfers: nftTransfers,
                  tokenTransfers: tokenTransfers,
              }),
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.ITransaction} request
       * @returns {Promise<HieroProto.proto.ITransactionResponse>}
       */
      _execute(channel, request) {
          return channel.token.airdropTokens(request);
      }

      /**
       * @override
       * @protected
       * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "tokenAirdrop";
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("../Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `TokenAirdropTransaction:${timestamp.toString()}`;
      }
  }

  TRANSACTION_REGISTRY.set(
      "tokenAirdrop",
      // eslint-disable-next-line @typescript-eslint/unbound-method
      TokenAirdropTransaction._fromProtobuf,
  );

  // SPDX-License-Identifier: Apache-2.0

  /**
   * @typedef {import("../token/PendingAirdropId.js").default} PendingAirdropId
   */
  class AirdropPendingTransaction extends Transaction {
      /**
       * @param {object} [props]
       * @param {PendingAirdropId[]} [props.pendingAirdropIds]
       */
      constructor(props) {
          /**
           * @private
           * @type {PendingAirdropId[]}
           */
          super();

          /**
           * @private
           * @type {PendingAirdropId[]}
           */
          this._pendingAirdropIds = [];

          if (props?.pendingAirdropIds != null) {
              this._pendingAirdropIds = props.pendingAirdropIds;
          }
      }

      /**
       * @returns {PendingAirdropId[]}
       */
      get pendingAirdropIds() {
          return this._pendingAirdropIds;
      }

      /**
       *
       * @param {PendingAirdropId} pendingAirdropId
       * @returns {this}
       */
      addPendingAirdropId(pendingAirdropId) {
          this._requireNotFrozen();
          this._pendingAirdropIds.push(pendingAirdropId);
          return this;
      }

      /**
       *
       * @param {PendingAirdropId[]} pendingAirdropIds
       * @returns {this}
       */
      setPendingAirdropIds(pendingAirdropIds) {
          this._requireNotFrozen();
          this._pendingAirdropIds = pendingAirdropIds;
          return this;
      }
  }

  // SPDX-License-Identifier: Apache-2.0

  /**
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITokenClaimAirdropTransactionBody} HieroProto.proto.ITokenClaimAirdropTransactionBody
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   * @typedef {import("../account/AccountId.js").default} AccountId
   */

  /**
   * A transaction that allows an account to claim tokens from a pending airdrop.
   * This transaction is used to finalize the receipt of tokens that were distributed
   * through an airdrop mechanism but require explicit claiming by the recipient.
   */
  class TokenClaimAirdropTransaction extends AirdropPendingTransaction {
      /**
       * @param {object} props
       * @param {PendingAirdropId[]} [props.pendingAirdropIds]
       */
      constructor(props = {}) {
          super(props);
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.ITransaction} request
       * @returns {Promise<HieroProto.proto.ITransactionResponse>}
       */
      _execute(channel, request) {
          return channel.token.claimAirdrop(request);
      }

      /**
       * @override
       * @internal
       * @returns {HieroProto.proto.ITokenClaimAirdropTransactionBody}
       */
      _makeTransactionData() {
          return {
              pendingAirdrops: this.pendingAirdropIds.map((pendingAirdropId) =>
                  pendingAirdropId.toBytes(),
              ),
          };
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransaction[]} transactions
       * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {HieroProto.proto.ITransactionBody[]} bodies
       * @returns {TokenClaimAirdropTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];
          const { pendingAirdrops } =
              /** @type {HieroProto.proto.ITokenClaimAirdropTransactionBody} */ (
                  body.tokenClaimAirdrop
              );

          return Transaction._fromProtobufTransactions(
              new TokenClaimAirdropTransaction({
                  pendingAirdropIds: pendingAirdrops?.map((pendingAirdrop) => {
                      return PendingAirdropId.fromBytes(pendingAirdrop);
                  }),
              }),
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * @override
       * @protected
       * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "tokenClaimAirdrop";
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("../Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `TokenClaimAirdropTransaction:${timestamp.toString()}`;
      }
  }

  TRANSACTION_REGISTRY.set(
      "tokenClaimAirdrop",
      // eslint-disable-next-line @typescript-eslint/unbound-method
      TokenClaimAirdropTransaction._fromProtobuf,
  );

  // SPDX-License-Identifier: Apache-2.0

  /**
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITokenCancelAirdropTransactionBody} HieroProto.proto.ITokenCancelAirdropTransactionBody
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   * @typedef {import("../account/AccountId.js").default} AccountId
   */

  /**
   * A transaction that allows the cancellation of pending airdrops.
   * This transaction can be used by authorized accounts to cancel airdrop operations
   * that have been initiated but not yet claimed by recipients.
   */
  class TokenCancelAirdropTransaction extends AirdropPendingTransaction {
      /**
       * @param {object} props
       * @param {PendingAirdropId[]} [props.pendingAirdropIds]
       */
      constructor(props = {}) {
          super(props);
      }

      /**
       * @override
       * @internal
       * @returns {HieroProto.proto.ITokenCancelAirdropTransactionBody}
       */
      _makeTransactionData() {
          return {
              pendingAirdrops: this.pendingAirdropIds.map((pendingAirdropId) =>
                  pendingAirdropId.toBytes(),
              ),
          };
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.ITransaction} request
       * @returns {Promise<HieroProto.proto.ITransactionResponse>}
       */
      _execute(channel, request) {
          return channel.token.cancelAirdrop(request);
      }

      /**
       * @override
       * @protected
       * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "tokenCancelAirdrop";
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransaction[]} transactions
       * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {HieroProto.proto.ITransactionBody[]} bodies
       * @returns {TokenCancelAirdropTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];
          const { pendingAirdrops } =
              /** @type {HieroProto.proto.ITokenCancelAirdropTransactionBody} */ (
                  body.tokenCancelAirdrop
              );

          return Transaction._fromProtobufTransactions(
              new TokenCancelAirdropTransaction({
                  pendingAirdropIds: pendingAirdrops?.map((pendingAirdrop) => {
                      return PendingAirdropId.fromBytes(pendingAirdrop);
                  }),
              }),
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("../Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `TokenCancelAirdrop:${timestamp.toString()}`;
      }
  }

  TRANSACTION_REGISTRY.set(
      "tokenCancelAirdrop",
      // eslint-disable-next-line @typescript-eslint/unbound-method
      TokenCancelAirdropTransaction._fromProtobuf,
  );

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.IGrantedCryptoAllowance} HieroProto.proto.IGrantedCryptoAllowance
   * @typedef {import("@hashgraph/proto").proto.ICryptoAllowance} HieroProto.proto.ICryptoAllowance
   * @typedef {import("@hashgraph/proto").proto.IAccountID} HieroProto.proto.IAccountID
   */

  /**
   * @typedef {import("long")} Long
   */

  /**
   * @typedef {import("../client/Client.js").default<*, *>} Client
   */

  /**
   * Represents an HBAR allowance granted to a spender account by an owner account.
   * This class manages the permissions for one account to spend HBAR on behalf of another account.
   */
  class HbarAllowance {
      /**
       * @internal
       * @param {object} props
       * @param {AccountId | null} props.spenderAccountId
       * @param {AccountId | null} props.ownerAccountId
       * @param {Hbar | null} props.amount
       */
      constructor(props) {
          /**
           * The account ID of the hbar allowance spender.
           *
           * @readonly
           */
          this.spenderAccountId = props.spenderAccountId;

          /**
           * The account ID of the hbar allowance owner.
           *
           * @readonly
           */
          this.ownerAccountId = props.ownerAccountId;

          /**
           * The current balance of the spender's allowance in tinybars.
           *
           * @readonly
           */
          this.amount = props.amount;

          Object.freeze(this);
      }

      /**
       * @internal
       * @param {HieroProto.proto.ICryptoAllowance} allowance
       * @returns {HbarAllowance}
       */
      static _fromProtobuf(allowance) {
          return new HbarAllowance({
              spenderAccountId: AccountId._fromProtobuf(
                  /** @type {HieroProto.proto.IAccountID} */ (allowance.spender),
              ),
              ownerAccountId:
                  allowance.owner != null
                      ? AccountId._fromProtobuf(
                            /**@type {HieroProto.proto.IAccountID}*/ (
                                allowance.owner
                            ),
                        )
                      : null,
              amount: Hbar.fromTinybars(
                  allowance.amount != null ? allowance.amount : 0,
              ),
          });
      }

      /**
       * @internal
       * @param {HieroProto.proto.IGrantedCryptoAllowance} allowance
       * @param {AccountId} ownerAccountId
       * @returns {HbarAllowance}
       */
      static _fromGrantedProtobuf(allowance, ownerAccountId) {
          return new HbarAllowance({
              spenderAccountId: AccountId._fromProtobuf(
                  /** @type {HieroProto.proto.IAccountID} */ (allowance.spender),
              ),
              ownerAccountId,
              amount: Hbar.fromTinybars(
                  allowance.amount != null ? allowance.amount : 0,
              ),
          });
      }

      /**
       * @internal
       * @returns {HieroProto.proto.ICryptoAllowance}
       */
      _toProtobuf() {
          return {
              owner:
                  this.ownerAccountId != null
                      ? this.ownerAccountId._toProtobuf()
                      : null,
              spender:
                  this.spenderAccountId != null
                      ? this.spenderAccountId._toProtobuf()
                      : null,
              amount: this.amount != null ? this.amount.toTinybars() : null,
          };
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          if (this.spenderAccountId != null) {
              this.spenderAccountId.validateChecksum(client);
          }

          if (this.spenderAccountId != null) {
              this.spenderAccountId.validateChecksum(client);
          }
      }

      /**
       * @returns {object}
       */
      toJSON() {
          return {
              ownerAccountId:
                  this.ownerAccountId != null
                      ? this.ownerAccountId.toString()
                      : null,
              spenderAccountId:
                  this.spenderAccountId != null
                      ? this.spenderAccountId.toString()
                      : null,
              amount: this.amount != null ? this.amount.toString() : null,
          };
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.IGrantedTokenAllowance} HieroProto.proto.IGrantedTokenAllowance
   * @typedef {import("@hashgraph/proto").proto.ITokenAllowance} HieroProto.proto.ITokenAllowance
   * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
   * @typedef {import("@hashgraph/proto").proto.IAccountID} HieroProto.proto.IAccountID
   */

  /**
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("bignumber.js").default} BigNumber
   */

  /**
   * Represents a token allowance granted to a spender account by an owner account.
   *
   * The `TokenAllowance` class manages the permissions for one account to spend a specified
   * amount of tokens on behalf of another account. It includes details about the token, the
   * spender, the owner, and the amount allowed.
   */
  class TokenAllowance {
      /**
       * @internal
       * @param {object} props
       * @param {TokenId} props.tokenId
       * @param {AccountId | null} props.spenderAccountId
       * @param {AccountId | null} props.ownerAccountId
       * @param {Long | number | BigNumber | bigint | null} props.amount
       */
      constructor(props) {
          /**
           * The token that the allowance pertains to.
           *
           * @readonly
           */
          this.tokenId = props.tokenId;

          /**
           * The account ID of the spender of the hbar allowance.
           *
           * @readonly
           */
          this.spenderAccountId = props.spenderAccountId;

          /**
           * The account ID of the owner of the hbar allowance.
           *
           * @readonly
           */
          this.ownerAccountId = props.ownerAccountId;

          /**
           * The current balance of the spender's token allowance.
           * **NOTE**: If `null`, the spender has access to all of the account owner's NFT instances
           * (currently owned and any in the future).
           *
           * @readonly
           */
          this.amount =
              props.amount != null ? convertAmountToLong(props.amount) : null;

          Object.freeze(this);
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITokenAllowance} allowance
       * @returns {TokenAllowance}
       */
      static _fromProtobuf(allowance) {
          return new TokenAllowance({
              tokenId: TokenId._fromProtobuf(
                  /** @type {HieroProto.proto.ITokenID} */ (allowance.tokenId),
              ),
              spenderAccountId: AccountId._fromProtobuf(
                  /** @type {HieroProto.proto.IAccountID} */ (allowance.spender),
              ),
              ownerAccountId:
                  allowance.owner != null
                      ? AccountId._fromProtobuf(
                            /**@type {HieroProto.proto.IAccountID}*/ (
                                allowance.owner
                            ),
                        )
                      : null,
              amount:
                  allowance.amount != null
                      ? Long.fromValue(/** @type {Long} */ (allowance.amount))
                      : null,
          });
      }

      /**
       * @internal
       * @param {HieroProto.proto.IGrantedTokenAllowance} allowance
       * @param {AccountId} ownerAccountId
       * @returns {TokenAllowance}
       */
      static _fromGrantedProtobuf(allowance, ownerAccountId) {
          return new TokenAllowance({
              tokenId: TokenId._fromProtobuf(
                  /** @type {HieroProto.proto.ITokenID} */ (allowance.tokenId),
              ),
              spenderAccountId: AccountId._fromProtobuf(
                  /** @type {HieroProto.proto.IAccountID} */ (allowance.spender),
              ),
              ownerAccountId,
              amount:
                  allowance.amount != null
                      ? Long.fromValue(/** @type {Long} */ (allowance.amount))
                      : null,
          });
      }

      /**
       * @internal
       * @returns {HieroProto.proto.ITokenAllowance}
       */
      _toProtobuf() {
          return {
              tokenId: this.tokenId._toProtobuf(),
              spender:
                  this.spenderAccountId != null
                      ? this.spenderAccountId._toProtobuf()
                      : null,
              owner:
                  this.ownerAccountId != null
                      ? this.ownerAccountId._toProtobuf()
                      : null,
              amount: this.amount,
          };
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          this.tokenId.validateChecksum(client);

          if (this.ownerAccountId != null) {
              this.ownerAccountId.validateChecksum(client);
          }

          if (this.spenderAccountId != null) {
              this.spenderAccountId.validateChecksum(client);
          }
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.IGrantedNftAllowance} HieroProto.proto.IGrantedNftAllowance
   * @typedef {import("@hashgraph/proto").proto.INftRemoveAllowance} HieroProto.proto.INftRemoveAllowance
   * @typedef {import("@hashgraph/proto").proto.INftAllowance} HieroProto.proto.INftAllowance
   * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
   * @typedef {import("@hashgraph/proto").proto.IAccountID} HieroProto.proto.IAccountID
   */

  /**
   * @typedef {import("../client/Client.js").default<*, *>} Client
   */

  /**
   * The token that the allowance pertains to.
   */
  class TokenNftAllowance {
      /**
       * @internal
       * @param {object} props
       * @param {TokenId} props.tokenId
       * @param {AccountId | null} props.spenderAccountId
       * @param {AccountId | null} props.ownerAccountId
       * @param {Long[] | null} props.serialNumbers
       * @param {boolean | null} props.allSerials
       * @param {AccountId | null} props.delegatingSpender
       */
      constructor(props) {
          /**
           * @readonly
           */
          this.tokenId = props.tokenId;

          /**
           * The account ID of the spender of the hbar allowance.
           *
           * @readonly
           */
          this.spenderAccountId = props.spenderAccountId;

          /**
           * The account ID of the owner of the hbar allowance.
           *
           * @readonly
           */
          this.ownerAccountId = props.ownerAccountId;

          /**
           * The current balance of the spender's token allowance.
           * **NOTE**: If `null`, the spender has access to all of the account owner's NFT instances
           * (currently owned and any in the future).
           *
           * @readonly
           */
          this.serialNumbers = props.serialNumbers;

          /**
           * @readonly
           */
          this.allSerials = props.allSerials;

          /**
           * The account ID of the spender who is granted approvedForAll allowance and granting
           * approval on an NFT serial to another spender.
           *
           * @readonly
           */
          this.delegatingSpender = props.delegatingSpender;

          Object.freeze(this);
      }

      /**
       * @internal
       * @param {HieroProto.proto.INftAllowance} allowance
       * @returns {TokenNftAllowance}
       */
      static _fromProtobuf(allowance) {
          const allSerials =
              allowance.approvedForAll != null &&
              allowance.approvedForAll.value == true;
          return new TokenNftAllowance({
              tokenId: TokenId._fromProtobuf(
                  /** @type {HieroProto.proto.ITokenID} */ (allowance.tokenId),
              ),
              spenderAccountId:
                  allowance.spender != null
                      ? AccountId._fromProtobuf(
                            /** @type {HieroProto.proto.IAccountID} */ (
                                allowance.spender
                            ),
                        )
                      : null,
              ownerAccountId:
                  allowance.owner != null
                      ? AccountId._fromProtobuf(
                            /**@type {HieroProto.proto.IAccountID}*/ (
                                allowance.owner
                            ),
                        )
                      : null,
              serialNumbers: allSerials
                  ? null
                  : allowance.serialNumbers != null
                  ? allowance.serialNumbers.map((serialNumber) =>
                        Long.fromValue(serialNumber),
                    )
                  : [],
              allSerials,
              delegatingSpender:
                  allowance.delegatingSpender != null
                      ? AccountId._fromProtobuf(
                            /**@type {HieroProto.proto.IAccountID}*/ (
                                allowance.delegatingSpender
                            ),
                        )
                      : null,
          });
      }

      /**
       * @internal
       * @param {HieroProto.proto.IGrantedNftAllowance} allowance
       * @param {AccountId} ownerAccountId
       * @returns {TokenNftAllowance}
       */
      static _fromGrantedProtobuf(allowance, ownerAccountId) {
          return new TokenNftAllowance({
              tokenId: TokenId._fromProtobuf(
                  /** @type {HieroProto.proto.ITokenID} */ (allowance.tokenId),
              ),
              spenderAccountId: AccountId._fromProtobuf(
                  /** @type {HieroProto.proto.IAccountID} */ (allowance.spender),
              ),
              ownerAccountId,
              serialNumbers: [],
              allSerials: null,
              delegatingSpender: null,
          });
      }

      /**
       * @internal
       * @param {HieroProto.proto.INftRemoveAllowance} allowance
       * @returns {TokenNftAllowance}
       */
      static _fromRemoveProtobuf(allowance) {
          return new TokenNftAllowance({
              tokenId: TokenId._fromProtobuf(
                  /** @type {HieroProto.proto.ITokenID} */ (allowance.tokenId),
              ),
              spenderAccountId: null,
              ownerAccountId:
                  allowance.owner != null
                      ? AccountId._fromProtobuf(
                            /**@type {HieroProto.proto.IAccountID}*/ (
                                allowance.owner
                            ),
                        )
                      : null,
              serialNumbers:
                  allowance.serialNumbers != null
                      ? allowance.serialNumbers.map((serialNumber) =>
                            Long.fromValue(serialNumber),
                        )
                      : [],
              allSerials: null,
              delegatingSpender: null,
          });
      }

      /**
       * @internal
       * @returns {HieroProto.proto.INftAllowance}
       */
      _toProtobuf() {
          return {
              tokenId: this.tokenId._toProtobuf(),
              spender:
                  this.spenderAccountId != null
                      ? this.spenderAccountId._toProtobuf()
                      : null,
              owner:
                  this.ownerAccountId != null
                      ? this.ownerAccountId._toProtobuf()
                      : null,
              approvedForAll:
                  this.serialNumbers == null ? { value: this.allSerials } : null,
              serialNumbers: this.serialNumbers,
              delegatingSpender:
                  this.delegatingSpender != null
                      ? this.delegatingSpender._toProtobuf()
                      : null,
          };
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          this.tokenId.validateChecksum(client);

          if (this.ownerAccountId != null) {
              this.ownerAccountId.validateChecksum(client);
          }

          if (this.spenderAccountId != null) {
              this.spenderAccountId.validateChecksum(client);
          }
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
   * @typedef {import("@hashgraph/proto").proto.IAccountID} HieroProto.proto.IAccountID
   * @typedef {import("@hashgraph/proto").proto.IContractID} HieroProto.proto.IContractID
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   * @typedef {import("bignumber.js").default} BigNumber
   * @typedef {import("../long.js").LongObject} LongObject
   */

  /**
   * @deprecated - No longer supported via Hedera Protobufs
   * Change properties for the given account.
   */
  class AccountAllowanceAdjustTransaction extends Transaction {
      /**
       * @param {object} [props]
       * @param {HbarAllowance[]} [props.hbarAllowances]
       * @param {TokenAllowance[]} [props.tokenAllowances]
       * @param {TokenNftAllowance[]} [props.nftAllowances]
       */
      constructor(props = {}) {
          super();

          /**
           * @private
           * @type {HbarAllowance[]}
           */
          this._hbarAllowances =
              props.hbarAllowances != null ? props.hbarAllowances : [];

          /**
           * @private
           * @type {TokenAllowance[]}
           */
          this._tokenAllowances =
              props.tokenAllowances != null ? props.tokenAllowances : [];

          /**
           * @private
           * @type {TokenNftAllowance[]}
           */
          this._nftAllowances =
              props.nftAllowances != null ? props.nftAllowances : [];
      }

      /**
       * @returns {HbarAllowance[]}
       */
      get hbarAllowances() {
          return this._hbarAllowances;
      }

      /**
       * @deprecated
       * @param {AccountId | string} spenderAccountId
       * @param {number | string | Long | LongObject | BigNumber | Hbar} amount
       * @returns {AccountAllowanceAdjustTransaction}
       */
      addHbarAllowance(spenderAccountId, amount) {
          const value = amount instanceof Hbar ? amount : new Hbar(amount);
          return this._adjustHbarAllowance(
              null,
              spenderAccountId,
              requireNotNegative(value),
          );
      }

      /**
       * @param {AccountId | string | null} ownerAccountId
       * @param {AccountId | ContractId | string} spenderAccountId
       * @param {Hbar} amount
       * @returns {AccountAllowanceAdjustTransaction}
       */
      _adjustHbarAllowance(ownerAccountId, spenderAccountId, amount) {
          this._requireNotFrozen();

          this._hbarAllowances.push(
              new HbarAllowance({
                  spenderAccountId:
                      typeof spenderAccountId === "string"
                          ? AccountId.fromString(spenderAccountId)
                          : spenderAccountId instanceof ContractId
                          ? AccountId.fromEvmAddress(
                                spenderAccountId.shard,
                                spenderAccountId.realm,
                                spenderAccountId.toEvmAddress(),
                            )
                          : spenderAccountId,
                  ownerAccountId:
                      typeof ownerAccountId === "string"
                          ? AccountId.fromString(ownerAccountId)
                          : ownerAccountId instanceof ContractId
                          ? AccountId.fromEvmAddress(
                                ownerAccountId.shard,
                                ownerAccountId.realm,
                                ownerAccountId.toEvmAddress(),
                            )
                          : ownerAccountId,
                  amount: amount,
              }),
          );

          return this;
      }

      /**
       * @deprecated
       * @param {AccountId | string} ownerAccountId
       * @param {AccountId | string} spenderAccountId
       * @param {number | string | Long | LongObject | BigNumber | Hbar} amount
       * @returns {AccountAllowanceAdjustTransaction}
       */
      grantHbarAllowance(ownerAccountId, spenderAccountId, amount) {
          const value = amount instanceof Hbar ? amount : new Hbar(amount);
          return this._adjustHbarAllowance(
              ownerAccountId,
              spenderAccountId,
              requireNotNegative(value),
          );
      }

      /**
       * @deprecated
       * @param {AccountId | string} ownerAccountId
       * @param {AccountId | string} spenderAccountId
       * @param {number | string | Long | LongObject | BigNumber | Hbar} amount
       * @returns {AccountAllowanceAdjustTransaction}
       */
      revokeHbarAllowance(ownerAccountId, spenderAccountId, amount) {
          const value = amount instanceof Hbar ? amount : new Hbar(amount);
          return this._adjustHbarAllowance(
              ownerAccountId,
              spenderAccountId,
              requireNotNegative(value).negated(),
          );
      }

      /**
       * @returns {TokenAllowance[]}
       */
      get tokenAllowances() {
          return this._tokenAllowances;
      }

      /**
       * @deprecated
       * @param {TokenId | string} tokenId
       * @param {AccountId | string} spenderAccountId
       * @param {Long | number} amount
       * @returns {AccountAllowanceAdjustTransaction}
       */
      addTokenAllowance(tokenId, spenderAccountId, amount) {
          return this._adjustTokenAllowance(
              tokenId,
              null,
              spenderAccountId,
              requireNotNegative(Long.fromValue(amount)),
          );
      }

      /**
       * @param {TokenId | string} tokenId
       * @param {AccountId | string | null} ownerAccountId
       * @param {AccountId | ContractId | string} spenderAccountId
       * @param {Long | number} amount
       * @returns {AccountAllowanceAdjustTransaction}
       */
      _adjustTokenAllowance(tokenId, ownerAccountId, spenderAccountId, amount) {
          this._requireNotFrozen();

          this._tokenAllowances.push(
              new TokenAllowance({
                  tokenId:
                      typeof tokenId === "string"
                          ? TokenId.fromString(tokenId)
                          : tokenId,
                  spenderAccountId:
                      typeof spenderAccountId === "string"
                          ? AccountId.fromString(spenderAccountId)
                          : spenderAccountId instanceof ContractId
                          ? AccountId.fromEvmAddress(
                                spenderAccountId.shard,
                                spenderAccountId.realm,
                                spenderAccountId.toEvmAddress(),
                            )
                          : spenderAccountId,
                  ownerAccountId:
                      typeof ownerAccountId === "string"
                          ? AccountId.fromString(ownerAccountId)
                          : ownerAccountId instanceof ContractId
                          ? AccountId.fromEvmAddress(
                                ownerAccountId.shard,
                                ownerAccountId.realm,
                                ownerAccountId.toEvmAddress(),
                            )
                          : ownerAccountId,
                  amount:
                      typeof amount === "number"
                          ? Long.fromNumber(amount)
                          : amount,
              }),
          );

          return this;
      }

      /**
       * @deprecated
       * @param {TokenId | string} tokenId
       * @param {AccountId | string} ownerAccountId
       * @param {AccountId | string} spenderAccountId
       * @param {Long | number} amount
       * @returns {AccountAllowanceAdjustTransaction}
       */
      grantTokenAllowance(tokenId, ownerAccountId, spenderAccountId, amount) {
          return this._adjustTokenAllowance(
              tokenId,
              ownerAccountId,
              spenderAccountId,
              requireNotNegative(Long.fromValue(amount)),
          );
      }

      /**
       * @deprecated
       * @param {TokenId | string} tokenId
       * @param {AccountId | string} ownerAccountId
       * @param {AccountId | string} spenderAccountId
       * @param {Long | number} amount
       * @returns {AccountAllowanceAdjustTransaction}
       */
      revokeTokenAllowance(tokenId, ownerAccountId, spenderAccountId, amount) {
          return this._adjustTokenAllowance(
              tokenId,
              ownerAccountId,
              spenderAccountId,
              requireNotNegative(Long.fromValue(amount)),
          );
      }

      /**
       * @deprecated
       * @param {NftId | string} nftId
       * @param {AccountId | string} spenderAccountId
       * @returns {AccountAllowanceAdjustTransaction}
       */
      addTokenNftAllowance(nftId, spenderAccountId) {
          const id = typeof nftId === "string" ? NftId.fromString(nftId) : nftId;
          return this._adjustTokenNftAllowance(id, null, spenderAccountId);
      }

      /**
       * @param {NftId} nftId
       * @param {AccountId | string | null} ownerAccountId
       * @param {AccountId | ContractId | string} spenderAccountId
       * @returns {AccountAllowanceAdjustTransaction}
       */
      _adjustTokenNftAllowance(nftId, ownerAccountId, spenderAccountId) {
          this._requireNotFrozen();

          const spender =
              typeof spenderAccountId === "string"
                  ? AccountId.fromString(spenderAccountId)
                  : spenderAccountId instanceof ContractId
                  ? AccountId.fromEvmAddress(
                        spenderAccountId.shard,
                        spenderAccountId.realm,
                        spenderAccountId.toEvmAddress(),
                    )
                  : spenderAccountId;
          const owner =
              typeof ownerAccountId === "string"
                  ? AccountId.fromString(ownerAccountId)
                  : ownerAccountId instanceof ContractId
                  ? AccountId.fromEvmAddress(
                        ownerAccountId.shard,
                        ownerAccountId.realm,
                        ownerAccountId.toEvmAddress(),
                    )
                  : ownerAccountId;
          let found = false;

          for (const allowance of this._nftAllowances) {
              if (
                  allowance.tokenId.compare(nftId.tokenId) === 0 &&
                  allowance.spenderAccountId != null &&
                  allowance.spenderAccountId.compare(spender) === 0
              ) {
                  if (allowance.serialNumbers != null) {
                      allowance.serialNumbers.push(nftId.serial);
                  }
                  found = true;
                  break;
              }
          }

          if (!found) {
              this._nftAllowances.push(
                  new TokenNftAllowance({
                      tokenId: nftId.tokenId,
                      spenderAccountId: spender,
                      serialNumbers: [nftId.serial],
                      ownerAccountId: owner,
                      allSerials: false,
                      delegatingSpender: null,
                  }),
              );
          }

          return this;
      }

      /**
       * @deprecated
       * @param {NftId | string} nftId
       * @param {AccountId | string} ownerAccountId
       * @param {AccountId | string} spenderAccountId
       * @returns {AccountAllowanceAdjustTransaction}
       */
      grantTokenNftAllowance(nftId, ownerAccountId, spenderAccountId) {
          const id = typeof nftId === "string" ? NftId.fromString(nftId) : nftId;

          requireNotNegative(id.serial);

          return this._adjustTokenNftAllowance(
              id,
              ownerAccountId,
              spenderAccountId,
          );
      }

      /**
       * @deprecated
       * @param {NftId | string} nftId
       * @param {AccountId | string} ownerAccountId
       * @param {AccountId | string} spenderAccountId
       * @returns {AccountAllowanceAdjustTransaction}
       */
      revokeTokenNftAllowance(nftId, ownerAccountId, spenderAccountId) {
          const id = typeof nftId === "string" ? NftId.fromString(nftId) : nftId;

          requireNotNegative(id.serial);
          return this._adjustTokenNftAllowance(
              new NftId(id.tokenId, id.serial.negate()),
              ownerAccountId,
              spenderAccountId,
          );
      }

      /**
       * @deprecated - use `grantTokenNftAllowanceAllSerials()` instead
       * @param {TokenId | string} tokenId
       * @param {AccountId | string} spenderAccountId
       * @returns {AccountAllowanceAdjustTransaction}
       */
      addAllTokenNftAllowance(tokenId, spenderAccountId) {
          return this._adjustTokenNftAllowanceAllSerials(
              tokenId,
              null,
              spenderAccountId,
              true,
          );
      }

      /**
       * @deprecated
       * @param {TokenId | string} tokenId
       * @param {AccountId | string} ownerAccountId
       * @param {AccountId | string} spenderAccountId
       * @returns {AccountAllowanceAdjustTransaction}
       */
      grantTokenNftAllowanceAllSerials(
          tokenId,
          ownerAccountId,
          spenderAccountId,
      ) {
          return this._adjustTokenNftAllowanceAllSerials(
              tokenId,
              ownerAccountId,
              spenderAccountId,
              true,
          );
      }

      /**
       * @deprecated
       * @param {TokenId | string} tokenId
       * @param {AccountId | string} ownerAccountId
       * @param {AccountId | string} spenderAccountId
       * @returns {AccountAllowanceAdjustTransaction}
       */
      revokeTokenNftAllowanceAllSerials(
          tokenId,
          ownerAccountId,
          spenderAccountId,
      ) {
          return this._adjustTokenNftAllowanceAllSerials(
              tokenId,
              ownerAccountId,
              spenderAccountId,
              false,
          );
      }

      /**
       * @param {TokenId | string} tokenId
       * @param {AccountId | string | null} ownerAccountId
       * @param {AccountId | ContractId | string} spenderAccountId
       * @param {boolean} allSerials
       * @returns {AccountAllowanceAdjustTransaction}
       */
      _adjustTokenNftAllowanceAllSerials(
          tokenId,
          ownerAccountId,
          spenderAccountId,
          allSerials,
      ) {
          this._requireNotFrozen();

          this._nftAllowances.push(
              new TokenNftAllowance({
                  tokenId:
                      typeof tokenId === "string"
                          ? TokenId.fromString(tokenId)
                          : tokenId,
                  ownerAccountId:
                      ownerAccountId != null
                          ? typeof ownerAccountId === "string"
                              ? AccountId.fromString(ownerAccountId)
                              : ownerAccountId instanceof ContractId
                              ? AccountId.fromEvmAddress(
                                    ownerAccountId.shard,
                                    ownerAccountId.realm,
                                    ownerAccountId.toEvmAddress(),
                                )
                              : ownerAccountId
                          : null,
                  spenderAccountId:
                      typeof spenderAccountId === "string"
                          ? AccountId.fromString(spenderAccountId)
                          : spenderAccountId instanceof ContractId
                          ? AccountId.fromEvmAddress(
                                spenderAccountId.shard,
                                spenderAccountId.realm,
                                spenderAccountId.toEvmAddress(),
                            )
                          : spenderAccountId,
                  serialNumbers: null,
                  allSerials,
                  delegatingSpender: null,
              }),
          );

          return this;
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          this._hbarAllowances.map((allowance) =>
              allowance._validateChecksums(client),
          );
          this._tokenAllowances.map((allowance) =>
              allowance._validateChecksums(client),
          );
          this._nftAllowances.map((allowance) =>
              allowance._validateChecksums(client),
          );
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.ITransaction} request
       * @returns {Promise<HieroProto.proto.ITransactionResponse>}
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _execute(channel, request) {
          return Promise.reject(
              new Error("This feature has been deprecated for this class."),
          );
      }

      // eslint-disable-next-line jsdoc/require-returns-check
      /**
       * @deprecated
       * @override
       * @protected
       * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          throw new Error("This feature has been deprecated for this class.");
      }

      // eslint-disable-next-line jsdoc/require-returns-check
      /**
       * @override
       * @protected
       * @returns {object}
       */
      _makeTransactionData() {
          throw new Error("This feature has been deprecated.");
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("../Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `AccountAllowanceAdjustTransaction:${timestamp.toString()}`;
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
   * @typedef {import("@hashgraph/proto").proto.ICryptoApproveAllowanceTransactionBody} HieroProto.proto.ICryptoApproveAllowanceTransactionBody
   * @typedef {import("@hashgraph/proto").proto.IAccountID} HieroProto.proto.IAccountID
   * @typedef {import("@hashgraph/proto").proto.IContractID} HieroProto.proto.IContractID
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   * @typedef {import("bignumber.js").default} BigNumber
   * @typedef {import("../long.js").LongObject} LongObject
   */

  /**
   * Change properties for the given account.
   */
  class AccountAllowanceApproveTransaction extends Transaction {
      /**
       * @param {object} [props]
       * @param {HbarAllowance[]} [props.hbarApprovals]
       * @param {TokenAllowance[]} [props.tokenApprovals]
       * @param {TokenNftAllowance[]} [props.nftApprovals]
       */
      constructor(props = {}) {
          super();

          /**
           * @private
           * @type {HbarAllowance[]}
           */
          this._hbarApprovals =
              props.hbarApprovals != null ? props.hbarApprovals : [];

          /**
           * @private
           * @type {TokenAllowance[]}
           */
          this._tokenApprovals =
              props.tokenApprovals != null ? props.tokenApprovals : [];

          /**
           * @private
           * @type {TokenNftAllowance[]}
           */
          this._nftApprovals =
              props.nftApprovals != null ? props.nftApprovals : [];
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransaction[]} transactions
       * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {HieroProto.proto.ITransactionBody[]} bodies
       * @returns {AccountAllowanceApproveTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];
          const allowanceApproval =
              /** @type {HieroProto.proto.ICryptoApproveAllowanceTransactionBody} */ (
                  body.cryptoApproveAllowance
              );

          return Transaction._fromProtobufTransactions(
              new AccountAllowanceApproveTransaction({
                  hbarApprovals: (allowanceApproval.cryptoAllowances != null
                      ? allowanceApproval.cryptoAllowances
                      : []
                  ).map((approval) => HbarAllowance._fromProtobuf(approval)),
                  tokenApprovals: (allowanceApproval.tokenAllowances != null
                      ? allowanceApproval.tokenAllowances
                      : []
                  ).map((approval) => TokenAllowance._fromProtobuf(approval)),
                  nftApprovals: (allowanceApproval.nftAllowances != null
                      ? allowanceApproval.nftAllowances
                      : []
                  ).map((approval) => TokenNftAllowance._fromProtobuf(approval)),
              }),
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * @returns {HbarAllowance[]}
       */
      get hbarApprovals() {
          return this._hbarApprovals;
      }

      /**
       * @param {AccountId | string} ownerAccountId
       * @param {AccountId | ContractId | string} spenderAccountId
       * @param {number | string | Long | LongObject | BigNumber | Hbar} amount
       * @returns {AccountAllowanceApproveTransaction}
       */
      approveHbarAllowance(ownerAccountId, spenderAccountId, amount) {
          this._requireNotFrozen();

          this._hbarApprovals.push(
              new HbarAllowance({
                  spenderAccountId:
                      typeof spenderAccountId === "string"
                          ? AccountId.fromString(spenderAccountId)
                          : spenderAccountId instanceof ContractId
                          ? AccountId.fromEvmAddress(
                                spenderAccountId.shard,
                                spenderAccountId.realm,
                                spenderAccountId.toEvmAddress(),
                            )
                          : spenderAccountId,
                  ownerAccountId:
                      typeof ownerAccountId === "string"
                          ? AccountId.fromString(ownerAccountId)
                          : ownerAccountId instanceof ContractId
                          ? AccountId.fromEvmAddress(
                                ownerAccountId.shard,
                                ownerAccountId.realm,
                                ownerAccountId.toEvmAddress(),
                            )
                          : ownerAccountId,
                  amount: amount instanceof Hbar ? amount : new Hbar(amount),
              }),
          );

          return this;
      }

      /**
       * @deprecated - Use `approveHbarAllowance()` instead
       * @param {AccountId | string} spenderAccountId
       * @param {number | string | Long | LongObject | BigNumber | Hbar} amount
       * @returns {AccountAllowanceApproveTransaction}
       */
      addHbarAllowance(spenderAccountId, amount) {
          this._requireNotFrozen();

          this._hbarApprovals.push(
              new HbarAllowance({
                  spenderAccountId:
                      typeof spenderAccountId === "string"
                          ? AccountId.fromString(spenderAccountId)
                          : spenderAccountId,
                  amount: amount instanceof Hbar ? amount : new Hbar(amount),
                  ownerAccountId: null,
              }),
          );

          return this;
      }

      /**
       * @returns {TokenAllowance[]}
       */
      get tokenApprovals() {
          return this._tokenApprovals;
      }

      /**
       * @param {TokenId | string} tokenId
       * @param {AccountId | string} ownerAccountId
       * @param {AccountId | ContractId | string} spenderAccountId
       * @param {Long | number | BigNumber | bigint} amount
       * @returns {AccountAllowanceApproveTransaction}
       */
      approveTokenAllowance(tokenId, ownerAccountId, spenderAccountId, amount) {
          this._requireNotFrozen();

          // Convert amount to Long
          const amountLong = convertAmountToLong(amount);

          this._tokenApprovals.push(
              new TokenAllowance({
                  tokenId:
                      typeof tokenId === "string"
                          ? TokenId.fromString(tokenId)
                          : tokenId,
                  spenderAccountId:
                      typeof spenderAccountId === "string"
                          ? AccountId.fromString(spenderAccountId)
                          : spenderAccountId instanceof ContractId
                          ? AccountId.fromEvmAddress(
                                spenderAccountId.shard,
                                spenderAccountId.realm,
                                spenderAccountId.toEvmAddress(),
                            )
                          : spenderAccountId,
                  ownerAccountId:
                      typeof ownerAccountId === "string"
                          ? AccountId.fromString(ownerAccountId)
                          : ownerAccountId instanceof ContractId
                          ? AccountId.fromEvmAddress(
                                ownerAccountId.shard,
                                ownerAccountId.realm,
                                ownerAccountId.toEvmAddress(),
                            )
                          : ownerAccountId,
                  amount: amountLong,
              }),
          );

          return this;
      }

      /**
       * @deprecated - Use `approveTokenAllowance()` instead
       * @param {TokenId | string} tokenId
       * @param {AccountId | string} spenderAccountId
       * @param {Long | number | BigNumber | bigint} amount
       * @returns {AccountAllowanceApproveTransaction}
       */
      addTokenAllowance(tokenId, spenderAccountId, amount) {
          this._requireNotFrozen();

          // Convert amount to Long
          const amountLong = convertAmountToLong(amount);

          this._tokenApprovals.push(
              new TokenAllowance({
                  tokenId:
                      typeof tokenId === "string"
                          ? TokenId.fromString(tokenId)
                          : tokenId,
                  spenderAccountId:
                      typeof spenderAccountId === "string"
                          ? AccountId.fromString(spenderAccountId)
                          : spenderAccountId,
                  amount: amountLong,
                  ownerAccountId: null,
              }),
          );

          return this;
      }

      /**
       * @deprecated - Use `approveTokenNftAllowance()` instead
       * @param {NftId | string} nftId
       * @param {AccountId | ContractId | string} spenderAccountId
       * @returns {AccountAllowanceApproveTransaction}
       */
      addTokenNftAllowance(nftId, spenderAccountId) {
          return this._approveTokenNftAllowance(
              nftId,
              null,
              spenderAccountId,
              null,
          );
      }

      /**
       * @returns {TokenNftAllowance[]}
       */
      get tokenNftApprovals() {
          return this._nftApprovals;
      }

      /**
       * @param {NftId | string} nftId
       * @param {AccountId | string | null} ownerAccountId
       * @param {AccountId | ContractId | string} spenderAccountId
       * @param {AccountId | string | null} delegatingSpender
       * @returns {AccountAllowanceApproveTransaction}
       */
      _approveTokenNftAllowance(
          nftId,
          ownerAccountId,
          spenderAccountId,
          delegatingSpender,
      ) {
          this._requireNotFrozen();

          const id = typeof nftId === "string" ? NftId.fromString(nftId) : nftId;
          const spender =
              typeof spenderAccountId === "string"
                  ? AccountId.fromString(spenderAccountId)
                  : spenderAccountId instanceof ContractId
                  ? AccountId.fromEvmAddress(
                        spenderAccountId.shard,
                        spenderAccountId.realm,
                        spenderAccountId.toEvmAddress(),
                    )
                  : spenderAccountId;
          let found = false;

          for (const allowance of this._nftApprovals) {
              if (
                  allowance.tokenId.compare(id.tokenId) === 0 &&
                  allowance.spenderAccountId != null &&
                  allowance.spenderAccountId.compare(spender) === 0
              ) {
                  if (allowance.serialNumbers != null) {
                      allowance.serialNumbers.push(id.serial);
                  }
                  found = true;
                  break;
              }
          }

          if (!found) {
              this._nftApprovals.push(
                  new TokenNftAllowance({
                      tokenId: id.tokenId,
                      spenderAccountId: spender,
                      ownerAccountId:
                          typeof ownerAccountId === "string"
                              ? AccountId.fromString(ownerAccountId)
                              : ownerAccountId instanceof ContractId
                              ? AccountId.fromEvmAddress(
                                    ownerAccountId.shard,
                                    ownerAccountId.realm,
                                    ownerAccountId.toEvmAddress(),
                                )
                              : ownerAccountId,
                      serialNumbers: [id.serial],
                      allSerials: false,
                      delegatingSpender:
                          typeof delegatingSpender === "string"
                              ? AccountId.fromString(delegatingSpender)
                              : delegatingSpender,
                  }),
              );
          }

          return this;
      }

      /**
       * @param {NftId | string} nftId
       * @param {AccountId | string} ownerAccountId
       * @param {AccountId | ContractId | string} spenderAccountId
       * @returns {AccountAllowanceApproveTransaction}
       */
      approveTokenNftAllowance(nftId, ownerAccountId, spenderAccountId) {
          return this._approveTokenNftAllowance(
              nftId,
              ownerAccountId,
              spenderAccountId,
              null,
          );
      }

      /**
       * @param {NftId | string} nftId
       * @param {AccountId | string} ownerAccountId
       * @param {AccountId | ContractId | string} spenderAccountId
       * @param {AccountId | string} delegatingSpender
       * @returns {AccountAllowanceApproveTransaction}
       */
      approveTokenNftAllowanceWithDelegatingSpender(
          nftId,
          ownerAccountId,
          spenderAccountId,
          delegatingSpender,
      ) {
          return this._approveTokenNftAllowance(
              nftId,
              ownerAccountId,
              spenderAccountId,
              delegatingSpender,
          );
      }

      /**
       * @param {TokenId | string} tokenId
       * @param {AccountId | string | null} ownerAccountId
       * @param {AccountId | ContractId | string} spenderAccountId
       * @param {boolean} allSerials
       * @returns {AccountAllowanceApproveTransaction}
       */
      _approveAllTokenNftAllowance(
          tokenId,
          ownerAccountId,
          spenderAccountId,
          allSerials,
      ) {
          this._requireNotFrozen();

          this._nftApprovals.push(
              new TokenNftAllowance({
                  tokenId:
                      typeof tokenId === "string"
                          ? TokenId.fromString(tokenId)
                          : tokenId,
                  spenderAccountId:
                      typeof spenderAccountId === "string"
                          ? AccountId.fromString(spenderAccountId)
                          : spenderAccountId instanceof ContractId
                          ? AccountId.fromEvmAddress(
                                spenderAccountId.shard,
                                spenderAccountId.realm,
                                spenderAccountId.toEvmAddress(),
                            )
                          : spenderAccountId,
                  ownerAccountId:
                      typeof ownerAccountId === "string"
                          ? AccountId.fromString(ownerAccountId)
                          : ownerAccountId instanceof ContractId
                          ? AccountId.fromEvmAddress(
                                ownerAccountId.shard,
                                ownerAccountId.realm,
                                ownerAccountId.toEvmAddress(),
                            )
                          : ownerAccountId,
                  serialNumbers: null,
                  allSerials,
                  delegatingSpender: null,
              }),
          );

          return this;
      }

      /**
       * @deprecated - Use `approveTokenNftAllowanceAllSerials()` instead
       * @param {TokenId | string} tokenId
       * @param {AccountId | string} ownerAccountId
       * @param {AccountId | string} spenderAccountId
       * @returns {AccountAllowanceApproveTransaction}
       */
      addAllTokenNftAllowance(tokenId, ownerAccountId, spenderAccountId) {
          return this._approveAllTokenNftAllowance(
              tokenId,
              ownerAccountId,
              spenderAccountId,
              true,
          );
      }

      /**
       * @param {TokenId | string} tokenId
       * @param {AccountId | string} ownerAccountId
       * @param {AccountId | ContractId | string} spenderAccountId
       * @returns {AccountAllowanceApproveTransaction}
       */
      approveTokenNftAllowanceAllSerials(
          tokenId,
          ownerAccountId,
          spenderAccountId,
      ) {
          return this._approveAllTokenNftAllowance(
              tokenId,
              ownerAccountId,
              spenderAccountId,
              true,
          );
      }

      /**
       * @param {TokenId | string} tokenId
       * @param {AccountId | string} ownerAccountId
       * @param {AccountId | ContractId | string} spenderAccountId
       * @returns {AccountAllowanceApproveTransaction}
       */
      deleteTokenNftAllowanceAllSerials(
          tokenId,
          ownerAccountId,
          spenderAccountId,
      ) {
          return this._approveAllTokenNftAllowance(
              tokenId,
              ownerAccountId,
              spenderAccountId,
              false,
          );
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          this._hbarApprovals.map((approval) =>
              approval._validateChecksums(client),
          );
          this._tokenApprovals.map((approval) =>
              approval._validateChecksums(client),
          );
          this._nftApprovals.map((approval) =>
              approval._validateChecksums(client),
          );
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.ITransaction} request
       * @returns {Promise<HieroProto.proto.ITransactionResponse>}
       */
      _execute(channel, request) {
          return channel.crypto.approveAllowances(request);
      }

      /**
       * @override
       * @protected
       * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "cryptoApproveAllowance";
      }

      /**
       * @override
       * @protected
       * @returns {HieroProto.proto.ICryptoApproveAllowanceTransactionBody}
       */
      _makeTransactionData() {
          return {
              cryptoAllowances: this._hbarApprovals.map((approval) =>
                  approval._toProtobuf(),
              ),
              tokenAllowances: this._tokenApprovals.map((approval) =>
                  approval._toProtobuf(),
              ),
              nftAllowances: this._nftApprovals.map((approval) =>
                  approval._toProtobuf(),
              ),
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("../Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `AccountAllowanceApproveTransaction:${timestamp.toString()}`;
      }
  }

  TRANSACTION_REGISTRY.set(
      "cryptoApproveAllowance",
      // eslint-disable-next-line @typescript-eslint/unbound-method
      AccountAllowanceApproveTransaction._fromProtobuf,
  );

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
   * @typedef {import("@hashgraph/proto").proto.ICryptoDeleteAllowanceTransactionBody} HieroProto.proto.ICryptoDeleteAllowanceTransactionBody
   * @typedef {import("@hashgraph/proto").proto.IAccountID} HieroProto.proto.IAccountID
   */

  /**
   * @typedef {import("./HbarAllowance.js").default} HbarAllowance
   * @typedef {import("./TokenAllowance.js").default} TokenAllowance
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   * @typedef {import("bignumber.js").default} BigNumber
   * @typedef {import("../long.js").LongObject} LongObject
   */

  /**
   * Change properties for the given account.
   */
  class AccountAllowanceDeleteTransaction extends Transaction {
      /**
       * @param {object} [props]
       * @param {HbarAllowance[]} [props.hbarAllowances]
       * @param {TokenAllowance[]} [props.tokenAllowances]
       * @param {TokenNftAllowance[]} [props.nftAllowances]
       */
      constructor(props = {}) {
          super();

          /**
           * @private
           * @type {TokenNftAllowance[]}
           */
          this._nftAllowances =
              props.nftAllowances != null ? props.nftAllowances : [];
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransaction[]} transactions
       * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {HieroProto.proto.ITransactionBody[]} bodies
       * @returns {AccountAllowanceDeleteTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];
          const allowance =
              /** @type {HieroProto.proto.ICryptoDeleteAllowanceTransactionBody} */ (
                  body.cryptoDeleteAllowance
              );

          return Transaction._fromProtobufTransactions(
              new AccountAllowanceDeleteTransaction({
                  nftAllowances: (allowance.nftAllowances != null
                      ? allowance.nftAllowances
                      : []
                  ).map((allowance) =>
                      TokenNftAllowance._fromProtobuf(allowance),
                  ),
              }),
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * @returns {TokenNftAllowance[]}
       */
      get tokenNftAllowanceDeletions() {
          return this._nftAllowances;
      }

      /**
       * @description If you want to remove allowance for all serials of a NFT
       *      - use AccountAllowanceApproveTransaction().deleteTokenNftAllowanceAllSerials()
       * @param {NftId | string} nftId
       * @param {AccountId | string} ownerAccountId
       * @returns {AccountAllowanceDeleteTransaction}
       */
      deleteAllTokenNftAllowances(nftId, ownerAccountId) {
          this._requireNotFrozen();

          const id = typeof nftId === "string" ? NftId.fromString(nftId) : nftId;

          const owner =
              typeof ownerAccountId === "string"
                  ? AccountId.fromString(ownerAccountId)
                  : ownerAccountId;
          let found = false;

          for (const allowance of this._nftAllowances) {
              if (allowance.tokenId.compare(id.tokenId) === 0) {
                  if (allowance.serialNumbers != null) {
                      allowance.serialNumbers.push(id.serial);
                  }
                  found = true;
                  break;
              }
          }

          if (!found) {
              this._nftAllowances.push(
                  new TokenNftAllowance({
                      tokenId: id.tokenId,
                      spenderAccountId: null,
                      serialNumbers: [id.serial],
                      ownerAccountId: owner,
                      allSerials: false,
                      delegatingSpender: null,
                  }),
              );
          }

          return this;
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          this._nftAllowances.map((allowance) =>
              allowance._validateChecksums(client),
          );
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.ITransaction} request
       * @returns {Promise<HieroProto.proto.ITransactionResponse>}
       */
      _execute(channel, request) {
          return channel.crypto.deleteAllowances(request);
      }

      /**
       * @override
       * @protected
       * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "cryptoDeleteAllowance";
      }

      /**
       * @override
       * @protected
       * @returns {HieroProto.proto.ICryptoDeleteAllowanceTransactionBody}
       */
      _makeTransactionData() {
          return {
              nftAllowances: this._nftAllowances.map((allowance) =>
                  allowance._toProtobuf(),
              ),
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("../Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `AccountAllowanceDeleteTransaction:${timestamp.toString()}`;
      }
  }

  TRANSACTION_REGISTRY.set(
      "cryptoDeleteAllowance",
      // eslint-disable-next-line @typescript-eslint/unbound-method
      AccountAllowanceDeleteTransaction._fromProtobuf,
  );

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITokenBalance} HieroProto.proto.ITokenBalance
   * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
   */

  /**
   * @typedef {import("long")} Long
   */

  /**
   * @augments {ObjectMap<TokenId, Long>}
   */
  class TokenBalanceMap extends ObjectMap {
      constructor() {
          super((s) => TokenId.fromString(s));
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITokenBalance} HieroProto.proto.ITokenBalance
   * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
   */

  /**
   * @augments {ObjectMap<TokenId, number>}
   */
  class TokenDecimalMap extends ObjectMap {
      constructor() {
          super((s) => TokenId.fromString(s));
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {object} TokenBalanceJson
   * @property {string} tokenId
   * @property {string} balance
   * @property {number} decimals
   */

  /**
   * @typedef {object} AccountBalanceJson
   * @property {string} hbars
   * @property {TokenBalanceJson[]} tokens
   */

  /**
   * Represents the balance of an account on the Hedera network, including both HBAR and token balances.
   */
  class AccountBalance {
      /**
       * @private
       * @param {object} props
       * @param {Hbar} props.hbars
       * @param {?TokenBalanceMap} props.tokens
       * @param {?TokenDecimalMap} props.tokenDecimals
       */
      constructor(props) {
          /**
           * The Hbar balance of the account
           *
           * @readonly
           */
          this.hbars = props.hbars;

          this.tokens = props.tokens;

          this.tokenDecimals = props.tokenDecimals;

          Object.freeze(this);
      }

      /**
       * @param {Uint8Array} bytes
       * @returns {AccountBalance}
       */
      static fromBytes(bytes) {
          return AccountBalance._fromProtobuf(
              libExports.proto.CryptoGetAccountBalanceResponse.decode(bytes),
          );
      }

      /**
       * @internal
       * @param {HieroProto.proto.ICryptoGetAccountBalanceResponse} accountBalance
       * @returns {AccountBalance}
       */
      static _fromProtobuf(accountBalance) {
          const tokenBalances = new TokenBalanceMap();
          const tokenDecimals = new TokenDecimalMap();

          if (accountBalance.tokenBalances != null) {
              for (const balance of accountBalance.tokenBalances) {
                  const tokenId = TokenId._fromProtobuf(
                      /** @type {HieroProto.proto.ITokenID} */ (balance.tokenId),
                  );

                  tokenDecimals._set(
                      tokenId,
                      balance.decimals != null ? balance.decimals : 0,
                  );
                  tokenBalances._set(
                      tokenId,
                      Long.fromValue(/** @type {Long} */ (balance.balance)),
                  );
              }
          }

          return new AccountBalance({
              hbars: Hbar.fromTinybars(
                  /** @type {Long} */ (accountBalance.balance),
              ),
              tokens: tokenBalances,
              tokenDecimals,
          });
      }

      /**
       * @returns {HieroProto.proto.ICryptoGetAccountBalanceResponse}
       */
      _toProtobuf() {
          /** @type {HieroProto.proto.ITokenBalance[]} */
          const list = [];

          // eslint-disable-next-line deprecation/deprecation
          for (const [key, value] of this.tokens != null ? this.tokens : []) {
              list.push({
                  tokenId: key._toProtobuf(),
                  balance: value,
                  decimals:
                      // eslint-disable-next-line deprecation/deprecation
                      this.tokenDecimals != null
                          ? // eslint-disable-next-line deprecation/deprecation
                            this.tokenDecimals.get(key)
                          : null,
              });
          }

          return {
              balance: this.hbars.toTinybars(),
              tokenBalances: list,
          };
      }

      /**
       * @returns {Uint8Array}
       */
      toBytes() {
          return libExports.proto.CryptoGetAccountBalanceResponse.encode(
              this._toProtobuf(),
          ).finish();
      }

      /**
       * @returns {string}
       */
      toString() {
          return JSON.stringify(this.toJSON());
      }

      /**
       * @returns {AccountBalanceJson}
       */
      toJSON() {
          const tokens = [];
          // eslint-disable-next-line deprecation/deprecation
          for (const [key, value] of this.tokens != null ? this.tokens : []) {
              const decimals =
                  // eslint-disable-next-line deprecation/deprecation
                  this.tokenDecimals != null ? this.tokenDecimals.get(key) : null;

              tokens.push({
                  tokenId: key.toString(),
                  balance: value.toString(),
                  decimals: decimals != null ? decimals : 0,
              });
          }

          return {
              hbars: this.hbars.toString(),
              tokens,
          };
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.IQuery} HieroProto.proto.IQuery
   * @typedef {import("@hashgraph/proto").proto.IQueryHeader} HieroProto.proto.IQueryHeader
   * @typedef {import("@hashgraph/proto").proto.IResponse} HieroProto.proto.IResponse
   * @typedef {import("@hashgraph/proto").proto.IResponseHeader} HieroProto.proto.IResponseHeader
   * @typedef {import("@hashgraph/proto").proto.ICryptoGetAccountBalanceQuery} HieroProto.proto.ICryptoGetAccountBalanceQuery
   * @typedef {import("@hashgraph/proto").proto.ICryptoGetAccountBalanceResponse} HieroProto.proto.ICryptoGetAccountBalanceResponse
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   */

  /**
   * Get the balance of a Hedera crypto-currency account.
   *
   * This returns only the balance, so its a smaller and faster reply
   * than AccountInfoQuery.
   *
   * This query is free.
   *
   * @augments {Query<AccountBalance>}
   */
  class AccountBalanceQuery extends Query {
      /**
       * @param {object} [props]
       * @param {AccountId | string} [props.accountId]
       * @param {ContractId | string} [props.contractId]
       */
      constructor(props = {}) {
          super();

          /**
           * @type {?AccountId}
           * @private
           */
          this._accountId = null;

          /**
           * @type {?ContractId}
           * @private
           */
          this._contractId = null;

          if (props.accountId != null) {
              this.setAccountId(props.accountId);
          }

          if (props.contractId != null) {
              this.setContractId(props.contractId);
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.IQuery} query
       * @returns {AccountBalanceQuery}
       */
      static _fromProtobuf(query) {
          const balance =
              /** @type {HieroProto.proto.ICryptoGetAccountBalanceQuery} */ (
                  query.cryptogetAccountBalance
              );

          return new AccountBalanceQuery({
              accountId:
                  balance.accountID != null
                      ? AccountId._fromProtobuf(balance.accountID)
                      : undefined,
              contractId:
                  balance.contractID != null
                      ? ContractId._fromProtobuf(balance.contractID)
                      : undefined,
          });
      }

      /**
       * @returns {?AccountId}
       */
      get accountId() {
          return this._accountId;
      }

      /**
       * Set the account ID for which the balance is being requested.
       *
       * This is mutually exclusive with `setContractId`.
       *
       * @param {AccountId | string} accountId
       * @returns {this}
       */
      setAccountId(accountId) {
          this._accountId =
              typeof accountId === "string"
                  ? AccountId.fromString(accountId)
                  : accountId.clone();

          return this;
      }

      /**
       * @returns {?ContractId}
       */
      get contractId() {
          return this._contractId;
      }

      /**
       * Set the contract ID for which the balance is being requested.
       *
       * This is mutually exclusive with `setAccountId`.
       *
       * @param {ContractId | string} contractId
       * @returns {this}
       */
      setContractId(contractId) {
          this._contractId =
              typeof contractId === "string"
                  ? ContractId.fromString(contractId)
                  : contractId.clone();

          return this;
      }

      /**
       * @protected
       * @override
       * @returns {boolean}
       */
      _isPaymentRequired() {
          return false;
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          if (this._accountId != null) {
              this._accountId.validateChecksum(client);
          }

          if (this._contractId != null) {
              this._contractId.validateChecksum(client);
          }
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.IQuery} request
       * @returns {Promise<HieroProto.proto.IResponse>}
       */
      _execute(channel, request) {
          return channel.crypto.cryptoGetBalance(request);
      }

      /**
       * @override
       * @override
       * @internal
       * @param {HieroProto.proto.IResponse} response
       * @returns {HieroProto.proto.IResponseHeader}
       */
      _mapResponseHeader(response) {
          const cryptogetAccountBalance =
              /** @type {HieroProto.proto.ICryptoGetAccountBalanceResponse} */ (
                  response.cryptogetAccountBalance
              );
          return /** @type {HieroProto.proto.IResponseHeader} */ (
              cryptogetAccountBalance.header
          );
      }

      /**
       * @override
       * @override
       * @internal
       * @param {HieroProto.proto.IResponse} response
       * @param {AccountId} nodeAccountId
       * @param {HieroProto.proto.IQuery} request
       * @returns {Promise<AccountBalance>}
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _mapResponse(response, nodeAccountId, request) {
          const cryptogetAccountBalance =
              /** @type {HieroProto.proto.ICryptoGetAccountBalanceResponse} */ (
                  response.cryptogetAccountBalance
              );
          return Promise.resolve(
              AccountBalance._fromProtobuf(cryptogetAccountBalance),
          );
      }

      /**
       * @override
       * @internal
       * @param {HieroProto.proto.IQueryHeader} header
       * @returns {HieroProto.proto.IQuery}
       */
      _onMakeRequest(header) {
          return {
              cryptogetAccountBalance: {
                  header,
                  accountID:
                      this._accountId != null
                          ? this._accountId._toProtobuf()
                          : null,
                  contractID:
                      this._contractId != null
                          ? this._contractId._toProtobuf()
                          : null,
              },
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          return `AccountBalanceQuery:${this._timestamp.toString()}`;
      }
  }

  QUERY_REGISTRY.set(
      "cryptogetAccountBalance",
      // eslint-disable-next-line @typescript-eslint/unbound-method
      AccountBalanceQuery._fromProtobuf,
  );

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.IDuration} HieroProto.proto.IDuration
   */

  /**
   * A duration type.
   *
   * The main point of this tyope is for encapsulating the `[to|from]Protobuf()` implementations
   */
  class Duration {
      /**
       * @param {Long | number} seconds
       */
      constructor(seconds) {
          /**
           * @readonly
           * @type {Long}
           */
          this.seconds =
              seconds instanceof Long ? seconds : Long.fromNumber(seconds);

          Object.freeze(this);
      }

      /**
       * @internal
       * @returns {HieroProto.proto.IDuration}
       */
      _toProtobuf() {
          return {
              seconds: this.seconds,
          };
      }

      /**
       * @internal
       * @param {HieroProto.proto.IDuration} duration
       * @returns {Duration}
       */
      static _fromProtobuf(duration) {
          return new Duration(/** @type {Long} */ (duration.seconds));
      }
  }

  // SPDX-License-Identifier: Apache-2.0
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  /**
   * @typedef {import("bignumber.js").default} BigNumber
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("../Timestamp.js").default} Timestamp
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   */

  /**
   * Create a new Hedera crypto-currency account.
   */
  class AccountCreateTransaction extends Transaction {
      /**
       * @param {object} [props]
       * @param {Key} [props.key]
       * @param {number | string | Long | BigNumber | Hbar} [props.initialBalance]
       * @param {boolean} [props.receiverSignatureRequired]
       * @param {AccountId} [props.proxyAccountId]
       * @param {Duration | Long | number} [props.autoRenewPeriod]
       * @param {string} [props.accountMemo]
       * @param {Long | number} [props.maxAutomaticTokenAssociations]
       * @param {AccountId | string} [props.stakedAccountId]
       * @param {Long | number} [props.stakedNodeId]
       * @param {boolean} [props.declineStakingReward]
       * @param {EvmAddress} [props.alias]
       */
      constructor(props = {}) {
          super();

          /**
           * @private
           * @type {?Key}
           */
          this._key = null;

          /**
           * @private
           * @type {?Hbar}
           */
          this._initialBalance = null;

          /**
           * @private
           * @type {Hbar}
           */
          this._sendRecordThreshold = DEFAULT_RECORD_THRESHOLD;

          /**
           * @private
           * @type {Hbar}
           */
          this._receiveRecordThreshold = DEFAULT_RECORD_THRESHOLD;

          /**
           * @private
           * @type {boolean}
           */
          this._receiverSignatureRequired = false;

          /**
           * @private
           * @type {?AccountId}
           */
          this._proxyAccountId = null;

          /**
           * @private
           * @type {Duration}
           */
          this._autoRenewPeriod = new Duration(DEFAULT_AUTO_RENEW_PERIOD);

          /**
           * @private
           * @type {?string}
           */
          this._accountMemo = null;

          /**
           * @private
           * @type {?Long}
           */
          this._maxAutomaticTokenAssociations = null;

          /**
           * @private
           * @type {?AccountId}
           */
          this._stakedAccountId = null;

          /**
           * @private
           * @type {?Long}
           */
          this._stakedNodeId = null;

          /**
           * @private
           * @type {boolean}
           */
          this._declineStakingReward = false;

          /**
           * @private
           * @type {?EvmAddress}
           */
          this._alias = null;

          if (props.key != null) {
              this.setKeyWithoutAlias(props.key);
          }

          if (props.receiverSignatureRequired != null) {
              this.setReceiverSignatureRequired(props.receiverSignatureRequired);
          }

          if (props.initialBalance != null) {
              this.setInitialBalance(props.initialBalance);
          }

          if (props.proxyAccountId != null) {
              // eslint-disable-next-line deprecation/deprecation
              this.setProxyAccountId(props.proxyAccountId);
          }

          if (props.autoRenewPeriod != null) {
              this.setAutoRenewPeriod(props.autoRenewPeriod);
          }

          if (props.accountMemo != null) {
              this.setAccountMemo(props.accountMemo);
          }

          if (props.maxAutomaticTokenAssociations != null) {
              this.setMaxAutomaticTokenAssociations(
                  props.maxAutomaticTokenAssociations,
              );
          }

          if (props.stakedAccountId != null) {
              this.setStakedAccountId(props.stakedAccountId);
          }

          if (props.stakedNodeId != null) {
              this.setStakedNodeId(props.stakedNodeId);
          }

          if (props.declineStakingReward != null) {
              this.setDeclineStakingReward(props.declineStakingReward);
          }

          if (props.alias != null) {
              this.setAlias(props.alias);
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransaction[]} transactions
       * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {HieroProto.proto.ITransactionBody[]} bodies
       * @returns {AccountCreateTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];
          const create =
              /** @type {HieroProto.proto.ICryptoCreateTransactionBody} */ (
                  body.cryptoCreateAccount
              );

          let alias = undefined;
          if (create.alias != null && create.alias.length > 0) {
              if (create.alias.length === 20) {
                  alias = EvmAddress.fromBytes(create.alias);
              }
          }

          return Transaction._fromProtobufTransactions(
              new AccountCreateTransaction({
                  key:
                      create.key != null
                          ? Key._fromProtobufKey(create.key)
                          : undefined,
                  initialBalance:
                      create.initialBalance != null
                          ? Hbar.fromTinybars(create.initialBalance)
                          : undefined,
                  receiverSignatureRequired:
                      create.receiverSigRequired != null
                          ? create.receiverSigRequired
                          : undefined,
                  proxyAccountId:
                      create.proxyAccountID != null
                          ? AccountId._fromProtobuf(
                                /** @type {HieroProto.proto.IAccountID} */ (
                                    create.proxyAccountID
                                ),
                            )
                          : undefined,
                  autoRenewPeriod:
                      create.autoRenewPeriod != null
                          ? create.autoRenewPeriod.seconds != null
                              ? create.autoRenewPeriod.seconds
                              : undefined
                          : undefined,
                  accountMemo: create.memo != null ? create.memo : undefined,
                  maxAutomaticTokenAssociations:
                      create.maxAutomaticTokenAssociations != null
                          ? create.maxAutomaticTokenAssociations
                          : undefined,
                  stakedAccountId:
                      create.stakedAccountId != null
                          ? AccountId._fromProtobuf(create.stakedAccountId)
                          : undefined,
                  stakedNodeId:
                      create.stakedNodeId != null
                          ? create.stakedNodeId
                          : undefined,
                  declineStakingReward: create.declineReward == true,
                  alias,
              }),
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * @returns {?Key}
       */
      get key() {
          return this._key;
      }

      /**
       * Set the key for this account.
       *
       * This is the key that must sign each transfer out of the account.
       *
       * If `receiverSignatureRequired` is true, then the key must also sign
       * any transfer into the account.
       *
       * @deprecated Use `setKeyWithoutAlias` instead.
       * @param {Key} key
       * @returns {this}
       */
      setKey(key) {
          this._requireNotFrozen();
          this._key = key;

          return this;
      }

      /**
       * Sets an ECDSA key (private or public) and a derived alias from this key in the background.
       * @param {Key} key - An ECDSA key (private or public) used for signing transactions and alias derivation.
       * @returns {this}
       * @throws {Error} If the key is not an ECDSA key.
       */
      setECDSAKeyWithAlias(key) {
          this.setKeyWithoutAlias(key);

          const alias = this._deriveECDSAKeyAlias(key);

          this.setAlias(alias);
          return this;
      }

      /**
       * Sets an account key and an alias derived from a separate ECDSA key.
       * The transaction must be signed by both keys.
       * @param {Key} key - The primary account key used for signing transactions.
       * @param {Key} aliasKey - The ECDSA key (private or public) used to derive the EVM address.
       * @returns {this}
       * @throws {Error} If the aliasKey is not an ECDSA key.
       */
      setKeyWithAlias(key, aliasKey) {
          this.setKeyWithoutAlias(key);

          const alias = this._deriveECDSAKeyAlias(aliasKey);

          this.setAlias(alias);
          return this;
      }

      /**
       * Set the key for this account without an alias.
       *
       * This is the key that must sign each transfer out of the account.
       *
       * If `receiverSignatureRequired` is true, then the key must also sign
       * any transfer into the account.
       *
       *
       * @param {Key} key
       * @returns {this}
       */
      setKeyWithoutAlias(key) {
          this._requireNotFrozen();
          this._key = key;

          return this;
      }

      /**
       * @returns {?Hbar}
       */
      get initialBalance() {
          return this._initialBalance;
      }

      /**
       * Set the initial amount to transfer into this account.
       *
       * @param {number | string | Long | BigNumber | Hbar} initialBalance
       * @returns {this}
       */
      setInitialBalance(initialBalance) {
          this._requireNotFrozen();
          this._initialBalance =
              initialBalance instanceof Hbar
                  ? initialBalance
                  : new Hbar(initialBalance);

          return this;
      }

      /**
       * @returns {boolean}
       */
      get receiverSignatureRequired() {
          return this._receiverSignatureRequired;
      }

      /**
       * Set to true to require the key for this account to sign any transfer of
       * hbars to this account.
       *
       * @param {boolean} receiverSignatureRequired
       * @returns {this}
       */
      setReceiverSignatureRequired(receiverSignatureRequired) {
          this._requireNotFrozen();
          this._receiverSignatureRequired = receiverSignatureRequired;

          return this;
      }

      /**
       * @deprecated
       * @returns {?AccountId}
       */
      get proxyAccountId() {
          return this._proxyAccountId;
      }

      /**
       * @deprecated
       *
       * Set the ID of the account to which this account is proxy staked.
       * @param {AccountId} proxyAccountId
       * @returns {this}
       */
      setProxyAccountId(proxyAccountId) {
          this._requireNotFrozen();
          this._proxyAccountId = proxyAccountId;

          return this;
      }

      /**
       * @returns {Duration}
       */
      get autoRenewPeriod() {
          return this._autoRenewPeriod;
      }

      /**
       * Set the auto renew period for this account.
       *
       * @param {Duration | Long | number} autoRenewPeriod
       * @returns {this}
       */
      setAutoRenewPeriod(autoRenewPeriod) {
          this._requireNotFrozen();
          this._autoRenewPeriod =
              autoRenewPeriod instanceof Duration
                  ? autoRenewPeriod
                  : new Duration(autoRenewPeriod);

          return this;
      }

      /**
       * @returns {?string}
       */
      get accountMemo() {
          return this._accountMemo;
      }

      /**
       * @param {string} memo
       * @returns {this}
       */
      setAccountMemo(memo) {
          this._requireNotFrozen();
          this._accountMemo = memo;

          return this;
      }

      /**
       * @returns {?Long}
       */
      get maxAutomaticTokenAssociations() {
          return this._maxAutomaticTokenAssociations;
      }

      /**
       * @param {Long | number} maxAutomaticTokenAssociations
       * @returns {this}
       */
      setMaxAutomaticTokenAssociations(maxAutomaticTokenAssociations) {
          this._requireNotFrozen();
          this._maxAutomaticTokenAssociations =
              typeof maxAutomaticTokenAssociations === "number"
                  ? Long.fromNumber(maxAutomaticTokenAssociations)
                  : maxAutomaticTokenAssociations;

          return this;
      }

      /**
       * @returns {?AccountId}
       */
      get stakedAccountId() {
          return this._stakedAccountId;
      }

      /**
       * @param {AccountId | string} stakedAccountId
       * @returns {this}
       */
      setStakedAccountId(stakedAccountId) {
          this._requireNotFrozen();
          this._stakedAccountId =
              typeof stakedAccountId === "string"
                  ? AccountId.fromString(stakedAccountId)
                  : stakedAccountId;

          return this;
      }

      /**
       * @returns {?Long}
       */
      get stakedNodeId() {
          return this._stakedNodeId;
      }

      /**
       * @param {Long | number} stakedNodeId
       * @returns {this}
       */
      setStakedNodeId(stakedNodeId) {
          this._requireNotFrozen();
          this._stakedNodeId = Long.fromValue(stakedNodeId);

          return this;
      }

      /**
       * @returns {boolean}
       */
      get declineStakingRewards() {
          return this._declineStakingReward;
      }

      /**
       * @param {boolean} declineStakingReward
       * @returns {this}
       */
      setDeclineStakingReward(declineStakingReward) {
          this._requireNotFrozen();
          this._declineStakingReward = declineStakingReward;

          return this;
      }

      /**
       * The bytes to be used as the account's alias.
       *
       * The bytes must be formatted as the calcluated last 20 bytes of the
       * keccak-256 of the ECDSA primitive key.
       *
       * All other types of keys, including but not limited to ED25519, ThresholdKey, KeyList, ContractID, and
       * delegatable_contract_id, are not supported.
       *
       * At most only one account can ever have a given alias on the network.
       *
       * @returns {?EvmAddress}
       */
      get alias() {
          return this._alias;
      }

      /**
       * The bytes to be used as the account's alias.
       *
       * The bytes must be formatted as the calcluated last 20 bytes of the
       * keccak-256 of the ECDSA primitive key.
       *
       * All other types of keys, including but not limited to ED25519, ThresholdKey, KeyList, ContractID, and
       * delegatable_contract_id, are not supported.
       *
       * At most only one account can ever have a given alias on the network.
       *
       * @param {string | EvmAddress} alias
       * @returns {this}
       */
      setAlias(alias) {
          if (typeof alias === "string") {
              if (
                  (alias.startsWith("0x") && alias.length == 42) ||
                  alias.length == 40
              ) {
                  this._alias = EvmAddress.fromString(alias);
              } else {
                  throw new Error(
                      'evmAddress must be a valid EVM address with or without "0x" prefix',
                  );
              }
          } else {
              this._alias = alias;
          }

          return this;
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          if (this._proxyAccountId != null) {
              this._proxyAccountId.validateChecksum(client);
          }
      }

      /**
       * Derives an EVM alias from an ECDSA key.
       * @private
       * @internal
       * @param {Key} key
       * @returns {string}
       * @throws {Error} If the key is not a ECDSA (secp256k1) PrivateKey or PublicKey.
       */
      _deriveECDSAKeyAlias(key) {
          const isPrivateECDSAKey =
              key instanceof PrivateKey && key.type === "secp256k1";
          const isPublicECDSAKey =
              key instanceof PublicKey && key.type === "secp256k1";

          if (isPrivateECDSAKey) {
              return key.publicKey.toEvmAddress();
          } else if (isPublicECDSAKey) {
              return key.toEvmAddress();
          }

          throw new Error(
              "Invalid key for alias derivation provided: expected an ECDSA (secp256k1) PrivateKey or PublicKey.",
          );
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.ITransaction} request
       * @returns {Promise<HieroProto.proto.ITransactionResponse>}
       */
      _execute(channel, request) {
          return channel.crypto.createAccount(request);
      }

      /**
       * @override
       * @protected
       * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "cryptoCreateAccount";
      }

      /**
       * @override
       * @protected
       * @returns {HieroProto.proto.ICryptoCreateTransactionBody}
       */
      _makeTransactionData() {
          let alias = null;
          if (this._alias != null) {
              alias = this._alias.toBytes();
          }

          return {
              key: this._key != null ? this._key._toProtobufKey() : null,
              initialBalance:
                  this._initialBalance != null
                      ? this._initialBalance.toTinybars()
                      : null,
              autoRenewPeriod: this._autoRenewPeriod._toProtobuf(),
              proxyAccountID:
                  this._proxyAccountId != null
                      ? this._proxyAccountId._toProtobuf()
                      : null,
              receiveRecordThreshold: this._receiveRecordThreshold.toTinybars(),
              sendRecordThreshold: this._sendRecordThreshold.toTinybars(),
              receiverSigRequired: this._receiverSignatureRequired,
              memo: this._accountMemo,
              maxAutomaticTokenAssociations:
                  this._maxAutomaticTokenAssociations != null
                      ? this._maxAutomaticTokenAssociations.toInt()
                      : null,
              stakedAccountId:
                  this.stakedAccountId != null
                      ? this.stakedAccountId._toProtobuf()
                      : null,
              stakedNodeId: this.stakedNodeId,
              declineReward: this.declineStakingRewards,
              alias,
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("../Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `AccountCreateTransaction:${timestamp.toString()}`;
      }
  }

  TRANSACTION_REGISTRY.set(
      "cryptoCreateAccount",
      // eslint-disable-next-line @typescript-eslint/unbound-method
      AccountCreateTransaction._fromProtobuf,
  );

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
   * @typedef {import("@hashgraph/proto").proto.ICryptoDeleteTransactionBody} HieroProto.proto.ICryptoDeleteTransactionBody
   * @typedef {import("@hashgraph/proto").proto.IAccountID} HieroProto.proto.IAccountID
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   */

  /**
   * Marks an account as deleted, moving all its current hbars to another account.
   *
   * It will remain in the ledger, marked as deleted, until it expires.
   * Transfers into it a deleted account fail. But a deleted account can still have its
   * expiration extended in the normal way.
   */
  class AccountDeleteTransaction extends Transaction {
      /**
       * @param {object} props
       * @param {AccountId} [props.accountId]
       * @param {AccountId} [props.transferAccountId]
       */
      constructor(props = {}) {
          super();

          /**
           * @private
           * @type {?AccountId}
           */
          this._accountId = null;

          /**
           * @private
           * @type {?AccountId}
           */
          this._transferAccountId = null;

          if (props.accountId != null) {
              this.setAccountId(props.accountId);
          }

          if (props.transferAccountId != null) {
              this.setTransferAccountId(props.transferAccountId);
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransaction[]} transactions
       * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {HieroProto.proto.ITransactionBody[]} bodies
       * @returns {AccountDeleteTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];
          const accountDelete =
              /** @type {HieroProto.proto.ICryptoDeleteTransactionBody} */ (
                  body.cryptoDelete
              );

          return Transaction._fromProtobufTransactions(
              new AccountDeleteTransaction({
                  accountId:
                      accountDelete.deleteAccountID != null
                          ? AccountId._fromProtobuf(
                                /** @type {HieroProto.proto.IAccountID} */ (
                                    accountDelete.deleteAccountID
                                ),
                            )
                          : undefined,
                  transferAccountId:
                      accountDelete.transferAccountID != null
                          ? AccountId._fromProtobuf(
                                /** @type {HieroProto.proto.IAccountID} */ (
                                    accountDelete.transferAccountID
                                ),
                            )
                          : undefined,
              }),
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * @returns {?AccountId}
       */
      get accountId() {
          return this._accountId;
      }

      /**
       * Set the account ID which is being deleted in this transaction.
       *
       * @param {AccountId | string} accountId
       * @returns {AccountDeleteTransaction}
       */
      setAccountId(accountId) {
          this._requireNotFrozen();
          this._accountId =
              typeof accountId === "string"
                  ? AccountId.fromString(accountId)
                  : accountId.clone();

          return this;
      }

      /**
       * @returns {?AccountId}
       */
      get transferAccountId() {
          return this._transferAccountId;
      }

      /**
       * Set the account ID which will receive all remaining hbars.
       *
       * @param {AccountId | string} transferAccountId
       * @returns {AccountDeleteTransaction}
       */
      setTransferAccountId(transferAccountId) {
          this._requireNotFrozen();
          this._transferAccountId =
              typeof transferAccountId === "string"
                  ? AccountId.fromString(transferAccountId)
                  : transferAccountId.clone();

          return this;
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          if (this._accountId != null) {
              this._accountId.validateChecksum(client);
          }

          if (this._transferAccountId != null) {
              this._transferAccountId.validateChecksum(client);
          }
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.ITransaction} request
       * @returns {Promise<HieroProto.proto.ITransactionResponse>}
       */
      _execute(channel, request) {
          return channel.crypto.cryptoDelete(request);
      }

      /**
       * @override
       * @protected
       * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "cryptoDelete";
      }

      /**
       * @override
       * @protected
       * @returns {HieroProto.proto.ICryptoDeleteTransactionBody}
       */
      _makeTransactionData() {
          return {
              deleteAccountID:
                  this._accountId != null ? this._accountId._toProtobuf() : null,
              transferAccountID:
                  this._transferAccountId != null
                      ? this._transferAccountId._toProtobuf()
                      : null,
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("../Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `AccountDeleteTransaction:${timestamp.toString()}`;
      }
  }

  TRANSACTION_REGISTRY.set(
      "cryptoDelete",
      // eslint-disable-next-line @typescript-eslint/unbound-method
      AccountDeleteTransaction._fromProtobuf,
  );

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {import("long")} Long
   */

  /**
   * @typedef {object} StakingInfoJson
   * @property {boolean} declineStakingReward
   * @property {?string} stakePeriodStart
   * @property {?string} pendingReward
   * @property {?string} stakedToMe
   * @property {?string} stakedAccountId
   * @property {?string} stakedNodeId
   */

  /**
   * Staking metadata for an account or a contract returned in CryptoGetInfo or ContractGetInfo queries
   */
  class StakingInfo {
      /**
       * @private
       * @param {object} props
       * @param {boolean} props.declineStakingReward
       * @param {?Timestamp} props.stakePeriodStart
       * @param {?Hbar} props.pendingReward
       * @param {?Hbar} props.stakedToMe
       * @param {?AccountId} props.stakedAccountId
       * @param {?Long} props.stakedNodeId
       */
      constructor(props) {
          /**
           * If true, this account or contract declined to receive a staking reward.
           *
           * @readonly
           */
          this.declineStakingReward = props.declineStakingReward;

          /**
           * The staking period during which either the staking settings for this
           * account or contract changed (such as starting staking or changing
           * staked_node_id) or the most recent reward was earned, whichever is
           * later. If this account or contract is not currently staked to a
           * node, then this field is not set.
           *
           * @readonly
           */
          this.stakePeriodStart = props.stakePeriodStart;

          /**
           * The amount in tinybars that will be received in the next reward
           * situation.
           *
           * @readonly
           */
          this.pendingReward = props.pendingReward;

          /**
           * The total of balance of all accounts staked to this account or contract.
           *
           * @readonly
           */
          this.stakedToMe = props.stakedToMe;

          /**
           * The account to which this account or contract is staking.
           *
           * @readonly
           */
          this.stakedAccountId = props.stakedAccountId;

          /**
           * The ID of the node this account or contract is staked to.
           *
           * @readonly
           */
          this.stakedNodeId = props.stakedNodeId;

          Object.freeze(this);
      }

      /**
       * @internal
       * @param {HieroProto.proto.IStakingInfo} info
       * @returns {StakingInfo}
       */
      static _fromProtobuf(info) {
          return new StakingInfo({
              declineStakingReward: info.declineReward == true,
              stakePeriodStart:
                  info.stakePeriodStart != null
                      ? Timestamp._fromProtobuf(info.stakePeriodStart)
                      : null,
              pendingReward:
                  info.pendingReward != null
                      ? Hbar.fromTinybars(info.pendingReward)
                      : null,
              stakedToMe:
                  info.stakedToMe != null
                      ? Hbar.fromTinybars(info.stakedToMe)
                      : null,
              stakedAccountId:
                  info.stakedAccountId != null
                      ? AccountId._fromProtobuf(info.stakedAccountId)
                      : null,
              stakedNodeId: info.stakedNodeId != null ? info.stakedNodeId : null,
          });
      }

      /**
       * @returns {HieroProto.proto.IStakingInfo}
       */
      _toProtobuf() {
          return {
              declineReward: this.declineStakingReward,
              stakePeriodStart:
                  this.stakePeriodStart != null
                      ? this.stakePeriodStart._toProtobuf()
                      : null,
              pendingReward:
                  this.pendingReward != null
                      ? this.pendingReward.toTinybars()
                      : null,
              stakedToMe:
                  this.stakedToMe != null ? this.stakedToMe.toTinybars() : null,
              stakedAccountId:
                  this.stakedAccountId != null
                      ? this.stakedAccountId._toProtobuf()
                      : null,
              stakedNodeId: this.stakedNodeId,
          };
      }

      /**
       * @param {Uint8Array} bytes
       * @returns {StakingInfo}
       */
      static fromBytes(bytes) {
          return StakingInfo._fromProtobuf(
              libExports.proto.StakingInfo.decode(bytes),
          );
      }

      /**
       * @returns {Uint8Array}
       */
      toBytes() {
          return libExports.proto.StakingInfo.encode(this._toProtobuf()).finish();
      }

      /**
       * @returns {string}
       */
      toString() {
          return JSON.stringify(this.toJSON());
      }

      /**
       * @returns {StakingInfoJson}
       */
      toJSON() {
          return {
              declineStakingReward: this.declineStakingReward,
              stakePeriodStart:
                  this.stakePeriodStart != null
                      ? this.stakePeriodStart.toString()
                      : null,
              pendingReward:
                  this.pendingReward != null
                      ? this.pendingReward.toString()
                      : null,
              stakedToMe:
                  this.stakedToMe != null ? this.stakedToMe.toString() : null,
              stakedAccountId:
                  this.stakedAccountId != null
                      ? this.stakedAccountId.toString()
                      : null,
              stakedNodeId:
                  this.stakedNodeId != null ? this.stakedNodeId.toString() : null,
          };
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.IAccountID} HieroProto.proto.IAccountID
   * @typedef {import("@hashgraph/proto").proto.ILiveHash} HieroProto.proto.ILiveHash
   * @typedef {import("@hashgraph/proto").proto.IDuration} HieroProto.proto.IDuration
   */

  /**
   * Response when the client sends the node CryptoGetInfoQuery.
   */
  class LiveHash {
      /**
       * @private
       * @param {object} props
       * @param {AccountId} props.accountId
       * @param {Uint8Array} props.hash
       * @param {KeyList} props.keys
       * @param {Duration} props.duration
       */
      constructor(props) {
          /** @readonly */
          this.accountId = props.accountId;

          /** @readonly */
          this.hash = props.hash;

          /** @readonly */
          this.keys = props.keys;

          /** @readonly */
          this.duration = props.duration;

          Object.freeze(this);
      }

      /**
       * @internal
       * @param {HieroProto.proto.ILiveHash} liveHash
       * @returns {LiveHash}
       */
      static _fromProtobuf(liveHash) {
          const liveHash_ = /** @type {HieroProto.proto.ILiveHash} */ (liveHash);

          return new LiveHash({
              accountId: AccountId._fromProtobuf(
                  /** @type {HieroProto.proto.IAccountID} */ (
                      liveHash_.accountId
                  ),
              ),
              hash: liveHash_.hash != null ? liveHash_.hash : new Uint8Array(),
              keys:
                  liveHash_.keys != null
                      ? KeyList.__fromProtobufKeyList(liveHash_.keys)
                      : new KeyList(),
              duration: Duration._fromProtobuf(
                  /** @type {HieroProto.proto.IDuration} */ (liveHash_.duration),
              ),
          });
      }

      /**
       * @internal
       * @returns {HieroProto.proto.ILiveHash}
       */
      _toProtobuf() {
          return {
              accountId: this.accountId._toProtobuf(),
              hash: this.hash,
              keys: this.keys._toProtobufKey().keyList,
              duration: this.duration._toProtobuf(),
          };
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITokenRelationship} HieroProto.proto.ITokenRelationship
   * @typedef {import("@hashgraph/proto").proto.TokenKycStatus} HieroProto.proto.TokenKycStatus
   * @typedef {import("@hashgraph/proto").proto.TokenFreezeStatus} HieroProto.proto.TokenFreezeStatus
   * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
   */

  /**
   * Token's information related to the given Account
   */
  class TokenRelationship {
      /**
       * @param {object} props
       * @param {TokenId} props.tokenId
       * @param {string} props.symbol
       * @param {Long} props.balance
       * @param {boolean | null} props.isKycGranted
       * @param {boolean | null} props.isFrozen
       * @param {boolean | null} props.automaticAssociation
       */
      constructor(props) {
          /**
           * The ID of the token
           *
           * @readonly
           */
          this.tokenId = props.tokenId;

          /**
           * The Symbol of the token
           *
           * @readonly
           */
          this.symbol = props.symbol;

          /**
           * The balance that the Account holds in the smallest denomination
           *
           * @readonly
           */
          this.balance = props.balance;

          /**
           * The KYC status of the account (KycNotApplicable, Granted or Revoked). If the token does
           * not have KYC key, KycNotApplicable is returned
           *
           * @readonly
           */
          this.isKycGranted = props.isKycGranted;

          /**
           * The Freeze status of the account (FreezeNotApplicable, Frozen or Unfrozen). If the token
           * does not have Freeze key, FreezeNotApplicable is returned
           *
           * @readonly
           */
          this.isFrozen = props.isFrozen;

          /**
           * Specifies if the relationship is created implicitly. False : explicitly associated, True :
           * implicitly associated.
           *
           * @readonly
           */
          this.automaticAssociation = props.automaticAssociation;

          Object.freeze(this);
      }

      /**
       * @param {HieroProto.proto.ITokenRelationship} relationship
       * @returns {TokenRelationship}
       */
      static _fromProtobuf(relationship) {
          const tokenId = TokenId._fromProtobuf(
              /** @type {HieroProto.proto.ITokenID} */ (relationship.tokenId),
          );
          const isKycGranted =
              relationship.kycStatus == null || relationship.kycStatus === 0
                  ? null
                  : relationship.kycStatus === 1;
          const isFrozen =
              relationship.freezeStatus == null || relationship.freezeStatus === 0
                  ? null
                  : relationship.freezeStatus === 1;

          return new TokenRelationship({
              tokenId,
              symbol: /** @type {string} */ (relationship.symbol),
              balance:
                  relationship.balance != null
                      ? relationship.balance instanceof Long
                          ? relationship.balance
                          : Long.fromValue(relationship.balance)
                      : Long.ZERO,
              isKycGranted,
              isFrozen,
              automaticAssociation:
                  relationship.automaticAssociation != null
                      ? relationship.automaticAssociation
                      : null,
          });
      }

      /**
       * @returns {HieroProto.proto.ITokenRelationship}
       */
      _toProtobuf() {
          return {
              tokenId: this.tokenId._toProtobuf(),
              symbol: this.symbol,
              balance: this.balance,
              kycStatus:
                  this.isKycGranted == null ? 0 : this.isKycGranted ? 1 : 2,
              freezeStatus: this.isFrozen == null ? 0 : this.isFrozen ? 1 : 2,
              automaticAssociation: this.automaticAssociation,
          };
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITokenRelationship} HieroProto.proto.ITokenRelationship
   * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
   */

  /**
   * @typedef {import("long")} Long
   */

  /**
   * @augments {ObjectMap<TokenId, TokenRelationship>}
   */
  class TokenRelationshipMap extends ObjectMap {
      constructor() {
          super((s) => TokenId.fromString(s));
      }

      /**
       * @param {HieroProto.proto.ITokenRelationship[]} relationships
       * @returns {TokenRelationshipMap}
       */
      static _fromProtobuf(relationships) {
          const tokenRelationships = new TokenRelationshipMap();

          for (const relationship of relationships) {
              const tokenId = TokenId._fromProtobuf(
                  /** @type {HieroProto.proto.ITokenID} */ (relationship.tokenId),
              );

              tokenRelationships._set(
                  tokenId,
                  TokenRelationship._fromProtobuf(relationship),
              );
          }

          return tokenRelationships;
      }

      /**
       * @returns {HieroProto.proto.ITokenRelationship[]}
       */
      _toProtobuf() {
          const list = [];

          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          for (const [_, relationship] of this) {
              list.push(relationship._toProtobuf());
          }

          return list;
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * Represents the ID of a network.
   */
  class LedgerId {
      /**
       * @hideconstructor
       * @internal
       * @param {Uint8Array} ledgerId
       */
      constructor(ledgerId) {
          /**
           * @readonly
           * @type {Uint8Array}
           */
          this._ledgerId = ledgerId;

          Object.freeze(this);
      }

      /**
       * @param {string} ledgerId
       * @returns {LedgerId}
       */
      static fromString(ledgerId) {
          switch (ledgerId) {
              case NETNAMES[0]:
              case "0":
                  return LedgerId.MAINNET;
              case NETNAMES[1]:
              case "1":
                  return LedgerId.TESTNET;
              case NETNAMES[2]:
              case "2":
                  return LedgerId.PREVIEWNET;
              case NETNAMES[3]:
              case "3":
                  return LedgerId.LOCAL_NODE;
              default: {
                  try {
                      let ledgerIdDecoded = decode$8(ledgerId);
                      return new LedgerId(ledgerIdDecoded);
                  } catch (error) {
                      throw new Error("Default reached for fromString");
                  }
              }
          }
      }

      /**
       * If the ledger ID is a known value such as `[0]`, `[1]`, `[2]` this method
       * will instead return "mainnet", "testnet", or "previewnet", otherwise it will
       * hex encode the bytes.
       *
       * @returns {string}
       */
      toString() {
          if (this._ledgerId.length == 1) {
              switch (this._ledgerId[0]) {
                  case 0:
                      return NETNAMES[0];
                  case 1:
                      return NETNAMES[1];
                  case 2:
                      return NETNAMES[2];
                  case 3:
                      return NETNAMES[3];
                  default:
                      return encode$5(this._ledgerId);
              }
          } else {
              return encode$5(this._ledgerId);
          }
      }

      /**
       * Using the UTF-8 byte representation of "mainnet", "testnet",
       * or "previewnet" is NOT supported.
       *
       * @param {Uint8Array} bytes
       * @returns {LedgerId}
       */
      static fromBytes(bytes) {
          return new LedgerId(bytes);
      }

      /**
       * @returns {Uint8Array}
       */
      toBytes() {
          return this._ledgerId;
      }

      /**
       * @returns {boolean}
       */
      isMainnet() {
          return this.toString() == NETNAMES[0];
      }

      /**
       * @returns {boolean}
       */
      isTestnet() {
          return this.toString() == NETNAMES[1];
      }

      /**
       * @returns {boolean}
       */
      isPreviewnet() {
          return this.toString() == NETNAMES[2];
      }

      /**
       * @returns {boolean}
       */
      isLocalNode() {
          return this.toString() == NETNAMES[3];
      }
  }

  const NETNAMES = ["mainnet", "testnet", "previewnet", "local-node"];

  LedgerId.MAINNET = new LedgerId(new Uint8Array([0]));

  LedgerId.TESTNET = new LedgerId(new Uint8Array([1]));

  LedgerId.PREVIEWNET = new LedgerId(new Uint8Array([2]));

  LedgerId.LOCAL_NODE = new LedgerId(new Uint8Array([3]));

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {import("./HbarAllowance.js").default} HbarAllowance
   * @typedef {import("./TokenAllowance.js").default} TokenAllowance
   * @typedef {import("./TokenNftAllowance.js").default} TokenNftAllowance
   * @typedef {import("../StakingInfo.js").StakingInfoJson} StakingInfoJson
   */

  /**
   * @typedef {object} AccountInfoJson
   * @property {string} accountId
   * @property {?string} contractAccountId
   * @property {boolean} isDeleted
   * @property {?string} proxyAccountId
   * @property {string} proxyReceived
   * @property {?string} key
   * @property {string} balance
   * @property {string} sendRecordThreshold
   * @property {string} receiveRecordThreshold
   * @property {boolean} isReceiverSignatureRequired
   * @property {string} expirationTime
   * @property {string} autoRenewPeriod
   * @property {string} accountMemo
   * @property {string} ownedNfts
   * @property {string} maxAutomaticTokenAssociations
   * @property {?string} aliasKey
   * @property {?string} ledgerId
   * @property {?string} ethereumNonce
   * @property {?StakingInfoJson} stakingInfo
   */

  /**
   * Current information about an account, including the balance.
   */
  class AccountInfo {
      /**
       * @private
       * @param {object} props
       * @param {AccountId} props.accountId
       * @param {?string} props.contractAccountId
       * @param {boolean} props.isDeleted
       * @param {?AccountId} props.proxyAccountId
       * @param {Hbar} props.proxyReceived
       * @param {Key} props.key
       * @param {Hbar} props.balance
       * @param {Hbar} props.sendRecordThreshold
       * @param {Hbar} props.receiveRecordThreshold
       * @param {boolean} props.isReceiverSignatureRequired
       * @param {Timestamp} props.expirationTime
       * @param {Duration} props.autoRenewPeriod
       * @param {LiveHash[]} props.liveHashes
       * @param {TokenRelationshipMap} props.tokenRelationships
       * @param {string} props.accountMemo
       * @param {Long} props.ownedNfts
       * @param {Long} props.maxAutomaticTokenAssociations
       * @param {PublicKey | null} props.aliasKey
       * @param {LedgerId | null} props.ledgerId
       * @param {HbarAllowance[]} props.hbarAllowances
       * @param {TokenAllowance[]} props.tokenAllowances
       * @param {TokenNftAllowance[]} props.nftAllowances
       * @param {?Long} props.ethereumNonce
       * @param {?StakingInfo} props.stakingInfo
       */
      constructor(props) {
          /**
           * The account ID for which this information applies.
           *
           * @readonly
           */
          this.accountId = props.accountId;

          /**
           * The Contract Account ID comprising of both the contract instance and the cryptocurrency
           * account owned by the contract instance, in the format used by Solidity.
           *
           * @readonly
           */
          this.contractAccountId = props.contractAccountId;

          /**
           * If true, then this account has been deleted, it will disappear when it expires, and
           * all transactions for it will fail except the transaction to extend its expiration date.
           *
           * @readonly
           */
          this.isDeleted = props.isDeleted;

          /**
           * @deprecated
           *
           * The Account ID of the account to which this is proxy staked. If proxyAccountID is null,
           * or is an invalid account, or is an account that isn't a node, then this account is
           * automatically proxy staked to a node chosen by the network, but without earning payments.
           * If the proxyAccountID account refuses to accept proxy staking , or if it is not currently
           * running a node, then it will behave as if proxyAccountID was null.
           * @readonly
           */
          // eslint-disable-next-line deprecation/deprecation
          this.proxyAccountId = props.proxyAccountId;

          /**
           * @deprecated
           * The total number of tinybars proxy staked to this account.
           *
           * @readonly
           */
          // eslint-disable-next-line deprecation/deprecation
          this.proxyReceived = props.proxyReceived;

          /**
           * The key for the account, which must sign in order to transfer out, or to modify the account
           * in any way other than extending its expiration date.
           *
           * @readonly
           */
          this.key = props.key;

          /**
           * The current balance of account.
           *
           * @readonly
           */
          this.balance = props.balance;

          /**
           * The threshold amount (in tinybars) for which an account record is created (and this account
           * charged for them) for any send/withdraw transaction.
           *
           * @readonly
           */
          this.sendRecordThreshold = props.sendRecordThreshold;

          /**
           * The threshold amount (in tinybars) for which an account record is created
           * (and this account charged for them) for any transaction above this amount.
           *
           * @readonly
           */
          this.receiveRecordThreshold = props.receiveRecordThreshold;

          /**
           * If true, no transaction can transfer to this account unless signed by this account's key.
           *
           * @readonly
           */
          this.isReceiverSignatureRequired = props.isReceiverSignatureRequired;

          /**
           * The TimeStamp time at which this account is set to expire.
           *
           * @readonly
           */
          this.expirationTime = props.expirationTime;

          /**
           * The duration for expiration time will extend every this many seconds. If there are
           * insufficient funds, then it extends as long as possible. If it is empty when it
           * expires, then it is deleted.
           *
           * @readonly
           */
          this.autoRenewPeriod = props.autoRenewPeriod;

          /** @readonly */
          this.liveHashes = props.liveHashes;

          /** @readonly */
          this.tokenRelationships = props.tokenRelationships;

          /** @readonly */
          this.accountMemo = props.accountMemo;

          /** @readonly */
          this.ownedNfts = props.ownedNfts;

          /** @readonly */
          this.maxAutomaticTokenAssociations =
              props.maxAutomaticTokenAssociations;

          this.aliasKey = props.aliasKey;

          this.ledgerId = props.ledgerId;
          /*
           * @deprecated - no longer supported
           */
          this.hbarAllowances = props.hbarAllowances;
          /*
           * @deprecated - no longer supported
           */
          this.tokenAllowances = props.tokenAllowances;
          /*
           * @deprecated - no longer supported
           */
          this.nftAllowances = props.nftAllowances;

          /**
           * The ethereum transaction nonce associated with this account.
           */
          this.ethereumNonce = props.ethereumNonce;

          /**
           * Staking metadata for this account.
           */
          this.stakingInfo = props.stakingInfo;

          Object.freeze(this);
      }

      /**
       * @internal
       * @param {HieroProto.proto.CryptoGetInfoResponse.IAccountInfo} info
       * @returns {AccountInfo}
       */
      static _fromProtobuf(info) {
          let aliasKey =
              info.alias != null && info.alias.length > 0
                  ? Key._fromProtobufKey(libExports.proto.Key.decode(info.alias))
                  : null;

          if (!(aliasKey instanceof PublicKey)) {
              aliasKey = null;
          }

          const accountId = AccountId._fromProtobuf(
              /** @type {HieroProto.proto.IAccountID} */ (info.accountID),
          );

          return new AccountInfo({
              accountId,
              contractAccountId:
                  info.contractAccountID != null ? info.contractAccountID : null,
              isDeleted: info.deleted != null ? info.deleted : false,
              key: Key._fromProtobufKey(
                  /** @type {HieroProto.proto.IKey} */ (info.key),
              ),
              balance: Hbar.fromTinybars(info.balance != null ? info.balance : 0),
              sendRecordThreshold: Hbar.fromTinybars(
                  info.generateSendRecordThreshold != null
                      ? info.generateSendRecordThreshold
                      : 0,
              ),
              receiveRecordThreshold: Hbar.fromTinybars(
                  info.generateReceiveRecordThreshold != null
                      ? info.generateReceiveRecordThreshold
                      : 0,
              ),
              isReceiverSignatureRequired:
                  info.receiverSigRequired != null
                      ? info.receiverSigRequired
                      : false,
              expirationTime: Timestamp._fromProtobuf(
                  /** @type {HieroProto.proto.ITimestamp} */ (
                      info.expirationTime
                  ),
              ),
              autoRenewPeriod:
                  info.autoRenewPeriod != null
                      ? new Duration(
                            /** @type {Long} */ (info.autoRenewPeriod.seconds),
                        )
                      : new Duration(0),
              proxyAccountId:
                  info.proxyAccountID != null &&
                  Long.fromValue(
                      /** @type {Long | number} */ (info.proxyAccountID.shardNum),
                  ).toInt() !== 0 &&
                  Long.fromValue(
                      /** @type {Long | number} */ (info.proxyAccountID.realmNum),
                  ).toInt() !== 0 &&
                  Long.fromValue(
                      /** @type {Long | number} */ (
                          info.proxyAccountID.accountNum
                      ),
                  ).toInt() !== 0
                      ? AccountId._fromProtobuf(info.proxyAccountID)
                      : null,
              proxyReceived: Hbar.fromTinybars(
                  info.proxyReceived != null ? info.proxyReceived : 0,
              ),
              liveHashes: (info.liveHashes != null ? info.liveHashes : []).map(
                  (hash) => LiveHash._fromProtobuf(hash),
              ),
              tokenRelationships: TokenRelationshipMap._fromProtobuf(
                  info.tokenRelationships != null ? info.tokenRelationships : [],
              ),
              accountMemo: info.memo != null ? info.memo : "",
              ownedNfts: info.ownedNfts ? info.ownedNfts : Long.ZERO,
              maxAutomaticTokenAssociations: info.maxAutomaticTokenAssociations
                  ? Long.fromNumber(info.maxAutomaticTokenAssociations)
                  : Long.ZERO,
              aliasKey,
              ledgerId:
                  info.ledgerId != null
                      ? LedgerId.fromBytes(info.ledgerId)
                      : null,
              hbarAllowances: [],
              tokenAllowances: [],
              nftAllowances: [],
              ethereumNonce:
                  info.ethereumNonce != null ? info.ethereumNonce : null,
              stakingInfo:
                  info.stakingInfo != null
                      ? StakingInfo._fromProtobuf(info.stakingInfo)
                      : null,
          });
      }

      /**
       * @returns {HieroProto.proto.CryptoGetInfoResponse.IAccountInfo}
       */
      _toProtobuf() {
          return {
              accountID: this.accountId._toProtobuf(),
              contractAccountID: this.contractAccountId,
              deleted: this.isDeleted,
              proxyAccountID:
                  // eslint-disable-next-line deprecation/deprecation
                  this.proxyAccountId != null
                      ? // eslint-disable-next-line deprecation/deprecation
                        this.proxyAccountId._toProtobuf()
                      : null,
              // eslint-disable-next-line deprecation/deprecation
              proxyReceived: this.proxyReceived.toTinybars(),
              key: this.key._toProtobufKey(),
              balance: this.balance.toTinybars(),
              generateSendRecordThreshold: this.sendRecordThreshold.toTinybars(),
              generateReceiveRecordThreshold:
                  this.receiveRecordThreshold.toTinybars(),
              receiverSigRequired: this.isReceiverSignatureRequired,
              expirationTime: this.expirationTime._toProtobuf(),
              autoRenewPeriod: this.autoRenewPeriod._toProtobuf(),
              liveHashes: this.liveHashes.map((hash) => hash._toProtobuf()),
              tokenRelationships:
                  this.tokenRelationships != null
                      ? this.tokenRelationships._toProtobuf()
                      : null,
              memo: this.accountMemo,
              ownedNfts: this.ownedNfts,
              maxAutomaticTokenAssociations:
                  this.maxAutomaticTokenAssociations.toInt(),
              alias:
                  this.aliasKey != null
                      ? libExports.proto.Key.encode(
                            this.aliasKey._toProtobufKey(),
                        ).finish()
                      : null,
              ledgerId: this.ledgerId != null ? this.ledgerId.toBytes() : null,
              ethereumNonce: this.ethereumNonce,
              stakingInfo:
                  this.stakingInfo != null
                      ? this.stakingInfo._toProtobuf()
                      : null,
          };
      }

      /**
       * @param {Uint8Array} bytes
       * @returns {AccountInfo}
       */
      static fromBytes(bytes) {
          return AccountInfo._fromProtobuf(
              libExports.proto.CryptoGetInfoResponse.AccountInfo.decode(bytes),
          );
      }

      /**
       * @returns {Uint8Array}
       */
      toBytes() {
          return libExports.proto.CryptoGetInfoResponse.AccountInfo.encode(
              this._toProtobuf(),
          ).finish();
      }

      /**
       * @returns {string}
       */
      toString() {
          return JSON.stringify(this.toJSON());
      }

      /**
       * @returns {AccountInfoJson}
       */
      toJSON() {
          return {
              balance: this.balance.toString(),
              accountId: this.accountId.toString(),
              contractAccountId: this.contractAccountId,
              isDeleted: this.isDeleted,
              proxyAccountId:
                  // eslint-disable-next-line deprecation/deprecation
                  this.proxyAccountId != null
                      ? // eslint-disable-next-line deprecation/deprecation
                        this.proxyAccountId.toString()
                      : null,
              // eslint-disable-next-line deprecation/deprecation
              proxyReceived: this.proxyReceived.toString(),
              key: this.key != null ? this.key.toString() : null,
              sendRecordThreshold: this.sendRecordThreshold.toString(),
              receiveRecordThreshold: this.receiveRecordThreshold.toString(),
              isReceiverSignatureRequired: this.isReceiverSignatureRequired,
              expirationTime: this.expirationTime.toString(),
              autoRenewPeriod: this.autoRenewPeriod.toString(),
              accountMemo: this.accountMemo,
              ownedNfts: this.ownedNfts.toString(),
              maxAutomaticTokenAssociations:
                  this.maxAutomaticTokenAssociations.toString(),
              aliasKey: this.aliasKey != null ? this.aliasKey.toString() : null,
              ledgerId: this.ledgerId != null ? this.ledgerId.toString() : null,
              ethereumNonce:
                  this.ethereumNonce != null
                      ? this.ethereumNonce.toString()
                      : null,
              stakingInfo:
                  this.stakingInfo != null ? this.stakingInfo.toJSON() : null,
          };
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.IQuery} HieroProto.proto.IQuery
   * @typedef {import("@hashgraph/proto").proto.IQueryHeader} HieroProto.proto.IQueryHeader
   * @typedef {import("@hashgraph/proto").proto.IResponse} HieroProto.proto.IResponse
   * @typedef {import("@hashgraph/proto").proto.IResponseHeader} HieroProto.proto.IResponseHeader
   * @typedef {import("@hashgraph/proto").proto.CryptoGetInfoResponse.IAccountInfo} HieroProto.proto.CryptoGetInfoResponse.IAccountInfo
   * @typedef {import("@hashgraph/proto").proto.ICryptoGetInfoQuery} HieroProto.proto.ICryptoGetInfoQuery
   * @typedef {import("@hashgraph/proto").proto.ICryptoGetInfoResponse} HieroProto.proto.ICryptoGetInfoResponse
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   */

  /**
   * Retrieves the metadata of an account
   * @augments {Query<AccountInfo>}
   */
  class AccountInfoQuery extends Query {
      /**
       * @param {object} props
       * @param {AccountId | string} [props.accountId]
       */
      constructor(props = {}) {
          super();

          /**
           * @private
           * @type {?AccountId}
           */
          this._accountId = null;
          if (props.accountId != null) {
              this.setAccountId(props.accountId);
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.IQuery} query
       * @returns {AccountInfoQuery}
       */
      static _fromProtobuf(query) {
          const info = /** @type {HieroProto.proto.ICryptoGetInfoQuery} */ (
              query.cryptoGetInfo
          );

          return new AccountInfoQuery({
              accountId:
                  info.accountID != null
                      ? AccountId._fromProtobuf(info.accountID)
                      : undefined,
          });
      }

      /**
       * @returns {?AccountId}
       */
      get accountId() {
          return this._accountId;
      }

      /**
       * Set the account ID for which the info is being requested.
       *
       * @param {AccountId | string} accountId
       * @returns {AccountInfoQuery}
       */
      setAccountId(accountId) {
          this._accountId =
              typeof accountId === "string"
                  ? AccountId.fromString(accountId)
                  : accountId.clone();

          return this;
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          if (this._accountId != null) {
              this._accountId.validateChecksum(client);
          }
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.IQuery} request
       * @returns {Promise<HieroProto.proto.IResponse>}
       */
      _execute(channel, request) {
          return channel.crypto.getAccountInfo(request);
      }

      /**
       * @override
       * @param {import("../client/Client.js").default<Channel, *>} client
       * @returns {Promise<Hbar>}
       */
      async getCost(client) {
          return super.getCost(client);
      }

      /**
       * @override
       * @internal
       * @param {HieroProto.proto.IResponse} response
       * @returns {HieroProto.proto.IResponseHeader}
       */
      _mapResponseHeader(response) {
          const cryptoGetInfo =
              /** @type {HieroProto.proto.ICryptoGetInfoResponse} */ (
                  response.cryptoGetInfo
              );
          return /** @type {HieroProto.proto.IResponseHeader} */ (
              cryptoGetInfo.header
          );
      }

      /**
       * @override
       * @internal
       * @param {HieroProto.proto.IResponse} response
       * @param {AccountId} nodeAccountId
       * @param {HieroProto.proto.IQuery} request
       * @returns {Promise<AccountInfo>}
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _mapResponse(response, nodeAccountId, request) {
          const info = /** @type {HieroProto.proto.ICryptoGetInfoResponse} */ (
              response.cryptoGetInfo
          );

          return Promise.resolve(
              AccountInfo._fromProtobuf(
                  /** @type {HieroProto.proto.CryptoGetInfoResponse.IAccountInfo} */ (
                      info.accountInfo
                  ),
              ),
          );
      }

      /**
       * @override
       * @internal
       * @param {HieroProto.proto.IQueryHeader} header
       * @returns {HieroProto.proto.IQuery}
       */
      _onMakeRequest(header) {
          return {
              cryptoGetInfo: {
                  header,
                  accountID:
                      this._accountId != null
                          ? this._accountId._toProtobuf()
                          : null,
              },
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp =
              this._paymentTransactionId != null &&
              this._paymentTransactionId.validStart != null
                  ? this._paymentTransactionId.validStart
                  : this._timestamp;
          return `AccountInfoQuery:${timestamp.toString()}`;
      }
  }

  // eslint-disable-next-line @typescript-eslint/unbound-method
  QUERY_REGISTRY.set("cryptoGetInfo", AccountInfoQuery._fromProtobuf);

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("../transaction/Transaction.js").default} Transaction
   * @typedef {import("../PublicKey.js").default} PublicKey
   * @typedef {import("./AccountId.js").default} AccountId
   * @typedef {import("../Signer.js").Signer} Signer
   */

  /**
   * This class provides static methods to verify signatures and transactions by fetching the account's key
   * from the network. It supports both Client and Signer-based operations.
   *
   * The class provides methods to:
   * - Verify message signatures using account public key
   * - Verify transaction signatures using account public key
   * - Perform verifications using either a Client or Signer instance
   */
  class AccountInfoFlow {
      /**
       * @param {Client} client
       * @param {AccountId | string} accountId
       * @param {Uint8Array} message
       * @param {Uint8Array} signature
       * @returns {Promise<boolean>}
       */
      static async verifySignature(client, accountId, message, signature) {
          const info = await new AccountInfoQuery()
              .setAccountId(accountId)
              .execute(client);

          if (info.key instanceof KeyList) {
              return false;
          }

          return /** @type {PublicKey} */ (info.key).verify(message, signature);
      }

      /**
       * @param {Client} client
       * @param {AccountId | string} accountId
       * @param {Transaction} transaction
       * @returns {Promise<boolean>}
       */
      static async verifyTransaction(client, accountId, transaction) {
          const info = await new AccountInfoQuery()
              .setAccountId(accountId)
              .execute(client);

          if (info.key instanceof KeyList) {
              return false;
          }

          return /** @type {PublicKey} */ (info.key).verifyTransaction(
              transaction,
          );
      }

      /**
       * @param {Signer} signer
       * @param {AccountId | string} accountId
       * @param {Uint8Array} message
       * @param {Uint8Array} signature
       * @returns {Promise<boolean>}
       */
      static async verifySignatureWithSigner(
          signer,
          accountId,
          message,
          signature,
      ) {
          const info = await new AccountInfoQuery()
              .setAccountId(accountId)
              .executeWithSigner(signer);

          if (info.key instanceof KeyList) {
              return false;
          }

          return /** @type {PublicKey} */ (info.key).verify(message, signature);
      }

      /**
       * @param {Signer} signer
       * @param {AccountId | string} accountId
       * @param {Transaction} transaction
       * @returns {Promise<boolean>}
       */
      static async verifyTransactionWithSigner(signer, accountId, transaction) {
          const info = await new AccountInfoQuery()
              .setAccountId(accountId)
              .executeWithSigner(signer);

          if (info.key instanceof KeyList) {
              return false;
          }

          return /** @type {PublicKey} */ (info.key).verifyTransaction(
              transaction,
          );
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.IQuery} HieroProto.proto.IQuery
   * @typedef {import("@hashgraph/proto").proto.IQueryHeader} HieroProto.proto.IQueryHeader
   * @typedef {import("@hashgraph/proto").proto.IResponse} HieroProto.proto.IResponse
   * @typedef {import("@hashgraph/proto").proto.IResponseHeader} HieroProto.proto.IResponseHeader
   * @typedef {import("@hashgraph/proto").proto.ICryptoGetAccountRecordsQuery} HieroProto.proto.ICryptoGetAccountRecordsQuery
   * @typedef {import("@hashgraph/proto").proto.ICryptoGetAccountRecordsResponse} HieroProto.proto.ICryptoGetAccountRecordsResponse
   * @typedef {import("@hashgraph/proto").proto.ITransactionRecord} HieroProto.proto.ITransactionRecord
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   */

  /**
   * Get all the records for an account for any transfers into it and out of it,
   * that were above the threshold, during the last 25 hours.
   *
   * @augments {Query<TransactionRecord[]>}
   */
  class AccountRecordsQuery extends Query {
      /**
       * @param {object} [props]
       * @param {AccountId | string} [props.accountId]
       */
      constructor(props = {}) {
          super();

          /**
           * @type {?AccountId}
           * @private
           */
          this._accountId = null;

          if (props.accountId != null) {
              this.setAccountId(props.accountId);
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.IQuery} query
       * @returns {AccountRecordsQuery}
       */
      static _fromProtobuf(query) {
          const records =
              /** @type {HieroProto.proto.ICryptoGetAccountRecordsQuery} */ (
                  query.cryptoGetAccountRecords
              );

          return new AccountRecordsQuery({
              accountId:
                  records.accountID != null
                      ? AccountId._fromProtobuf(records.accountID)
                      : undefined,
          });
      }

      /**
       * @returns {?AccountId}
       */
      get accountId() {
          return this._accountId;
      }

      /**
       * Set the account ID for which the records are being requested.
       *
       * @param {AccountId | string} accountId
       * @returns {this}
       */
      setAccountId(accountId) {
          this._accountId =
              typeof accountId === "string"
                  ? AccountId.fromString(accountId)
                  : accountId.clone();

          return this;
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          if (this._accountId != null) {
              this._accountId.validateChecksum(client);
          }
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.IQuery} request
       * @returns {Promise<HieroProto.proto.IResponse>}
       */
      _execute(channel, request) {
          return channel.crypto.getAccountRecords(request);
      }

      /**
       * @override
       * @internal
       * @param {HieroProto.proto.IResponse} response
       * @returns {HieroProto.proto.IResponseHeader}
       */
      _mapResponseHeader(response) {
          const cryptoGetAccountRecords =
              /** @type {HieroProto.proto.ICryptoGetAccountRecordsResponse} */ (
                  response.cryptoGetAccountRecords
              );
          return /** @type {HieroProto.proto.IResponseHeader} */ (
              cryptoGetAccountRecords.header
          );
      }

      /**
       * @protected
       * @override
       * @param {HieroProto.proto.IResponse} response
       * @param {AccountId} nodeAccountId
       * @param {HieroProto.proto.IQuery} request
       * @returns {Promise<TransactionRecord[]>}
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _mapResponse(response, nodeAccountId, request) {
          const cryptoGetAccountRecords =
              /** @type {HieroProto.proto.ICryptoGetAccountRecordsResponse} */ (
                  response.cryptoGetAccountRecords
              );
          const records = /** @type {HieroProto.proto.ITransactionRecord[]} */ (
              cryptoGetAccountRecords.records
          );

          return Promise.resolve(
              records.map((record) =>
                  TransactionRecord._fromProtobuf({ transactionRecord: record }),
              ),
          );
      }

      /**
       * @override
       * @internal
       * @param {HieroProto.proto.IQueryHeader} header
       * @returns {HieroProto.proto.IQuery}
       */
      _onMakeRequest(header) {
          return {
              cryptoGetAccountRecords: {
                  header,
                  accountID:
                      this._accountId != null
                          ? this._accountId._toProtobuf()
                          : null,
              },
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp =
              this._paymentTransactionId != null &&
              this._paymentTransactionId.validStart != null
                  ? this._paymentTransactionId.validStart
                  : this._timestamp;

          return `AccountRecordsQuery:${timestamp.toString()}`;
      }
  }

  QUERY_REGISTRY.set(
      "cryptoGetAccountRecords",
      // eslint-disable-next-line @typescript-eslint/unbound-method
      AccountRecordsQuery._fromProtobuf,
  );

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
   * @typedef {import("@hashgraph/proto").proto.ICryptoUpdateTransactionBody} HieroProto.proto.ICryptoUpdateTransactionBody
   * @typedef {import("@hashgraph/proto").proto.IAccountID} HieroProto.proto.IAccountID
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   */

  /**
   * Change properties for the given account.
   */
  class AccountUpdateTransaction extends Transaction {
      /**
       * @param {object} props
       * @param {AccountId} [props.accountId]
       * @param {Key} [props.key]
       * @param {?boolean} [props.receiverSignatureRequired]
       * @param {AccountId} [props.proxyAccountId]
       * @param {Duration | Long | number} [props.autoRenewPeriod]
       * @param {Timestamp | Date} [props.expirationTime]
       * @param {?string} [props.accountMemo]
       * @param {Long | number} [props.maxAutomaticTokenAssociations]
       * @param {Key} [props.aliasKey]
       * @param {AccountId | string} [props.stakedAccountId]
       * @param {Long | number} [props.stakedNodeId]
       * @param {?boolean} [props.declineStakingReward]
       */
      constructor(props = {}) {
          super();

          /**
           * @private
           * @type {?AccountId}
           */
          this._accountId = null;

          /**
           * @private
           * @type {?Key}
           */
          this._key = null;

          /**
           * @private
           * @type {?boolean}
           */
          this._receiverSignatureRequired = null;

          /**
           * @private
           * @type {?AccountId}
           */
          this._proxyAccountId = null;

          /**
           * @private
           * @type {?Duration}
           */
          this._autoRenewPeriod = null;

          /**
           * @private
           * @type {?Timestamp}
           */
          this._expirationTime = null;

          /**
           * @private
           * @type {?string}
           */
          this._accountMemo = null;

          /**
           * @private
           * @type {?Long}
           */
          this._maxAutomaticTokenAssociations = null;

          /**
           * @private
           * @type {?Key}
           */
          this._aliasKey = null;

          /**
           * @private
           * @type {?AccountId}
           */
          this._stakedAccountId = null;

          /**
           * @private
           * @type {?Long}
           */
          this._stakedNodeId = null;

          /**
           * @private
           * @type {?boolean}
           */
          this._declineStakingReward = null;

          if (props.accountId != null) {
              this.setAccountId(props.accountId);
          }

          if (props.key != null) {
              this.setKey(props.key);
          }

          if (props.receiverSignatureRequired != null) {
              this.setReceiverSignatureRequired(props.receiverSignatureRequired);
          }

          if (props.proxyAccountId != null) {
              // eslint-disable-next-line deprecation/deprecation
              this.setProxyAccountId(props.proxyAccountId);
          }

          if (props.autoRenewPeriod != null) {
              this.setAutoRenewPeriod(props.autoRenewPeriod);
          }

          if (props.expirationTime != null) {
              this.setExpirationTime(props.expirationTime);
          }

          if (props.accountMemo != null) {
              this.setAccountMemo(props.accountMemo);
          }

          if (props.maxAutomaticTokenAssociations != null) {
              this.setMaxAutomaticTokenAssociations(
                  props.maxAutomaticTokenAssociations,
              );
          }

          if (props.stakedAccountId != null) {
              this.setStakedAccountId(props.stakedAccountId);
          }

          if (props.stakedNodeId != null) {
              this.setStakedNodeId(props.stakedNodeId);
          }

          if (props.declineStakingReward != null) {
              this.setDeclineStakingReward(props.declineStakingReward);
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransaction[]} transactions
       * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {HieroProto.proto.ITransactionBody[]} bodies
       * @returns {AccountUpdateTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];
          const update =
              /** @type {HieroProto.proto.ICryptoUpdateTransactionBody} */ (
                  body.cryptoUpdateAccount
              );

          return Transaction._fromProtobufTransactions(
              new AccountUpdateTransaction({
                  accountId:
                      update.accountIDToUpdate != null
                          ? AccountId._fromProtobuf(
                                /** @type {HieroProto.proto.IAccountID} */ (
                                    update.accountIDToUpdate
                                ),
                            )
                          : undefined,
                  key:
                      update.key != null
                          ? Key._fromProtobufKey(update.key)
                          : undefined,
                  receiverSignatureRequired:
                      update.receiverSigRequiredWrapper != null
                          ? Object.hasOwn(
                                update.receiverSigRequiredWrapper,
                                "value",
                            )
                              ? update.receiverSigRequiredWrapper.value
                              : undefined
                          : undefined,
                  proxyAccountId:
                      update.proxyAccountID != null
                          ? AccountId._fromProtobuf(
                                /** @type {HieroProto.proto.IAccountID} */ (
                                    update.proxyAccountID
                                ),
                            )
                          : undefined,
                  autoRenewPeriod:
                      update.autoRenewPeriod != null
                          ? update.autoRenewPeriod.seconds != null
                              ? update.autoRenewPeriod.seconds
                              : undefined
                          : undefined,
                  expirationTime:
                      update.expirationTime != null
                          ? Timestamp._fromProtobuf(update.expirationTime)
                          : undefined,
                  accountMemo:
                      update.memo != null
                          ? Object.hasOwn(update.memo, "value")
                              ? update.memo.value
                              : undefined
                          : undefined,
                  maxAutomaticTokenAssociations:
                      update.maxAutomaticTokenAssociations != null &&
                      update.maxAutomaticTokenAssociations.value != null &&
                      Object.hasOwn(update.maxAutomaticTokenAssociations, "value")
                          ? Long.fromNumber(
                                update.maxAutomaticTokenAssociations.value,
                            )
                          : undefined,
                  stakedAccountId:
                      update.stakedAccountId != null
                          ? AccountId._fromProtobuf(update.stakedAccountId)
                          : undefined,
                  stakedNodeId:
                      update.stakedNodeId != null
                          ? update.stakedNodeId
                          : undefined,
                  declineStakingReward:
                      update.declineReward != null
                          ? Object.hasOwn(update.declineReward, "value")
                              ? update.declineReward.value
                              : undefined
                          : undefined,
              }),
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * @returns {?AccountId}
       */
      get accountId() {
          return this._accountId;
      }

      /**
       * Sets the account ID which is being updated in this transaction.
       *
       * @param {AccountId | string} accountId
       * @returns {AccountUpdateTransaction}
       */
      setAccountId(accountId) {
          this._requireNotFrozen();
          this._accountId =
              typeof accountId === "string"
                  ? AccountId.fromString(accountId)
                  : accountId.clone();

          return this;
      }

      /**
       * @returns {?Key}
       */
      get key() {
          return this._key;
      }

      /**
       * @param {Key} key
       * @returns {this}
       */
      setKey(key) {
          this._requireNotFrozen();
          this._key = key;

          return this;
      }

      /**
       * @returns {?boolean}
       */
      get receiverSignatureRequired() {
          return this._receiverSignatureRequired;
      }

      /**
       * @param {boolean} receiverSignatureRequired
       * @returns {this}
       */
      setReceiverSignatureRequired(receiverSignatureRequired) {
          this._requireNotFrozen();
          this._receiverSignatureRequired = receiverSignatureRequired;

          return this;
      }

      /**
       * @deprecated
       * @returns {?AccountId}
       */
      get proxyAccountId() {
          return this._proxyAccountId;
      }

      /**
       * @deprecated
       * @param {AccountId} proxyAccountId
       * @returns {this}
       */
      setProxyAccountId(proxyAccountId) {
          this._requireNotFrozen();
          this._proxyAccountId = proxyAccountId;

          return this;
      }

      /**
       * @returns {?Duration}
       */
      get autoRenewPeriod() {
          return this._autoRenewPeriod;
      }

      /**
       * @param {Duration | Long | number} autoRenewPeriod
       * @returns {this}
       */
      setAutoRenewPeriod(autoRenewPeriod) {
          this._requireNotFrozen();
          this._autoRenewPeriod =
              autoRenewPeriod instanceof Duration
                  ? autoRenewPeriod
                  : new Duration(autoRenewPeriod);

          return this;
      }

      /**
       * @returns {?Timestamp}
       */
      get expirationTime() {
          return this._expirationTime;
      }

      /**
       * @param {Timestamp | Date} expirationTime
       * @returns {this}
       */
      setExpirationTime(expirationTime) {
          this._requireNotFrozen();
          this._expirationTime =
              expirationTime instanceof Date
                  ? Timestamp.fromDate(expirationTime)
                  : expirationTime;

          return this;
      }

      /**
       * @returns {?string}
       */
      get accountMemo() {
          return this._accountMemo;
      }

      /**
       * @param {string} memo
       * @returns {this}
       */
      setAccountMemo(memo) {
          this._requireNotFrozen();
          this._accountMemo = memo;

          return this;
      }

      /**
       * @returns {this}
       */
      clearAccountMemo() {
          this._requireNotFrozen();
          this._accountMemo = null;

          return this;
      }

      /**
       * @returns {?Long}
       */
      get maxAutomaticTokenAssociations() {
          return this._maxAutomaticTokenAssociations;
      }

      /**
       * @param {Long | number} maxAutomaticTokenAssociations
       * @returns {this}
       */
      setMaxAutomaticTokenAssociations(maxAutomaticTokenAssociations) {
          this._requireNotFrozen();
          this._maxAutomaticTokenAssociations =
              typeof maxAutomaticTokenAssociations === "number"
                  ? Long.fromNumber(maxAutomaticTokenAssociations)
                  : maxAutomaticTokenAssociations;

          return this;
      }

      /**
       * @deprecated - no longer supported
       * @returns {?Key}
       */
      get aliasKey() {
          return null;
      }

      /**
       * @deprecated - no longer supported
       * @param {Key} _
       * @returns {this}
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      setAliasKey(_) {
          return this;
      }

      /**
       * @returns {?AccountId}
       */
      get stakedAccountId() {
          return this._stakedAccountId;
      }

      /**
       * @param {AccountId | string} stakedAccountId
       * @returns {this}
       */
      setStakedAccountId(stakedAccountId) {
          this._requireNotFrozen();
          this._stakedAccountId =
              typeof stakedAccountId === "string"
                  ? AccountId.fromString(stakedAccountId)
                  : stakedAccountId;

          return this;
      }

      /**
       * @returns {this}
       */
      clearStakedAccountId() {
          this._requireNotFrozen();
          this._stakedAccountId = new AccountId(0, 0, 0);

          return this;
      }

      /**
       * @returns {?Long}
       */
      get stakedNodeId() {
          return this._stakedNodeId;
      }

      /**
       * @param {Long | number} stakedNodeId
       * @returns {this}
       */
      setStakedNodeId(stakedNodeId) {
          this._requireNotFrozen();
          this._stakedNodeId = Long.fromValue(stakedNodeId);

          return this;
      }

      /**
       * @returns {this}
       */
      clearStakedNodeId() {
          this._requireNotFrozen();
          this._stakedNodeId = Long.fromNumber(-1);

          return this;
      }

      /**
       * @returns {?boolean}
       */
      get declineStakingRewards() {
          return this._declineStakingReward;
      }

      /**
       * @param {boolean} declineStakingReward
       * @returns {this}
       */
      setDeclineStakingReward(declineStakingReward) {
          this._requireNotFrozen();
          this._declineStakingReward = declineStakingReward;

          return this;
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          if (this._accountId != null) {
              this._accountId.validateChecksum(client);
          }

          if (this._proxyAccountId != null) {
              this._proxyAccountId.validateChecksum(client);
          }
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.ITransaction} request
       * @returns {Promise<HieroProto.proto.ITransactionResponse>}
       */
      _execute(channel, request) {
          return channel.crypto.updateAccount(request);
      }

      /**
       * @override
       * @protected
       * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "cryptoUpdateAccount";
      }

      /**
       * @override
       * @protected
       * @returns {HieroProto.proto.ICryptoUpdateTransactionBody}
       */
      _makeTransactionData() {
          return {
              accountIDToUpdate:
                  this._accountId != null ? this._accountId._toProtobuf() : null,
              key: this._key != null ? this._key._toProtobufKey() : null,
              expirationTime:
                  this._expirationTime != null
                      ? this._expirationTime._toProtobuf()
                      : null,
              proxyAccountID:
                  this._proxyAccountId != null
                      ? this._proxyAccountId._toProtobuf()
                      : null,
              autoRenewPeriod:
                  this._autoRenewPeriod != null
                      ? this._autoRenewPeriod._toProtobuf()
                      : null,
              receiverSigRequiredWrapper:
                  this._receiverSignatureRequired == null
                      ? null
                      : {
                            value: this._receiverSignatureRequired,
                        },
              memo:
                  this._accountMemo != null
                      ? {
                            value: this._accountMemo,
                        }
                      : null,
              maxAutomaticTokenAssociations:
                  this._maxAutomaticTokenAssociations != null
                      ? { value: this._maxAutomaticTokenAssociations.toInt() }
                      : null,
              stakedAccountId:
                  this.stakedAccountId != null
                      ? this.stakedAccountId._toProtobuf()
                      : null,
              stakedNodeId: this.stakedNodeId,
              declineReward:
                  this.declineStakingRewards != null
                      ? { value: this.declineStakingRewards }
                      : null,
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("../Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `AccountUpdateTransaction:${timestamp.toString()}`;
      }
  }

  TRANSACTION_REGISTRY.set(
      "cryptoUpdateAccount",
      // eslint-disable-next-line @typescript-eslint/unbound-method
      AccountUpdateTransaction._fromProtobuf,
  );

  // SPDX-License-Identifier: Apache-2.0

  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.FreezeType} HieroProto.proto.FreezeType
   */

  class FreezeType {
      /**
       * @hideconstructor
       * @internal
       * @param {number} code
       */
      constructor(code) {
          /** @readonly */
          this._code = code;

          Object.freeze(this);
      }

      /**
       * @returns {string}
       */
      toString() {
          switch (this) {
              case FreezeType.UnknownFreezeType:
                  return "UNKNOWN_FREEZE_TYPE";
              case FreezeType.FreezeOnly:
                  return "FREEZE_ONLY";
              case FreezeType.PrepareUpgrade:
                  return "PREPARE_UPGRADE";
              case FreezeType.FreezeUpgrade:
                  return "FREEZE_UPGRADE";
              case FreezeType.FreezeAbort:
                  return "FREEZE_ABORT";
              case FreezeType.TelemetryUpgrade:
                  return "TELEMETRY_UPGRADE";
              default:
                  return `UNKNOWN (${this._code})`;
          }
      }

      /**
       * @internal
       * @param {number} code
       * @returns {FreezeType}
       */
      static _fromCode(code) {
          switch (code) {
              case 0:
                  return FreezeType.UnknownFreezeType;
              case 1:
                  return FreezeType.FreezeOnly;
              case 2:
                  return FreezeType.PrepareUpgrade;
              case 3:
                  return FreezeType.FreezeUpgrade;
              case 4:
                  return FreezeType.FreezeAbort;
              case 5:
                  return FreezeType.TelemetryUpgrade;
              default:
                  throw new Error(
                      `(BUG) Status.fromCode() does not handle code: ${code}`,
                  );
          }
      }

      /**
       * @returns {HieroProto.proto.FreezeType}
       */
      valueOf() {
          return this._code;
      }
  }

  /**
   * An (invalid) default value for this enum, to ensure the client explicitly sets
   * the intended type of freeze transaction.
   */
  FreezeType.UnknownFreezeType = new FreezeType(0);

  /**
   * Freezes the network at the specified time. The start_time field must be provided and
   * must reference a future time. Any values specified for the update_file and file_hash
   * fields will be ignored. This transaction does not perform any network changes or
   * upgrades and requires manual intervention to restart the network.
   */
  FreezeType.FreezeOnly = new FreezeType(1);

  /**
   * A non-freezing operation that initiates network wide preparation in advance of a
   * scheduled freeze upgrade. The update_file and file_hash fields must be provided and
   * valid. The start_time field may be omitted and any value present will be ignored.
   */
  FreezeType.PrepareUpgrade = new FreezeType(2);

  /**
   * Freezes the network at the specified time and performs the previously prepared
   * automatic upgrade across the entire network.
   */
  FreezeType.FreezeUpgrade = new FreezeType(3);

  /**
   * Aborts a pending network freeze operation.
   */
  FreezeType.FreezeAbort = new FreezeType(4);

  /**
   * Performs an immediate upgrade on auxilary services and containers providing
   * telemetry/metrics. Does not impact network operations.
   */
  FreezeType.TelemetryUpgrade = new FreezeType(5);

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
   * @typedef {import("@hashgraph/proto").proto.IFreezeTransactionBody} HieroProto.proto.IFreezeTransactionBody
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../account/AccountId.js").default} AccountId
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   */

  /**
   * @typedef {object} HourMinute
   * @property {number} hour
   * @property {number} minute
   */

  /**
   * Freeze, cancel, or prepare a freeze.
   * This single transaction performs all of the functions supported
   * by the network freeze service. These functions include actions to
   * prepare an upgrade, prepare a telemetry upgrade, freeze the network,
   * freeze the network for upgrade, or abort a scheduled freeze.
   * <p>
   * The actual freeze action SHALL be determined by the `freeze_type` field
   * of the `FreezeTransactionBody`.<br/>
   */
  class FreezeTransaction extends Transaction {
      /**
       * @param {object} [props]
       * @param {HourMinute} [props.startTime]
       * @param {HourMinute} [props.endTime]
       * @param {Timestamp} [props.startTimestamp]
       * @param {FileId} [props.updateFileId]
       * @param {FileId} [props.fileId]
       * @param {Uint8Array | string} [props.fileHash]
       * @param { FreezeType } [props.freezeType]
       */
      constructor(props = {}) {
          super();

          /**
           * @private
           * @type {?HourMinute}
           */
          this._startTime = null;

          /**
           * @private
           * @type {?Timestamp}
           */
          this._startTimestamp = null;

          /**
           * @private
           * @type {?HourMinute}
           */
          this._endTime = null;

          /**
           * @private
           * @type {?FileId}
           */
          this._fileId = null;

          /**
           * @private
           * @type {?Uint8Array}
           */
          this._fileHash = null;

          /**
           * @private
           * @type {?FreezeType}
           */
          this._freezeType = null;

          if (props.startTime != null) {
              // eslint-disable-next-line deprecation/deprecation
              this.setStartTime(props.startTime.hour, props.startTime.minute);
          }

          if (props.endTime != null) {
              // eslint-disable-next-line deprecation/deprecation
              this.setEndTime(props.endTime.hour, props.endTime.minute);
          }

          if (props.startTimestamp != null) {
              this.setStartTimestamp(props.startTimestamp);
          }

          if (props.updateFileId != null) {
              // eslint-disable-next-line deprecation/deprecation
              this.setUpdateFileId(props.updateFileId);
          }

          if (props.fileId != null) {
              this.setFileId(props.fileId);
          }

          if (props.fileHash != null) {
              this.setFileHash(props.fileHash);
          }

          if (props.freezeType != null) {
              this.setFreezeType(props.freezeType);
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransaction[]} transactions
       * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {HieroProto.proto.ITransactionBody[]} bodies
       * @returns {FreezeTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];
          const freeze = /** @type {HieroProto.proto.IFreezeTransactionBody} */ (
              body.freeze
          );

          return Transaction._fromProtobufTransactions(
              new FreezeTransaction({
                  startTime:
                      freeze.startHour != null && freeze.startMin != null
                          ? {
                                hour: freeze.startHour,
                                minute: freeze.startMin,
                            }
                          : undefined,
                  endTime:
                      freeze.endHour != null && freeze.endMin != null
                          ? {
                                hour: freeze.endHour,
                                minute: freeze.endMin,
                            }
                          : undefined,
                  startTimestamp:
                      freeze.startTime != null
                          ? Timestamp._fromProtobuf(freeze.startTime)
                          : undefined,
                  updateFileId:
                      freeze.updateFile != null
                          ? FileId._fromProtobuf(freeze.updateFile)
                          : undefined,
                  fileHash: freeze.fileHash != null ? freeze.fileHash : undefined,
                  freezeType:
                      freeze.freezeType != null
                          ? FreezeType._fromCode(freeze.freezeType)
                          : undefined,
              }),
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * @deprecated - Use `startTimestamp` instead
       * @returns {?HourMinute}
       */
      get startTime() {
          return null;
      }

      /**
       * @deprecated - Use `startTimestamp` instead
       * @param {number | string} startHourOrString
       * @param {?number} startMinute
       * @returns {FreezeTransaction}
       */
      setStartTime(startHourOrString, startMinute) {
          this._requireNotFrozen();
          if (typeof startHourOrString === "string") {
              const split = startHourOrString.split(":");
              this._startTime = {
                  hour: Number(split[0]),
                  minute: Number(split[1]),
              };
          } else {
              this._startTime = {
                  hour: startHourOrString,
                  minute: /** @type {number} */ (startMinute),
              };
          }

          return this;
      }

      /**
       * @returns {?Timestamp}
       */
      get startTimestamp() {
          return this._startTimestamp;
      }

      /**
       * @param {Timestamp} startTimestamp
       * @returns {FreezeTransaction}
       */
      setStartTimestamp(startTimestamp) {
          this._requireNotFrozen();
          this._startTimestamp = startTimestamp;

          return this;
      }

      /**
       * @deprecated
       * @returns {?HourMinute}
       */
      get endTime() {
          console.warn("`FreezeTransaction.endTime` is deprecated");
          return this._endTime;
      }

      /**
       * @deprecated
       * @param {number | string} endHourOrString
       * @param {?number} endMinute
       * @returns {FreezeTransaction}
       */
      setEndTime(endHourOrString, endMinute) {
          console.warn("`FreezeTransaction.endTime` is deprecated");
          this._requireNotFrozen();
          if (typeof endHourOrString === "string") {
              const split = endHourOrString.split(":");
              this._endTime = {
                  hour: Number(split[0]),
                  minute: Number(split[1]),
              };
          } else {
              this._endTime = {
                  hour: endHourOrString,
                  minute: /** @type {number} */ (endMinute),
              };
          }

          return this;
      }

      /**
       * @deprecated - Use `fileId` instead
       * @returns {?FileId}
       */
      get updateFileId() {
          return this.fileId;
      }

      /**
       * @deprecated - Use `setFileId()` instead
       * @param {FileId} updateFileId
       * @returns {FreezeTransaction}
       */
      setUpdateFileId(updateFileId) {
          return this.setFileId(updateFileId);
      }

      /**
       * @returns {?FileId}
       */
      get fileId() {
          return this._fileId;
      }

      /**
       * @param {FileId} fileId
       * @returns {FreezeTransaction}
       */
      setFileId(fileId) {
          this._requireNotFrozen();
          this._fileId = fileId;

          return this;
      }

      /**
       * @returns {?Uint8Array}
       */
      get fileHash() {
          return this._fileHash;
      }

      /**
       * @param {Uint8Array | string} fileHash
       * @returns {FreezeTransaction}
       */
      setFileHash(fileHash) {
          this._requireNotFrozen();
          this._fileHash =
              typeof fileHash === "string" ? decode$8(fileHash) : fileHash;

          return this;
      }

      /**
       * @returns {?FreezeType}
       */
      get freezeType() {
          return this._freezeType;
      }

      /**
       * @param {FreezeType} freezeType
       * @returns {FreezeTransaction}
       */
      setFreezeType(freezeType) {
          this._requireNotFrozen();
          this._freezeType = freezeType;
          return this;
      }

      /**
       * @override
       * @protected
       * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "freeze";
      }

      /**
       * @override
       * @protected
       * @returns {HieroProto.proto.IFreezeTransactionBody}
       */
      _makeTransactionData() {
          return {
              startTime:
                  this._startTimestamp != null
                      ? this._startTimestamp._toProtobuf()
                      : null,
              updateFile:
                  this._fileId != null ? this._fileId._toProtobuf() : null,
              fileHash: this._fileHash,
              freezeType:
                  this._freezeType != null ? this._freezeType.valueOf() : null,
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("../Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `FreezeTransaction:${timestamp.toString()}`;
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.ITransaction} request
       * @returns {Promise<HieroProto.proto.ITransactionResponse>}
       */
      _execute(channel, request) {
          return channel.freeze.freeze(request);
      }
  }

  // eslint-disable-next-line @typescript-eslint/unbound-method
  TRANSACTION_REGISTRY.set("freeze", FreezeTransaction._fromProtobuf);

  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   * @typedef {import("../account/AccountId.js").default} AccountId
   * @typedef {import("../Key.js").default} Key
   */

  /**
   * @description Execute multiple transactions in a single consensus event. This allows for atomic execution of multiple
   * transactions, where they either all succeed or all fail together.
   * <p>
   * Requirements:
   * <ul>
   *     <li>All inner transactions must be frozen before being added to the batch</li>
   *     <li>All inner transactions must have a batch key set</li>
   *     <li>All inner transactions must be signed as required for each individual transaction</li>
   *     <li>The BatchTransaction must be signed by all batch keys of the inner transactions</li>
   *     <li>Certain transaction types (FreezeTransaction, BatchTransaction) are not allowed in a batch</li>
   * </ul>
   * <p>
   * Important notes:
   * <ul>
   *     <li>Fees are assessed for each inner transaction separately</li>
   *     <li>The maximum number of inner transactions in a batch is limited to 25</li>
   *     <li>Inner transactions cannot be scheduled transactions</li>
   * </ul>
   *
   */
  class BatchTransaction extends Transaction {
      /**
       * @param {object} [options]
       * @param {Transaction[] | null} [options.transactions]
       */
      constructor(options) {
          super();
          this._batchTransactions = options?.transactions || [];
      }

      /**
       * Set the list of transactions to be executed as part of this BatchTransaction.
       * <p>
       * Requirements for each inner transaction:
       * <ul>
       *     <li>Must be frozen (use {@link Transaction#freeze()} or {@link Transaction#freezeWith(Client)})</li>
       *     <li>Must have a batch key set (use {@link Transaction#setBatchKey(Key)}} or {@link Transaction#batchify(Client, Key)})</li>
       *     <li>Must not be a blacklisted transaction type</li>
       * </ul>
       * <p>
       * Note: This method creates a defensive copy of the provided list.
       *
       * @param {Transaction[]} txs
       * @returns {BatchTransaction}
       */
      setInnerTransactions(txs) {
          txs.forEach((tx) => this._validateTransaction(tx));
          this._batchTransactions = txs;
          return this;
      }

      /**
       * Append a transaction to the list of transactions this BatchTransaction will execute.
       * <p>
       * Requirements for the inner transaction:
       * <ul>
       *     <li>Must be frozen (use {@link Transaction#freeze()} or {@link Transaction#freezeWith(Client)})</li>
       *     <li>Must have a batch key set (use {@link Transaction#setBatchKey(Key)}} or {@link Transaction#batchify(Client, Key)})</li>
       *     <li>Must not be a blacklisted transaction type</li>
       * </ul>
       *
       * @param {Transaction} tx
       * @returns {BatchTransaction}
       */
      addInnerTransaction(tx) {
          this._validateTransaction(tx);
          this._requireNotFrozen();
          this._batchTransactions.push(tx);
          return this;
      }

      /**
       * Get the list of transactions this BatchTransaction is currently configured to execute.
       * <p>
       * Note: This returns the actual list of transactions. Modifications to this list will affect
       * the batch transaction if it is not frozen.
       *
       * @returns {Transaction[]}
       */
      get innerTransactions() {
          return this._batchTransactions;
      }

      /**
       * Get the list of transaction IDs of each inner transaction of this BatchTransaction.
       * <p>
       * This method is particularly useful after execution to:
       * <ul>
       *     <li>Track individual transaction results</li>
       *     <li>Query receipts for specific inner transactions</li>
       *     <li>Monitor the status of each transaction in the batch</li>
       * </ul>
       * <p>
       * <b>NOTE:</b> Transaction IDs will only be meaningful after the batch transaction has been
       * executed or the IDs have been explicitly set on the inner transactions.
       *
       * @returns {(TransactionId | null)[]}
       */
      get innerTransactionIds() {
          if (!Array.isArray(this._batchTransactions)) {
              return [];
          }

          return this._batchTransactions.map((tx) => tx.transactionId);
      }

      /**
       *
       * @returns {proto.AtomicBatchTransactionBody}
       */
      _makeTransactionData() {
          if (!Array.isArray(this._batchTransactions)) {
              return {
                  transactions: [],
              };
          }

          const signedTransactionBytes = this._batchTransactions.map((tx) =>
              libExports.proto.SignedTransaction.encode(
                  tx._signedTransactions.get(0),
              ).finish(),
          );
          return {
              transactions: signedTransactionBytes,
          };
      }

      /**
       * @internal
       * @param {proto.ITransaction[]} transactions
       * @param {proto.ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {HieroProto.proto.ITransactionBody[]} bodies
       * @returns {BatchTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];
          const atomicBatchTxBytes = body.atomicBatch?.transactions;

          const atomicBatchSignedTransactions = atomicBatchTxBytes?.map((tx) =>
              libExports.proto.SignedTransaction.decode(tx),
          );

          const atomicBatchTxs = atomicBatchSignedTransactions?.map((tx) => {
              const txBody = libExports.proto.TransactionBody.decode(tx.bodyBytes);
              const txType = txBody.data;
              if (!txType) {
                  throw new Error("Transaction type not found");
              }

              const fromProtobuf = TRANSACTION_REGISTRY.get(txType);
              if (!fromProtobuf) {
                  throw new Error("fromProtobuf not found");
              }
              /* Inner transactions only have one signed transactios therefore
              the other properties are empty that are needed from the 
              Transaction._fromProtobufTransactions method
              */

              /**
               * @type {proto.ITransaction[]}
               */
              const innerTransactions = [];
              /**
               * @type {proto.ISignedTransaction[]}
               */
              const signedInnerTransactions = [tx];
              /**
               * @type {TransactionId[]}
               */
              const innerTransactionIds = [];

              /**
               * Node account IDs is empty for inner transactions
               * @type {AccountId[]}
               */
              const nodeAccountIds = [];

              /**
               * @type {HieroProto.proto.TransactionBody[]}
               */
              const bodies = [txBody];

              return fromProtobuf(
                  innerTransactions,
                  signedInnerTransactions,
                  innerTransactionIds,
                  nodeAccountIds,
                  bodies,
              );
          });

          return Transaction._fromProtobufTransactions(
              new BatchTransaction({
                  transactions: atomicBatchTxs,
              }),
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * This method returns a key for the `data` field in a transaction body.
       * Each transaction overwrite this to make sure when we build the transaction body
       * we set the right data field.
       *
       * @abstract
       * @protected
       * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "atomicBatch";
      }

      /**
       * @description Get the log ID for the BatchTransaction.
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("../Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `AtomicBatch:${timestamp.toString()}`;
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.ITransaction} request
       * @returns {Promise<HieroProto.proto.ITransactionResponse>}
       */
      _execute(channel, request) {
          return channel.util.atomicBatch(request);
      }

      /**
       * @description Validate the transaction
       * @param {Transaction} tx
       * @throws {Error} If the transaction is a batch or freeze transaction
       */
      _validateTransaction(tx) {
          if (tx instanceof BatchTransaction || tx instanceof FreezeTransaction) {
              throw new Error(
                  "Transaction is not allowed to be added to a batch",
              );
          }
          if (!tx.isFrozen()) {
              throw new Error(
                  "Transaction must be frozen before being added to a batch",
              );
          }
          if (!tx.batchKey) {
              throw new Error("Transaction must have a batch key");
          }
      }
  }

  TRANSACTION_REGISTRY.set(
      "atomicBatch",
      // eslint-disable-next-line @typescript-eslint/unbound-method
      BatchTransaction._fromProtobuf,
  );

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.IQuery} HieroProto.proto.IQuery
   * @typedef {import("@hashgraph/proto").proto.IQueryHeader} HieroProto.proto.IQueryHeader
   * @typedef {import("@hashgraph/proto").proto.IResponse} HieroProto.proto.IResponse
   * @typedef {import("@hashgraph/proto").proto.IResponseHeader} HieroProto.proto.IResponseHeader
   * @typedef {import("@hashgraph/proto").proto.IContractGetBytecodeQuery} HieroProto.proto.IContractGetBytecodeQuery
   * @typedef {import("@hashgraph/proto").proto.IContractGetBytecodeResponse} HieroProto.proto.IContractGetBytecodeResponse
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("../account/AccountId.js").default} AccountId
   */

  /**
   * Query to retrieve the bytecode of a smart contract from the network.
   *
   * This query returns the bytecode of a smart contract instance that has been
   * created on the Hedera network. The bytecode represents the compiled code
   * that is executed by the Hedera network when the contract is called.
   *
   * @augments {Query<Uint8Array>}
   */
  class ContractByteCodeQuery extends Query {
      /**
       * @param {object} props
       * @param {ContractId | string} [props.contractId]
       */
      constructor(props = {}) {
          super();

          /**
           * @type {?ContractId}
           * @private
           */
          this._contractId = null;
          if (props.contractId != null) {
              this.setContractId(props.contractId);
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.IQuery} query
       * @returns {ContractByteCodeQuery}
       */
      static _fromProtobuf(query) {
          const bytecode =
              /** @type {HieroProto.proto.IContractGetBytecodeQuery} */ (
                  query.contractGetBytecode
              );

          return new ContractByteCodeQuery({
              contractId:
                  bytecode.contractID != null
                      ? ContractId._fromProtobuf(bytecode.contractID)
                      : undefined,
          });
      }

      /**
       * @returns {?ContractId}
       */
      get contractId() {
          return this._contractId;
      }

      /**
       * Set the contract ID for which the info is being requested.
       *
       * @param {ContractId | string} contractId
       * @returns {ContractByteCodeQuery}
       */
      setContractId(contractId) {
          this._contractId =
              typeof contractId === "string"
                  ? ContractId.fromString(contractId)
                  : contractId.clone();

          return this;
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          if (this._contractId != null) {
              this._contractId.validateChecksum(client);
          }
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.IQuery} request
       * @returns {Promise<HieroProto.proto.IResponse>}
       */
      _execute(channel, request) {
          return channel.smartContract.contractGetBytecode(request);
      }

      /**
       * @override
       * @internal
       * @param {HieroProto.proto.IResponse} response
       * @returns {HieroProto.proto.IResponseHeader}
       */
      _mapResponseHeader(response) {
          const contractGetBytecodeResponse =
              /** @type {HieroProto.proto.IContractGetBytecodeResponse} */ (
                  response.contractGetBytecodeResponse
              );
          return /** @type {HieroProto.proto.IResponseHeader} */ (
              contractGetBytecodeResponse.header
          );
      }

      /**
       * @protected
       * @override
       * @param {HieroProto.proto.IResponse} response
       * @returns {Promise<Uint8Array>}
       */
      _mapResponse(response) {
          const contractGetBytecodeResponse =
              /** @type {HieroProto.proto.IContractGetBytecodeResponse} */ (
                  response.contractGetBytecodeResponse
              );

          return Promise.resolve(
              contractGetBytecodeResponse.bytecode != null
                  ? contractGetBytecodeResponse.bytecode
                  : new Uint8Array(),
          );
      }

      /**
       * @override
       * @internal
       * @param {HieroProto.proto.IQueryHeader} header
       * @returns {HieroProto.proto.IQuery}
       */
      _onMakeRequest(header) {
          return {
              contractGetBytecode: {
                  header,
                  contractID:
                      this._contractId != null
                          ? this._contractId._toProtobuf()
                          : null,
              },
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp =
              this._paymentTransactionId != null &&
              this._paymentTransactionId.validStart != null
                  ? this._paymentTransactionId.validStart
                  : this._timestamp;

          return `ContractByteCodeQuery:${timestamp.toString()}`;
      }
  }

  // eslint-disable-next-line @typescript-eslint/unbound-method
  QUERY_REGISTRY.set("contractGetBytecode", ContractByteCodeQuery._fromProtobuf);

  // SPDX-License-Identifier: Apache-2.0

  // Originally sourced from:
  // https://github.com/MaiaVictor/eth-lib/blob/da0971f5b09964d9c8449975fa87933f0c9fef35/src/hash.js
  //  - added type declarations
  //  - switched to es6 module syntax
  //
  // Disable linting for entire file because it's nearly all pure JS
  // eslint-disable

  const HEX_CHARS = "0123456789abcdef".split("");
  const KECCAK_PADDING = [1, 256, 65536, 16777216];
  const SHIFT = [0, 8, 16, 24];
  const RC = [
      1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0,
      2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0,
      2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905,
      2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0,
      2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648,
      2147483649, 0, 2147516424, 2147483648,
  ];

  /**
   * @typedef {object} KeccakT
   * @property {number[]} blocks
   * @property {number} blockCount
   * @property {number} outputBlocks
   * @property {number[]} s
   * @property {number} start
   * @property {number} block
   * @property {boolean} reset
   * @property {number=} lastByteIndex
   */

  /** @type {(bits: number) => KeccakT} */
  const Keccak = (bits) => ({
      blocks: [],
      reset: true,
      block: 0,
      start: 0,
      blockCount: (1600 - (bits << 1)) >> 5,
      outputBlocks: bits >> 5,
      // @ts-ignore
      s: ((s) => [].concat(s, s, s, s, s))([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
  });

  /** @type {(state: KeccakT, message: string | number[]) => string} */
  //NOSONAR
  const update = (state, /** @type {string | number[]} */ message) => {
      var length = message.length,
          blocks = state.blocks,
          byteCount = state.blockCount << 2,
          blockCount = state.blockCount,
          outputBlocks = state.outputBlocks,
          s = state.s,
          index = 0,
          i,
          code;

      // update
      while (index < length) {
          if (state.reset) {
              state.reset = false;
              blocks[0] = state.block;
              for (i = 1; i < blockCount + 1; ++i) {
                  blocks[i] = 0;
              }
          }
          if (typeof message !== "string") {
              for (i = state.start; index < length && i < byteCount; ++index) {
                  blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
              }
          } else {
              for (i = state.start; index < length && i < byteCount; ++index) {
                  code = message.charCodeAt(index);
                  if (code < 0x80) {
                      blocks[i >> 2] |= code << SHIFT[i++ & 3];
                  } else if (code < 0x800) {
                      blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
                      blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                  } else if (code < 0xd800 || code >= 0xe000) {
                      blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
                      blocks[i >> 2] |=
                          (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
                      blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                  } else {
                      code =
                          0x10000 +
                          (((code & 0x3ff) << 10) |
                              (message.charCodeAt(++index) & 0x3ff)); //NOSONAR
                      blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
                      blocks[i >> 2] |=
                          (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
                      blocks[i >> 2] |=
                          (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
                      blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                  }
              }
          }
          state.lastByteIndex = i;
          if (i >= byteCount) {
              state.start = i - byteCount;
              state.block = blocks[blockCount];
              for (i = 0; i < blockCount; ++i) {
                  s[i] ^= blocks[i];
              }
              f(s);
              state.reset = true;
          } else {
              state.start = i;
          }
      }

      // finalize
      i = state.lastByteIndex;
      // @ts-ignore
      blocks[i >> 2] |= KECCAK_PADDING[i & 3];
      if (state.lastByteIndex === byteCount) {
          blocks[0] = blocks[blockCount];
          for (i = 1; i < blockCount + 1; ++i) {
              blocks[i] = 0;
          }
      }
      blocks[blockCount - 1] |= 0x80000000;
      for (i = 0; i < blockCount; ++i) {
          s[i] ^= blocks[i];
      }
      f(s);

      // toString
      var hex = "";
      var block;
      var j = 0;
      i = 0; //NOSONAR
      while (j < outputBlocks) {
          for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
              block = s[i];
              hex +=
                  HEX_CHARS[(block >> 4) & 0x0f] +
                  HEX_CHARS[block & 0x0f] +
                  HEX_CHARS[(block >> 12) & 0x0f] +
                  HEX_CHARS[(block >> 8) & 0x0f] +
                  HEX_CHARS[(block >> 20) & 0x0f] +
                  HEX_CHARS[(block >> 16) & 0x0f] +
                  HEX_CHARS[(block >> 28) & 0x0f] +
                  HEX_CHARS[(block >> 24) & 0x0f];
          }
          if (j % blockCount === 0) {
              f(s);
              i = 0; //NOSONAR
          }
      }
      // @ts-ignore
      return "0x" + hex;
  };

  /** @type {(s: number[]) => void} */
  const f = (s) => {
      var h,
          l,
          n,
          c0,
          c1,
          c2,
          c3,
          c4,
          c5,
          c6,
          c7,
          c8,
          c9,
          b0,
          b1,
          b2,
          b3,
          b4,
          b5,
          b6,
          b7,
          b8,
          b9,
          b10,
          b11,
          b12,
          b13,
          b14,
          b15,
          b16,
          b17,
          b18,
          b19,
          b20,
          b21,
          b22,
          b23,
          b24,
          b25,
          b26,
          b27,
          b28,
          b29,
          b30,
          b31,
          b32,
          b33,
          b34,
          b35,
          b36,
          b37,
          b38,
          b39,
          b40,
          b41,
          b42,
          b43,
          b44,
          b45,
          b46,
          b47,
          b48,
          b49;

      for (n = 0; n < 48; n += 2) {
          c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
          c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
          c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
          c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
          c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
          c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
          c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
          c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
          c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
          c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];

          h = c8 ^ ((c2 << 1) | (c3 >>> 31));
          l = c9 ^ ((c3 << 1) | (c2 >>> 31));
          s[0] ^= h;
          s[1] ^= l;
          s[10] ^= h;
          s[11] ^= l;
          s[20] ^= h;
          s[21] ^= l;
          s[30] ^= h;
          s[31] ^= l;
          s[40] ^= h;
          s[41] ^= l;
          h = c0 ^ ((c4 << 1) | (c5 >>> 31));
          l = c1 ^ ((c5 << 1) | (c4 >>> 31));
          s[2] ^= h;
          s[3] ^= l;
          s[12] ^= h;
          s[13] ^= l;
          s[22] ^= h;
          s[23] ^= l;
          s[32] ^= h;
          s[33] ^= l;
          s[42] ^= h;
          s[43] ^= l;
          h = c2 ^ ((c6 << 1) | (c7 >>> 31));
          l = c3 ^ ((c7 << 1) | (c6 >>> 31));
          s[4] ^= h;
          s[5] ^= l;
          s[14] ^= h;
          s[15] ^= l;
          s[24] ^= h;
          s[25] ^= l;
          s[34] ^= h;
          s[35] ^= l;
          s[44] ^= h;
          s[45] ^= l;
          h = c4 ^ ((c8 << 1) | (c9 >>> 31));
          l = c5 ^ ((c9 << 1) | (c8 >>> 31));
          s[6] ^= h;
          s[7] ^= l;
          s[16] ^= h;
          s[17] ^= l;
          s[26] ^= h;
          s[27] ^= l;
          s[36] ^= h;
          s[37] ^= l;
          s[46] ^= h;
          s[47] ^= l;
          h = c6 ^ ((c0 << 1) | (c1 >>> 31));
          l = c7 ^ ((c1 << 1) | (c0 >>> 31));
          s[8] ^= h;
          s[9] ^= l;
          s[18] ^= h;
          s[19] ^= l;
          s[28] ^= h;
          s[29] ^= l;
          s[38] ^= h;
          s[39] ^= l;
          s[48] ^= h;
          s[49] ^= l;

          b0 = s[0];
          b1 = s[1];
          b32 = (s[11] << 4) | (s[10] >>> 28);
          b33 = (s[10] << 4) | (s[11] >>> 28);
          b14 = (s[20] << 3) | (s[21] >>> 29);
          b15 = (s[21] << 3) | (s[20] >>> 29);
          b46 = (s[31] << 9) | (s[30] >>> 23);
          b47 = (s[30] << 9) | (s[31] >>> 23);
          b28 = (s[40] << 18) | (s[41] >>> 14);
          b29 = (s[41] << 18) | (s[40] >>> 14);
          b20 = (s[2] << 1) | (s[3] >>> 31);
          b21 = (s[3] << 1) | (s[2] >>> 31);
          b2 = (s[13] << 12) | (s[12] >>> 20);
          b3 = (s[12] << 12) | (s[13] >>> 20);
          b34 = (s[22] << 10) | (s[23] >>> 22);
          b35 = (s[23] << 10) | (s[22] >>> 22);
          b16 = (s[33] << 13) | (s[32] >>> 19);
          b17 = (s[32] << 13) | (s[33] >>> 19);
          b48 = (s[42] << 2) | (s[43] >>> 30);
          b49 = (s[43] << 2) | (s[42] >>> 30);
          b40 = (s[5] << 30) | (s[4] >>> 2);
          b41 = (s[4] << 30) | (s[5] >>> 2);
          b22 = (s[14] << 6) | (s[15] >>> 26);
          b23 = (s[15] << 6) | (s[14] >>> 26);
          b4 = (s[25] << 11) | (s[24] >>> 21);
          b5 = (s[24] << 11) | (s[25] >>> 21);
          b36 = (s[34] << 15) | (s[35] >>> 17);
          b37 = (s[35] << 15) | (s[34] >>> 17);
          b18 = (s[45] << 29) | (s[44] >>> 3);
          b19 = (s[44] << 29) | (s[45] >>> 3);
          b10 = (s[6] << 28) | (s[7] >>> 4);
          b11 = (s[7] << 28) | (s[6] >>> 4);
          b42 = (s[17] << 23) | (s[16] >>> 9);
          b43 = (s[16] << 23) | (s[17] >>> 9);
          b24 = (s[26] << 25) | (s[27] >>> 7);
          b25 = (s[27] << 25) | (s[26] >>> 7);
          b6 = (s[36] << 21) | (s[37] >>> 11);
          b7 = (s[37] << 21) | (s[36] >>> 11);
          b38 = (s[47] << 24) | (s[46] >>> 8);
          b39 = (s[46] << 24) | (s[47] >>> 8);
          b30 = (s[8] << 27) | (s[9] >>> 5);
          b31 = (s[9] << 27) | (s[8] >>> 5);
          b12 = (s[18] << 20) | (s[19] >>> 12);
          b13 = (s[19] << 20) | (s[18] >>> 12);
          b44 = (s[29] << 7) | (s[28] >>> 25);
          b45 = (s[28] << 7) | (s[29] >>> 25);
          b26 = (s[38] << 8) | (s[39] >>> 24);
          b27 = (s[39] << 8) | (s[38] >>> 24);
          b8 = (s[48] << 14) | (s[49] >>> 18);
          b9 = (s[49] << 14) | (s[48] >>> 18);

          s[0] = b0 ^ (~b2 & b4);
          s[1] = b1 ^ (~b3 & b5);
          s[10] = b10 ^ (~b12 & b14);
          s[11] = b11 ^ (~b13 & b15);
          s[20] = b20 ^ (~b22 & b24);
          s[21] = b21 ^ (~b23 & b25);
          s[30] = b30 ^ (~b32 & b34);
          s[31] = b31 ^ (~b33 & b35);
          s[40] = b40 ^ (~b42 & b44);
          s[41] = b41 ^ (~b43 & b45);
          s[2] = b2 ^ (~b4 & b6);
          s[3] = b3 ^ (~b5 & b7);
          s[12] = b12 ^ (~b14 & b16);
          s[13] = b13 ^ (~b15 & b17);
          s[22] = b22 ^ (~b24 & b26);
          s[23] = b23 ^ (~b25 & b27);
          s[32] = b32 ^ (~b34 & b36);
          s[33] = b33 ^ (~b35 & b37);
          s[42] = b42 ^ (~b44 & b46);
          s[43] = b43 ^ (~b45 & b47);
          s[4] = b4 ^ (~b6 & b8);
          s[5] = b5 ^ (~b7 & b9);
          s[14] = b14 ^ (~b16 & b18);
          s[15] = b15 ^ (~b17 & b19);
          s[24] = b24 ^ (~b26 & b28);
          s[25] = b25 ^ (~b27 & b29);
          s[34] = b34 ^ (~b36 & b38);
          s[35] = b35 ^ (~b37 & b39);
          s[44] = b44 ^ (~b46 & b48);
          s[45] = b45 ^ (~b47 & b49);
          s[6] = b6 ^ (~b8 & b0);
          s[7] = b7 ^ (~b9 & b1);
          s[16] = b16 ^ (~b18 & b10);
          s[17] = b17 ^ (~b19 & b11);
          s[26] = b26 ^ (~b28 & b20);
          s[27] = b27 ^ (~b29 & b21);
          s[36] = b36 ^ (~b38 & b30);
          s[37] = b37 ^ (~b39 & b31);
          s[46] = b46 ^ (~b48 & b40);
          s[47] = b47 ^ (~b49 & b41);
          s[8] = b8 ^ (~b0 & b2);
          s[9] = b9 ^ (~b1 & b3);
          s[18] = b18 ^ (~b10 & b12);
          s[19] = b19 ^ (~b11 & b13);
          s[28] = b28 ^ (~b20 & b22);
          s[29] = b29 ^ (~b21 & b23);
          s[38] = b38 ^ (~b30 & b32);
          s[39] = b39 ^ (~b31 & b33);
          s[48] = b48 ^ (~b40 & b42);
          s[49] = b49 ^ (~b41 & b43);

          s[0] ^= RC[n];
          s[1] ^= RC[n + 1];
      }
  };

  const keccak = (/** @type {number} */ bits) => (/** @type {string} */ str) => {
      var msg;
      if (str.slice(0, 2) === "0x") {
          msg = [];
          for (var i = 2, l = str.length; i < l; i += 2)
              msg.push(parseInt(str.slice(i, i + 2), 16));
      } else {
          msg = str;
      }
      // @ts-ignore
      return update(Keccak(bits), msg);
  };

  /**
   * @type {(message: string) => string}
   */
  const keccak256 = keccak(256);

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @enum {number}
   */
  const ArgumentType = {
      uint8: 0,
      int8: 1,
      uint16: 2,
      int16: 3,
      uint24: 4,
      int24: 5,
      uint32: 6,
      int32: 7,
      uint40: 8,
      int40: 9,
      uint48: 10,
      int48: 11,
      uint56: 12,
      int56: 13,
      uint64: 14,
      int64: 15,
      uint72: 16,
      int72: 17,
      uint80: 18,
      int80: 19,
      uint88: 20,
      int88: 21,
      uint96: 22,
      int96: 23,
      uint104: 24,
      int104: 25,
      uint112: 26,
      int112: 27,
      uint120: 28,
      int120: 29,
      uint128: 30,
      int128: 31,
      uint136: 32,
      int136: 33,
      uint144: 34,
      int144: 35,
      uint152: 36,
      int152: 37,
      uint160: 38,
      int160: 39,
      uint168: 40,
      int168: 41,
      uint176: 42,
      int176: 43,
      uint184: 44,
      int184: 45,
      uint192: 46,
      int192: 47,
      uint200: 48,
      int200: 49,
      uint208: 50,
      int208: 51,
      uint216: 52,
      int216: 53,
      uint224: 54,
      int224: 55,
      uint232: 56,
      int232: 57,
      uint240: 58,
      int240: 59,
      uint248: 60,
      int248: 61,
      uint256: 62,
      int256: 63,
      string: 64,
      bool: 65,
      bytes: 66,
      bytes32: 67,
      address: 68,
      func: 69,
  };

  /**
   * @typedef {object} Argument
   * @property {boolean} dynamic
   * @property {Uint8Array} value
   */

  /**
   * @typedef {object} SolidityType
   * @property {ArgumentType} ty
   * @property {boolean} array
   */

  /**
   * Class to help construct function selectors for Hedera smart contract function calls.
   * Function selectors are the first 4 bytes of the Keccak-256 hash of the function's signature.
   *
   * This class provides methods to build function signatures by adding parameters of various Solidity types.
   * It supports all standard Solidity parameter types and their array variants.
   */
  class ContractFunctionSelector {
      /**
       * @param {string} [name]
       */
      constructor(name) {
          /**
           * @type {?string}
           */
          this.name = null;

          /**
           * @type {string}
           */
          this._params = "";

          /**
           * @type {SolidityType[]}
           */
          this._paramTypes = [];

          if (name != null) {
              this._name = name;
          }
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addString() {
          return this._addParam({ ty: ArgumentType.string, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addStringArray() {
          return this._addParam({ ty: ArgumentType.string, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addBytes() {
          return this._addParam({ ty: ArgumentType.bytes, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addBytes32() {
          return this._addParam({ ty: ArgumentType.bytes32, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addBytesArray() {
          return this._addParam({ ty: ArgumentType.bytes, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addBytes32Array() {
          return this._addParam({ ty: ArgumentType.bytes32, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt8() {
          return this._addParam({ ty: ArgumentType.int8, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint8() {
          return this._addParam({ ty: ArgumentType.uint8, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt16() {
          return this._addParam({ ty: ArgumentType.int16, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint16() {
          return this._addParam({ ty: ArgumentType.uint16, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt24() {
          return this._addParam({ ty: ArgumentType.int24, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint24() {
          return this._addParam({ ty: ArgumentType.uint24, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt32() {
          return this._addParam({ ty: ArgumentType.int32, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint32() {
          return this._addParam({ ty: ArgumentType.uint32, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt40() {
          return this._addParam({ ty: ArgumentType.int40, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint40() {
          return this._addParam({ ty: ArgumentType.uint40, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt48() {
          return this._addParam({ ty: ArgumentType.int48, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint48() {
          return this._addParam({ ty: ArgumentType.uint48, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt56() {
          return this._addParam({ ty: ArgumentType.int56, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint56() {
          return this._addParam({ ty: ArgumentType.uint56, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt64() {
          return this._addParam({ ty: ArgumentType.int64, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint64() {
          return this._addParam({ ty: ArgumentType.uint64, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt72() {
          return this._addParam({ ty: ArgumentType.int72, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint72() {
          return this._addParam({ ty: ArgumentType.uint72, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt80() {
          return this._addParam({ ty: ArgumentType.int80, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint80() {
          return this._addParam({ ty: ArgumentType.uint80, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt88() {
          return this._addParam({ ty: ArgumentType.int88, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint88() {
          return this._addParam({ ty: ArgumentType.uint88, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt96() {
          return this._addParam({ ty: ArgumentType.int96, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint96() {
          return this._addParam({ ty: ArgumentType.uint96, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt104() {
          return this._addParam({ ty: ArgumentType.int104, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint104() {
          return this._addParam({ ty: ArgumentType.uint104, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt112() {
          return this._addParam({ ty: ArgumentType.int112, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint112() {
          return this._addParam({ ty: ArgumentType.uint112, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt120() {
          return this._addParam({ ty: ArgumentType.int120, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint120() {
          return this._addParam({ ty: ArgumentType.uint120, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt128() {
          return this._addParam({ ty: ArgumentType.int128, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint128() {
          return this._addParam({ ty: ArgumentType.uint128, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt136() {
          return this._addParam({ ty: ArgumentType.int136, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint136() {
          return this._addParam({ ty: ArgumentType.uint136, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt144() {
          return this._addParam({ ty: ArgumentType.int144, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint144() {
          return this._addParam({ ty: ArgumentType.uint144, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt152() {
          return this._addParam({ ty: ArgumentType.int152, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint152() {
          return this._addParam({ ty: ArgumentType.uint152, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt160() {
          return this._addParam({ ty: ArgumentType.int160, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint160() {
          return this._addParam({ ty: ArgumentType.uint160, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt168() {
          return this._addParam({ ty: ArgumentType.int168, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint168() {
          return this._addParam({ ty: ArgumentType.uint168, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt176() {
          return this._addParam({ ty: ArgumentType.int176, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint176() {
          return this._addParam({ ty: ArgumentType.uint176, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt184() {
          return this._addParam({ ty: ArgumentType.int184, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint184() {
          return this._addParam({ ty: ArgumentType.uint184, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt192() {
          return this._addParam({ ty: ArgumentType.int192, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint192() {
          return this._addParam({ ty: ArgumentType.uint192, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt200() {
          return this._addParam({ ty: ArgumentType.int200, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint200() {
          return this._addParam({ ty: ArgumentType.uint200, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt208() {
          return this._addParam({ ty: ArgumentType.int208, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint208() {
          return this._addParam({ ty: ArgumentType.uint208, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt216() {
          return this._addParam({ ty: ArgumentType.int216, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint216() {
          return this._addParam({ ty: ArgumentType.uint216, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt224() {
          return this._addParam({ ty: ArgumentType.int224, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint224() {
          return this._addParam({ ty: ArgumentType.uint224, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt232() {
          return this._addParam({ ty: ArgumentType.int232, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint232() {
          return this._addParam({ ty: ArgumentType.uint232, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt240() {
          return this._addParam({ ty: ArgumentType.int240, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint240() {
          return this._addParam({ ty: ArgumentType.uint240, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt248() {
          return this._addParam({ ty: ArgumentType.int248, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint248() {
          return this._addParam({ ty: ArgumentType.uint248, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt256() {
          return this._addParam({ ty: ArgumentType.int256, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint256() {
          return this._addParam({ ty: ArgumentType.uint256, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt8Array() {
          return this._addParam({ ty: ArgumentType.int8, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint8Array() {
          return this._addParam({ ty: ArgumentType.uint8, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt16Array() {
          return this._addParam({ ty: ArgumentType.int16, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint16Array() {
          return this._addParam({ ty: ArgumentType.uint16, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt24Array() {
          return this._addParam({ ty: ArgumentType.int24, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint24Array() {
          return this._addParam({ ty: ArgumentType.uint24, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt32Array() {
          return this._addParam({ ty: ArgumentType.int32, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint32Array() {
          return this._addParam({ ty: ArgumentType.uint32, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt40Array() {
          return this._addParam({ ty: ArgumentType.int40, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint40Array() {
          return this._addParam({ ty: ArgumentType.uint40, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt48Array() {
          return this._addParam({ ty: ArgumentType.int48, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint48Array() {
          return this._addParam({ ty: ArgumentType.uint48, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt56Array() {
          return this._addParam({ ty: ArgumentType.int56, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint56Array() {
          return this._addParam({ ty: ArgumentType.uint56, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt64Array() {
          return this._addParam({ ty: ArgumentType.int64, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint64Array() {
          return this._addParam({ ty: ArgumentType.uint64, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt72Array() {
          return this._addParam({ ty: ArgumentType.int72, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint72Array() {
          return this._addParam({ ty: ArgumentType.uint72, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt80Array() {
          return this._addParam({ ty: ArgumentType.int80, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint80Array() {
          return this._addParam({ ty: ArgumentType.uint80, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt88Array() {
          return this._addParam({ ty: ArgumentType.int88, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint88Array() {
          return this._addParam({ ty: ArgumentType.uint88, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt96Array() {
          return this._addParam({ ty: ArgumentType.int96, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint96Array() {
          return this._addParam({ ty: ArgumentType.uint96, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt104Array() {
          return this._addParam({ ty: ArgumentType.int104, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint104Array() {
          return this._addParam({ ty: ArgumentType.uint104, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt112Array() {
          return this._addParam({ ty: ArgumentType.int112, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint112Array() {
          return this._addParam({ ty: ArgumentType.uint112, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt120Array() {
          return this._addParam({ ty: ArgumentType.int120, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint120Array() {
          return this._addParam({ ty: ArgumentType.uint120, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt128Array() {
          return this._addParam({ ty: ArgumentType.int128, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint128Array() {
          return this._addParam({ ty: ArgumentType.uint128, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt136Array() {
          return this._addParam({ ty: ArgumentType.int136, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint136Array() {
          return this._addParam({ ty: ArgumentType.uint136, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt144Array() {
          return this._addParam({ ty: ArgumentType.int144, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint144Array() {
          return this._addParam({ ty: ArgumentType.uint144, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt152Array() {
          return this._addParam({ ty: ArgumentType.int152, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint152Array() {
          return this._addParam({ ty: ArgumentType.uint152, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt160Array() {
          return this._addParam({ ty: ArgumentType.int160, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint160Array() {
          return this._addParam({ ty: ArgumentType.uint160, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt168Array() {
          return this._addParam({ ty: ArgumentType.int168, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint168Array() {
          return this._addParam({ ty: ArgumentType.uint168, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt176Array() {
          return this._addParam({ ty: ArgumentType.int176, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint176Array() {
          return this._addParam({ ty: ArgumentType.uint176, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt184Array() {
          return this._addParam({ ty: ArgumentType.int184, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint184Array() {
          return this._addParam({ ty: ArgumentType.uint184, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt192Array() {
          return this._addParam({ ty: ArgumentType.int192, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint192Array() {
          return this._addParam({ ty: ArgumentType.uint192, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt200Array() {
          return this._addParam({ ty: ArgumentType.int200, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint200Array() {
          return this._addParam({ ty: ArgumentType.uint200, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt208Array() {
          return this._addParam({ ty: ArgumentType.int208, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint208Array() {
          return this._addParam({ ty: ArgumentType.uint208, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt216Array() {
          return this._addParam({ ty: ArgumentType.int216, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint216Array() {
          return this._addParam({ ty: ArgumentType.uint216, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt224Array() {
          return this._addParam({ ty: ArgumentType.int224, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint224Array() {
          return this._addParam({ ty: ArgumentType.uint224, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt232Array() {
          return this._addParam({ ty: ArgumentType.int232, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint232Array() {
          return this._addParam({ ty: ArgumentType.uint232, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt240Array() {
          return this._addParam({ ty: ArgumentType.int240, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint240Array() {
          return this._addParam({ ty: ArgumentType.uint240, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt248Array() {
          return this._addParam({ ty: ArgumentType.int248, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint248Array() {
          return this._addParam({ ty: ArgumentType.uint248, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addInt256Array() {
          return this._addParam({ ty: ArgumentType.int256, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addUint256Array() {
          return this._addParam({ ty: ArgumentType.uint256, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addBool() {
          return this._addParam({ ty: ArgumentType.bool, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addAddress() {
          return this._addParam({ ty: ArgumentType.address, array: false });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addAddressArray() {
          return this._addParam({ ty: ArgumentType.address, array: true });
      }

      /**
       * @returns {ContractFunctionSelector}
       */
      addFunction() {
          return this._addParam({ ty: ArgumentType.func, array: false });
      }

      /**
       * @param {SolidityType} ty
       * @returns {ContractFunctionSelector}
       */
      _addParam(ty) {
          if (this._paramTypes.length > 0) {
              this._params += ",";
          }

          this._params += solidityTypeToString(ty);
          this._paramTypes.push(ty);

          return this;
      }

      /**
       * @param {string} [name]
       * @returns {Uint8Array}
       */
      _build(name) {
          if (name != null) {
              this._name = name;
          } else if (this._name == null) {
              throw new Error("`name` required for ContractFunctionSelector");
          }

          const func = encode$5(encode$1(this.toString()));
          return decode$8(keccak256(`0x${func}`)).slice(0, 4);
      }

      /**
       * @returns {string}
       */
      toString() {
          return `${this._name != null ? this._name.toString() : ""}(${
            this._params
        })`;
      }
  }

  /**
   * @param {SolidityType} ty
   * @returns {string}
   */
  function solidityTypeToString(ty) {
      let s = "";
      switch (ty.ty) {
          case ArgumentType.uint8:
              s = "uint8";
              break;
          case ArgumentType.int8:
              s = "int8";
              break;
          case ArgumentType.uint16:
              s = "uint16";
              break;
          case ArgumentType.int16:
              s = "int16";
              break;
          case ArgumentType.uint24:
              s = "uint24";
              break;
          case ArgumentType.int24:
              s = "int24";
              break;
          case ArgumentType.uint32:
              s = "uint32";
              break;
          case ArgumentType.int32:
              s = "int32";
              break;
          case ArgumentType.uint40:
              s = "uint40";
              break;
          case ArgumentType.int40:
              s = "int40";
              break;
          case ArgumentType.uint48:
              s = "uint48";
              break;
          case ArgumentType.int48:
              s = "int48";
              break;
          case ArgumentType.uint56:
              s = "uint56";
              break;
          case ArgumentType.int56:
              s = "int56";
              break;
          case ArgumentType.uint64:
              s = "uint64";
              break;
          case ArgumentType.int64:
              s = "int64";
              break;
          case ArgumentType.uint72:
              s = "uint72";
              break;
          case ArgumentType.int72:
              s = "int72";
              break;
          case ArgumentType.uint80:
              s = "uint80";
              break;
          case ArgumentType.int80:
              s = "int80";
              break;
          case ArgumentType.uint88:
              s = "uint88";
              break;
          case ArgumentType.int88:
              s = "int88";
              break;
          case ArgumentType.uint96:
              s = "uint96";
              break;
          case ArgumentType.int96:
              s = "int96";
              break;
          case ArgumentType.uint104:
              s = "uint104";
              break;
          case ArgumentType.int104:
              s = "int104";
              break;
          case ArgumentType.uint112:
              s = "uint112";
              break;
          case ArgumentType.int112:
              s = "int112";
              break;
          case ArgumentType.uint120:
              s = "uint120";
              break;
          case ArgumentType.int120:
              s = "int120";
              break;
          case ArgumentType.uint128:
              s = "uint128";
              break;
          case ArgumentType.int128:
              s = "int128";
              break;
          case ArgumentType.uint136:
              s = "uint136";
              break;
          case ArgumentType.int136:
              s = "int136";
              break;
          case ArgumentType.uint144:
              s = "uint144";
              break;
          case ArgumentType.int144:
              s = "int144";
              break;
          case ArgumentType.uint152:
              s = "uint152";
              break;
          case ArgumentType.int152:
              s = "int152";
              break;
          case ArgumentType.uint160:
              s = "uint160";
              break;
          case ArgumentType.int160:
              s = "int160";
              break;
          case ArgumentType.uint168:
              s = "uint168";
              break;
          case ArgumentType.int168:
              s = "int168";
              break;
          case ArgumentType.uint176:
              s = "uint176";
              break;
          case ArgumentType.int176:
              s = "int176";
              break;
          case ArgumentType.uint184:
              s = "uint184";
              break;
          case ArgumentType.int184:
              s = "int184";
              break;
          case ArgumentType.uint192:
              s = "uint192";
              break;
          case ArgumentType.int192:
              s = "int192";
              break;
          case ArgumentType.uint200:
              s = "uint200";
              break;
          case ArgumentType.int200:
              s = "int200";
              break;
          case ArgumentType.uint208:
              s = "uint208";
              break;
          case ArgumentType.int208:
              s = "int208";
              break;
          case ArgumentType.uint216:
              s = "uint216";
              break;
          case ArgumentType.int216:
              s = "int216";
              break;
          case ArgumentType.uint224:
              s = "uint224";
              break;
          case ArgumentType.int224:
              s = "int224";
              break;
          case ArgumentType.uint232:
              s = "uint232";
              break;
          case ArgumentType.int232:
              s = "int232";
              break;
          case ArgumentType.uint240:
              s = "uint240";
              break;
          case ArgumentType.int240:
              s = "int240";
              break;
          case ArgumentType.uint248:
              s = "uint248";
              break;
          case ArgumentType.int248:
              s = "int248";
              break;
          case ArgumentType.uint256:
              s = "uint256";
              break;
          case ArgumentType.int256:
              s = "int256";
              break;
          case ArgumentType.string:
              s = "string";
              break;
          case ArgumentType.bool:
              s = "bool";
              break;
          case ArgumentType.bytes:
              s = "bytes";
              break;
          case ArgumentType.bytes32:
              s = "bytes32";
              break;
          case ArgumentType.address:
              s = "address";
              break;
          case ArgumentType.func:
              s = "function";
              break;
          default:
              s = "";
              break;
      }

      if (ty.array) {
          s += "[]";
      }

      return s;
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * Class to help construct parameters for a Hedera smart contract function call.
   *
   * This class provides methods to add different types of parameters that will be passed to a smart contract function.
   * It supports all Solidity parameter types including basic types (uint/int of various sizes, bool, address),
   * arrays, strings, and bytes.
   *
   */
  class ContractFunctionParameters {
      constructor() {
          /**
           * @type {ContractFunctionSelector}
           */
          this._selector = new ContractFunctionSelector();

          /**
           * @type {import("./ContractFunctionSelector.js").Argument[]}
           */
          this._arguments = [];
      }

      /**
       * @param {string} value
       * @returns {ContractFunctionParameters}
       */
      addString(value) {
          this._selector.addString();
          return this._addParam(value, true);
      }

      /**
       * @param {string[]} value
       * @returns {ContractFunctionParameters}
       */
      addStringArray(value) {
          this._selector.addStringArray();
          return this._addParam(value, true);
      }

      /**
       * @param {Uint8Array} value
       * @returns {ContractFunctionParameters}
       */
      addBytes(value) {
          this._selector.addBytes();
          return this._addParam(value, true);
      }

      /**
       * @param {Uint8Array} value
       * @returns {ContractFunctionParameters}
       */
      addBytes32(value) {
          if (value.length !== 32) {
              throw new Error(
                  `addBytes32 expected array to be of length 32, but received ${value.length}`,
              );
          }

          this._selector.addBytes32();
          return this._addParam(value, false);
      }

      /**
       * @param {Uint8Array[]} value
       * @returns {ContractFunctionParameters}
       */
      addBytesArray(value) {
          this._selector.addBytesArray();
          return this._addParam(value, true);
      }

      /**
       * @param {Uint8Array[]} value
       * @returns {ContractFunctionParameters}
       */
      addBytes32Array(value) {
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          for (const [_, entry] of value.entries()) {
              if (entry.length !== 32) {
                  throw new Error(
                      `addBytes32 expected array to be of length 32, but received ${entry.length}`,
                  );
              }
          }

          this._selector.addBytes32Array();
          return this._addParam(value, true);
      }

      /**
       * @param {boolean} value
       * @returns {ContractFunctionParameters}
       */
      addBool(value) {
          this._selector.addBool();
          return this._addParam(value, false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addInt8(value) {
          this._selector.addInt8();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addUint8(value) {
          this._selector.addUint8();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addInt16(value) {
          this._selector.addInt16();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addUint16(value) {
          this._selector.addUint16();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addInt24(value) {
          this._selector.addInt24();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addUint24(value) {
          this._selector.addUint24();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addInt32(value) {
          this._selector.addInt32();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addUint32(value) {
          this._selector.addUint32();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addInt40(value) {
          this._selector.addInt40();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addUint40(value) {
          this._selector.addUint40();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addInt48(value) {
          this._selector.addInt48();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addUint48(value) {
          this._selector.addUint48();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addInt56(value) {
          this._selector.addInt56();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addUint56(value) {
          this._selector.addUint56();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addInt64(value) {
          this._selector.addInt64();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addUint64(value) {
          this._selector.addUint64();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addInt72(value) {
          this._selector.addInt72();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addUint72(value) {
          this._selector.addUint72();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addInt80(value) {
          this._selector.addInt80();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addUint80(value) {
          this._selector.addUint80();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addInt88(value) {
          this._selector.addInt88();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addUint88(value) {
          this._selector.addUint88();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addInt96(value) {
          this._selector.addInt96();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addUint96(value) {
          this._selector.addUint96();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addInt104(value) {
          this._selector.addInt104();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addUint104(value) {
          this._selector.addUint104();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addInt112(value) {
          this._selector.addInt112();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addUint112(value) {
          this._selector.addUint112();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addInt120(value) {
          this._selector.addInt120();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addUint120(value) {
          this._selector.addUint120();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addInt128(value) {
          this._selector.addInt128();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addUint128(value) {
          this._selector.addUint128();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addInt136(value) {
          this._selector.addInt136();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addUint136(value) {
          this._selector.addUint136();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addInt144(value) {
          this._selector.addInt144();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addUint144(value) {
          this._selector.addUint144();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addInt152(value) {
          this._selector.addInt152();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addUint152(value) {
          this._selector.addUint152();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addInt160(value) {
          this._selector.addInt160();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addUint160(value) {
          this._selector.addUint160();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addInt168(value) {
          this._selector.addInt168();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addUint168(value) {
          this._selector.addUint168();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addInt176(value) {
          this._selector.addInt176();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addUint176(value) {
          this._selector.addUint176();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addInt184(value) {
          this._selector.addInt184();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addUint184(value) {
          this._selector.addUint184();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addInt192(value) {
          this._selector.addInt192();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addUint192(value) {
          this._selector.addUint192();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addInt200(value) {
          this._selector.addInt200();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addUint200(value) {
          this._selector.addUint200();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addInt208(value) {
          this._selector.addInt208();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addUint208(value) {
          this._selector.addUint208();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addInt216(value) {
          this._selector.addInt216();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addUint216(value) {
          this._selector.addUint216();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addInt224(value) {
          this._selector.addInt224();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addUint224(value) {
          this._selector.addUint224();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addInt232(value) {
          this._selector.addInt232();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addUint232(value) {
          this._selector.addUint232();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addInt240(value) {
          this._selector.addInt240();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addUint240(value) {
          this._selector.addUint240();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addInt248(value) {
          this._selector.addInt248();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addUint248(value) {
          this._selector.addUint248();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addInt256(value) {
          this._selector.addInt256();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number | BigNumber | Long} value
       * @returns {ContractFunctionParameters}
       */
      addUint256(value) {
          this._selector.addUint256();
          return this._addParam(convertToBigNumber(value), false);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addInt8Array(value) {
          this._selector.addInt8Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addUint8Array(value) {
          this._selector.addUint8Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addInt16Array(value) {
          this._selector.addInt16Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addUint16Array(value) {
          this._selector.addUint16Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addInt24Array(value) {
          this._selector.addInt24Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addUint24Array(value) {
          this._selector.addUint24Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addInt32Array(value) {
          this._selector.addInt32Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addUint32Array(value) {
          this._selector.addUint32Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addInt40Array(value) {
          this._selector.addInt40Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addUint40Array(value) {
          this._selector.addUint40Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addInt48Array(value) {
          this._selector.addInt48Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addUint48Array(value) {
          this._selector.addUint48Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addInt56Array(value) {
          this._selector.addInt56Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addUint56Array(value) {
          this._selector.addUint56Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addInt64Array(value) {
          this._selector.addInt64Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addUint64Array(value) {
          this._selector.addUint64Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addInt72Array(value) {
          this._selector.addInt72Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addUint72Array(value) {
          this._selector.addUint72Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addInt80Array(value) {
          this._selector.addInt80Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addUint80Array(value) {
          this._selector.addUint80Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addInt88Array(value) {
          this._selector.addInt88Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addUint88Array(value) {
          this._selector.addUint88Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addInt96Array(value) {
          this._selector.addInt96Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addUint96Array(value) {
          this._selector.addUint96Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addInt104Array(value) {
          this._selector.addInt104Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addUint104Array(value) {
          this._selector.addUint104Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addInt112Array(value) {
          this._selector.addInt112Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addUint112Array(value) {
          this._selector.addUint112Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addInt120Array(value) {
          this._selector.addInt120Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addUint120Array(value) {
          this._selector.addUint120Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addInt128Array(value) {
          this._selector.addInt128Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addUint128Array(value) {
          this._selector.addUint128Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addInt136Array(value) {
          this._selector.addInt136Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addUint136Array(value) {
          this._selector.addUint136Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addInt144Array(value) {
          this._selector.addInt144Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addUint144Array(value) {
          this._selector.addUint144Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addInt152Array(value) {
          this._selector.addInt152Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addUint152Array(value) {
          this._selector.addUint152Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addInt160Array(value) {
          this._selector.addInt160Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addUint160Array(value) {
          this._selector.addUint160Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addInt168Array(value) {
          this._selector.addInt168Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addUint168Array(value) {
          this._selector.addUint168Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addInt176Array(value) {
          this._selector.addInt176Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addUint176Array(value) {
          this._selector.addUint176Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addInt184Array(value) {
          this._selector.addInt184Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addUint184Array(value) {
          this._selector.addUint184Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addInt192Array(value) {
          this._selector.addInt192Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addUint192Array(value) {
          this._selector.addUint192Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addInt200Array(value) {
          this._selector.addInt200Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addUint200Array(value) {
          this._selector.addUint200Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addInt208Array(value) {
          this._selector.addInt208Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addUint208Array(value) {
          this._selector.addUint208Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addInt216Array(value) {
          this._selector.addInt216Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addUint216Array(value) {
          this._selector.addUint216Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addInt224Array(value) {
          this._selector.addInt224Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addUint224Array(value) {
          this._selector.addUint224Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addInt232Array(value) {
          this._selector.addInt232Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addUint232Array(value) {
          this._selector.addUint232Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addInt240Array(value) {
          this._selector.addInt240Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addUint240Array(value) {
          this._selector.addUint240Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addInt248Array(value) {
          this._selector.addInt248Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addUint248Array(value) {
          this._selector.addUint248Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addInt256Array(value) {
          this._selector.addInt256Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {number[] | BigNumber[] | Long[]} value
       * @returns {ContractFunctionParameters}
       */
      addUint256Array(value) {
          this._selector.addUint256Array();
          return this._addParam(convertToBigNumberArray(value), true);
      }

      /**
       * @param {string | EvmAddress} value
       * @returns {ContractFunctionParameters}
       */
      addAddress(value) {
          let address;
          if (typeof value === "string") {
              // Allow `0x` prefix
              if (value.length !== 40 && value.length !== 42) {
                  throw new Error(
                      "`address` type requires parameter to be 40 or 42 characters",
                  );
              }
              address = value;
          } else {
              address = value.toString();
          }

          const par =
              address.length === 40
                  ? decode$8(address)
                  : decode$8(address.substring(2));

          this._selector.addAddress();

          return this._addParam(par, false);
      }

      /**
       * @param {string[] | EvmAddress[]} value
       * @returns {ContractFunctionParameters}
       */
      addAddressArray(value) {
          /**
           * @type {Uint8Array[]}
           */
          const par = [];
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          for (const [_, entry] of value.entries()) {
              let address;
              if (typeof entry === "string") {
                  if (entry.length !== 40 && entry.length !== 42) {
                      throw new Error(
                          "`address` type requires parameter to be 40 or 42 characters",
                      );
                  }
                  address = entry;
              } else {
                  address = entry.toString();
              }

              const buf =
                  address.length === 40
                      ? decode$8(address)
                      : decode$8(address.substring(2));

              par.push(buf);
          }

          this._selector.addAddressArray();

          return this._addParam(par, true);
      }

      /**
       * @param {string} address
       * @param {ContractFunctionSelector} selector
       * @returns {ContractFunctionParameters}
       */
      addFunction(address, selector) {
          const addressParam = decode$8(address);
          const functionSelector = selector._build();

          if (addressParam.length !== 20) {
              throw new Error(
                  "`function` type requires parameter `address` to be exactly 20 bytes",
              );
          }

          this._selector.addFunction();

          const proto = new Uint8Array(24);
          proto.set(addressParam, 0);
          proto.set(functionSelector, 20);

          return this._addParam(proto, false);
      }

      /**
       * @internal
       * @param {string | boolean | number | Uint8Array | BigNumber | string[] | boolean[] | number[] | Uint8Array[] | BigNumber[]} param
       * @param {boolean} dynamic
       * @returns {ContractFunctionParameters}
       */
      _addParam(param, dynamic) {
          const index = this._selector._paramTypes.length - 1;
          const value = argumentToBytes(param, this._selector._paramTypes[index]);

          this._arguments.push({ dynamic, value });
          return this;
      }

      /**
       * @internal
       * @param {string=} name
       * @returns {Uint8Array}
       */
      _build(name) {
          const includeId = name != null;
          const nameOffset = includeId ? 4 : 0;

          const length =
              this._arguments.length === 0
                  ? nameOffset
                  : this._arguments.length * 32 +
                    this._arguments
                        .map((arg) => (arg.dynamic ? arg.value.length : 0))
                        .reduce((sum, value) => sum + value) +
                    nameOffset;

          const func = new Uint8Array(length);

          if (includeId) {
              func.set(this._selector._build(name), 0);
          }

          let offset = 32 * this._arguments.length;

          for (const [i, { dynamic, value }] of this._arguments.entries()) {
              if (dynamic) {
                  const view = safeView(func, nameOffset + i * 32 + 28);
                  view.setUint32(0, offset);
                  func.set(value, view.getUint32(0) + nameOffset);
                  offset += value.length;
              } else {
                  func.set(value, nameOffset + i * 32);
              }
          }

          return func;
      }
  }

  /**
   * @param {string | boolean | number | Uint8Array | BigNumber | string[] | boolean[] | number[] | Uint8Array[] | BigNumber[]} param
   * @param {import("./ContractFunctionSelector.js").SolidityType} ty
   * @returns {Uint8Array}
   */
  function argumentToBytes(param, ty) {
      let value = new Uint8Array(32);
      let valueView = safeView(value);
      /** @type {Uint8Array} */
      let par;

      if (ty.array) {
          if (!Array.isArray(param)) {
              throw new TypeError(
                  "SolidityType indicates type is array, but parameter is not an array",
              );
          }

          /**
           * @type {Uint8Array[]}
           */
          const values = [];

          // Generic over any type of array
          // Destructuring required so the first variable must be assigned
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          for (const [_, p] of param.entries()) {
              const arg = argumentToBytes(p, { ty: ty.ty, array: false });
              values.push(arg);
          }

          const totalLengthOfValues = values
              .map((a) => a.length)
              .reduce((total, current) => total + current, 0);

          switch (ty.ty) {
              case ArgumentType.uint8:
              case ArgumentType.int8:
              case ArgumentType.uint16:
              case ArgumentType.int16:
              case ArgumentType.uint24:
              case ArgumentType.int24:
              case ArgumentType.uint32:
              case ArgumentType.int32:
              case ArgumentType.uint40:
              case ArgumentType.int40:
              case ArgumentType.uint48:
              case ArgumentType.int48:
              case ArgumentType.uint56:
              case ArgumentType.int56:
              case ArgumentType.uint64:
              case ArgumentType.int64:
              case ArgumentType.uint72:
              case ArgumentType.int72:
              case ArgumentType.uint80:
              case ArgumentType.int80:
              case ArgumentType.uint88:
              case ArgumentType.int88:
              case ArgumentType.uint96:
              case ArgumentType.int96:
              case ArgumentType.uint104:
              case ArgumentType.int104:
              case ArgumentType.uint112:
              case ArgumentType.int112:
              case ArgumentType.uint120:
              case ArgumentType.int120:
              case ArgumentType.uint128:
              case ArgumentType.int128:
              case ArgumentType.uint136:
              case ArgumentType.int136:
              case ArgumentType.uint144:
              case ArgumentType.int144:
              case ArgumentType.uint152:
              case ArgumentType.int152:
              case ArgumentType.uint160:
              case ArgumentType.int160:
              case ArgumentType.uint168:
              case ArgumentType.int168:
              case ArgumentType.uint176:
              case ArgumentType.int176:
              case ArgumentType.uint184:
              case ArgumentType.int184:
              case ArgumentType.uint192:
              case ArgumentType.int192:
              case ArgumentType.uint200:
              case ArgumentType.int200:
              case ArgumentType.uint208:
              case ArgumentType.int208:
              case ArgumentType.uint216:
              case ArgumentType.int216:
              case ArgumentType.uint224:
              case ArgumentType.int224:
              case ArgumentType.uint232:
              case ArgumentType.int232:
              case ArgumentType.uint240:
              case ArgumentType.int240:
              case ArgumentType.uint248:
              case ArgumentType.int248:
              case ArgumentType.uint256:
              case ArgumentType.int256:
              case ArgumentType.bool:
              case ArgumentType.bytes32:
              case ArgumentType.address:
              case ArgumentType.func:
                  value = new Uint8Array(totalLengthOfValues + 32);
                  break;
              case ArgumentType.bytes:
              case ArgumentType.string:
                  value = new Uint8Array(
                      values.length * 32 + totalLengthOfValues + 32,
                  );
                  break;
              default:
                  throw new TypeError(
                      `Expected param type to be ArgumentType, but received ${ty.ty}`,
                  );
          }

          valueView = safeView(value, 28);
          valueView.setUint32(0, values.length);

          let offset = 32 * values.length;

          for (const [i, e] of values.entries()) {
              switch (ty.ty) {
                  case ArgumentType.uint8:
                  case ArgumentType.int8:
                  case ArgumentType.uint16:
                  case ArgumentType.int16:
                  case ArgumentType.uint24:
                  case ArgumentType.int24:
                  case ArgumentType.uint32:
                  case ArgumentType.int32:
                  case ArgumentType.uint40:
                  case ArgumentType.int40:
                  case ArgumentType.uint48:
                  case ArgumentType.int48:
                  case ArgumentType.uint56:
                  case ArgumentType.int56:
                  case ArgumentType.uint64:
                  case ArgumentType.int64:
                  case ArgumentType.uint72:
                  case ArgumentType.int72:
                  case ArgumentType.uint80:
                  case ArgumentType.int80:
                  case ArgumentType.uint88:
                  case ArgumentType.int88:
                  case ArgumentType.uint96:
                  case ArgumentType.int96:
                  case ArgumentType.uint104:
                  case ArgumentType.int104:
                  case ArgumentType.uint112:
                  case ArgumentType.int112:
                  case ArgumentType.uint120:
                  case ArgumentType.int120:
                  case ArgumentType.uint128:
                  case ArgumentType.int128:
                  case ArgumentType.uint136:
                  case ArgumentType.int136:
                  case ArgumentType.uint144:
                  case ArgumentType.int144:
                  case ArgumentType.uint152:
                  case ArgumentType.int152:
                  case ArgumentType.uint160:
                  case ArgumentType.int160:
                  case ArgumentType.uint168:
                  case ArgumentType.int168:
                  case ArgumentType.uint176:
                  case ArgumentType.int176:
                  case ArgumentType.uint184:
                  case ArgumentType.int184:
                  case ArgumentType.uint192:
                  case ArgumentType.int192:
                  case ArgumentType.uint200:
                  case ArgumentType.int200:
                  case ArgumentType.uint208:
                  case ArgumentType.int208:
                  case ArgumentType.uint216:
                  case ArgumentType.int216:
                  case ArgumentType.uint224:
                  case ArgumentType.int224:
                  case ArgumentType.uint232:
                  case ArgumentType.int232:
                  case ArgumentType.uint240:
                  case ArgumentType.int240:
                  case ArgumentType.uint248:
                  case ArgumentType.int248:
                  case ArgumentType.uint256:
                  case ArgumentType.int256:
                  case ArgumentType.bool:
                  case ArgumentType.bytes32:
                  case ArgumentType.address:
                  case ArgumentType.func:
                      value.set(e, i * 32 + 32);
                      break;
                  case ArgumentType.bytes:
                  case ArgumentType.string:
                      // eslint-disable-next-line no-case-declarations
                      const view = safeView(value, (i + 1) * 32 + 28);
                      view.setUint32(0, offset);
                      value.set(e, view.getUint32(0) + 32);
                      offset += e.length;
                      break;
                  default:
                      throw new TypeError(
                          `Expected param type to be ArgumentType, but received ${ty.ty}`,
                      );
              }
          }

          return value;
      }

      switch (ty.ty) {
          case ArgumentType.uint8:
          case ArgumentType.int8:
          case ArgumentType.uint16:
          case ArgumentType.int16:
          case ArgumentType.uint24:
          case ArgumentType.int24:
          case ArgumentType.uint32:
          case ArgumentType.int32:
          case ArgumentType.uint40:
          case ArgumentType.int40:
          case ArgumentType.uint48:
          case ArgumentType.int48:
          case ArgumentType.uint56:
          case ArgumentType.int56:
          case ArgumentType.uint64:
          case ArgumentType.int64:
          case ArgumentType.uint72:
          case ArgumentType.int72:
          case ArgumentType.uint80:
          case ArgumentType.int80:
          case ArgumentType.uint88:
          case ArgumentType.int88:
          case ArgumentType.uint96:
          case ArgumentType.int96:
          case ArgumentType.uint104:
          case ArgumentType.int104:
          case ArgumentType.uint112:
          case ArgumentType.int112:
          case ArgumentType.uint120:
          case ArgumentType.int120:
          case ArgumentType.uint128:
          case ArgumentType.int128:
          case ArgumentType.uint136:
          case ArgumentType.int136:
          case ArgumentType.uint144:
          case ArgumentType.int144:
          case ArgumentType.uint152:
          case ArgumentType.int152:
          case ArgumentType.uint160:
          case ArgumentType.int160:
          case ArgumentType.uint168:
          case ArgumentType.int168:
          case ArgumentType.uint176:
          case ArgumentType.int176:
          case ArgumentType.uint184:
          case ArgumentType.int184:
          case ArgumentType.uint192:
          case ArgumentType.int192:
          case ArgumentType.uint200:
          case ArgumentType.int200:
          case ArgumentType.uint208:
          case ArgumentType.int208:
          case ArgumentType.uint216:
          case ArgumentType.int216:
          case ArgumentType.uint224:
          case ArgumentType.int224:
          case ArgumentType.uint232:
          case ArgumentType.int232:
          case ArgumentType.uint240:
          case ArgumentType.int240:
          case ArgumentType.uint248:
          case ArgumentType.int248:
          case ArgumentType.int256:
          case ArgumentType.uint256: {
              let paramToHex = param.toString(16);

              // @ts-ignore
              if (param > 0 || param == 0) {
                  paramToHex = "0x" + paramToHex;
              } else {
                  paramToHex =
                      paramToHex.slice(0, 1) + "0x" + paramToHex.slice(1);
              }

              // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call
              const encodedData = defaultAbiCoder.encode(
                  [solidityTypeToString(ty)],
                  [paramToHex],
              );

              // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
              const dataToArrayify = arrayify(encodedData);
              return dataToArrayify;
          }
          case ArgumentType.address:
              value.set(/** @type {Uint8Array} */ (param), 32 - 20);
              return value;
          case ArgumentType.bool:
              value[31] = /** @type {boolean} */ (param) ? 1 : 0;
              return value;
          case ArgumentType.func:
              value.set(/** @type {Uint8Array} */ (param), 32 - 24);
              return value;
          case ArgumentType.bytes32:
              value.set(/** @type {Uint8Array} */ (param), 0);
              return value;
          // Bytes should have not the length already encoded
          // JS String type is encoded as UTF-16 whilst Solidity `string` type is UTF-8 encoded.
          // So if will assume is already correctly updated to being a Uint8Array of UTF-8 string
          case ArgumentType.bytes:
          case ArgumentType.string: {
              // If value is of type string, encode it in UTF-8 format and conver it to Uint8Array
              // Required because JS Strings are UTF-16
              // eslint-disable-next-line no-case-declarations
              par =
                  param instanceof Uint8Array
                      ? param
                      : encode$1(/** @type {string} */ (param));

              // Resize value to a 32 byte boundary if needed
              if (Math.floor(par.length / 32) >= 0) {
                  if (Math.floor(par.length % 32) !== 0) {
                      value = new Uint8Array(
                          (Math.floor(par.length / 32) + 1) * 32 + 32,
                      );
                  } else {
                      value = new Uint8Array(
                          Math.floor(par.length / 32) * 32 + 32,
                      );
                  }
              } else {
                  value = new Uint8Array(64);
              }

              value.set(par, 32);

              valueView = safeView(value, 28);
              valueView.setUint32(0, par.length);
              return value;
          }
          default:
              throw new Error(`Unsupported argument type: ${ty.toString()}`);
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   */

  /**
   * @typedef {object} FunctionParameters
   * @property {ContractFunctionParameters} parameters
   * @property {string} name
   */

  /**
   * A query that calls a function of a contract instance. It will consume the amount of gas
   * specified, and return the result of the function call.
   *
   * This query will not update the state of the contract instance on the network, but will
   * only retrieve information. To update the state, you must use ContractExecuteTransaction.
   *
   * @augments {Query<ContractFunctionResult>}
   */
  class ContractCallQuery extends Query {
      /**
       * @param {object} [props]
       * @param {ContractId | string} [props.contractId]
       * @param {number | Long} [props.gas]
       * @param {FunctionParameters | Uint8Array} [props.functionParameters]
       * @param {number | Long} [props.maxResultSize]
       * @param {AccountId | string} [props.senderAccountId]
       */
      constructor(props = {}) {
          super();

          /**
           * @private
           * @type {?ContractId}
           */
          this._contractId = null;
          if (props.contractId != null) {
              this.setContractId(props.contractId);
          }

          /**
           * @private
           * @type {?Long}
           */
          this._gas = null;
          if (props.gas != null) {
              this.setGas(props.gas);
          }

          /**
           * @private
           * @type {?Uint8Array}
           */
          this._functionParameters = null;
          if (props.functionParameters != null) {
              if (props.functionParameters instanceof Uint8Array) {
                  this.setFunctionParameters(props.functionParameters);
              } else {
                  this.setFunction(
                      props.functionParameters.name,
                      props.functionParameters.parameters,
                  );
              }
          }

          /**
           * @private
           * @type {?Long}
           */
          this._maxResultSize = null;
          if (props.maxResultSize != null) {
              this.setMaxResultSize(props.maxResultSize);
          }

          /**
           * @private
           * @type {?AccountId}
           */
          this._senderAccountId = null;
          if (props.senderAccountId != null) {
              this.setSenderAccountId(props.senderAccountId);
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.IQuery} query
       * @returns {ContractCallQuery}
       */
      static _fromProtobuf(query) {
          const call = /** @type {HieroProto.proto.IContractCallLocalQuery} */ (
              query.contractCallLocal
          );

          return new ContractCallQuery({
              contractId:
                  call.contractID != null
                      ? ContractId._fromProtobuf(call.contractID)
                      : undefined,
              gas: call.gas != null ? call.gas : undefined,
              functionParameters:
                  call.functionParameters != null
                      ? call.functionParameters
                      : undefined,
              maxResultSize:
                  call.maxResultSize != null ? call.maxResultSize : undefined,
          });
      }

      /**
       * @returns {?ContractId}
       */
      get contractId() {
          return this._contractId;
      }

      /**
       * Set the contract ID for which the call is being requested.
       *
       * @param {ContractId | string} contractId
       * @returns {ContractCallQuery}
       */
      setContractId(contractId) {
          this._contractId =
              typeof contractId === "string"
                  ? ContractId.fromString(contractId)
                  : contractId.clone();

          return this;
      }

      /**
       * @returns {?Long}
       */
      get gas() {
          return this._gas;
      }

      /**
       * @param {number | Long} gas
       * @returns {ContractCallQuery}
       */
      setGas(gas) {
          this._gas = gas instanceof Long ? gas : Long.fromValue(gas);
          return this;
      }

      /**
       * @returns {?AccountId}
       */
      get senderAccountId() {
          return this._senderAccountId;
      }

      /**
       * @param {AccountId | string} senderAccountId
       * @returns {ContractCallQuery}
       */
      setSenderAccountId(senderAccountId) {
          this._senderAccountId =
              typeof senderAccountId === "string"
                  ? AccountId.fromString(senderAccountId)
                  : senderAccountId;
          return this;
      }

      /**
       * @returns {?Uint8Array}
       */
      get functionParameters() {
          return this._functionParameters;
      }

      /**
       * @param {Uint8Array} params
       * @returns {ContractCallQuery}
       */
      setFunctionParameters(params) {
          this._functionParameters = params;
          return this;
      }

      /**
       * @param {string} name
       * @param {?ContractFunctionParameters} [params]
       * @returns {ContractCallQuery}
       */
      setFunction(name, params) {
          this._functionParameters = (
              params != null ? params : new ContractFunctionParameters()
          )._build(name);

          return this;
      }

      /**
       * @param {number | Long} size
       * @returns {ContractCallQuery}
       */
      setMaxResultSize(size) {
          this._maxResultSize =
              size instanceof Long ? size : Long.fromValue(size);
          return this;
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          if (this._contractId != null) {
              this._contractId.validateChecksum(client);
          }
      }

      /**
       * @override
       * @internal
       * @param {HieroProto.proto.IQuery} request
       * @param {HieroProto.proto.IResponse} response
       * @param {AccountId} nodeId
       * @returns {Error}
       */
      _mapStatusError(request, response, nodeId) {
          const { nodeTransactionPrecheckCode } =
              this._mapResponseHeader(response);

          const status = Status._fromCode(
              nodeTransactionPrecheckCode != null
                  ? nodeTransactionPrecheckCode
                  : libExports.proto.ResponseCodeEnum.OK,
          );

          const call =
              /**
               *@type {HieroProto.proto.IContractCallLocalResponse}
               */
              (response.contractCallLocal);
          if (!call.functionResult) {
              return new PrecheckStatusError({
                  nodeId,
                  status,
                  transactionId: this._getTransactionId(),
                  contractFunctionResult: null,
              });
          }

          const contractFunctionResult = this._mapResponseSync(response);

          return new PrecheckStatusError({
              nodeId,
              status,
              transactionId: this._getTransactionId(),
              contractFunctionResult,
          });
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.IQuery} request
       * @returns {Promise<HieroProto.proto.IResponse>}
       */
      _execute(channel, request) {
          return channel.smartContract.contractCallLocalMethod(request);
      }

      /**
       * @override
       * @internal
       * @param {HieroProto.proto.IResponse} response
       * @returns {HieroProto.proto.IResponseHeader}
       */
      _mapResponseHeader(response) {
          const contractCallLocal =
              /** @type {HieroProto.proto.IContractCallLocalResponse} */ (
                  response.contractCallLocal
              );
          return /** @type {HieroProto.proto.IResponseHeader} */ (
              contractCallLocal.header
          );
      }

      /**
       * @protected
       * @override
       * @param {HieroProto.proto.IResponse} response
       * @returns {Promise<ContractFunctionResult>}
       */
      _mapResponse(response) {
          const call =
              /**
               *@type {HieroProto.proto.IContractCallLocalResponse}
               */
              (response.contractCallLocal);

          return Promise.resolve(
              ContractFunctionResult._fromProtobuf(
                  /**
                   * @type {HieroProto.proto.IContractFunctionResult}
                   */
                  (call.functionResult),
                  false,
              ),
          );
      }

      /**
       * @private
       * @param {HieroProto.proto.IResponse} response
       * @returns {ContractFunctionResult}
       */
      _mapResponseSync(response) {
          const call =
              /**
               *@type {HieroProto.proto.IContractCallLocalResponse}
               */
              (response.contractCallLocal);

          return ContractFunctionResult._fromProtobuf(
              /**
               * @type {HieroProto.proto.IContractFunctionResult}
               */
              (call.functionResult),
              false,
          );
      }

      /**
       * @override
       * @internal
       * @param {HieroProto.proto.IQueryHeader} header
       * @returns {HieroProto.proto.IQuery}
       */
      _onMakeRequest(header) {
          return {
              contractCallLocal: {
                  header,
                  contractID:
                      this._contractId != null
                          ? this._contractId._toProtobuf()
                          : null,
                  gas: this._gas,
                  maxResultSize: this._maxResultSize,
                  functionParameters: this._functionParameters,
                  senderId:
                      this._senderAccountId != null
                          ? this._senderAccountId._toProtobuf()
                          : null,
              },
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp =
              this._paymentTransactionId != null &&
              this._paymentTransactionId.validStart != null
                  ? this._paymentTransactionId.validStart
                  : this._timestamp;

          return `ContractCallQuery:${timestamp.toString()}`;
      }
  }

  // eslint-disable-next-line @typescript-eslint/unbound-method
  QUERY_REGISTRY.set("contractCallLocal", ContractCallQuery._fromProtobuf);

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
   * @typedef {import("@hashgraph/proto").proto.IFileCreateTransactionBody} HieroProto.proto.IFileCreateTransactionBody
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../account/AccountId.js").default} AccountId
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   */

  /**
   * Create a new Hedera crypto-currency file.
   */
  class FileCreateTransaction extends Transaction {
      /**
       * @param {object} [props]
       * @param {Key[] | KeyList} [props.keys]
       * @param {Timestamp | Date} [props.expirationTime]
       * @param {Uint8Array | string} [props.contents]
       * @param {string} [props.fileMemo]
       */
      constructor(props = {}) {
          super();

          /**
           * @private
           * @type {?Key[]}
           */
          this._keys = null;

          /**
           * @private
           * @type {Timestamp}
           */
          this._expirationTime = new Timestamp(0, 0).plusNanos(
              Long.fromNumber(Date.now())
                  .mul(1000000)
                  .add(DEFAULT_AUTO_RENEW_PERIOD.mul(1000000000)),
          );

          /**
           * @private
           * @type {?Uint8Array}
           */
          this._contents = null;

          /**
           * @private
           * @type {?string}
           */
          this._fileMemo = null;

          this._defaultMaxTransactionFee = new Hbar(5);

          if (props.keys != null) {
              this.setKeys(props.keys);
          }

          if (props.expirationTime != null) {
              this.setExpirationTime(props.expirationTime);
          }

          if (props.contents != null) {
              this.setContents(props.contents);
          }

          if (props.fileMemo && props.fileMemo != null) {
              this.setFileMemo(props.fileMemo);
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransaction[]} transactions
       * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {HieroProto.proto.ITransactionBody[]} bodies
       * @returns {FileCreateTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];
          const create =
              /** @type {HieroProto.proto.IFileCreateTransactionBody} */ (
                  body.fileCreate
              );

          return Transaction._fromProtobufTransactions(
              new FileCreateTransaction({
                  keys:
                      create.keys != null
                          ? create.keys.keys != null
                              ? create.keys.keys.map((key) =>
                                    Key._fromProtobufKey(key),
                                )
                              : undefined
                          : undefined,
                  expirationTime:
                      create.expirationTime != null
                          ? Timestamp._fromProtobuf(create.expirationTime)
                          : undefined,
                  contents: create.contents != null ? create.contents : undefined,
                  fileMemo: create.memo != null ? create.memo : undefined,
              }),
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * @returns {?Key[]}
       */
      get keys() {
          return this._keys;
      }

      /**
       * Set the keys which must sign any transactions modifying this file. Required.
       *
       * All keys must sign to modify the file's contents or keys. No key is required
       * to sign for extending the expiration time (except the one for the operator account
       * paying for the transaction). Only one key must sign to delete the file, however.
       *
       * To require more than one key to sign to delete a file, add them to a
       * KeyList and pass that here.
       *
       * The network currently requires a file to have at least one key (or key list or threshold key)
       * but this requirement may be lifted in the future.
       *
       * @param {Key[] | KeyList} keys
       * @returns {this}
       */
      setKeys(keys) {
          this._requireNotFrozen();
          if (keys instanceof KeyList && keys.threshold != null) {
              throw new Error("Cannot set threshold key as file key");
          }

          this._keys = keys instanceof KeyList ? keys.toArray() : keys;

          return this;
      }

      /**
       * @returns {Timestamp}
       */
      get expirationTime() {
          return this._expirationTime;
      }

      /**
       * Set the instant at which this file will expire, after which its contents will no longer be
       * available.
       *
       * Defaults to 1/4 of a Julian year from the instant FileCreateTransaction
       * was invoked.
       *
       * May be extended using FileUpdateTransaction#setExpirationTime(Timestamp).
       *
       * @param {Timestamp | Date} expirationTime
       * @returns {this}
       */
      setExpirationTime(expirationTime) {
          this._requireNotFrozen();
          this._expirationTime =
              expirationTime instanceof Timestamp
                  ? expirationTime
                  : Timestamp.fromDate(expirationTime);

          return this;
      }

      /**
       * @returns {?Uint8Array}
       */
      get contents() {
          return this._contents;
      }

      /**
       * Set the given byte array as the file's contents.
       *
       * This may be omitted to create an empty file.
       *
       * Note that total size for a given transaction is limited to 6KiB (as of March 2020) by the
       * network; if you exceed this you may receive a HederaPreCheckStatusException
       * with Status#TransactionOversize.
       *
       * In this case, you will need to break the data into chunks of less than ~6KiB and execute this
       * transaction with the first chunk and then use FileAppendTransaction with
       * FileAppendTransaction#setContents(Uint8Array) for the remaining chunks.
       *
       * @param {Uint8Array | string} contents
       * @returns {this}
       */
      setContents(contents) {
          this._requireNotFrozen();
          this._contents =
              contents instanceof Uint8Array ? contents : encode$1(contents);

          return this;
      }

      /**
       * @returns {?string}
       */
      get fileMemo() {
          return this._fileMemo;
      }

      /**
       * @param {string} memo
       * @returns {this}
       */
      setFileMemo(memo) {
          this._requireNotFrozen();
          this._fileMemo = memo;

          return this;
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.ITransaction} request
       * @returns {Promise<HieroProto.proto.ITransactionResponse>}
       */
      _execute(channel, request) {
          return channel.file.createFile(request);
      }

      /**
       * @override
       * @protected
       * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "fileCreate";
      }

      /**
       * @override
       * @protected
       * @returns {HieroProto.proto.IFileCreateTransactionBody}
       */
      _makeTransactionData() {
          return {
              keys:
                  this._keys != null
                      ? {
                            keys: this._keys.map((key) => key._toProtobufKey()),
                        }
                      : null,
              expirationTime: this._expirationTime._toProtobuf(),
              contents: this._contents,
              memo: this._fileMemo,
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("../Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `FileCreateTransaction:${timestamp.toString()}`;
      }
  }

  // eslint-disable-next-line @typescript-eslint/unbound-method
  TRANSACTION_REGISTRY.set("fileCreate", FileCreateTransaction._fromProtobuf);

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
   * @typedef {import("@hashgraph/proto").proto.IFileAppendTransactionBody} HieroProto.proto.IFileAppendTransactionBody
   * @typedef {import("@hashgraph/proto").proto.IFileID} HieroProto.proto.IFileID
   */

  /**
   * @typedef {import("../PublicKey.js").default} PublicKey
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<Channel, *>} Client
   * @typedef {import("../transaction/TransactionResponse.js").default} TransactionResponse
   * @typedef {import("../schedule/ScheduleCreateTransaction.js").default} ScheduleCreateTransaction
   */

  /**
   * A transaction specifically to append data to a file on the network.
   *
   * If a file has multiple keys, all keys must sign to modify its contents.
   */
  class FileAppendTransaction extends Transaction {
      /**
       * @param {object} [props]
       * @param {FileId | string} [props.fileId]
       * @param {Uint8Array | string} [props.contents]
       * @param {number} [props.maxChunks]
       * @param {number} [props.chunkSize]
       * @param {number} [props.chunkInterval]
       */
      constructor(props = {}) {
          super();

          /**
           * @private
           * @type {?FileId}
           */
          this._fileId = null;

          /**
           * @private
           * @type {?Uint8Array}
           */
          this._contents = null;

          /**
           * @private
           * @type {number}
           */
          this._maxChunks = 20;

          /**
           * @private
           * @type {number}
           */
          this._chunkSize = 4096;

          /**
           * @private
           * @type {number}
           */
          this._chunkInterval = 10;

          this._defaultMaxTransactionFee = new Hbar(5);

          if (props.fileId != null) {
              this.setFileId(props.fileId);
          }

          if (props.contents != null) {
              this.setContents(props.contents);
          }

          if (props.maxChunks != null) {
              this.setMaxChunks(props.maxChunks);
          }

          if (props.chunkSize != null) {
              this.setChunkSize(props.chunkSize);
          }

          if (props.chunkInterval != null) {
              this.setChunkInterval(props.chunkInterval);
          }

          /** @type {List<TransactionId>} */
          this._transactionIds = new List();
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransaction[]} transactions
       * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {HieroProto.proto.ITransactionBody[]} bodies
       * @returns {FileAppendTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];
          const append =
              /** @type {HieroProto.proto.IFileAppendTransactionBody} */ (
                  body.fileAppend
              );

          let contents;

          // The increment value depends on whether the node IDs list is empty or not.
          // The node IDs list is not empty if the transaction has been frozen
          // before serialization and deserialization, otherwise, it's empty.
          const incrementValue = nodeIds.length > 0 ? nodeIds.length : 1;

          for (let i = 0; i < bodies.length; i += incrementValue) {
              const fileAppend =
                  /** @type {HieroProto.proto.IFileAppendTransactionBody} */ (
                      bodies[i].fileAppend
                  );
              if (fileAppend.contents == null) {
                  break;
              }

              if (contents == null) {
                  contents = new Uint8Array(
                      /** @type {Uint8Array} */ (fileAppend.contents),
                  );
                  continue;
              }

              /** @type {Uint8Array} */
              const concat = new Uint8Array(
                  contents.length +
                      /** @type {Uint8Array} */ (fileAppend.contents).length,
              );
              concat.set(contents, 0);
              concat.set(
                  /** @type {Uint8Array} */ (fileAppend.contents),
                  contents.length,
              );
              contents = concat;
          }
          const chunkSize = append.contents?.length || undefined;
          const maxChunks = bodies.length
              ? bodies.length / incrementValue
              : undefined;
          let chunkInterval;
          if (transactionIds.length > 1) {
              const firstValidStart = transactionIds[0].validStart;
              const secondValidStart = transactionIds[1].validStart;
              if (firstValidStart && secondValidStart) {
                  chunkInterval = secondValidStart.nanos
                      .sub(firstValidStart.nanos)
                      .toNumber();
              }
          }

          return Transaction._fromProtobufTransactions(
              new FileAppendTransaction({
                  fileId:
                      append.fileID != null
                          ? FileId._fromProtobuf(
                                /** @type {HieroProto.proto.IFileID} */ (
                                    append.fileID
                                ),
                            )
                          : undefined,
                  contents,
                  chunkSize,
                  maxChunks,
                  chunkInterval,
              }),
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * @returns {?FileId}
       */
      get fileId() {
          return this._fileId;
      }

      /**
       * Set the keys which must sign any transactions modifying this file. Required.
       *
       * All keys must sign to modify the file's contents or keys. No key is required
       * to sign for extending the expiration time (except the one for the operator account
       * paying for the transaction). Only one key must sign to delete the file, however.
       *
       * To require more than one key to sign to delete a file, add them to a
       * KeyList and pass that here.
       *
       * The network currently requires a file to have at least one key (or key list or threshold key)
       * but this requirement may be lifted in the future.
       *
       * @param {FileId | string} fileId
       * @returns {this}
       */
      setFileId(fileId) {
          this._requireNotFrozen();
          this._fileId =
              typeof fileId === "string"
                  ? FileId.fromString(fileId)
                  : fileId.clone();

          return this;
      }

      /**
       * @override
       * @returns {number}
       */
      getRequiredChunks() {
          if (this._contents == null) {
              return 1;
          }

          const result = Math.ceil(this._contents.length / this._chunkSize);

          return result;
      }

      /**
       * @returns {?Uint8Array}
       */
      get contents() {
          return this._contents;
      }

      /**
       * Set the given byte array as the file's contents.
       *
       * This may be omitted to append an empty file.
       *
       * Note that total size for a given transaction is limited to 6KiB (as of March 2020) by the
       * network; if you exceed this you may receive a HederaPreCheckStatusException
       * with Status#TransactionOversize.
       *
       * In this case, you will need to break the data into chunks of less than ~6KiB and execute this
       * transaction with the first chunk and then use FileAppendTransaction with
       * FileAppendTransaction#setContents(Uint8Array) for the remaining chunks.
       *
       * @param {Uint8Array | string} contents
       * @returns {this}
       */
      setContents(contents) {
          this._requireNotFrozen();
          this._contents =
              contents instanceof Uint8Array ? contents : encode$1(contents);

          return this;
      }

      /**
       * @returns {?number}
       */
      get maxChunks() {
          return this._maxChunks;
      }

      /**
       * @param {number} maxChunks
       * @returns {this}
       */
      setMaxChunks(maxChunks) {
          if (maxChunks <= 0) {
              throw new Error("Max chunks must be greater than 0");
          }
          this._requireNotFrozen();
          this._maxChunks = maxChunks;
          return this;
      }

      /**
       * @returns {?number}
       */
      get chunkSize() {
          return this._chunkSize;
      }

      /**
       * @param {number} chunkSize
       * @returns {this}
       */
      setChunkSize(chunkSize) {
          if (chunkSize <= 0) {
              throw new Error("Chunk size must be greater than 0");
          }
          this._chunkSize = chunkSize;
          return this;
      }

      /**
       * @returns {number}
       */
      get chunkInterval() {
          return this._chunkInterval;
      }

      /**
       * @param {number} chunkInterval The valid start interval between chunks in nanoseconds
       * @returns {this}
       */
      setChunkInterval(chunkInterval) {
          this._chunkInterval = chunkInterval;
          return this;
      }

      /**
       * Freeze this transaction from further modification to prepare for
       * signing or serialization.
       *
       * Will use the `Client`, if available, to generate a default Transaction ID and select 1/3
       * nodes to prepare this transaction for.
       *
       * @param {?import("../client/Client.js").default<Channel, *>} client
       * @returns {this}
       */
      freezeWith(client) {
          super.freezeWith(client);

          if (this._contents == null) {
              return this;
          }

          let nextTransactionId = this._getTransactionId();

          // Hack around the locked list. Should refactor a bit to remove such code
          this._transactionIds.locked = false;

          this._transactions.clear();
          this._transactionIds.clear();
          this._signedTransactions.clear();

          for (let chunk = 0; chunk < this.getRequiredChunks(); chunk++) {
              this._transactionIds.push(nextTransactionId);
              this._transactionIds.advance();

              for (const nodeAccountId of this._nodeAccountIds.list) {
                  this._signedTransactions.push(
                      this._makeSignedTransaction(nodeAccountId),
                  );
              }

              nextTransactionId = new TransactionId(
                  /** @type {AccountId} */ (nextTransactionId.accountId),
                  new Timestamp(
                      /** @type {Timestamp} */ (
                          nextTransactionId.validStart
                      ).seconds,
                      /** @type {Timestamp} */ (
                          nextTransactionId.validStart
                      ).nanos.add(this._chunkInterval),
                  ),
              );
          }

          this._transactionIds.advance();
          this._transactionIds.setLocked();

          return this;
      }

      /**
       * @returns {ScheduleCreateTransaction}
       */
      schedule() {
          this._requireNotFrozen();

          if (this._contents != null && this._contents.length > this._chunkSize) {
              throw new Error(
                  `cannot schedule \`FileAppendTransaction\` with message over ${this._chunkSize} bytes`,
              );
          }

          return super.schedule();
      }

      /**
       * @param {import("../client/Client.js").default<Channel, *>} client
       * @param {number=} requestTimeout
       * @returns {Promise<TransactionResponse>}
       */
      async execute(client, requestTimeout) {
          return (await this.executeAll(client, requestTimeout))[0];
      }

      /**
       * @param {import("../client/Client.js").default<Channel, *>} client
       * @param {number=} requestTimeout
       * @returns {Promise<TransactionResponse[]>}
       */
      async executeAll(client, requestTimeout) {
          if (this.maxChunks && this.getRequiredChunks() > this.maxChunks) {
              throw new Error(
                  `cannot execute \`FileAppendTransaction\` with more than ${this.maxChunks} chunks`,
              );
          }

          if (!super._isFrozen()) {
              this.freezeWith(client);
          }

          // on execute, sign each transaction with the operator, if present
          // and we are signing a transaction that used the default transaction ID

          const transactionId = this._getTransactionId();
          const operatorAccountId = client.operatorAccountId;

          if (
              operatorAccountId != null &&
              operatorAccountId.equals(
                  /** @type {AccountId} */ (transactionId.accountId),
              )
          ) {
              await super.signWithOperator(client);
          }

          const responses = [];
          let remainingTimeout = requestTimeout;

          for (let i = 0; i < this._transactionIds.length; i++) {
              const startTimestamp = Date.now();
              const response = await super.execute(client, remainingTimeout);

              if (remainingTimeout != null) {
                  remainingTimeout = Date.now() - startTimestamp;
              }

              await response.getReceipt(client);
              responses.push(response);
          }

          return responses;
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          if (this._fileId != null) {
              this._fileId.validateChecksum(client);
          }
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.ITransaction} request
       * @returns {Promise<HieroProto.proto.ITransactionResponse>}
       */
      _execute(channel, request) {
          return channel.file.appendContent(request);
      }

      /**
       * @override
       * @protected
       * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "fileAppend";
      }

      /**
       * Build all the transactions
       * when transactions are not complete.
       * @override
       * @internal
       */
      _buildIncompleteTransactions() {
          const dummyAccountId = AccountId.fromString("0.0.0");
          const accountId = this.transactionId?.accountId || dummyAccountId;
          const validStart =
              this.transactionId?.validStart || Timestamp.fromDate(new Date());

          if (this.maxChunks && this.getRequiredChunks() > this.maxChunks) {
              throw new Error(
                  `cannot build \`FileAppendTransaction\` with more than ${this.maxChunks} chunks`,
              );
          }

          // Hack around the locked list. Should refactor a bit to remove such code
          this._transactionIds.locked = false;

          this._transactions.clear();
          this._transactionIds.clear();
          this._signedTransactions.clear();

          for (let chunk = 0; chunk < this.getRequiredChunks(); chunk++) {
              let nextTransactionId = TransactionId.withValidStart(
                  accountId,
                  validStart.plusNanos(this._chunkInterval * chunk),
              );
              this._transactionIds.push(nextTransactionId);
              this._transactionIds.advance();

              if (this._nodeAccountIds.list.length === 0) {
                  this._transactions.push(this._makeSignedTransaction(null));
              } else {
                  for (const nodeAccountId of this._nodeAccountIds.list) {
                      this._transactions.push(
                          this._makeSignedTransaction(nodeAccountId),
                      );
                  }
              }
          }

          this._transactionIds.advance();
          this._transactionIds.setLocked();
      }

      /**
       * Build all the signed transactions
       * @override
       * @internal
       */
      _buildAllTransactions() {
          if (this.maxChunks && this.getRequiredChunks() > this.maxChunks) {
              throw new Error(
                  `cannot build \`FileAppendTransaction\` with more than ${this.maxChunks} chunks`,
              );
          }
          for (let i = 0; i < this._signedTransactions.length; i++) {
              this._buildTransaction(i);
          }
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("../Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `FileAppendTransaction:${timestamp.toString()}`;
      }

      /**
       * @override
       * @protected
       * @returns {HieroProto.proto.IFileAppendTransactionBody}
       */
      _makeTransactionData() {
          const length = this._contents != null ? this._contents.length : 0;
          const startIndex = this._transactionIds.index * this._chunkSize;
          const endIndex = Math.min(startIndex + this._chunkSize, length);

          return {
              fileID: this._fileId != null ? this._fileId._toProtobuf() : null,
              contents:
                  this._contents != null
                      ? this._contents.slice(startIndex, endIndex)
                      : null,
          };
      }
  }

  // eslint-disable-next-line @typescript-eslint/unbound-method
  TRANSACTION_REGISTRY.set("fileAppend", FileAppendTransaction._fromProtobuf);

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
   * @typedef {import("@hashgraph/proto").proto.IFileDeleteTransactionBody} HieroProto.proto.IFileDeleteTransactionBody
   */

  /**
   * @typedef {import("@hashgraph/cryptography").Key} Key
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("../account/AccountId.js").default} AccountId
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   */

  /**
   * A transaction to delete a file on the Hedera network.
   *
   * When deleted, a file's contents are truncated to zero length and it can no longer be updated
   * or appended to, or its expiration time extended. FileContentsQuery and FileInfoQuery
   * will throw HederaPreCheckStatusException with a status of Status#FileDeleted.
   *
   * Only one of the file's keys needs to sign to delete the file, unless the key you have is part
   * of a KeyList.
   */
  class FileDeleteTransaction extends Transaction {
      /**
       * @param {object} [props]
       * @param {FileId | string} [props.fileId]
       */
      constructor(props = {}) {
          super();

          /**
           * @private
           * @type {?FileId}
           */
          this._fileId = null;

          if (props.fileId != null) {
              this.setFileId(props.fileId);
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransaction[]} transactions
       * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {HieroProto.proto.ITransactionBody[]} bodies
       * @returns {FileDeleteTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];
          const fileDelete =
              /** @type {HieroProto.proto.IFileDeleteTransactionBody} */ (
                  body.fileDelete
              );

          return Transaction._fromProtobufTransactions(
              new FileDeleteTransaction({
                  fileId:
                      fileDelete.fileID != null
                          ? FileId._fromProtobuf(fileDelete.fileID)
                          : undefined,
              }),
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * @returns {?FileId}
       */
      get fileId() {
          return this._fileId;
      }

      /**
       * Set the file ID which is being deleted in this transaction.
       *
       * @param {FileId | string} fileId
       * @returns {FileDeleteTransaction}
       */
      setFileId(fileId) {
          this._requireNotFrozen();
          this._fileId =
              typeof fileId === "string"
                  ? FileId.fromString(fileId)
                  : fileId.clone();

          return this;
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          if (this._fileId != null) {
              this._fileId.validateChecksum(client);
          }
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.ITransaction} request
       * @returns {Promise<HieroProto.proto.ITransactionResponse>}
       */
      _execute(channel, request) {
          return channel.file.deleteFile(request);
      }

      /**
       * @override
       * @protected
       * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "fileDelete";
      }

      /**
       * @override
       * @protected
       * @returns {HieroProto.proto.IFileDeleteTransactionBody}
       */
      _makeTransactionData() {
          return {
              fileID: this._fileId != null ? this._fileId._toProtobuf() : null,
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("../Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `FileDeleteTransaction:${timestamp.toString()}`;
      }
  }

  // eslint-disable-next-line @typescript-eslint/unbound-method
  TRANSACTION_REGISTRY.set("fileDelete", FileDeleteTransaction._fromProtobuf);

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
   * @typedef {import("@hashgraph/proto").proto.IContractCreateTransactionBody} HieroProto.proto.IContractCreateTransactionBody
   * @typedef {import("@hashgraph/proto").proto.IAccountID} HieroProto.proto.IAccountID
   * @typedef {import("@hashgraph/proto").proto.IFileID} HieroProto.proto.IFileID
   */

  /**
   * @typedef {import("bignumber.js").default} BigNumber
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   */

  /**
   * Create a new smart contract.
   *
   * If this transaction succeeds, the `ContractID` for the new smart contract
   * SHALL be set in the transaction receipt.<br/>
   * The contract is defined by the initial bytecode (or `initcode`). The
   * `initcode` SHALL be stored either in a previously created file, or in the
   * transaction body itself for very small contracts.
   *
   * As part of contract creation, the constructor defined for the new smart
   * contract SHALL run with the parameters provided in the
   * `constructorParameters` field.<br/>
   * The gas to "power" that constructor MUST be provided via the `gas` field,
   * and SHALL be charged to the payer for this transaction.<br/>
   * If the contract _constructor_ stores information, it is charged gas for that
   * storage. There is a separate fee in HBAR to maintain that storage until the
   * expiration, and that fee SHALL be added to this transaction as part of the
   * _transaction fee_, rather than gas.
   *
   */

  class ContractCreateTransaction extends Transaction {
      /**
       * @param {object} [props]
       * @param {FileId | string} [props.bytecodeFileId]
       * @param {Uint8Array} [props.bytecode]
       * @param {Key} [props.adminKey]
       * @param {number | Long} [props.gas]
       * @param {number | string | Long | BigNumber | Hbar} [props.initialBalance]
       * @param {AccountId | string} [props.proxyAccountId]
       * @param {Duration | Long | number} [props.autoRenewPeriod]
       * @param {Uint8Array} [props.constructorParameters]
       * @param {string} [props.contractMemo]
       * @param {number} [props.maxAutomaticTokenAssociations]
       * @param {AccountId | string} [props.stakedAccountId]
       * @param {Long | number} [props.stakedNodeId]
       * @param {boolean} [props.declineStakingReward]
       * @param {AccountId} [props.autoRenewAccountId]
       */
      constructor(props = {}) {
          super();

          /**
           * @private
           * @type {?FileId}
           */
          this._bytecodeFileId = null;

          /**
           * @private
           * @type {?Uint8Array}
           */
          this._bytecode = null;

          /**
           * @private
           * @type {?Key}
           */
          this._adminKey = null;

          /**
           * @private
           * @type {?Long}
           */
          this._gas = null;

          /**
           * @private
           * @type {?Hbar}
           */
          this._initialBalance = null;

          /**
           * @private
           * @type {?AccountId}
           */
          this._proxyAccountId = null;

          /**
           * @private
           * @type {Duration}
           */
          this._autoRenewPeriod = new Duration(DEFAULT_AUTO_RENEW_PERIOD);

          /**
           * @private
           * @type {?Uint8Array}
           */
          this._constructorParameters = null;

          /**
           * @private
           * @type {?string}
           */
          this._contractMemo = null;

          /**
           * @private
           * @type {?number}
           */
          this._maxAutomaticTokenAssociations = null;

          this._defaultMaxTransactionFee = new Hbar(20);

          /**
           * @private
           * @type {?AccountId}
           */
          this._stakedAccountId = null;

          /**
           * @private
           * @type {?Long}
           */
          this._stakedNodeId = null;

          /**
           * @private
           * @type {boolean}
           */
          this._declineStakingReward = false;

          /**
           * @type {?AccountId}
           */
          this._autoRenewAccountId = null;

          if (props.bytecodeFileId != null) {
              this.setBytecodeFileId(props.bytecodeFileId);
          }

          if (props.bytecode != null) {
              this.setBytecode(props.bytecode);
          }

          if (props.adminKey != null) {
              this.setAdminKey(props.adminKey);
          }

          if (props.gas != null) {
              this.setGas(props.gas);
          }

          if (props.initialBalance != null) {
              this.setInitialBalance(props.initialBalance);
          }

          if (props.proxyAccountId != null) {
              // eslint-disable-next-line deprecation/deprecation
              this.setProxyAccountId(props.proxyAccountId);
          }

          if (props.autoRenewPeriod != null) {
              this.setAutoRenewPeriod(props.autoRenewPeriod);
          }

          if (props.constructorParameters != null) {
              this.setConstructorParameters(props.constructorParameters);
          }

          if (props.contractMemo != null) {
              this.setContractMemo(props.contractMemo);
          }

          if (props.maxAutomaticTokenAssociations != null) {
              this.setMaxAutomaticTokenAssociations(
                  props.maxAutomaticTokenAssociations,
              );
          }

          if (props.stakedAccountId != null) {
              this.setStakedAccountId(props.stakedAccountId);
          }

          if (props.stakedNodeId != null) {
              this.setStakedNodeId(props.stakedNodeId);
          }

          if (props.declineStakingReward != null) {
              this.setDeclineStakingReward(props.declineStakingReward);
          }

          if (props.autoRenewAccountId != null) {
              this.setAutoRenewAccountId(props.autoRenewAccountId);
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransaction[]} transactions
       * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {HieroProto.proto.ITransactionBody[]} bodies
       * @returns {ContractCreateTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];
          const create =
              /** @type {HieroProto.proto.IContractCreateTransactionBody} */ (
                  body.contractCreateInstance
              );

          return Transaction._fromProtobufTransactions(
              new ContractCreateTransaction({
                  bytecodeFileId:
                      create.fileID != null
                          ? FileId._fromProtobuf(
                                /** @type {HieroProto.proto.IFileID} */ (
                                    create.fileID
                                ),
                            )
                          : undefined,
                  adminKey:
                      create.adminKey != null
                          ? Key._fromProtobufKey(create.adminKey)
                          : undefined,
                  gas: create.gas != null ? create.gas : undefined,
                  initialBalance:
                      create.initialBalance != null
                          ? Hbar.fromTinybars(create.initialBalance)
                          : undefined,
                  proxyAccountId:
                      create.proxyAccountID != null
                          ? AccountId._fromProtobuf(
                                /** @type {HieroProto.proto.IAccountID} */ (
                                    create.proxyAccountID
                                ),
                            )
                          : undefined,
                  autoRenewPeriod:
                      create.autoRenewPeriod != null
                          ? create.autoRenewPeriod.seconds != null
                              ? create.autoRenewPeriod.seconds
                              : undefined
                          : undefined,
                  constructorParameters:
                      create.constructorParameters != null
                          ? create.constructorParameters
                          : undefined,
                  contractMemo: create.memo != null ? create.memo : undefined,
                  maxAutomaticTokenAssociations:
                      create.maxAutomaticTokenAssociations != null
                          ? create.maxAutomaticTokenAssociations
                          : undefined,
                  stakedAccountId:
                      create.stakedAccountId != null
                          ? AccountId._fromProtobuf(create.stakedAccountId)
                          : undefined,
                  stakedNodeId:
                      create.stakedNodeId != null
                          ? create.stakedNodeId
                          : undefined,
                  declineStakingReward: create.declineReward == true,
                  autoRenewAccountId:
                      create.autoRenewAccountId != null
                          ? AccountId._fromProtobuf(create.autoRenewAccountId)
                          : undefined,
              }),
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * @returns {?FileId}
       */
      get bytecodeFileId() {
          return this._bytecodeFileId;
      }

      /**
       * @param {FileId | string} bytecodeFileId
       * @returns {this}
       */
      setBytecodeFileId(bytecodeFileId) {
          this._requireNotFrozen();
          this._bytecodeFileId =
              typeof bytecodeFileId === "string"
                  ? FileId.fromString(bytecodeFileId)
                  : bytecodeFileId.clone();
          this._bytecode = null;

          return this;
      }

      /**
       * @returns {?Uint8Array}
       */
      get bytecode() {
          return this._bytecode;
      }

      /**
       * @param {Uint8Array} bytecode
       * @returns {this}
       */
      setBytecode(bytecode) {
          this._requireNotFrozen();
          this._bytecode = bytecode;
          this._bytecodeFileId = null;

          return this;
      }

      /**
       * @returns {?Key}
       */
      get adminKey() {
          return this._adminKey;
      }

      /**
       * @param {Key} adminKey
       * @returns {this}
       */
      setAdminKey(adminKey) {
          this._requireNotFrozen();
          this._adminKey = adminKey;

          return this;
      }

      /**
       * @returns {?Long}
       */
      get gas() {
          return this._gas;
      }

      /**
       * @param {number | Long} gas
       * @returns {this}
       */
      setGas(gas) {
          this._requireNotFrozen();
          this._gas = gas instanceof Long ? gas : Long.fromValue(gas);
          if (this._gas.lessThan(0)) {
              throw new Error("Gas cannot be negative number");
          }
          return this;
      }

      /**
       * @returns {?Hbar}
       */
      get initialBalance() {
          return this._initialBalance;
      }

      /**
       * Set the initial amount to transfer into this contract.
       *
       * @param {number | string | Long | BigNumber | Hbar} initialBalance
       * @returns {this}
       */
      setInitialBalance(initialBalance) {
          this._requireNotFrozen();
          this._initialBalance =
              initialBalance instanceof Hbar
                  ? initialBalance
                  : new Hbar(initialBalance);

          return this;
      }

      /**
       * @deprecated
       * @returns {?AccountId}
       */
      get proxyAccountId() {
          return this._proxyAccountId;
      }

      /**
       * @deprecated
       * @param {AccountId | string} proxyAccountId
       * @returns {this}
       */
      setProxyAccountId(proxyAccountId) {
          this._requireNotFrozen();
          this._proxyAccountId =
              proxyAccountId instanceof AccountId
                  ? proxyAccountId
                  : AccountId.fromString(proxyAccountId);

          return this;
      }

      /**
       * @returns {Duration}
       */
      get autoRenewPeriod() {
          return this._autoRenewPeriod;
      }

      /**
       * An account to charge for auto-renewal of this contract. If not set, or set to an
       * account with zero hbar balance, the contract's own hbar balance will be used to
       * cover auto-renewal fees.
       *
       * @param {Duration | Long | number} autoRenewPeriod
       * @returns {this}
       */
      setAutoRenewPeriod(autoRenewPeriod) {
          this._requireNotFrozen();
          this._autoRenewPeriod =
              autoRenewPeriod instanceof Duration
                  ? autoRenewPeriod
                  : new Duration(autoRenewPeriod);

          return this;
      }

      /**
       * @returns {?Uint8Array}
       */
      get constructorParameters() {
          return this._constructorParameters;
      }

      /**
       * @param {Uint8Array | ContractFunctionParameters} constructorParameters
       * @returns {this}
       */
      setConstructorParameters(constructorParameters) {
          this._requireNotFrozen();
          this._constructorParameters =
              constructorParameters instanceof ContractFunctionParameters
                  ? constructorParameters._build()
                  : constructorParameters;

          return this;
      }

      /**
       * @returns {?string}
       */
      get contractMemo() {
          return this._contractMemo;
      }

      /**
       * @param {string} contractMemo
       * @returns {this}
       */
      setContractMemo(contractMemo) {
          this._requireNotFrozen();
          this._contractMemo = contractMemo;

          return this;
      }

      /**
       * @returns {?number}
       */
      get maxAutomaticTokenAssociations() {
          return this._maxAutomaticTokenAssociations;
      }

      /**
       * @param {number} maxAutomaticTokenAssociations
       * @returns {this}
       */
      setMaxAutomaticTokenAssociations(maxAutomaticTokenAssociations) {
          this._maxAutomaticTokenAssociations = maxAutomaticTokenAssociations;

          return this;
      }

      /**
       * @returns {?AccountId}
       */
      get stakedAccountId() {
          return this._stakedAccountId;
      }

      /**
       * @param {AccountId | string} stakedAccountId
       * @returns {this}
       */
      setStakedAccountId(stakedAccountId) {
          this._requireNotFrozen();
          this._stakedAccountId =
              typeof stakedAccountId === "string"
                  ? AccountId.fromString(stakedAccountId)
                  : stakedAccountId;
          this._stakedNodeId = null;
          return this;
      }

      /**
       * @returns {?Long}
       */
      get stakedNodeId() {
          return this._stakedNodeId;
      }

      /**
       * @param {Long | number} stakedNodeId
       * @returns {this}
       */
      setStakedNodeId(stakedNodeId) {
          this._requireNotFrozen();
          this._stakedNodeId = Long.fromValue(stakedNodeId);
          this._stakedAccountId = null;
          return this;
      }

      /**
       * @returns {boolean}
       */
      get declineStakingRewards() {
          return this._declineStakingReward;
      }

      /**
       * @param {boolean} declineStakingReward
       * @returns {this}
       */
      setDeclineStakingReward(declineStakingReward) {
          this._requireNotFrozen();
          this._declineStakingReward = declineStakingReward;

          return this;
      }

      /**
       * @returns {?AccountId}
       */
      get autoRenewAccountId() {
          return this._autoRenewAccountId;
      }

      /**
       * @param {string | AccountId} autoRenewAccountId
       * @returns {this}
       */
      setAutoRenewAccountId(autoRenewAccountId) {
          this._requireNotFrozen();
          this._autoRenewAccountId =
              typeof autoRenewAccountId === "string"
                  ? AccountId.fromString(autoRenewAccountId)
                  : autoRenewAccountId;

          return this;
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          if (this._bytecodeFileId != null) {
              this._bytecodeFileId.validateChecksum(client);
          }

          if (this._proxyAccountId != null) {
              this._proxyAccountId.validateChecksum(client);
          }
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.ITransaction} request
       * @returns {Promise<HieroProto.proto.ITransactionResponse>}
       */
      _execute(channel, request) {
          return channel.smartContract.createContract(request);
      }

      /**
       * @override
       * @protected
       * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "contractCreateInstance";
      }

      /**
       * @override
       * @protected
       * @returns {HieroProto.proto.IContractCreateTransactionBody}
       */
      _makeTransactionData() {
          return {
              fileID:
                  this._bytecodeFileId != null
                      ? this._bytecodeFileId._toProtobuf()
                      : null,
              initcode: this._bytecode,
              adminKey:
                  this._adminKey != null ? this._adminKey._toProtobufKey() : null,
              gas: this._gas,
              initialBalance:
                  this._initialBalance != null
                      ? this._initialBalance.toTinybars()
                      : null,
              proxyAccountID:
                  this._proxyAccountId != null
                      ? this._proxyAccountId._toProtobuf()
                      : null,
              autoRenewPeriod: this._autoRenewPeriod._toProtobuf(),
              constructorParameters: this._constructorParameters,
              memo: this._contractMemo,
              maxAutomaticTokenAssociations: this._maxAutomaticTokenAssociations,
              stakedAccountId:
                  this.stakedAccountId != null
                      ? this.stakedAccountId._toProtobuf()
                      : null,
              stakedNodeId: this.stakedNodeId,
              declineReward: this.declineStakingRewards,
              autoRenewAccountId:
                  this._autoRenewAccountId != null
                      ? this._autoRenewAccountId._toProtobuf()
                      : null,
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("../Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `ContractCreateTransaction:${timestamp.toString()}`;
      }
  }

  TRANSACTION_REGISTRY.set(
      "contractCreateInstance",
      // eslint-disable-next-line @typescript-eslint/unbound-method
      ContractCreateTransaction._fromProtobuf,
  );

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {import("../account/AccountId.js").default} AccountId
   * @typedef {import("../file/FileId.js").default} FileId
   * @typedef {import("../Key.js").default} Key
   * @typedef {import("./ContractFunctionParameters.js").default} ContractFunctionParameters
   * @typedef {import("../Hbar.js").default} Hbar
   * @typedef {import("../Duration.js").default} Duration
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../channel/MirrorChannel.js").default} MirrorChannel
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   * @typedef {import("../transaction/TransactionResponse.js").default} TransactionResponse
   * @typedef {import("../transaction/TransactionReceipt.js").default} TransactionReceipt
   * @typedef {import("../client/Client.js").ClientOperator} ClientOperator
   * @typedef {import("../Signer.js").Signer} Signer
   * @typedef {import("../PrivateKey.js").default} PrivateKey
   * @typedef {import("../transaction/Transaction.js").default} Transaction
   */

  /**
   * @typedef {import("bignumber.js").BigNumber} BigNumber
   * @typedef {import("long")} Long
   */

  /**
   * A convenience flow that handles the creation of a smart contract on the Hedera network.
   * This flow abstracts away the complexity of the contract creation process by:
   *
   * 1. Creating a file to store the contract bytecode
   * 2. Uploading the contract bytecode in chunks if necessary
   * 3. Creating the contract instance using the uploaded bytecode
   * 4. Cleaning up by deleting the bytecode file (if operator key is available)
   *
   * This flow is particularly useful when deploying large contracts that exceed the 2048 byte
   * limit of a single transaction.
   */
  class ContractCreateFlow {
      constructor() {
          /** @type {Uint8Array | null} */
          this._bytecode = null;
          this._contractCreate = new ContractCreateTransaction();

          /**
           * Read `Transaction._signerPublicKeys`
           *
           * @internal
           * @type {Set<string>}
           */
          this._signerPublicKeys = new Set();

          /**
           * Read `Transaction._publicKeys`
           *
           * @private
           * @type {PublicKey[]}
           */
          this._publicKeys = [];

          /**
           * Read `Transaction._transactionSigners`
           *
           * @private
           * @type {((message: Uint8Array) => Promise<Uint8Array>)[]}
           */
          this._transactionSigners = [];

          this._maxChunks = null;
      }

      /**
       * @returns {number | null}
       */
      get maxChunks() {
          return this._maxChunks;
      }

      /**
       * @param {number} maxChunks
       * @returns {this}
       */
      setMaxChunks(maxChunks) {
          this._maxChunks = maxChunks;
          return this;
      }

      /**
       * @returns {?Uint8Array}
       */
      get bytecode() {
          return this._bytecode;
      }

      /**
       * @param {string | Uint8Array} bytecode
       * @returns {this}
       */
      setBytecode(bytecode) {
          this._bytecode =
              bytecode instanceof Uint8Array ? bytecode : encode$1(bytecode);

          return this;
      }

      /**
       * @returns {?Key}
       */
      get adminKey() {
          return this._contractCreate.adminKey;
      }

      /**
       * @param {Key} adminKey
       * @returns {this}
       */
      setAdminKey(adminKey) {
          this._contractCreate.setAdminKey(adminKey);
          return this;
      }

      /**
       * @returns {?Long}
       */
      get gas() {
          return this._contractCreate.gas;
      }

      /**
       * @param {number | Long} gas
       * @returns {this}
       */
      setGas(gas) {
          this._contractCreate.setGas(gas);
          return this;
      }

      /**
       * @returns {?Hbar}
       */
      get initialBalance() {
          return this._contractCreate.initialBalance;
      }

      /**
       * Set the initial amount to transfer into this contract.
       *
       * @param {number | string | Long | BigNumber | Hbar} initialBalance
       * @returns {this}
       */
      setInitialBalance(initialBalance) {
          this._contractCreate.setInitialBalance(initialBalance);
          return this;
      }

      /**
       * @deprecated
       * @returns {?AccountId}
       */
      get proxyAccountId() {
          // eslint-disable-next-line deprecation/deprecation
          return this._contractCreate.proxyAccountId;
      }

      /**
       * @deprecated
       * @param {AccountId | string} proxyAccountId
       * @returns {this}
       */
      setProxyAccountId(proxyAccountId) {
          // eslint-disable-next-line deprecation/deprecation
          this._contractCreate.setProxyAccountId(proxyAccountId);
          return this;
      }

      /**
       * @returns {Duration}
       */
      get autoRenewPeriod() {
          return this._contractCreate.autoRenewPeriod;
      }

      /**
       * @param {Duration | Long | number} autoRenewPeriod
       * @returns {this}
       */
      setAutoRenewPeriod(autoRenewPeriod) {
          this._contractCreate.setAutoRenewPeriod(autoRenewPeriod);
          return this;
      }

      /**
       * @returns {?Uint8Array}
       */
      get constructorParameters() {
          return this._contractCreate.constructorParameters;
      }

      /**
       * @param {Uint8Array | ContractFunctionParameters} constructorParameters
       * @returns {this}
       */
      setConstructorParameters(constructorParameters) {
          this._contractCreate.setConstructorParameters(constructorParameters);
          return this;
      }

      /**
       * @returns {?string}
       */
      get contractMemo() {
          return this._contractCreate.contractMemo;
      }

      /**
       * @param {string} contractMemo
       * @returns {this}
       */
      setContractMemo(contractMemo) {
          this._contractCreate.setContractMemo(contractMemo);
          return this;
      }

      /**
       * @returns {?number}
       */
      get maxAutomaticTokenAssociation() {
          return this._contractCreate.maxAutomaticTokenAssociations;
      }

      /**
       * @param {number} maxAutomaticTokenAssociation
       * @returns {this}
       */
      setMaxAutomaticTokenAssociations(maxAutomaticTokenAssociation) {
          this._contractCreate.setMaxAutomaticTokenAssociations(
              maxAutomaticTokenAssociation,
          );

          return this;
      }

      /**
       * @returns {?AccountId}
       */
      get stakedAccountId() {
          return this._contractCreate.stakedAccountId;
      }

      /**
       * @param {AccountId | string} stakedAccountId
       * @returns {this}
       */
      setStakedAccountId(stakedAccountId) {
          this._contractCreate.setStakedAccountId(stakedAccountId);
          return this;
      }

      /**
       * @returns {?Long}
       */
      get stakedNodeId() {
          return this._contractCreate.stakedNodeId;
      }

      /**
       * @param {Long | number} stakedNodeId
       * @returns {this}
       */
      setStakedNodeId(stakedNodeId) {
          this._contractCreate.setStakedNodeId(stakedNodeId);
          return this;
      }

      /**
       * @returns {boolean}
       */
      get declineStakingRewards() {
          return this._contractCreate.declineStakingRewards;
      }

      /**
       * @param {boolean} declineStakingReward
       * @returns {this}
       */
      setDeclineStakingReward(declineStakingReward) {
          this._contractCreate.setDeclineStakingReward(declineStakingReward);
          return this;
      }

      /**
       * @returns {?AccountId}
       */
      get autoRenewAccountId() {
          return this._contractCreate.autoRenewAccountId;
      }

      /**
       * @param {string | AccountId} autoRenewAccountId
       * @returns {this}
       */
      setAutoRenewAccountId(autoRenewAccountId) {
          this._contractCreate.setAutoRenewAccountId(autoRenewAccountId);
          return this;
      }

      /**
       * Sign the transaction with the private key
       * **NOTE**: This is a thin wrapper around `.signWith()`
       *
       * @param {PrivateKey} privateKey
       * @returns {this}
       */
      sign(privateKey) {
          return this.signWith(privateKey.publicKey, (message) =>
              Promise.resolve(privateKey.sign(message)),
          );
      }

      /**
       * Sign the transaction with the public key and signer function
       *
       * If sign on demand is enabled no signing will be done immediately, instead
       * the private key signing function and public key are saved to be used when
       * a user calls an exit condition method (not sure what a better name for this is)
       * such as `toBytes[Async]()`, `getTransactionHash[PerNode]()` or `execute()`.
       *
       * @param {PublicKey} publicKey
       * @param {(message: Uint8Array) => Promise<Uint8Array>} transactionSigner
       * @returns {this}
       */
      signWith(publicKey, transactionSigner) {
          const publicKeyData = publicKey.toBytesRaw();
          const publicKeyHex = encode$5(publicKeyData);

          if (this._signerPublicKeys.has(publicKeyHex)) {
              // this public key has already signed this transaction
              return this;
          }

          this._publicKeys.push(publicKey);
          this._transactionSigners.push(transactionSigner);

          return this;
      }

      /**
       * @template {Channel} ChannelT
       * @template {MirrorChannel} MirrorChannelT
       * @param {import("../client/Client.js").default<ChannelT, MirrorChannelT>} client
       * @param {number=} requestTimeout
       * @returns {Promise<TransactionResponse>}
       */
      async execute(client, requestTimeout) {
          if (this._bytecode == null) {
              throw new Error("cannot create contract with no bytecode");
          }

          const key = client.operatorPublicKey;

          const fileCreateTransaction = new FileCreateTransaction()
              .setKeys(key != null ? [key] : [])
              .setContents(
                  this._bytecode.subarray(
                      0,
                      Math.min(this._bytecode.length, 2048),
                  ),
              )
              .freezeWith(client);
          await addSignersToTransaction(
              fileCreateTransaction,
              this._publicKeys,
              this._transactionSigners,
          );

          let response = await fileCreateTransaction.execute(
              client,
              requestTimeout,
          );
          const receipt = await response.getReceipt(client);

          const fileId = /** @type {FileId} */ (receipt.fileId);

          if (this._bytecode.length > 2048) {
              const fileAppendTransaction = new FileAppendTransaction()
                  .setFileId(fileId)
                  .setContents(this._bytecode.subarray(2048))
                  .freezeWith(client);
              await addSignersToTransaction(
                  fileAppendTransaction,
                  this._publicKeys,
                  this._transactionSigners,
              );
              await fileAppendTransaction.execute(client, requestTimeout);
          }

          this._contractCreate.setBytecodeFileId(fileId).freezeWith(client);

          await addSignersToTransaction(
              this._contractCreate,
              this._publicKeys,
              this._transactionSigners,
          );

          response = await this._contractCreate.execute(client, requestTimeout);
          await response.getReceipt(client);

          if (key != null) {
              const fileDeleteTransaction = new FileDeleteTransaction()
                  .setFileId(fileId)
                  .freezeWith(client);
              await addSignersToTransaction(
                  fileDeleteTransaction,
                  this._publicKeys,
                  this._transactionSigners,
              );
              await (
                  await fileDeleteTransaction.execute(client, requestTimeout)
              ).getReceipt(client);
          }

          return response;
      }

      /**
       * @param {Signer} signer
       * @returns {Promise<TransactionResponse>}
       */
      async executeWithSigner(signer) {
          if (this._bytecode == null) {
              throw new Error("cannot create contract with no bytecode");
          }

          if (signer.getAccountKey == null) {
              throw new Error(
                  "`Signer.getAccountKey()` is not implemented, but is required for `ContractCreateFlow`",
              );
          }
          // eslint-disable-next-line @typescript-eslint/await-thenable
          const key = await signer.getAccountKey();
          let formattedPublicKey;

          if (key instanceof PublicKey) {
              formattedPublicKey = key;
          } else {
              const propertyValues = Object.values(
                  // @ts-ignore
                  // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-member-access
                  key._key._key._keyData,
              );
              const keyArray = new Uint8Array(propertyValues);

              formattedPublicKey = PublicKey.fromBytes(keyArray);
          }

          const fileCreateTransaction = await new FileCreateTransaction()
              .setKeys(formattedPublicKey != null ? [formattedPublicKey] : [])
              .setContents(
                  this._bytecode.subarray(
                      0,
                      Math.min(this._bytecode.length, 2048),
                  ),
              )
              .freezeWithSigner(signer);
          await fileCreateTransaction.signWithSigner(signer);
          await addSignersToTransaction(
              fileCreateTransaction,
              this._publicKeys,
              this._transactionSigners,
          );

          let response = await fileCreateTransaction.executeWithSigner(signer);
          const receipt = await response.getReceiptWithSigner(signer);

          const fileId = /** @type {FileId} */ (receipt.fileId);

          if (this._bytecode.length > 2048) {
              let fileAppendTransaction = new FileAppendTransaction()
                  .setFileId(fileId)
                  .setContents(this._bytecode.subarray(2048));
              if (this._maxChunks != null) {
                  fileAppendTransaction.setMaxChunks(this._maxChunks);
              }
              fileAppendTransaction =
                  await fileAppendTransaction.freezeWithSigner(signer);
              await fileAppendTransaction.signWithSigner(signer);
              await addSignersToTransaction(
                  fileAppendTransaction,
                  this._publicKeys,
                  this._transactionSigners,
              );
              await fileAppendTransaction.executeWithSigner(signer);
          }

          this._contractCreate = await this._contractCreate
              .setBytecodeFileId(fileId)
              .freezeWithSigner(signer);
          this._contractCreate =
              await this._contractCreate.signWithSigner(signer);
          await addSignersToTransaction(
              this._contractCreate,
              this._publicKeys,
              this._transactionSigners,
          );

          response = await this._contractCreate.executeWithSigner(signer);

          await response.getReceiptWithSigner(signer);

          if (key != null) {
              const fileDeleteTransaction = await new FileDeleteTransaction()
                  .setFileId(fileId)
                  .freezeWithSigner(signer);
              await fileDeleteTransaction.signWithSigner(signer);
              await addSignersToTransaction(
                  fileDeleteTransaction,
                  this._publicKeys,
                  this._transactionSigners,
              );
              await (
                  await fileDeleteTransaction.executeWithSigner(signer)
              ).getReceiptWithSigner(signer);
          }

          return response;
      }
  }

  /**
   * @template {Transaction} T
   * @param {T} transaction
   * @param {PublicKey[]} publicKeys
   * @param {((message: Uint8Array) => Promise<Uint8Array>)[]} transactionSigners
   * @returns {Promise<void>}
   */
  async function addSignersToTransaction(
      transaction,
      publicKeys,
      transactionSigners,
  ) {
      for (let i = 0; i < publicKeys.length; i++) {
          await transaction.signWith(publicKeys[i], transactionSigners[i]);
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
   * @typedef {import("@hashgraph/proto").proto.IContractDeleteTransactionBody} HieroProto.proto.IContractDeleteTransactionBody
   * @typedef {import("@hashgraph/proto").proto.IContractID} HieroProto.proto.IContractID
   * @typedef {import("@hashgraph/proto").proto.IAccountID} HieroProto.proto.IAccountID
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   */

  /**
   * Delete a smart contract, and transfer any remaining HBAR balance to a
   * designated account.
   *
   * If this call succeeds then all subsequent calls to that smart contract
   * SHALL execute the `0x0` opcode, as required for EVM equivalence.
   *
   * ### Requirements
   *  - An account or smart contract MUST be designated to receive all remaining
   *    account balances.
   *  - The smart contract MUST have an admin key set. If the contract does not
   *    have `admin_key` set, then this transaction SHALL fail and response code
   *    `MODIFYING_IMMUTABLE_CONTRACT` SHALL be set.
   *  - If `admin_key` is, or contains, an empty `KeyList` key, it SHALL be
   *    treated the same as an admin key that is not set.
   *  - The `Key` set for `admin_key` on the smart contract MUST have a valid
   *    signature set on this transaction.
   *  - The designated receiving account MAY have `receiver_sig_required` set. If
   *    that field is set, the receiver account MUST also sign this transaction.
   *  - The field `permanent_removal` MUST NOT be set. That field is reserved for
   *    internal system use when purging the smart contract from state. Any user
   *    transaction with that field set SHALL be rejected and a response code
   *    `PERMANENT_REMOVAL_REQUIRES_SYSTEM_INITIATION` SHALL be set.
   */
  class ContractDeleteTransaction extends Transaction {
      /**
       * @param {object} [props]
       * @param {ContractId | string} [props.contractId]
       * @param {ContractId | string} [props.transferContractId]
       * @param {AccountId | string} [props.transferAccountId]
       * @param {boolean} [props.permanentRemoval]
       */
      constructor(props = {}) {
          super();

          /**
           * @private
           * @type {?ContractId}
           */
          this._contractId = null;

          /**
           * @private
           * @type {?AccountId}
           */
          this._transferAccountId = null;

          /**
           * @private
           * @type {?ContractId}
           */
          this._transferContractId = null;

          /**
           * @private
           * @type {boolean}
           */
          this._permanentRemoval = false;

          if (props.contractId != null) {
              this.setContractId(props.contractId);
          }

          if (props.transferAccountId != null) {
              this.setTransferAccountId(props.transferAccountId);
          }

          if (props.transferContractId != null) {
              this.setTransferContractId(props.transferContractId);
          }

          if (props.permanentRemoval != null) {
              this.setPermanentRemoval(props.permanentRemoval);
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransaction[]} transactions
       * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {HieroProto.proto.ITransactionBody[]} bodies
       * @returns {ContractDeleteTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];
          const contractDelete =
              /** @type {HieroProto.proto.IContractDeleteTransactionBody} */ (
                  body.contractDeleteInstance
              );

          return Transaction._fromProtobufTransactions(
              new ContractDeleteTransaction({
                  contractId:
                      contractDelete.contractID != null
                          ? ContractId._fromProtobuf(
                                /** @type {HieroProto.proto.IContractID} */ (
                                    contractDelete.contractID
                                ),
                            )
                          : undefined,
                  transferAccountId:
                      contractDelete.transferAccountID != null
                          ? AccountId._fromProtobuf(
                                /** @type {HieroProto.proto.IAccountID} */ (
                                    contractDelete.transferAccountID
                                ),
                            )
                          : undefined,
                  transferContractId:
                      contractDelete.transferContractID != null
                          ? ContractId._fromProtobuf(
                                /** @type {HieroProto.proto.IContractID} */ (
                                    contractDelete.transferContractID
                                ),
                            )
                          : undefined,
                  permanentRemoval: contractDelete.permanentRemoval ?? false,
              }),
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * @returns {?ContractId}
       */
      get contractId() {
          return this._contractId;
      }

      /**
       * Sets the contract ID which is being deleted in this transaction.
       *
       * @param {ContractId | string} contractId
       * @returns {ContractDeleteTransaction}
       */
      setContractId(contractId) {
          this._requireNotFrozen();
          this._contractId =
              typeof contractId === "string"
                  ? ContractId.fromString(contractId)
                  : contractId.clone();

          return this;
      }

      /**
       * @returns {?ContractId}
       */
      get transferContractId() {
          return this._transferContractId;
      }

      /**
       * Sets the contract ID which will receive all remaining hbars.
       *
       * @param {ContractId | string} transferContractId
       * @returns {ContractDeleteTransaction}
       */
      setTransferContractId(transferContractId) {
          this._requireNotFrozen();
          this._transferContractId =
              transferContractId instanceof ContractId
                  ? transferContractId
                  : ContractId.fromString(transferContractId);
          this._transferAccountId = null;

          return this;
      }

      /**
       * @returns {?AccountId}
       */
      get transferAccountId() {
          return this._transferAccountId;
      }

      /**
       * Sets the account ID which will receive all remaining hbars.
       *
       * @param {AccountId | string} transferAccountId
       * @returns {ContractDeleteTransaction}
       */
      setTransferAccountId(transferAccountId) {
          this._requireNotFrozen();
          this._transferAccountId =
              transferAccountId instanceof AccountId
                  ? transferAccountId
                  : AccountId.fromString(transferAccountId);
          this._transferContractId = null;

          return this;
      }

      /**
       * @returns {boolean}
       */
      get permanentRemoval() {
          return this._permanentRemoval;
      }

      /**
       * Sets the permanent removal flag.
       *
       * @param {boolean} permanentRemoval
       * @returns {ContractDeleteTransaction}
       */
      setPermanentRemoval(permanentRemoval) {
          this._requireNotFrozen();
          this._permanentRemoval = permanentRemoval;
          return this;
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          if (this._contractId != null) {
              this._contractId.validateChecksum(client);
          }

          if (this._transferAccountId != null) {
              this._transferAccountId.validateChecksum(client);
          }

          if (this._transferContractId != null) {
              this._transferContractId.validateChecksum(client);
          }
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.ITransaction} request
       * @returns {Promise<HieroProto.proto.ITransactionResponse>}
       */
      _execute(channel, request) {
          return channel.smartContract.deleteContract(request);
      }

      /**
       * @override
       * @protected
       * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "contractDeleteInstance";
      }

      /**
       * @override
       * @protected
       * @returns {HieroProto.proto.IContractDeleteTransactionBody}
       */
      _makeTransactionData() {
          return {
              contractID:
                  this._contractId != null
                      ? this._contractId._toProtobuf()
                      : null,
              transferAccountID: this._transferAccountId
                  ? this._transferAccountId._toProtobuf()
                  : null,
              transferContractID:
                  this._transferContractId != null
                      ? this._transferContractId._toProtobuf()
                      : null,
              permanentRemoval: this._permanentRemoval,
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("../Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `ContractDeleteTransaction:${timestamp.toString()}`;
      }
  }

  TRANSACTION_REGISTRY.set(
      "contractDeleteInstance",
      // eslint-disable-next-line @typescript-eslint/unbound-method
      ContractDeleteTransaction._fromProtobuf,
  );

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
   * @typedef {import("@hashgraph/proto").proto.IContractCallTransactionBody} HieroProto.proto.IContractCallTransactionBody
   * @typedef {import("@hashgraph/proto").proto.IAccountID} HieroProto.proto.IAccountID
   * @typedef {import("@hashgraph/proto").proto.IContractID} HieroProto.proto.IContractID
   * @typedef {import("@hashgraph/proto").proto.IFileID} HieroProto.proto.IFileID
   */

  /**
   * @typedef {import("bignumber.js").default} BigNumber
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("../account/AccountId.js").default} AccountId
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   */

  /**
   * @typedef {object} FunctionParameters
   * @property {string} name
   * @property {ContractFunctionParameters} parameters
   */

  /**
   * Call a function of a given smart contract, providing function parameter
   * inputs as needed.
   * <p>
   * Resource ("gas") charges SHALL include all relevant fees incurred by
   * the contract execution, including any storage required.<br/>
   * The total transaction fee SHALL incorporate all of the "gas" actually
   * consumed as well as the standard fees for transaction handling,
   * data transfers, signature verification, etc...
   */
  class ContractExecuteTransaction extends Transaction {
      /**
       * @param {object} [props]
       * @param {ContractId | string} [props.contractId]
       * @param {number | Long} [props.gas]
       * @param {number | string | Long | BigNumber | Hbar} [props.amount]
       * @param {Uint8Array} [props.functionParameters]
       * @param {FunctionParameters} [props.function]
       */
      constructor(props = {}) {
          super();

          /**
           * @private
           * @type {?ContractId}
           */
          this._contractId = null;

          /**
           * @private
           * @type {?Long}
           */
          this._gas = null;

          /**
           * @private
           * @type {?Hbar}
           */
          this._amount = null;

          /**
           * @private
           * @type {?Uint8Array}
           */
          this._functionParameters = null;

          if (props.contractId != null) {
              this.setContractId(props.contractId);
          }

          if (props.gas != null) {
              this.setGas(props.gas);
          }

          if (props.amount != null) {
              this.setPayableAmount(props.amount);
          }

          if (props.functionParameters != null) {
              this.setFunctionParameters(props.functionParameters);
          } else if (props.function != null) {
              this.setFunction(props.function.name, props.function.parameters);
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransaction[]} transactions
       * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {HieroProto.proto.ITransactionBody[]} bodies
       * @returns {ContractExecuteTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];
          const call =
              /** @type {HieroProto.proto.IContractCallTransactionBody} */ (
                  body.contractCall
              );

          return Transaction._fromProtobufTransactions(
              new ContractExecuteTransaction({
                  contractId:
                      call.contractID != null
                          ? ContractId._fromProtobuf(
                                /** @type {HieroProto.proto.IContractID} */ (
                                    call.contractID
                                ),
                            )
                          : undefined,
                  gas: call.gas != null ? call.gas : undefined,
                  amount:
                      call.amount != null
                          ? Hbar.fromTinybars(call.amount)
                          : undefined,
                  functionParameters:
                      call.functionParameters != null
                          ? call.functionParameters
                          : undefined,
              }),
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * @returns {?ContractId}
       */
      get contractId() {
          return this._contractId;
      }

      /**
       * Sets the contract ID which is being executed in this transaction.
       *
       * @param {ContractId | string} contractId
       * @returns {ContractExecuteTransaction}
       */
      setContractId(contractId) {
          this._requireNotFrozen();
          this._contractId =
              typeof contractId === "string"
                  ? ContractId.fromString(contractId)
                  : contractId.clone();

          return this;
      }

      /**
       * @returns {?Long}
       */
      get gas() {
          return this._gas;
      }

      /**
       * Sets the amount of gas to use for the call.
       *
       * @param {number | Long} gas
       * @returns {ContractExecuteTransaction}
       */
      setGas(gas) {
          this._requireNotFrozen();
          const gasLong = gas instanceof Long ? gas : Long.fromValue(gas);
          if (gasLong.lt(0)) {
              throw new Error("Gas must be greater than 0");
          }
          this._gas = gasLong;

          return this;
      }

      /**
       * @returns {?Hbar}
       */
      get payableAmount() {
          return this._amount;
      }

      /**
       * Sets the number of hbars to be sent with this function call.
       *
       * @param {number | string | Long | BigNumber | Hbar} amount
       * @param {HbarUnit} unit
       * @returns {ContractExecuteTransaction}
       */
      setPayableAmount(amount, unit = HbarUnit.Hbar) {
          this._requireNotFrozen();
          this._amount =
              amount instanceof Hbar ? amount : Hbar.from(amount, unit);

          return this;
      }

      /**
       * @returns {?Uint8Array}
       */
      get functionParameters() {
          return this._functionParameters;
      }

      /**
       * @param {Uint8Array} functionParameters
       * @returns {this}
       */
      setFunctionParameters(functionParameters) {
          this._requireNotFrozen();
          this._functionParameters = functionParameters;

          return this;
      }

      /**
       * @param {string} name
       * @param {ContractFunctionParameters} [functionParameters]
       * @returns {this}
       */
      setFunction(name, functionParameters) {
          this._requireNotFrozen();
          this._functionParameters =
              functionParameters != null
                  ? functionParameters._build(name)
                  : new ContractFunctionParameters()._build(name);

          return this;
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          if (this._contractId != null) {
              this._contractId.validateChecksum(client);
          }
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.ITransaction} request
       * @returns {Promise<HieroProto.proto.ITransactionResponse>}
       */
      _execute(channel, request) {
          return channel.smartContract.contractCallMethod(request);
      }

      /**
       * @override
       * @protected
       * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "contractCall";
      }

      /**
       * @override
       * @protected
       * @returns {HieroProto.proto.IContractCallTransactionBody}
       */
      _makeTransactionData() {
          return {
              contractID:
                  this._contractId != null
                      ? this._contractId._toProtobuf()
                      : null,
              gas: this._gas,
              amount: this._amount != null ? this._amount.toTinybars() : null,
              functionParameters: this._functionParameters,
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("../Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `ContractExecuteTransaction:${timestamp.toString()}`;
      }
  }

  TRANSACTION_REGISTRY.set(
      "contractCall",
      // eslint-disable-next-line @typescript-eslint/unbound-method
      ContractExecuteTransaction._fromProtobuf,
  );

  // SPDX-License-Identifier: Apache-2.0


  const { proto: proto$4 } = HieroProto;

  /**
   * @typedef {import("../StakingInfo.js").StakingInfoJson} StakingInfoJson
   */

  /**
   * Response when the client sends the node CryptoGetInfoQuery.
   */
  class ContractInfo {
      /**
       * @private
       * @param {object} props
       * @param {ContractId} props.contractId
       * @param {AccountId} props.accountId
       * @param {string} props.contractAccountId
       * @param {?Key} props.adminKey
       * @param {Timestamp} props.expirationTime
       * @param {Duration} props.autoRenewPeriod
       * @param {?AccountId} props.autoRenewAccountId
       * @param {Long} props.storage
       * @param {string} props.contractMemo
       * @param {Hbar} props.balance
       * @param {boolean} props.isDeleted
       * @param {TokenRelationshipMap} props.tokenRelationships
       * @param {LedgerId|null} props.ledgerId
       * @param {?StakingInfo} props.stakingInfo
       * @param {Long} props.maxAutomaticTokenAssociations
       */
      constructor(props) {
          /**
           * ID of the contract instance, in the format used in transactions.
           *
           * @readonly
           */
          this.contractId = props.contractId;

          /**
           * ID of the cryptocurrency account owned by the contract instance,
           * in the format used in transactions.
           *
           * @readonly
           */
          this.accountId = props.accountId;

          /**
           * ID of both the contract instance and the cryptocurrency account owned by the contract
           * instance, in the format used by Solidity.
           *
           * @readonly
           */
          this.contractAccountId = props.contractAccountId;

          /**
           * The state of the instance and its fields can be modified arbitrarily if this key signs a
           * transaction to modify it. If this is null, then such modifications are not possible,
           * and there is no administrator that can override the normal operation of this smart
           * contract instance. Note that if it is created with no admin keys, then there is no
           * administrator to authorize changing the admin keys, so there can never be any admin keys
           * for that instance.
           *
           * @readonly
           */
          this.adminKey = props.adminKey != null ? props.adminKey : null;

          /**
           * The current time at which this contract instance (and its account) is set to expire.
           *
           * @readonly
           */
          this.expirationTime = props.expirationTime;

          /**
           * The expiration time will extend every this many seconds. If there are insufficient funds,
           * then it extends as long as possible. If the account is empty when it expires,
           * then it is deleted.
           *
           * @readonly
           */
          this.autoRenewPeriod = props.autoRenewPeriod;

          /**
           * ID of the an account to charge for auto-renewal of this contract. If not set, or set
           * to an account with zero hbar balance, the contract's own hbar balance will be used
           * to cover auto-renewal fees.
           *
           * @readonly
           */
          this.autoRenewAccountId = props.autoRenewAccountId;

          /**
           * Number of bytes of storage being used by this instance (which affects the cost to
           * extend the expiration time).
           *
           * @readonly
           */
          this.storage = props.storage;

          /**
           * The memo associated with the contract (max 100 bytes).
           *
           * @readonly
           */
          this.contractMemo = props.contractMemo;

          /**
           * The current balance of the contract.
           *
           * @readonly
           */
          this.balance = props.balance;

          /**
           * Whether the contract has been deleted
           *
           * @readonly
           */
          this.isDeleted = props.isDeleted;

          /**
           * The tokens associated to the contract
           *
           * @readonly
           */
          this.tokenRelationships = props.tokenRelationships;

          /**
           * The maximum number of automatic token associations allowed for this contract.
           * @readonly
           */
          this.maxAutomaticTokenAssociations =
              props.maxAutomaticTokenAssociations;

          /**
           * The ledger ID the response was returned from; please see <a href="https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a> for the network-specific IDs.
           */
          this.ledgerId = props.ledgerId;

          /**
           * Staking metadata for this account.
           */
          this.stakingInfo = props.stakingInfo;

          Object.freeze(this);
      }

      /**
       * @internal
       * @param {HieroProto.proto.ContractGetInfoResponse.IContractInfo} info
       * @returns {ContractInfo}
       */
      static _fromProtobuf(info) {
          const autoRenewPeriod = /** @type {Long | number} */ (
              /** @type {HieroProto.proto.IDuration} */ (info.autoRenewPeriod)
                  .seconds
          );

          return new ContractInfo({
              contractId: ContractId._fromProtobuf(
                  /** @type {HieroProto.proto.IContractID} */ (info.contractID),
              ),
              accountId: AccountId._fromProtobuf(
                  /** @type {HieroProto.proto.IAccountID} */ (info.accountID),
              ),
              contractAccountId:
                  info.contractAccountID != null ? info.contractAccountID : "",
              adminKey:
                  info.adminKey != null
                      ? Key._fromProtobufKey(info.adminKey)
                      : null,
              expirationTime: Timestamp._fromProtobuf(
                  /** @type {HieroProto.proto.ITimestamp} */ (
                      info.expirationTime
                  ),
              ),
              autoRenewPeriod: new Duration(autoRenewPeriod),
              autoRenewAccountId:
                  info.autoRenewAccountId != null
                      ? AccountId._fromProtobuf(info.autoRenewAccountId)
                      : null,
              storage:
                  info.storage != null
                      ? info.storage instanceof Long
                          ? info.storage
                          : Long.fromValue(info.storage)
                      : Long.ZERO,
              contractMemo: info.memo != null ? info.memo : "",
              balance: Hbar.fromTinybars(info.balance != null ? info.balance : 0),
              isDeleted: /** @type {boolean} */ (info.deleted),
              tokenRelationships: TokenRelationshipMap._fromProtobuf(
                  info.tokenRelationships != null ? info.tokenRelationships : [],
              ),
              ledgerId:
                  info.ledgerId != null
                      ? LedgerId.fromBytes(info.ledgerId)
                      : null,
              stakingInfo:
                  info.stakingInfo != null
                      ? StakingInfo._fromProtobuf(info.stakingInfo)
                      : null,
              maxAutomaticTokenAssociations:
                  info.maxAutomaticTokenAssociations != null
                      ? Long.isLong(info.maxAutomaticTokenAssociations)
                          ? info.maxAutomaticTokenAssociations
                          : Long.fromValue(info.maxAutomaticTokenAssociations)
                      : Long.ZERO,
          });
      }

      /**
       * @internal
       * @returns {HieroProto.proto.ContractGetInfoResponse.IContractInfo}
       */
      _toProtobuf() {
          return {
              contractID: this.contractId._toProtobuf(),
              accountID: this.accountId._toProtobuf(),
              contractAccountID: this.contractAccountId,
              adminKey:
                  this.adminKey != null ? this.adminKey._toProtobufKey() : null,
              expirationTime: this.expirationTime._toProtobuf(),
              autoRenewPeriod:
                  this.autoRenewPeriod != null
                      ? this.autoRenewPeriod._toProtobuf()
                      : null,
              autoRenewAccountId:
                  this.autoRenewAccountId != null
                      ? this.autoRenewAccountId._toProtobuf()
                      : null,
              storage: this.storage,
              memo: this.contractMemo,
              balance: this.balance.toTinybars(),
              deleted: this.isDeleted,
              tokenRelationships:
                  this.tokenRelationships != null
                      ? this.tokenRelationships._toProtobuf()
                      : null,
              ledgerId: this.ledgerId != null ? this.ledgerId.toBytes() : null,
              stakingInfo:
                  this.stakingInfo != null
                      ? this.stakingInfo._toProtobuf()
                      : null,
              maxAutomaticTokenAssociations:
                  this.maxAutomaticTokenAssociations.toNumber(),
          };
      }

      /**
       * @param {Uint8Array} bytes
       * @returns {ContractInfo}
       */
      static fromBytes(bytes) {
          return ContractInfo._fromProtobuf(
              proto$4.ContractGetInfoResponse.ContractInfo.decode(bytes),
          );
      }

      /**
       * @returns {Uint8Array}
       */
      toBytes() {
          return proto$4.ContractGetInfoResponse.ContractInfo.encode(
              this._toProtobuf(),
          ).finish();
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.IQuery} HieroProto.proto.IQuery
   * @typedef {import("@hashgraph/proto").proto.IQueryHeader} HieroProto.proto.IQueryHeader
   * @typedef {import("@hashgraph/proto").proto.IResponse} HieroProto.proto.IResponse
   * @typedef {import("@hashgraph/proto").proto.IResponseHeader} HieroProto.proto.IResponseHeader
   * @typedef {import("@hashgraph/proto").proto.IContractGetInfoQuery} HieroProto.proto.IContractGetInfoQuery
   * @typedef {import("@hashgraph/proto").proto.IContractGetInfoResponse} HieroProto.proto.IContractGetInfoResponse
   * @typedef {import("@hashgraph/proto").proto.ContractGetInfoResponse.IContractInfo} HieroProto.proto.ContractGetInfoResponse.IContractInfo
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("../account/AccountId.js").default} AccountId
   */

  /**
   * A query that returns information about a smart contract instance.
   * This includes the account that it owns, the contract's bytecode, and the timestamp when it will expire.
   * @augments {Query<ContractInfo>}
   */
  class ContractInfoQuery extends Query {
      /**
       * @param {object} [props]
       * @param {ContractId | string} [props.contractId]
       */
      constructor(props = {}) {
          super();

          /**
           * @type {?ContractId}
           * @private
           */
          this._contractId = null;
          if (props.contractId != null) {
              this.setContractId(props.contractId);
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.IQuery} query
       * @returns {ContractInfoQuery}
       */
      static _fromProtobuf(query) {
          const info = /** @type {HieroProto.proto.IContractGetInfoQuery} */ (
              query.contractGetInfo
          );

          return new ContractInfoQuery({
              contractId:
                  info.contractID != null
                      ? ContractId._fromProtobuf(info.contractID)
                      : undefined,
          });
      }

      /**
       * @returns {?ContractId}
       */
      get contractId() {
          return this._contractId;
      }

      /**
       * Set the contract ID for which the info is being requested.
       *
       * @param {ContractId | string} contractId
       * @returns {ContractInfoQuery}
       */
      setContractId(contractId) {
          this._contractId =
              typeof contractId === "string"
                  ? ContractId.fromString(contractId)
                  : contractId.clone();

          return this;
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          if (this._contractId != null) {
              this._contractId.validateChecksum(client);
          }
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.IQuery} request
       * @returns {Promise<HieroProto.proto.IResponse>}
       */
      _execute(channel, request) {
          return channel.smartContract.getContractInfo(request);
      }

      /**
       * @override
       * @param {import("../client/Client.js").default<Channel, *>} client
       * @returns {Promise<Hbar>}
       */
      async getCost(client) {
          return super.getCost(client);
      }

      /**
       * @override
       * @internal
       * @param {HieroProto.proto.IResponse} response
       * @returns {HieroProto.proto.IResponseHeader}
       */
      _mapResponseHeader(response) {
          const contractGetInfo =
              /** @type {HieroProto.proto.IContractGetInfoResponse} */ (
                  response.contractGetInfo
              );
          return /** @type {HieroProto.proto.IResponseHeader} */ (
              contractGetInfo.header
          );
      }

      /**
       * @protected
       * @override
       * @param {HieroProto.proto.IResponse} response
       * @param {AccountId} nodeAccountId
       * @param {HieroProto.proto.IQuery} request
       * @returns {Promise<ContractInfo>}
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _mapResponse(response, nodeAccountId, request) {
          const info = /** @type {HieroProto.proto.IContractGetInfoResponse} */ (
              response.contractGetInfo
          );

          return Promise.resolve(
              ContractInfo._fromProtobuf(
                  /** @type {HieroProto.proto.ContractGetInfoResponse.IContractInfo} */ (
                      info.contractInfo
                  ),
              ),
          );
      }

      /**
       * @override
       * @internal
       * @param {HieroProto.proto.IQueryHeader} header
       * @returns {HieroProto.proto.IQuery}
       */
      _onMakeRequest(header) {
          return {
              contractGetInfo: {
                  header,
                  contractID:
                      this._contractId != null
                          ? this._contractId._toProtobuf()
                          : null,
              },
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp =
              this._paymentTransactionId != null &&
              this._paymentTransactionId.validStart != null
                  ? this._paymentTransactionId.validStart
                  : this._timestamp;

          return `ContractInfoQuery:${timestamp.toString()}`;
      }
  }

  // eslint-disable-next-line @typescript-eslint/unbound-method
  QUERY_REGISTRY.set("contractGetInfo", ContractInfoQuery._fromProtobuf);

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
   * @typedef {import("@hashgraph/proto").proto.IContractUpdateTransactionBody} HieroProto.proto.IContractUpdateTransactionBody
   * @typedef {import("@hashgraph/proto").proto.IAccountID} HieroProto.proto.IAccountID
   * @typedef {import("@hashgraph/proto").proto.IContractID} HieroProto.proto.IContractID
   * @typedef {import("@hashgraph/proto").proto.IFileID} HieroProto.proto.IFileID
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   */

  /**
   * Modify a smart contract.<br/>
   * Any change other than updating the expiration time requires that the
   * contract be modifiable (has a valid `adminKey`) and that the
   * transaction be signed by the `adminKey`
   * <p>
   * Fields _not set_ on the request SHALL NOT be modified.
   */
  class ContractUpdateTransaction extends Transaction {
      /**
       * @param {object} props
       * @param {ContractId | string} [props.contractId]
       * @param {FileId | string} [props.bytecodeFileId]
       * @param {Timestamp | Date} [props.expirationTime]
       * @param {Key} [props.adminKey]
       * @param {AccountId | string} [props.proxyAccountId]
       * @param {Duration | Long | number} [props.autoRenewPeriod]
       * @param {string} [props.contractMemo]
       * @param {number} [props.maxAutomaticTokenAssociations]
       * @param {AccountId | string} [props.stakedAccountId]
       * @param {Long | number} [props.stakedNodeId]
       * @param {boolean} [props.declineStakingReward]
       * @param {AccountId} [props.autoRenewAccountId]
       */
      constructor(props = {}) {
          super();

          /**
           * @private
           * @type {?ContractId}
           */
          this._contractId = null;

          /**
           * @private
           * @type {?Timestamp}
           */
          this._expirationTime = null;

          /**
           * @private
           * @type {?Key}
           */
          this._adminKey = null;

          /**
           * @private
           * @type {?AccountId}
           */
          this._proxyAccountId = null;

          /**
           * @private
           * @type {?Duration}
           */
          this._autoRenewPeriod = null;

          /**
           * @private
           * @type {?FileId}
           */
          this._bytecodeFileId = null;

          /**
           * @private
           * @type {?string}
           */
          this._contractMemo = null;

          /**
           * @private
           * @type {?number}
           */
          this._maxAutomaticTokenAssociations = null;

          /**
           * @private
           * @type {?AccountId}
           */
          this._stakedAccountId = null;

          /**
           * @private
           * @type {?Long}
           */
          this._stakedNodeId = null;

          /**
           * @private
           * @type {?boolean}
           */
          this._declineStakingReward = null;

          /**
           * @type {?AccountId}
           */
          this._autoRenewAccountId = null;

          if (props.contractId != null) {
              this.setContractId(props.contractId);
          }

          if (props.expirationTime != null) {
              this.setExpirationTime(props.expirationTime);
          }

          if (props.adminKey != null) {
              this.setAdminKey(props.adminKey);
          }

          if (props.proxyAccountId != null) {
              // eslint-disable-next-line deprecation/deprecation
              this.setProxyAccountId(props.proxyAccountId);
          }

          if (props.autoRenewPeriod != null) {
              this.setAutoRenewPeriod(props.autoRenewPeriod);
          }

          if (props.bytecodeFileId != null) {
              this.setBytecodeFileId(props.bytecodeFileId);
          }

          if (props.contractMemo != null) {
              this.setContractMemo(props.contractMemo);
          }

          if (props.maxAutomaticTokenAssociations != null) {
              this.setMaxAutomaticTokenAssociations(
                  props.maxAutomaticTokenAssociations,
              );
          }

          if (props.stakedAccountId != null) {
              this.setStakedAccountId(props.stakedAccountId);
          }

          if (props.stakedNodeId != null) {
              this.setStakedNodeId(props.stakedNodeId);
          }

          if (props.declineStakingReward != null) {
              this.setDeclineStakingReward(props.declineStakingReward);
          }

          if (props.autoRenewAccountId != null) {
              this.setAutoRenewAccountId(props.autoRenewAccountId);
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransaction[]} transactions
       * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {HieroProto.proto.ITransactionBody[]} bodies
       * @returns {ContractUpdateTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];
          const update =
              /** @type {HieroProto.proto.IContractUpdateTransactionBody} */ (
                  body.contractUpdateInstance
              );

          let autoRenewPeriod = undefined;
          if (
              update.autoRenewPeriod != null &&
              update.autoRenewPeriod.seconds != null
          ) {
              autoRenewPeriod = update.autoRenewPeriod.seconds;
          }

          let contractMemo = undefined;
          if (
              update.memoWrapper != null &&
              Object.hasOwn(update.memoWrapper, "value") &&
              update.memoWrapper.value != null
          ) {
              contractMemo = update.memoWrapper.value;
          }

          let maxAutomaticTokenAssociations = undefined;
          if (
              update.maxAutomaticTokenAssociations != null &&
              update.maxAutomaticTokenAssociations.value != null
          ) {
              maxAutomaticTokenAssociations =
                  update.maxAutomaticTokenAssociations.value;
          }

          return Transaction._fromProtobufTransactions(
              new ContractUpdateTransaction({
                  contractId:
                      update.contractID != null
                          ? ContractId._fromProtobuf(
                                /** @type {HieroProto.proto.IContractID} */ (
                                    update.contractID
                                ),
                            )
                          : undefined,
                  bytecodeFileId:
                      update.fileID != null
                          ? FileId._fromProtobuf(
                                /** @type {HieroProto.proto.IFileID} */ (
                                    update.fileID
                                ),
                            )
                          : undefined,
                  expirationTime:
                      update.expirationTime != null
                          ? Timestamp._fromProtobuf(update.expirationTime)
                          : undefined,
                  adminKey:
                      update.adminKey != null
                          ? Key._fromProtobufKey(update.adminKey)
                          : undefined,
                  proxyAccountId:
                      update.proxyAccountID != null
                          ? AccountId._fromProtobuf(
                                /** @type {HieroProto.proto.IAccountID} */ (
                                    update.proxyAccountID
                                ),
                            )
                          : undefined,
                  autoRenewPeriod,
                  contractMemo,
                  maxAutomaticTokenAssociations,
                  stakedAccountId:
                      update.stakedAccountId != null
                          ? AccountId._fromProtobuf(update.stakedAccountId)
                          : undefined,
                  stakedNodeId:
                      update.stakedNodeId != null
                          ? update.stakedNodeId
                          : undefined,
                  declineStakingReward:
                      update.declineReward != null &&
                      Boolean(update.declineReward) == true,
                  autoRenewAccountId:
                      update.autoRenewAccountId != null
                          ? AccountId._fromProtobuf(update.autoRenewAccountId)
                          : undefined,
              }),
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * @returns {?ContractId}
       */
      get contractId() {
          return this._contractId;
      }

      /**
       * Sets the contract ID which is being deleted in this transaction.
       *
       * @param {ContractId | string} contractId
       * @returns {ContractUpdateTransaction}
       */
      setContractId(contractId) {
          this._requireNotFrozen();
          this._contractId =
              typeof contractId === "string"
                  ? ContractId.fromString(contractId)
                  : contractId.clone();

          return this;
      }

      /**
       * @returns {?Timestamp}
       */
      get expirationTime() {
          return this._expirationTime;
      }

      /**
       * Sets the contract ID which is being deleted in this transaction.
       *
       * @param {Timestamp | Date} expirationTime
       * @returns {ContractUpdateTransaction}
       */
      setExpirationTime(expirationTime) {
          this._requireNotFrozen();
          this._expirationTime =
              expirationTime instanceof Timestamp
                  ? expirationTime
                  : Timestamp.fromDate(expirationTime);

          return this;
      }

      /**
       * @returns {?Key}
       */
      get adminKey() {
          return this._adminKey;
      }

      /**
       * @param {Key} adminKey
       * @returns {this}
       */
      setAdminKey(adminKey) {
          this._requireNotFrozen();
          this._adminKey = adminKey;

          return this;
      }

      /**
       * @deprecated
       * @returns {?AccountId}
       */
      get proxyAccountId() {
          return this._proxyAccountId;
      }

      /**
       * @deprecated
       * @param {AccountId | string} proxyAccountId
       * @returns {this}
       */
      setProxyAccountId(proxyAccountId) {
          this._requireNotFrozen();
          this._proxyAccountId =
              typeof proxyAccountId === "string"
                  ? AccountId.fromString(proxyAccountId)
                  : proxyAccountId.clone();

          return this;
      }

      /**
       * @returns {?Duration}
       */
      get autoRenewPeriod() {
          return this._autoRenewPeriod;
      }

      /**
       * @param {Duration | Long | number} autoRenewPeriod
       * @returns {this}
       */
      setAutoRenewPeriod(autoRenewPeriod) {
          this._requireNotFrozen();
          this._autoRenewPeriod =
              autoRenewPeriod instanceof Duration
                  ? autoRenewPeriod
                  : new Duration(autoRenewPeriod);

          return this;
      }

      /**
       * @returns {?FileId}
       */
      get bytecodeFileId() {
          return this._bytecodeFileId;
      }

      /**
       * @param {FileId | string} bytecodeFileId
       * @returns {this}
       */
      setBytecodeFileId(bytecodeFileId) {
          console.warn("Deprecated: there is no replacement");
          this._requireNotFrozen();
          this._bytecodeFileId =
              typeof bytecodeFileId === "string"
                  ? FileId.fromString(bytecodeFileId)
                  : bytecodeFileId.clone();

          return this;
      }

      /**
       * @returns {?string}
       */
      get contractMemo() {
          return this._contractMemo;
      }

      /**
       * @param {string} contractMemo
       * @returns {this}
       */
      setContractMemo(contractMemo) {
          this._requireNotFrozen();
          this._contractMemo = contractMemo;

          return this;
      }

      /**
       * @returns {this}
       */
      clearContractMemo() {
          this._requireNotFrozen();
          this._contractMemo = null;

          return this;
      }

      /**
       * @returns {number | null}
       */
      get maxAutomaticTokenAssociations() {
          return this._maxAutomaticTokenAssociations;
      }

      /**
       * @param {number} maxAutomaticTokenAssociations
       * @returns {this}
       */
      setMaxAutomaticTokenAssociations(maxAutomaticTokenAssociations) {
          this._requireNotFrozen();
          this._maxAutomaticTokenAssociations = maxAutomaticTokenAssociations;

          return this;
      }

      /**
       * @returns {?AccountId}
       */
      get stakedAccountId() {
          return this._stakedAccountId;
      }

      /**
       * @param {AccountId | string} stakedAccountId
       * @returns {this}
       */
      setStakedAccountId(stakedAccountId) {
          this._requireNotFrozen();
          this._stakedAccountId =
              typeof stakedAccountId === "string"
                  ? AccountId.fromString(stakedAccountId)
                  : stakedAccountId;

          return this;
      }

      /**
       * @returns {?Long}
       */
      get stakedNodeId() {
          return this._stakedNodeId;
      }

      /**
       * @param {Long | number} stakedNodeId
       * @returns {this}
       */
      setStakedNodeId(stakedNodeId) {
          this._requireNotFrozen();
          this._stakedNodeId = Long.fromValue(stakedNodeId);

          return this;
      }

      /**
       * @returns {?boolean}
       */
      get declineStakingRewards() {
          return this._declineStakingReward;
      }

      /**
       * @param {boolean} declineStakingReward
       * @returns {this}
       */
      setDeclineStakingReward(declineStakingReward) {
          this._requireNotFrozen();
          this._declineStakingReward = declineStakingReward;

          return this;
      }

      /**
       * @returns {?AccountId}
       */
      get autoRenewAccountId() {
          return this._autoRenewAccountId;
      }

      /**
       * If set to the sentinel <tt>0.0.0</tt> AccountID, this field removes the contract's auto-renew
       * account. Otherwise it updates the contract's auto-renew account to the referenced account.
       *
       * @param {string | AccountId} autoRenewAccountId
       * @returns {this}
       */
      setAutoRenewAccountId(autoRenewAccountId) {
          this._requireNotFrozen();
          this._autoRenewAccountId =
              typeof autoRenewAccountId === "string"
                  ? AccountId.fromString(autoRenewAccountId)
                  : autoRenewAccountId;

          return this;
      }

      /**
       * @returns {this}
       */
      clearAutoRenewAccountId() {
          this._autoRenewAccountId = new AccountId(0);
          return this;
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          if (this._contractId != null) {
              this._contractId.validateChecksum(client);
          }

          if (this._bytecodeFileId != null) {
              this._bytecodeFileId.validateChecksum(client);
          }

          if (this._proxyAccountId != null) {
              this._proxyAccountId.validateChecksum(client);
          }
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.ITransaction} request
       * @returns {Promise<HieroProto.proto.ITransactionResponse>}
       */
      _execute(channel, request) {
          return channel.smartContract.updateContract(request);
      }

      /**
       * @override
       * @protected
       * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "contractUpdateInstance";
      }

      /**
       * @override
       * @protected
       * @returns {HieroProto.proto.IContractUpdateTransactionBody}
       */
      _makeTransactionData() {
          return {
              contractID:
                  this._contractId != null
                      ? this._contractId._toProtobuf()
                      : null,
              expirationTime:
                  this._expirationTime != null
                      ? this._expirationTime._toProtobuf()
                      : null,
              adminKey:
                  this._adminKey != null ? this._adminKey._toProtobufKey() : null,
              proxyAccountID:
                  this._proxyAccountId != null
                      ? this._proxyAccountId._toProtobuf()
                      : null,
              autoRenewPeriod:
                  this._autoRenewPeriod != null
                      ? this._autoRenewPeriod._toProtobuf()
                      : null,
              fileID: this._bytecodeFileId
                  ? this._bytecodeFileId._toProtobuf()
                  : null,
              memoWrapper:
                  this._contractMemo != null
                      ? {
                            value: this._contractMemo,
                        }
                      : null,
              maxAutomaticTokenAssociations:
                  this._maxAutomaticTokenAssociations != null
                      ? {
                            value: this._maxAutomaticTokenAssociations,
                        }
                      : null,
              stakedAccountId:
                  this.stakedAccountId != null
                      ? this.stakedAccountId._toProtobuf()
                      : null,
              stakedNodeId: this.stakedNodeId,
              declineReward:
                  this.declineStakingRewards != null
                      ? { value: this.declineStakingRewards }
                      : null,
              autoRenewAccountId:
                  this._autoRenewAccountId != null
                      ? this._autoRenewAccountId.toString() == "0.0.0"
                          ? libExports.proto.AccountID.create()
                          : this._autoRenewAccountId._toProtobuf()
                      : null,
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("../Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `ContractUpdateTransaction:${timestamp.toString()}`;
      }
  }

  TRANSACTION_REGISTRY.set(
      "contractUpdateInstance",
      // eslint-disable-next-line @typescript-eslint/unbound-method
      ContractUpdateTransaction._fromProtobuf,
  );

  // SPDX-License-Identifier: Apache-2.0

  class FeeAssessmentMethod {
      /**
       * @hideconstructor
       * @internal
       * @param {boolean} value
       */
      constructor(value) {
          /** @readonly */
          this._value = value;

          Object.freeze(this);
      }

      /**
       * @returns {string}
       */
      toString() {
          switch (this) {
              case FeeAssessmentMethod.Inclusive:
                  return "INCLUSIVE";
              case FeeAssessmentMethod.Exclusive:
                  return "EXCLUSIVE";
              default:
                  return `UNKNOWN (${this._value.toString()})`;
          }
      }

      /**
       * @internal
       * @param {boolean} value
       * @returns {FeeAssessmentMethod}
       */
      static _fromValue(value) {
          switch (value) {
              case false:
                  return FeeAssessmentMethod.Inclusive;
              case true:
                  return FeeAssessmentMethod.Exclusive;
          }
      }

      /**
       * @returns {boolean}
       */
      valueOf() {
          return this._value;
      }
  }

  FeeAssessmentMethod.Inclusive = new FeeAssessmentMethod(false);
  FeeAssessmentMethod.Exclusive = new FeeAssessmentMethod(true);

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ICustomFee} HieroProto.proto.ICustomFee
   * @typedef {import("@hashgraph/proto").proto.IFractionalFee} HieroProto.proto.IFractionalFee
   * @typedef {import("@hashgraph/proto").proto.IFraction} HieroProto.proto.IFraction
   */

  class CustomFractionalFee extends CustomFee {
      /**
       * @param {object} props
       * @param {AccountId | string} [props.feeCollectorAccountId]
       * @param {boolean} [props.allCollectorsAreExempt]
       * @param {Long | number} [props.numerator]
       * @param {Long | number} [props.denominator]
       * @param {Long | number} [props.min]
       * @param {Long | number} [props.max]
       * @param {FeeAssessmentMethod} [props.assessmentMethod]
       */
      constructor(props = {}) {
          super(props);

          /**
           * @type {?Long}
           */
          this._numerator = null;

          if (props.numerator != null) {
              this.setNumerator(props.numerator);
          }

          /**
           * @type {?Long}
           */
          this._denominator = null;

          if (props.denominator != null) {
              this.setDenominator(props.denominator);
          }

          /**
           * @type {?Long}
           */
          this._min = null;

          if (props.min != null) {
              this.setMin(props.min);
          }

          /**
           * @type {?Long}
           */
          this._max;

          if (props.max != null) {
              this.setMax(props.max);
          }

          /**
           * @type {?FeeAssessmentMethod}
           */
          this._assessmentMethod;

          if (props.assessmentMethod != null) {
              this.setAssessmentMethod(props.assessmentMethod);
          }
      }

      /**
       * @returns {?Long}
       */
      get numerator() {
          return this._numerator;
      }

      /**
       * @param {Long | number} numerator
       * @returns {CustomFractionalFee}
       */
      setNumerator(numerator) {
          this._numerator =
              typeof numerator === "number"
                  ? Long.fromNumber(numerator)
                  : numerator;
          return this;
      }

      /**
       * @returns {?Long}
       */
      get denominator() {
          return this._denominator;
      }

      /**
       * @param {Long | number} denominator
       * @returns {CustomFractionalFee}
       */
      setDenominator(denominator) {
          this._denominator =
              typeof denominator === "number"
                  ? Long.fromNumber(denominator)
                  : denominator;
          return this;
      }

      /**
       * @returns {?Long}
       */
      get min() {
          return this._min;
      }

      /**
       * @param {Long | number} min
       * @returns {CustomFractionalFee}
       */
      setMin(min) {
          this._min = typeof min === "number" ? Long.fromNumber(min) : min;
          return this;
      }

      /**
       * @returns {?Long}
       */
      get max() {
          return this._max;
      }

      /**
       * @param {Long | number} max
       * @returns {CustomFractionalFee}
       */
      setMax(max) {
          this._max = typeof max === "number" ? Long.fromNumber(max) : max;
          return this;
      }

      /**
       * @returns {?FeeAssessmentMethod}
       */
      get assessmentMethod() {
          return this._assessmentMethod;
      }

      /**
       * @param {FeeAssessmentMethod} assessmentMethod
       * @returns {CustomFractionalFee}
       */
      setAssessmentMethod(assessmentMethod) {
          this._assessmentMethod = assessmentMethod;
          return this;
      }

      /**
       * @internal
       * @override
       * @param {HieroProto.proto.ICustomFee} info
       * @returns {CustomFee}
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      static _fromProtobuf(info) {
          const fee = /** @type {HieroProto.proto.IFractionalFee} */ (
              info.fractionalFee
          );
          const fractional = /** @type {HieroProto.proto.IFraction} */ (
              fee.fractionalAmount
          );

          return new CustomFractionalFee({
              feeCollectorAccountId:
                  info.feeCollectorAccountId != null
                      ? AccountId._fromProtobuf(info.feeCollectorAccountId)
                      : undefined,
              allCollectorsAreExempt:
                  info.allCollectorsAreExempt != null
                      ? info.allCollectorsAreExempt
                      : undefined,
              numerator:
                  fractional.numerator != null ? fractional.numerator : undefined,
              denominator:
                  fractional.denominator != null
                      ? fractional.denominator
                      : undefined,
              min: fee.minimumAmount != null ? fee.minimumAmount : undefined,
              max: fee.maximumAmount != null ? fee.maximumAmount : undefined,
              assessmentMethod:
                  fee.netOfTransfers != null
                      ? new FeeAssessmentMethod(fee.netOfTransfers)
                      : undefined,
          });
      }

      /**
       * @internal
       * @abstract
       * @returns {HieroProto.proto.ICustomFee}
       */
      _toProtobuf() {
          return {
              feeCollectorAccountId:
                  this.feeCollectorAccountId != null
                      ? this.feeCollectorAccountId._toProtobuf()
                      : null,
              allCollectorsAreExempt: this.allCollectorsAreExempt,
              fractionalFee: {
                  fractionalAmount: {
                      numerator: this._numerator,
                      denominator: this._denominator,
                  },
                  minimumAmount: this._min,
                  maximumAmount: this._max,
                  netOfTransfers:
                      this._assessmentMethod != null
                          ? this._assessmentMethod.valueOf()
                          : false,
              },
          };
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.IFraction} HieroProto.proto.IFraction
   * @typedef {import("@hashgraph/proto").proto.IRoyaltyFee} HieroProto.proto.IRoyaltyFee
   * @typedef {import("@hashgraph/proto").proto.ICustomFee} HieroProto.proto.ICustomFee
   * @typedef {import("@hashgraph/proto").proto.IFixedFee} HieroProto.proto.IFixedFee
   */

  class CustomRoyalyFee extends CustomFee {
      /**
       * @param {object} props
       * @param {AccountId | string} [props.feeCollectorAccountId]
       * @param {boolean} [props.allCollectorsAreExempt]
       * @param {Long | number} [props.numerator]
       * @param {Long | number} [props.denominator]
       * @param {CustomFixedFee} [props.fallbackFee]
       */
      constructor(props = {}) {
          super(props);

          /**
           * @type {?CustomFixedFee}
           */
          this._fallbackFee = null;

          if (props.fallbackFee != null) {
              this.setFallbackFee(props.fallbackFee);
          }

          /**
           * @type {?Long}
           */
          this._numerator = null;

          if (props.numerator != null) {
              this.setNumerator(props.numerator);
          }

          /**
           * @type {?Long}
           */
          this._denominator = null;

          if (props.denominator != null) {
              this.setDenominator(props.denominator);
          }
      }

      /**
       * @returns {?CustomFixedFee}
       */
      get fallbackFee() {
          return this._fallbackFee;
      }

      /**
       * @param {CustomFixedFee} fallbackFee
       * @returns {CustomRoyalyFee}
       */
      setFallbackFee(fallbackFee) {
          this._fallbackFee = fallbackFee;
          return this;
      }

      /**
       * @returns {?Long}
       */
      get numerator() {
          return this._numerator;
      }

      /**
       * @param {Long | number} numerator
       * @returns {CustomRoyalyFee}
       */
      setNumerator(numerator) {
          this._numerator =
              typeof numerator === "number"
                  ? Long.fromNumber(numerator)
                  : numerator;
          return this;
      }

      /**
       * @returns {?Long}
       */
      get denominator() {
          return this._denominator;
      }

      /**
       * @param {Long | number} denominator
       * @returns {CustomRoyalyFee}
       */
      setDenominator(denominator) {
          this._denominator =
              typeof denominator === "number"
                  ? Long.fromNumber(denominator)
                  : denominator;
          return this;
      }

      /**
       * @internal
       * @override
       * @param {HieroProto.proto.ICustomFee} info
       * @returns {CustomFee}
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      static _fromProtobuf(info) {
          const fee = /** @type {HieroProto.proto.IRoyaltyFee} */ (
              info.royaltyFee
          );
          const fraction = /** @type {HieroProto.proto.IFraction} */ (
              fee.exchangeValueFraction
          );

          return new CustomRoyalyFee({
              feeCollectorAccountId:
                  info.feeCollectorAccountId != null
                      ? AccountId._fromProtobuf(info.feeCollectorAccountId)
                      : undefined,
              allCollectorsAreExempt:
                  info.allCollectorsAreExempt != null
                      ? info.allCollectorsAreExempt
                      : undefined,
              fallbackFee:
                  fee.fallbackFee != null
                      ? /** @type {CustomFixedFee} */ (
                            CustomFixedFee._fromProtobuf({
                                fixedFee: fee.fallbackFee,
                            })
                        )
                      : undefined,
              numerator:
                  fraction.numerator != null ? fraction.numerator : undefined,
              denominator:
                  fraction.denominator != null ? fraction.denominator : undefined,
          });
      }

      /**
       * @internal
       * @abstract
       * @returns {HieroProto.proto.ICustomFee}
       */
      _toProtobuf() {
          return {
              feeCollectorAccountId:
                  this.feeCollectorAccountId != null
                      ? this.feeCollectorAccountId._toProtobuf()
                      : null,
              allCollectorsAreExempt: this.allCollectorsAreExempt,
              royaltyFee: {
                  exchangeValueFraction: {
                      numerator: this._numerator,
                      denominator: this._denominator,
                  },
                  fallbackFee:
                      this._fallbackFee != null
                          ? this._fallbackFee._toProtobuf().fixedFee
                          : null,
              },
          };
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace {proto}
   * @typedef {import("@hashgraph/proto").proto.IContractID} HieroProto.proto.IContractID
   * @typedef {import("@hashgraph/proto").proto.IKey} HieroProto.proto.IKey
   */

  /**
   * @typedef {import("long")} Long
   * @typedef {import("../client/Client.js").default<*, *>} Client
   */

  /**
   * epresents a delegatable smart contract ID on the Hedera network.
   * This class extends ContractId and provides additional functionality for delegatable contracts.
   */
  class DelegateContractId extends ContractId {
      /**
       * @param {number | Long | import("../EntityIdHelper").IEntityId} props
       * @param {(number | Long)=} realm
       * @param {(number | Long)=} num
       * @param {Uint8Array=} evmAddress
       */
      constructor(props, realm, num, evmAddress) {
          super(props, realm, num, evmAddress);
      }

      /**
       * @param {string} text
       * @returns {DelegateContractId}
       */
      static fromString(text) {
          return new DelegateContractId(ContractId.fromString(text));
      }

      /**
       * @internal
       * @param {HieroProto.proto.IContractID} id
       * @returns {DelegateContractId}
       */
      static _fromProtobuf(id) {
          return new DelegateContractId(ContractId._fromProtobuf(id));
      }

      /**
       * @param {Uint8Array} bytes
       * @returns {DelegateContractId}
       */
      static fromBytes(bytes) {
          return new DelegateContractId(ContractId.fromBytes(bytes));
      }

      /**
       * @param {string} address
       * @deprecated - Use `fromEvmAddress` instead
       * @returns {DelegateContractId}
       */
      static fromSolidityAddress(address) {
          // eslint-disable-next-line deprecation/deprecation
          return new DelegateContractId(ContractId.fromSolidityAddress(address));
      }

      /**
       * @returns {DelegateContractId}
       */
      clone() {
          const id = new DelegateContractId(this);
          id._checksum = this._checksum;
          return id;
      }

      /**
       * @returns {HieroProto.proto.IKey}
       */
      _toProtobufKey() {
          return {
              delegatableContractId: this._toProtobuf(),
          };
      }

      /**
       * @param {HieroProto.proto.IContractID} key
       * @returns {DelegateContractId}
       */
      static __fromProtobufKey(key) {
          return DelegateContractId._fromProtobuf(key);
      }
  }

  CACHE.setDelegateContractId((key) => DelegateContractId.__fromProtobufKey(key));

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
   * @typedef {import("@hashgraph/proto").proto.IEthereumTransactionBody} HieroProto.proto.IEthereumTransactionBody
   * @typedef {import("@hashgraph/proto").proto.IAccountID} HieroProto.proto.IAccountID
   */

  /**
   * @typedef {import("bignumber.js").default} BigNumber
   * @typedef {import("./account/AccountId.js").default} AccountId
   * @typedef {import("./channel/Channel.js").default} Channel
   * @typedef {import("./client/Client.js").default<*, *>} Client
   * @typedef {import("./Timestamp.js").default} Timestamp
   * @typedef {import("./transaction/TransactionId.js").default} TransactionId
   * @typedef {import("long")} Long
   */

  /**
   * Create a new Hedera transaction wrapped ethereum transaction.
   */
  class EthereumTransaction extends Transaction {
      /**
       * @param {object} [props]
       * @param {Uint8Array} [props.ethereumData]
       * @param {FileId} [props.callData]
       * @param {FileId} [props.callDataFileId]
       * @param {number | string | Long | BigNumber | Hbar} [props.maxGasAllowance]
       */
      constructor(props = {}) {
          super();

          /**
           * @private
           * @type {?Uint8Array}
           */
          this._ethereumData = null;

          /**
           * @private
           * @type {?FileId}
           */
          this._callDataFileId = null;

          /**
           * @private
           * @type {?Hbar}
           */
          this._maxGasAllowance = null;

          if (props.ethereumData != null) {
              this.setEthereumData(props.ethereumData);
          }

          if (props.callData != null) {
              this.setCallDataFileId(props.callData);
          }

          if (props.callDataFileId != null) {
              this.setCallDataFileId(props.callDataFileId);
          }

          if (props.maxGasAllowance != null) {
              this.setMaxGasAllowanceHbar(props.maxGasAllowance);
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransaction[]} transactions
       * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {HieroProto.proto.ITransactionBody[]} bodies
       * @returns {EthereumTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];
          const transaction =
              /** @type {HieroProto.proto.IEthereumTransactionBody} */ (
                  body.ethereumTransaction
              );

          return Transaction._fromProtobufTransactions(
              new EthereumTransaction({
                  ethereumData:
                      transaction.ethereumData != null
                          ? transaction.ethereumData
                          : undefined,
                  callData:
                      transaction.callData != null
                          ? FileId._fromProtobuf(transaction.callData)
                          : undefined,
                  maxGasAllowance:
                      transaction.maxGasAllowance != null
                          ? Hbar.fromTinybars(transaction.maxGasAllowance)
                          : undefined,
              }),
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * @returns {?(Uint8Array | FileId)}
       */
      get ethereumData() {
          return this._ethereumData;
      }

      /**
       * The raw Ethereum transaction (RLP encoded type 0, 1, and 2). Complete
       * unless the callData field is set.
       *
       * @param {Uint8Array} ethereumData
       * @returns {this}
       */
      setEthereumData(ethereumData) {
          this._requireNotFrozen();
          this._ethereumData = ethereumData;
          return this;
      }

      /**
       * @deprecated - Use `callDataFileId` instead
       * @returns {?FileId}
       */
      get callData() {
          return this.callDataFileId;
      }

      /**
       * @deprecated - Use `setCallDataFileId()` instead
       *
       * For large transactions (for example contract create) this is the callData
       * of the callData. The data in the callData will be re-written with
       * the callData element as a zero length string with the original contents in
       * the referenced file at time of execution. The callData will need to be
       * "rehydrated" with the callData for signature validation to pass.
       * @param {FileId} callDataFileId
       * @returns {this}
       */
      setCallData(callDataFileId) {
          return this.setCallDataFileId(callDataFileId);
      }

      /**
       * @returns {?FileId}
       */
      get callDataFileId() {
          return this._callDataFileId;
      }

      /**
       * For large transactions (for example contract create) this is the callData
       * of the callData. The data in the callData will be re-written with
       * the callData element as a zero length string with the original contents in
       * the referenced file at time of execution. The callData will need to be
       * "rehydrated" with the callData for signature validation to pass.
       *
       * @param {FileId} callDataFileId
       * @returns {this}
       */
      setCallDataFileId(callDataFileId) {
          this._requireNotFrozen();
          this._callDataFileId = callDataFileId;
          return this;
      }

      /**
       * @returns {?Hbar}
       */
      get maxGasAllowance() {
          return this._maxGasAllowance;
      }

      /**
       * @deprecated -- use setMaxGasAllowanceHbar instead
       * @param {number | string | Long | BigNumber | Hbar} maxGasAllowance
       * @returns {this}
       */
      setMaxGasAllowance(maxGasAllowance) {
          return this.setMaxGasAllowanceHbar(maxGasAllowance);
      }

      /**
       * The maximum amount, in hbars, that the payer of the hedera transaction
       * is willing to pay to complete the transaction.
       *
       * Ordinarily the account with the ECDSA alias corresponding to the public
       * key that is extracted from the ethereum_data signature is responsible for
       * fees that result from the execution of the transaction. If that amount of
       * authorized fees is not sufficient then the payer of the transaction can be
       * charged, up to but not exceeding this amount. If the ethereum_data
       * transaction authorized an amount that was insufficient then the payer will
       * only be charged the amount needed to make up the difference. If the gas
       * price in the transaction was set to zero then the payer will be assessed
       * the entire fee.
       *
       * @param {number | string | Long | BigNumber | Hbar} maxGasAllowance
       * @returns {this}
       */
      setMaxGasAllowanceHbar(maxGasAllowance) {
          this._requireNotFrozen();
          this._maxGasAllowance =
              maxGasAllowance instanceof Hbar
                  ? maxGasAllowance
                  : new Hbar(maxGasAllowance);
          return this;
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          if (
              this._ethereumData != null &&
              this._ethereumData instanceof FileId
          ) {
              this._ethereumData.validateChecksum(client);
          }
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.ITransaction} request
       * @returns {Promise<HieroProto.proto.ITransactionResponse>}
       */
      _execute(channel, request) {
          return channel.smartContract.callEthereum(request);
      }

      /**
       * @override
       * @protected
       * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "ethereumTransaction";
      }

      /**
       * @override
       * @protected
       * @returns {HieroProto.proto.IEthereumTransactionBody}
       */
      _makeTransactionData() {
          return {
              ethereumData: this._ethereumData,
              callData:
                  this._callDataFileId != null
                      ? this._callDataFileId._toProtobuf()
                      : null,
              maxGasAllowance:
                  this._maxGasAllowance != null
                      ? this._maxGasAllowance.toTinybars()
                      : null,
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("./Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `EthereumTransaction:${timestamp.toString()}`;
      }
  }

  TRANSACTION_REGISTRY.set(
      "ethereumTransaction",
      // eslint-disable-next-line @typescript-eslint/unbound-method
      EthereumTransaction._fromProtobuf,
  );

  /**
   * Represents the base class for Ethereum transaction data.
   * This class provides the foundation for different types of Ethereum transactions
   * including Legacy, EIP-1559, and EIP-2930 transactions.
   */
  class EthereumTransactionData {
      /**
       * @protected
       * @param {object} props
       * @param {Uint8Array} props.callData
       */
      constructor(props) {
          this.callData = props.callData;
      }

      /**
       * @param {Uint8Array} bytes
       * @returns {EthereumTransactionData}
       */
      static fromBytes(bytes) {
          if (bytes.length === 0) {
              throw new Error("empty bytes");
          }

          switch (bytes[0]) {
              case 1:
                  return CACHE.ethereumTransactionDataEip2930FromBytes(bytes);
              case 2:
                  return CACHE.ethereumTransactionDataEip1559FromBytes(bytes);
              default:
                  return CACHE.ethereumTransactionDataLegacyFromBytes(bytes);
          }
      }

      // eslint-disable-next-line jsdoc/require-returns-check
      /**
       * @returns {Uint8Array}
       */
      toBytes() {
          throw new Error("not implemented");
      }

      // eslint-disable-next-line jsdoc/require-returns-check
      /**
       * @returns {string}
       */
      toString() {
          throw new Error("not implemented");
      }

      // eslint-disable-next-line jsdoc/require-returns-check
      /**
       * @returns {{[key: string]: any}}
       */
      toJSON() {
          throw new Error("not implemented");
      }
  }

  /**
   * @typedef {object} EthereumTransactionDataLegacyJSON
   * @property {string} nonce
   * @property {string} gasPrice
   * @property {string} gasLimit
   * @property {string} to
   * @property {string} value
   * @property {string} callData
   * @property {string} v
   * @property {string} r
   * @property {string} s
   */

  class EthereumTransactionDataLegacy extends EthereumTransactionData {
      /**
       * @private
       * @param {object} props
       * @param {Uint8Array} props.nonce
       * @param {Uint8Array} props.gasPrice
       * @param {Uint8Array} props.gasLimit
       * @param {Uint8Array} props.to
       * @param {Uint8Array} props.value
       * @param {Uint8Array} props.callData
       * @param {Uint8Array} props.v
       * @param {Uint8Array} props.r
       * @param {Uint8Array} props.s
       */
      constructor(props) {
          super(props);

          this.nonce = props.nonce;
          this.gasPrice = props.gasPrice;
          this.gasLimit = props.gasLimit;
          this.to = props.to;
          this.value = props.value;
          this.v = props.v;
          this.r = props.r;
          this.s = props.s;
      }

      /**
       * @param {Uint8Array} bytes
       * @returns {EthereumTransactionData}
       */
      static fromBytes(bytes) {
          if (bytes.length === 0) {
              throw new Error("empty bytes");
          }

          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
          const decoded = /** @type {string[]} */ (decode(bytes));

          if (decoded.length != 9) {
              throw new Error("invalid ethereum transaction data");
          }

          return new EthereumTransactionDataLegacy({
              nonce: decode$8(/** @type {string} */ (decoded[0])),
              gasPrice: decode$8(/** @type {string} */ (decoded[1])),
              gasLimit: decode$8(/** @type {string} */ (decoded[2])),
              to: decode$8(/** @type {string} */ (decoded[3])),
              value: decode$8(/** @type {string} */ (decoded[4])),
              callData: decode$8(/** @type {string} */ (decoded[5])),
              v: decode$8(/** @type {string} */ (decoded[6])),
              r: decode$8(/** @type {string} */ (decoded[7])),
              s: decode$8(/** @type {string} */ (decoded[8])),
          });
      }

      /**
       * @returns {Uint8Array}
       */
      toBytes() {
          return decode$8(
              encode([
                  this.nonce,
                  this.gasPrice,
                  this.gasLimit,
                  this.to,
                  this.value,
                  this.callData,
                  this.v,
                  this.r,
                  this.s,
              ]),
          );
      }

      /**
       * @returns {string}
       */
      toString() {
          return JSON.stringify(this.toJSON(), null, 2);
      }

      /**
       * @returns {EthereumTransactionDataLegacyJSON}
       */
      toJSON() {
          return {
              nonce: encode$5(this.nonce),
              gasPrice: encode$5(this.gasPrice),
              gasLimit: encode$5(this.gasLimit),
              to: encode$5(this.to),
              value: encode$5(this.value),
              callData: encode$5(this.callData),
              v: encode$5(this.v),
              r: encode$5(this.r),
              s: encode$5(this.s),
          };
      }
  }

  CACHE.setEthereumTransactionDataLegacyFromBytes((bytes) =>
      EthereumTransactionDataLegacy.fromBytes(bytes),
  );

  /**
   * @typedef {object} EthereumTransactionDataEip1559JSON
   * @property {string} chainId
   * @property {string} nonce
   * @property {string} maxPriorityGas
   * @property {string} maxGas
   * @property {string} gasLimit
   * @property {string} to
   * @property {string} value
   * @property {string} callData
   * @property {string[]} accessList
   * @property {string} recId
   * @property {string} r
   * @property {string} s
   */

  class EthereumTransactionDataEip1559 extends EthereumTransactionData {
      /**
       * @private
       * @param {object} props
       * @param {Uint8Array} props.chainId
       * @param {Uint8Array} props.nonce
       * @param {Uint8Array} props.maxPriorityGas
       * @param {Uint8Array} props.maxGas
       * @param {Uint8Array} props.gasLimit
       * @param {Uint8Array} props.to
       * @param {Uint8Array} props.value
       * @param {Uint8Array} props.callData
       * @param {Uint8Array[]} props.accessList
       * @param {Uint8Array} props.recId
       * @param {Uint8Array} props.r
       * @param {Uint8Array} props.s
       */
      constructor(props) {
          super(props);

          this.chainId = props.chainId;
          this.nonce = props.nonce;
          this.maxPriorityGas = props.maxPriorityGas;
          this.maxGas = props.maxGas;
          this.gasLimit = props.gasLimit;
          this.to = props.to;
          this.value = props.value;
          this.accessList = props.accessList;
          this.recId = props.recId;
          this.r = props.r;
          this.s = props.s;
      }

      /**
       * @param {Uint8Array} bytes
       * @returns {EthereumTransactionData}
       */
      static fromBytes(bytes) {
          if (bytes.length === 0) {
              throw new Error("empty bytes");
          }

          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
          const decoded = /** @type {string[]} */ (decode(bytes.subarray(1)));

          if (!Array.isArray(decoded)) {
              throw new Error("ethereum data is not a list");
          }

          if (decoded.length != 12) {
              throw new Error("invalid ethereum transaction data");
          }

          // TODO
          return new EthereumTransactionDataEip1559({
              chainId: decode$8(/** @type {string} */ (decoded[0])),
              nonce: decode$8(/** @type {string} */ (decoded[1])),
              maxPriorityGas: decode$8(/** @type {string} */ (decoded[2])),
              maxGas: decode$8(/** @type {string} */ (decoded[3])),
              gasLimit: decode$8(/** @type {string} */ (decoded[4])),
              to: decode$8(/** @type {string} */ (decoded[5])),
              value: decode$8(/** @type {string} */ (decoded[6])),
              callData: decode$8(/** @type {string} */ (decoded[7])),
              // @ts-ignore
              accessList: /** @type {string[]} */ (decoded[8]).map((v) =>
                  decode$8(v),
              ),
              recId: decode$8(/** @type {string} */ (decoded[9])),
              r: decode$8(/** @type {string} */ (decoded[10])),
              s: decode$8(/** @type {string} */ (decoded[11])),
          });
      }

      /**
       * @returns {Uint8Array}
       */
      toBytes() {
          const encoded = encode([
              this.chainId,
              this.nonce,
              this.maxPriorityGas,
              this.maxGas,
              this.gasLimit,
              this.to,
              this.value,
              this.callData,
              this.accessList,
              this.recId,
              this.r,
              this.s,
          ]);
          return decode$8("02" + encoded.substring(2));
      }

      /**
       * @returns {string}
       */
      toString() {
          return JSON.stringify(this.toJSON(), null, 2);
      }

      /**
       * @returns {EthereumTransactionDataEip1559JSON}
       */
      toJSON() {
          return {
              chainId: encode$5(this.chainId),
              nonce: encode$5(this.nonce),
              maxPriorityGas: encode$5(this.maxPriorityGas),
              maxGas: encode$5(this.maxGas),
              gasLimit: encode$5(this.gasLimit),
              to: encode$5(this.to),
              value: encode$5(this.value),
              callData: encode$5(this.callData),
              accessList: this.accessList.map((v) => encode$5(v)),
              recId: encode$5(this.recId),
              r: encode$5(this.r),
              s: encode$5(this.s),
          };
      }
  }

  CACHE.setEthereumTransactionDataEip1559FromBytes((bytes) =>
      EthereumTransactionDataEip1559.fromBytes(bytes),
  );

  /**
   * @typedef {object} EthereumTransactionDataEip2930JSON
   * @property {string} chainId
   * @property {string} nonce
   * @property {string} gasPrice
   * @property {string} gasLimit
   * @property {string} to
   * @property {string} value
   * @property {string} callData
   * @property {string[]} accessList
   * @property {string} recId
   * @property {string} r
   * @property {string} s
   */

  class EthereumTransactionDataEip2930 extends EthereumTransactionData {
      /**
       * @private
       * @param {object} props
       * @param {Uint8Array} props.chainId
       * @param {Uint8Array} props.nonce
       * @param {Uint8Array} props.gasPrice
       * @param {Uint8Array} props.gasLimit
       * @param {Uint8Array} props.to
       * @param {Uint8Array} props.value
       * @param {Uint8Array} props.callData
       * @param {Uint8Array[]} props.accessList
       * @param {Uint8Array} props.recId
       * @param {Uint8Array} props.r
       * @param {Uint8Array} props.s
       */
      constructor(props) {
          super(props);

          this.chainId = props.chainId;
          this.nonce = props.nonce;
          this.gasPrice = props.gasPrice;
          this.gasLimit = props.gasLimit;
          this.to = props.to;
          this.value = props.value;
          this.accessList = props.accessList;
          this.recId = props.recId;
          this.r = props.r;
          this.s = props.s;
      }

      /**
       * @param {Uint8Array} bytes
       * @returns {EthereumTransactionData}
       */
      static fromBytes(bytes) {
          if (bytes.length === 0) {
              throw new Error("empty bytes");
          }

          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
          const decoded = /** @type {string[]} */ (decode(bytes.subarray(1)));

          if (!Array.isArray(decoded)) {
              throw new Error("ethereum data is not a list");
          }

          if (decoded.length !== 11) {
              throw new Error("invalid ethereum transaction data");
          }

          // TODO
          return new EthereumTransactionDataEip2930({
              chainId: decode$8(/** @type {string} */ (decoded[0])),
              nonce: decode$8(/** @type {string} */ (decoded[1])),
              gasPrice: decode$8(/** @type {string} */ (decoded[2])),
              gasLimit: decode$8(/** @type {string} */ (decoded[3])),
              to: decode$8(/** @type {string} */ (decoded[4])),
              value: decode$8(/** @type {string} */ (decoded[5])),
              callData: decode$8(/** @type {string} */ (decoded[6])),
              // @ts-ignore
              accessList: /** @type {string[]} */ (decoded[7]).map((v) =>
                  decode$8(v),
              ),
              recId: decode$8(/** @type {string} */ (decoded[8])),
              r: decode$8(/** @type {string} */ (decoded[9])),
              s: decode$8(/** @type {string} */ (decoded[10])),
          });
      }

      /**
       * @returns {Uint8Array}
       */
      toBytes() {
          const encoded = encode([
              this.chainId,
              this.nonce,
              this.gasPrice,
              this.gasLimit,
              this.to,
              this.value,
              this.callData,
              this.accessList,
              this.recId,
              this.r,
              this.s,
          ]);
          return decode$8("01" + encoded.substring(2));
      }

      /**
       * @returns {string}
       */
      toString() {
          return JSON.stringify(this.toJSON(), null, 2);
      }

      /**
       * @returns {EthereumTransactionDataEip2930JSON}
       */
      toJSON() {
          return {
              chainId: encode$5(this.chainId),
              nonce: encode$5(this.nonce),
              gasPrice: encode$5(this.gasPrice),
              gasLimit: encode$5(this.gasLimit),
              to: encode$5(this.to),
              value: encode$5(this.value),
              callData: encode$5(this.callData),
              accessList: this.accessList.map((v) => encode$5(v)),
              recId: encode$5(this.recId),
              r: encode$5(this.r),
              s: encode$5(this.s),
          };
      }
  }

  CACHE.setEthereumTransactionDataEip2930FromBytes((bytes) =>
      EthereumTransactionDataEip2930.fromBytes(bytes),
  );

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
   * @typedef {import("@hashgraph/proto").proto.IEthereumTransactionBody} HieroProto.proto.IEthereumTransactionBody
   * @typedef {import("@hashgraph/proto").proto.IAccountID} HieroProto.proto.IAccountID
   */

  /**
   * @typedef {import("bignumber.js").default} BigNumber
   * @typedef {import("./account/AccountId.js").default} AccountId
   * @typedef {import("./file/FileId.js").default} FileId
   * @typedef {import("./channel/Channel.js").default} Channel
   * @typedef {import("./channel/MirrorChannel.js").default} MirrorChannel
   * @typedef {import("./client/Client.js").default<*, *>} Client
   * @typedef {import("./Timestamp.js").default} Timestamp
   * @typedef {import("./transaction/TransactionId.js").default} TransactionId
   * @typedef {import("./transaction/TransactionResponse.js").default} TransactionResponse
   * @typedef {import("long")} Long
   */

  /**
   * Create a new Hedera transaction wrapped ethereum transaction.
   * @deprecated - use EthereumTransaction instead. With the introduction of jumbo transactions, it should always be less cost and more efficient to use EthereumTransaction instead.
   */
  class EthereumFlow {
      /**
       * @param {object} [props]
       * @param {Uint8Array} [props.ethereumData]
       * @param {FileId} [props.callData]
       * @param {number | string | Long | BigNumber | Hbar} [props.maxGasAllowance]
       */
      constructor(props = {}) {
          /**
           * @private
           * @type {?EthereumTransactionData}
           */
          this._ethereumData = null;

          /**
           * @private
           * @type {?FileId}
           */
          this._callDataFileId = null;

          /**
           * @private
           * @type {?Hbar}
           */
          this._maxGasAllowance = null;

          if (props.ethereumData != null) {
              this.setEthereumData(props.ethereumData);
          }

          if (props.maxGasAllowance != null) {
              this.setMaxGasAllowanceHbar(props.maxGasAllowance);
          }

          this._maxChunks = null;
      }

      /**
       * @returns {number | null}
       */
      get maxChunks() {
          return this._maxChunks;
      }

      /**
       * @param {number} maxChunks
       * @returns {this}
       */
      setMaxChunks(maxChunks) {
          this._maxChunks = maxChunks;
          return this;
      }

      /**
       * @returns {?EthereumTransactionData}
       */
      get ethereumData() {
          return this._ethereumData;
      }

      /**
       * The raw Ethereum transaction (RLP encoded type 0, 1, and 2). Complete
       * unless the callData field is set.
       *
       * @param {EthereumTransactionData | Uint8Array} ethereumData
       * @returns {this}
       */
      setEthereumData(ethereumData) {
          this._ethereumData =
              ethereumData instanceof Uint8Array
                  ? EthereumTransactionData.fromBytes(ethereumData)
                  : ethereumData;
          return this;
      }

      /**
       * @returns {?Hbar}
       */
      get maxGasAllowance() {
          return this._maxGasAllowance;
      }

      /**
       * @deprecated - use masGasAllowanceHbar instead.
       * @param {number | string | Long | BigNumber | Hbar} maxGasAllowance
       * @returns {this}
       */
      setMaxGasAllowance(maxGasAllowance) {
          return this.setMaxGasAllowanceHbar(maxGasAllowance);
      }

      /**
       * The maximum amount, in hbars, that the payer of the hedera transaction
       * is willing to pay to complete the transaction.
       *
       * Ordinarily the account with the ECDSA alias corresponding to the public
       * key that is extracted from the ethereum_data signature is responsible for
       * fees that result from the execution of the transaction. If that amount of
       * authorized fees is not sufficient then the payer of the transaction can be
       * charged, up to but not exceeding this amount. If the ethereum_data
       * transaction authorized an amount that was insufficient then the payer will
       * only be charged the amount needed to make up the difference. If the gas
       * price in the transaction was set to zero then the payer will be assessed
       * the entire fee.
       *
       * @param {number | string | Long | BigNumber | Hbar} maxGasAllowance
       * @returns {this}
       */
      setMaxGasAllowanceHbar(maxGasAllowance) {
          this._maxGasAllowance =
              maxGasAllowance instanceof Hbar
                  ? maxGasAllowance
                  : new Hbar(maxGasAllowance);
          return this;
      }

      /**
       * @template {Channel} ChannelT
       * @template {MirrorChannel} MirrorChannelT
       * @param {import("./client/Client.js").default<ChannelT, MirrorChannelT>} client
       * @returns {Promise<TransactionResponse>}
       */
      async execute(client) {
          if (this._ethereumData == null) {
              throw new Error(
                  "cannot submit ethereum transaction with no ethereum data",
              );
          }

          const ethereumTransaction = new EthereumTransaction();
          const ethereumTransactionDataBytes = this._ethereumData.toBytes();

          if (this._maxGasAllowance != null) {
              ethereumTransaction.setMaxGasAllowanceHbar(this._maxGasAllowance);
          }

          if (this._callDataFileId != null) {
              if (this._ethereumData.callData.length === 0) {
                  throw new Error(
                      "call data file ID provided, but ethereum data already contains call data",
                  );
              }

              ethereumTransaction
                  .setEthereumData(ethereumTransactionDataBytes)
                  .setCallDataFileId(this._callDataFileId);
              // in the consensus node config file, the maximum size of the call data file is 128000 bytes
              // so we need to check if the call data is less than or equal to 128000 bytes
          } else if (ethereumTransactionDataBytes.length <= 128000) {
              ethereumTransaction.setEthereumData(ethereumTransactionDataBytes);
          } else {
              const fileId = await createFile(
                  this._ethereumData.callData,
                  client,
                  this._maxChunks,
              );

              this._ethereumData.callData = new Uint8Array();

              ethereumTransaction
                  .setEthereumData(this._ethereumData.toBytes())
                  .setCallDataFileId(fileId);
          }

          return ethereumTransaction.execute(client);
      }
  }

  /**
   * @template {Channel} ChannelT
   * @template {MirrorChannel} MirrorChannelT
   * @param {Uint8Array} callData
   * @param {import("./client/Client.js").default<ChannelT, MirrorChannelT>} client
   * @param {?number} maxChunks
   * @returns {Promise<FileId>}
   */
  async function createFile(callData, client, maxChunks) {
      const hexedCallData = encode$5(callData);

      const fileId = /** @type {FileId} */ (
          (
              await (
                  await new FileCreateTransaction()
                      .setContents(hexedCallData.substring(0, 4096))
                      .setKeys(
                          client.operatorPublicKey
                              ? [client.operatorPublicKey]
                              : [],
                      )
                      .execute(client)
              ).getReceipt(client)
          ).fileId
      );

      if (callData.length > 4096) {
          let fileAppendTransaction = new FileAppendTransaction()
              .setFileId(fileId)
              .setContents(hexedCallData.substring(4096, hexedCallData.length));
          if (maxChunks != null) {
              fileAppendTransaction.setMaxChunks(maxChunks);
          }

          await (await fileAppendTransaction.execute(client)).getReceipt(client);
      }

      return fileId;
  }

  // SPDX-License-Identifier: Apache-2.0


  const { proto: proto$3 } = HieroProto;

  /**
   *  Represents a pair of exchange rates for HBAR to USD cents conversion.
   * Contains both the current exchange rate and the next exchange rate that will take effect.
   */
  class ExchangeRates {
      /**
       * @private
       * @param {object} props
       * @param {ExchangeRate} props.currentRate
       * @param {ExchangeRate} props.nextRate
       */
      constructor(props) {
          /**
           * @readonly
           */
          this.currentRate = props.currentRate;

          /**
           * @readonly
           */
          this.nextRate = props.nextRate;

          Object.freeze(this);
      }

      /**
       * @internal
       * @param {HieroProto.proto.IExchangeRateSet} rateSet
       * @returns {ExchangeRates}
       */
      static _fromProtobuf(rateSet) {
          return new ExchangeRates({
              currentRate: ExchangeRate._fromProtobuf(
                  /** @type {HieroProto.proto.IExchangeRate} */ (
                      rateSet.currentRate
                  ),
              ),
              nextRate: ExchangeRate._fromProtobuf(
                  /** @type {HieroProto.proto.IExchangeRate} */ (
                      rateSet.nextRate
                  ),
              ),
          });
      }

      /**
       * @internal
       * @returns {HieroProto.proto.IExchangeRateSet}
       */
      _toProtobuf() {
          return {
              currentRate: this.currentRate._toProtobuf(),
              nextRate: this.nextRate._toProtobuf(),
          };
      }

      /**
       * @param {Uint8Array} bytes
       * @returns {ExchangeRates}
       */
      static fromBytes(bytes) {
          return ExchangeRates._fromProtobuf(proto$3.ExchangeRateSet.decode(bytes));
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * A set of values the nodes use in determining transaction and query fees, and
   * constants involved in fee calculations.
   */
  class FeeComponents {
      /**
       * @param {object} [props]
       * @param {Long} [props.min]
       * @param {Long} [props.max]
       * @param {Long} [props.constant]
       * @param {Long} [props.transactionBandwidthByte]
       * @param {Long} [props.transactionVerification]
       * @param {Long} [props.transactionRamByteHour]
       * @param {Long} [props.transactionStorageByteHour]
       * @param {Long} [props.contractTransactionGas]
       * @param {Long} [props.transferVolumeHbar]
       * @param {Long} [props.responseMemoryByte]
       * @param {Long} [props.responseDiskByte]
       */
      constructor(props = {}) {
          /*
           * A minimum, the calculated fee must be greater than this value
           *
           * @type {Long}
           */
          this.min = props.min;

          /*
           * A maximum, the calculated fee must be less than this value
           *
           * @type {Long}
           */
          this.max = props.max;

          /*
           * A constant contribution to the fee
           *
           * @type {Long}
           */
          this.constant = props.constant;

          /*
           * The price of bandwidth consumed by a transaction, measured in bytes
           *
           * @type {Long}
           */
          this.transactionBandwidthByte = props.transactionBandwidthByte;

          /*
           * The price per signature verification for a transaction
           *
           * @type {Long}
           */
          this.transactionVerification = props.transactionVerification;

          /*
           * The price of RAM consumed by a transaction, measured in byte-hours
           *
           * @type {Long}
           */
          this.transactionRamByteHour = props.transactionRamByteHour;

          /*
           * The price of storage consumed by a transaction, measured in byte-hours
           *
           * @type {Long}
           */
          this.transactionStorageByteHour = props.transactionStorageByteHour;

          /*
           * The price of computation for a smart contract transaction, measured in gas
           *
           * @type {Long}
           */
          this.contractTransactionGas = props.contractTransactionGas;

          /*
           * The price per hbar transferred for a transfer
           *
           * @type {Long}
           */
          this.transferVolumeHbar = props.transferVolumeHbar;

          /*
           * The price of bandwidth for data retrieved from memory for a response, measured in bytes
           *
           * @type {Long}
           */
          this.responseMemoryByte = props.responseMemoryByte;

          /*
           * The price of bandwidth for data retrieved from disk for a response, measured in bytes
           *
           * @type {Long}
           */
          this.responseDiskByte = props.responseDiskByte;
      }

      /**
       * @param {Uint8Array} bytes
       * @returns {FeeComponents}
       */
      static fromBytes(bytes) {
          return FeeComponents._fromProtobuf(
              libExports.proto.FeeComponents.decode(bytes),
          );
      }

      /**
       * @internal
       * @param {HieroProto.proto.IFeeComponents} feeComponents
       * @returns {FeeComponents}
       */
      static _fromProtobuf(feeComponents) {
          return new FeeComponents({
              min: feeComponents.min != null ? feeComponents.min : undefined,
              max: feeComponents.max != null ? feeComponents.max : undefined,
              constant:
                  feeComponents.constant != null
                      ? feeComponents.constant
                      : undefined,
              transactionBandwidthByte:
                  feeComponents.bpt != null ? feeComponents.bpt : undefined,
              transactionVerification:
                  feeComponents.vpt != null ? feeComponents.vpt : undefined,
              transactionRamByteHour:
                  feeComponents.rbh != null ? feeComponents.rbh : undefined,
              transactionStorageByteHour:
                  feeComponents.sbh != null ? feeComponents.sbh : undefined,
              contractTransactionGas:
                  feeComponents.gas != null ? feeComponents.gas : undefined,
              transferVolumeHbar:
                  feeComponents.tv != null ? feeComponents.tv : undefined,
              responseMemoryByte:
                  feeComponents.bpr != null ? feeComponents.bpr : undefined,
              responseDiskByte:
                  feeComponents.sbpr != null ? feeComponents.sbpr : undefined,
          });
      }

      /**
       * @internal
       * @returns {HieroProto.proto.IFeeComponents}
       */
      _toProtobuf() {
          return {
              min: this.min != null ? this.min : undefined,
              max: this.max != null ? this.max : undefined,
              constant: this.constant != null ? this.constant : undefined,
              bpt:
                  this.transactionBandwidthByte != null
                      ? this.transactionBandwidthByte
                      : undefined,
              vpt:
                  this.transactionVerification != null
                      ? this.transactionVerification
                      : undefined,
              rbh:
                  this.transactionRamByteHour != null
                      ? this.transactionRamByteHour
                      : undefined,
              sbh:
                  this.transactionStorageByteHour != null
                      ? this.transactionStorageByteHour
                      : undefined,
              gas:
                  this.contractTransactionGas != null
                      ? this.contractTransactionGas
                      : undefined,
              tv:
                  this.transferVolumeHbar != null
                      ? this.transferVolumeHbar
                      : undefined,
              bpr:
                  this.responseMemoryByte != null
                      ? this.responseMemoryByte
                      : undefined,
              sbpr:
                  this.responseDiskByte != null
                      ? this.responseDiskByte
                      : undefined,
          };
      }

      /**
       * @returns {Uint8Array}
       */
      toBytes() {
          return libExports.proto.FeeComponents.encode(
              this._toProtobuf(),
          ).finish();
      }
  }

  // SPDX-License-Identifier: Apache-2.0

  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.SubType} HieroProto.proto.SubType
   */

  class FeeDataType {
      /**
       * @hideconstructor
       * @internal
       * @param {number} code
       */
      constructor(code) {
          /** @readonly */
          this._code = code;

          Object.freeze(this);
      }

      /**
       * @returns {string}
       */
      toString() {
          switch (this) {
              case FeeDataType.Default:
                  return "DEFAULT";
              case FeeDataType.TokenFungibleCommon:
                  return "TOKEN_FUNGIBLE_COMMON";
              case FeeDataType.TokenNonFungibleUnique:
                  return "TOKEN_NON_FUNGIBLE_UNIQUE";
              case FeeDataType.TokenFungibleCommonWithCustomFees:
                  return "TOKEN_FUNGIBLE_COMMON_WITH_CUSTOM_FEES";
              case FeeDataType.TokenNonFungibleUniqueWithCustomFees:
                  return "TOKEN_NON_FUNGIBLE_UNIQUE_WITH_CUSTOM_FEES";
              case FeeDataType.ScheduleCreateContractCall:
                  return "SCHEDULE_CREATE_CONTRACT_CALL";
              case FeeDataType.TopicCreateWithCustomFees:
                  return "TOPIC_CREATE_WITH_CUSTOM_FEES";
              case FeeDataType.SubmitMessageWithCustomFees:
                  return "SUBMIT_MESSAGE_WITH_CUSTOM_FEES";
              default:
                  return `UNKNOWN (${this._code})`;
          }
      }

      /**
       * @internal
       * @param {number} code
       * @returns {FeeDataType}
       */
      static _fromCode(code) {
          switch (code) {
              case 0:
                  return FeeDataType.Default;
              case 1:
                  return FeeDataType.TokenFungibleCommon;
              case 2:
                  return FeeDataType.TokenNonFungibleUnique;
              case 3:
                  return FeeDataType.TokenFungibleCommonWithCustomFees;
              case 4:
                  return FeeDataType.TokenNonFungibleUniqueWithCustomFees;
              case 5:
                  return FeeDataType.ScheduleCreateContractCall;
              case 6:
                  return FeeDataType.TopicCreateWithCustomFees;
              case 7:
                  return FeeDataType.SubmitMessageWithCustomFees;
          }

          throw new Error(
              `(BUG) SubType.fromCode() does not handle code: ${code}`,
          );
      }

      /**
       * @returns {HieroProto.proto.SubType}
       */
      valueOf() {
          return this._code;
      }
  }

  /**
   * The resource prices have no special scope
   */
  FeeDataType.Default = new FeeDataType(0);

  /**
   * The resource prices are scoped to an operation on a fungible common token
   */
  FeeDataType.TokenFungibleCommon = new FeeDataType(1);

  /**
   * The resource prices are scoped to an operation on a non-fungible unique token
   */
  FeeDataType.TokenNonFungibleUnique = new FeeDataType(2);

  /**
   * The resource prices are scoped to an operation on a fungible common token with a custom fee schedule
   */
  FeeDataType.TokenFungibleCommonWithCustomFees = new FeeDataType(3);

  /**
   * The resource prices are scoped to an operation on a non-fungible unique token with a custom fee schedule
   */
  FeeDataType.TokenNonFungibleUniqueWithCustomFees = new FeeDataType(4);

  /**
   * The resource prices are scoped to a ScheduleCreate containing a ContractCall.
   */
  FeeDataType.ScheduleCreateContractCall = new FeeDataType(5);

  /**
   * The resource cost for the transaction type includes a TopicCreate
   * with custom fees.
   */
  FeeDataType.TopicCreateWithCustomFees = new FeeDataType(6);

  /**
   * The resource cost for the transaction type includes a ConsensusSubmitMessage
   * for a topic with custom fees.
   */
  FeeDataType.SubmitMessageWithCustomFees = new FeeDataType(7);

  // SPDX-License-Identifier: Apache-2.0


  /**
   * A total fee, in component amounts charged for a transaction.
   *
   * Total fees are composed of three sets of components.
   * - Node data, components that compensate the specific node that submitted
   *   the transaction.
   * - Network data, components that compensate the Hedera network for gossiping
   *   the transaction and determining the consensus timestamp.
   * - Service data, components that compensate the Hedera network for the ongoing
   *   maintenance and operation of the network, as well as ongoing development
   *   of network services.
   *
   * Fee components are recorded in thousandths of a tiny cent, and the network
   * exchange rate converts these to tinybar amounts, which are what the network
   * charges for transactions and what the network reports in the record stream.
   */
  class FeeData {
      /**
       * @param {object} [props]
       * @param {FeeComponents} [props.nodedata]
       * @param {FeeComponents} [props.networkdata]
       * @param {FeeComponents} [props.servicedata]
       * @param {FeeDataType} [props.feeDataType]
       */
      constructor(props = {}) {
          /*
           * Fee paid to the submitting node
           *
           * @type {FeeComponents}
           */
          this.nodedata = props.nodedata;

          /*
           * Fee paid to the network for processing a transaction into consensus
           *
           * @type {FeeComponents}
           */
          this.networkdata = props.networkdata;

          /*
           * Fee paid to the network for providing the service associated with the transaction; for instance, storing a file
           *
           * @type {FeeComponents}
           */
          this.servicedata = props.servicedata;

          /*
           * SubType distinguishing between different types of FeeData, correlating to the same HederaFunctionality
           *
           * @type {SubType}
           */
          this.feeDataType = props.feeDataType;
      }

      /**
       * @param {Uint8Array} bytes
       * @returns {FeeData}
       */
      static fromBytes(bytes) {
          return FeeData._fromProtobuf(libExports.proto.FeeData.decode(bytes));
      }

      /**
       * @internal
       * @param {HieroProto.proto.IFeeData} feeData
       * @returns {FeeData}
       */
      static _fromProtobuf(feeData) {
          return new FeeData({
              nodedata:
                  feeData.nodedata != null
                      ? FeeComponents._fromProtobuf(feeData.nodedata)
                      : undefined,
              networkdata:
                  feeData.networkdata != null
                      ? FeeComponents._fromProtobuf(feeData.networkdata)
                      : undefined,
              servicedata:
                  feeData.servicedata != null
                      ? FeeComponents._fromProtobuf(feeData.servicedata)
                      : undefined,
              feeDataType:
                  feeData.subType != null
                      ? FeeDataType._fromCode(feeData.subType)
                      : undefined,
          });
      }

      /**
       * @internal
       * @returns {HieroProto.proto.IFeeData}
       */
      _toProtobuf() {
          return {
              nodedata:
                  this.nodedata != null ? this.nodedata._toProtobuf() : undefined,

              networkdata:
                  this.networkdata != null
                      ? this.networkdata._toProtobuf()
                      : undefined,

              servicedata:
                  this.servicedata != null
                      ? this.servicedata._toProtobuf()
                      : undefined,

              subType:
                  this.feeDataType != null
                      ? this.feeDataType.valueOf()
                      : undefined,
          };
      }

      /**
       * @returns {Uint8Array}
       */
      toBytes() {
          return libExports.proto.FeeData.encode(this._toProtobuf()).finish();
      }
  }

  // SPDX-License-Identifier: Apache-2.0

  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.HederaFunctionality} HieroProto.proto.HederaFunctionality
   */

  class RequestType {
      /**
       * @hideconstructor
       * @internal
       * @param {number} code
       */
      constructor(code) {
          /** @readonly */
          this._code = code;

          Object.freeze(this);
      }

      /**
       * @returns {string}
       */
      toString() {
          switch (this) {
              case RequestType.None:
                  return "NONE";
              case RequestType.CryptoTransfer:
                  return "CryptoTransfer";
              case RequestType.CryptoUpdate:
                  return "CryptoUpdate";
              case RequestType.CryptoDelete:
                  return "CryptoDelete";
              case RequestType.CryptoAddLiveHash:
                  return "CryptoAddLiveHash";
              case RequestType.CryptoDeleteLiveHash:
                  return "CryptoDeleteLiveHash";
              case RequestType.ContractCall:
                  return "ContractCall";
              case RequestType.ContractCreate:
                  return "ContractCreate";
              case RequestType.ContractUpdate:
                  return "ContractUpdate";
              case RequestType.FileCreate:
                  return "FileCreate";
              case RequestType.FileAppend:
                  return "FileAppend";
              case RequestType.FileUpdate:
                  return "FileUpdate";
              case RequestType.FileDelete:
                  return "FileDelete";
              case RequestType.CryptoGetAccountBalance:
                  return "CryptoGetAccountBalance";
              case RequestType.CryptoGetAccountRecords:
                  return "CryptoGetAccountRecords";
              case RequestType.CryptoGetInfo:
                  return "CryptoGetInfo";
              case RequestType.ContractCallLocal:
                  return "ContractCallLocal";
              case RequestType.ContractGetInfo:
                  return "ContractGetInfo";
              case RequestType.ContractGetBytecode:
                  return "ContractGetBytecode";
              case RequestType.GetBySolidityID:
                  return "GetBySolidityID";
              case RequestType.GetByKey:
                  return "GetByKey";
              case RequestType.CryptoGetLiveHash:
                  return "CryptoGetLiveHash";
              case RequestType.CryptoGetStakers:
                  return "CryptoGetStakers";
              case RequestType.FileGetContents:
                  return "FileGetContents";
              case RequestType.FileGetInfo:
                  return "FileGetInfo";
              case RequestType.TransactionGetRecord:
                  return "TransactionGetRecord";
              case RequestType.ContractGetRecords:
                  return "ContractGetRecords";
              case RequestType.CryptoCreate:
                  return "CryptoCreate";
              case RequestType.SystemDelete:
                  return "SystemDelete";
              case RequestType.SystemUndelete:
                  return "SystemUndelete";
              case RequestType.ContractDelete:
                  return "ContractDelete";
              case RequestType.Freeze:
                  return "Freeze";
              case RequestType.CreateTransactionRecord:
                  return "CreateTransactionRecord";
              case RequestType.CryptoAccountAutoRenew:
                  return "CryptoAccountAutoRenew";
              case RequestType.ContractAutoRenew:
                  return "ContractAutoRenew";
              case RequestType.GetVersionInfo:
                  return "GetVersionInfo";
              case RequestType.TransactionGetReceipt:
                  return "TransactionGetReceipt";
              case RequestType.ConsensusCreateTopic:
                  return "ConsensusCreateTopic";
              case RequestType.ConsensusUpdateTopic:
                  return "ConsensusUpdateTopic";
              case RequestType.ConsensusDeleteTopic:
                  return "ConsensusDeleteTopic";
              case RequestType.ConsensusGetTopicInfo:
                  return "ConsensusGetTopicInfo";
              case RequestType.ConsensusSubmitMessage:
                  return "ConsensusSubmitMessage";
              case RequestType.UncheckedSubmit:
                  return "UncheckedSubmit";
              case RequestType.TokenCreate:
                  return "TokenCreate";
              case RequestType.TokenGetInfo:
                  return "TokenGetInfo";
              case RequestType.TokenFreezeAccount:
                  return "TokenFreezeAccount";
              case RequestType.TokenUnfreezeAccount:
                  return "TokenUnfreezeAccount";
              case RequestType.TokenGrantKycToAccount:
                  return "TokenGrantKycToAccount";
              case RequestType.TokenRevokeKycFromAccount:
                  return "TokenRevokeKycFromAccount";
              case RequestType.TokenDelete:
                  return "TokenDelete";
              case RequestType.TokenUpdate:
                  return "TokenUpdate";
              case RequestType.TokenMint:
                  return "TokenMint";
              case RequestType.TokenBurn:
                  return "TokenBurn";
              case RequestType.TokenAccountWipe:
                  return "TokenAccountWipe";
              case RequestType.TokenAssociateToAccount:
                  return "TokenAssociateToAccount";
              case RequestType.TokenDissociateFromAccount:
                  return "TokenDissociateFromAccount";
              case RequestType.ScheduleCreate:
                  return "ScheduleCreate";
              case RequestType.ScheduleDelete:
                  return "ScheduleDelete";
              case RequestType.ScheduleSign:
                  return "ScheduleSign";
              case RequestType.ScheduleGetInfo:
                  return "ScheduleGetInfo";
              case RequestType.TokenGetAccountNftInfos:
                  return "TokenGetAccountNftInfos";
              case RequestType.TokenGetNftInfo:
                  return "TokenGetNftInfo";
              case RequestType.TokenGetNftInfos:
                  return "TokenGetNftInfos";
              case RequestType.TokenFeeScheduleUpdate:
                  return "TokenFeeScheduleUpdate";
              case RequestType.NetworkGetExecutionTime:
                  return "NetworkGetExecutionTime";
              case RequestType.TokenPause:
                  return "TokenPause";
              case RequestType.TokenUnpause:
                  return "TokenUnpause";
              case RequestType.CryptoApproveAllowance:
                  return "CryptoApproveAllowance";
              case RequestType.CryptoDeleteAllowance:
                  return "CryptoDeleteAllowance";
              case RequestType.GetAccountDetails:
                  return "GetAccountDetails";
              case RequestType.EthereumTransaction:
                  return "EthereumTransaction";
              case RequestType.NodeStakeUpdate:
                  return "NodeStakeUpdate";
              case RequestType.Prng:
                  return "UtilPrng";
              case RequestType.TransactionGetFastRecord:
                  return "TransactionGetFastRecord";
              case RequestType.TokenUpdateNfts:
                  return "TokenUpdateNfts";
              case RequestType.NodeCreate:
                  return "NodeCreate";
              case RequestType.NodeUpdate:
                  return "NodeUpdate";
              case RequestType.NodeDelete:
                  return "NodeDelete";
              case RequestType.TokenReject:
                  return "TokenReject";
              case RequestType.TokenAirdrop:
                  return "TokenAirdrop";
              case RequestType.TokenCancelAirdrop:
                  return "TokenCancelAirdrop";
              case RequestType.TokenClaimAirdrop:
                  return "TokenClaimAirdrop";
              case RequestType.TssMessage:
                  return "TssMessage";
              case RequestType.TssVote:
                  return "TssVote";
              case RequestType.TssShareSignature:
                  return "TssShareSignature";
              case RequestType.TssEncryptionKey:
                  return "TssEncryptionKey";
              case RequestType.StateSignatureTransaction:
                  return "StateSignatureTransaction";
              case RequestType.HistoryAssemblySignature:
                  return "HistoryAssemblySignature";
              case RequestType.HistoryProofKeyPublication:
                  return "HistoryProofKeyPublication";
              case RequestType.HistoryProofVote:
                  return "HistoryProofVote";
              case RequestType.HintsKeyPublication:
                  return "HintsKeyPublication";
              case RequestType.HintsPreprocessingVote:
                  return "HintsPreprocessingVote";
              case RequestType.HintsPartialSignature:
                  return "HintsPartialSignature";
              case RequestType.CrsPublication:
                  return "CrsPublication";
              case RequestType.AtomicBatch:
                  return "AtomicBatch";
              default:
                  return `UNKNOWN (${this._code})`;
          }
      }

      /**
       * @internal
       * @param {number} code
       * @returns {RequestType}
       */
      static _fromCode(code) {
          switch (code) {
              case 0:
                  return RequestType.None;
              case 1:
                  return RequestType.CryptoTransfer;
              case 2:
                  return RequestType.CryptoUpdate;
              case 3:
                  return RequestType.CryptoDelete;
              case 4:
                  return RequestType.CryptoAddLiveHash;
              case 5:
                  return RequestType.CryptoDeleteLiveHash;
              case 6:
                  return RequestType.ContractCall;
              case 7:
                  return RequestType.ContractCreate;
              case 8:
                  return RequestType.ContractUpdate;
              case 9:
                  return RequestType.FileCreate;
              case 10:
                  return RequestType.FileAppend;
              case 11:
                  return RequestType.FileUpdate;
              case 12:
                  return RequestType.FileDelete;
              case 13:
                  return RequestType.CryptoGetAccountBalance;
              case 14:
                  return RequestType.CryptoGetAccountRecords;
              case 15:
                  return RequestType.CryptoGetInfo;
              case 16:
                  return RequestType.ContractCallLocal;
              case 17:
                  return RequestType.ContractGetInfo;
              case 18:
                  return RequestType.ContractGetBytecode;
              case 19:
                  return RequestType.GetBySolidityID;
              case 20:
                  return RequestType.GetByKey;
              case 21:
                  return RequestType.CryptoGetLiveHash;
              case 22:
                  return RequestType.CryptoGetStakers;
              case 23:
                  return RequestType.FileGetContents;
              case 24:
                  return RequestType.FileGetInfo;
              case 25:
                  return RequestType.TransactionGetRecord;
              case 26:
                  return RequestType.ContractGetRecords;
              case 27:
                  return RequestType.CryptoCreate;
              case 28:
                  return RequestType.SystemDelete;
              case 29:
                  return RequestType.SystemUndelete;
              case 30:
                  return RequestType.ContractDelete;
              case 31:
                  return RequestType.Freeze;
              case 32:
                  return RequestType.CreateTransactionRecord;
              case 33:
                  return RequestType.CryptoAccountAutoRenew;
              case 34:
                  return RequestType.ContractAutoRenew;
              case 35:
                  return RequestType.GetVersionInfo;
              case 36:
                  return RequestType.TransactionGetReceipt;
              case 50:
                  return RequestType.ConsensusCreateTopic;
              case 51:
                  return RequestType.ConsensusUpdateTopic;
              case 52:
                  return RequestType.ConsensusDeleteTopic;
              case 53:
                  return RequestType.ConsensusGetTopicInfo;
              case 54:
                  return RequestType.ConsensusSubmitMessage;
              case 55:
                  return RequestType.UncheckedSubmit;
              case 56:
                  return RequestType.TokenCreate;
              case 58:
                  return RequestType.TokenGetInfo;
              case 59:
                  return RequestType.TokenFreezeAccount;
              case 60:
                  return RequestType.TokenUnfreezeAccount;
              case 61:
                  return RequestType.TokenGrantKycToAccount;
              case 62:
                  return RequestType.TokenRevokeKycFromAccount;
              case 63:
                  return RequestType.TokenDelete;
              case 64:
                  return RequestType.TokenUpdate;
              case 65:
                  return RequestType.TokenMint;
              case 66:
                  return RequestType.TokenBurn;
              case 67:
                  return RequestType.TokenAccountWipe;
              case 68:
                  return RequestType.TokenAssociateToAccount;
              case 69:
                  return RequestType.TokenDissociateFromAccount;
              case 70:
                  return RequestType.ScheduleCreate;
              case 71:
                  return RequestType.ScheduleDelete;
              case 72:
                  return RequestType.ScheduleSign;
              case 73:
                  return RequestType.ScheduleGetInfo;
              case 74:
                  return RequestType.TokenGetAccountNftInfos;
              case 75:
                  return RequestType.TokenGetNftInfo;
              case 76:
                  return RequestType.TokenGetNftInfos;
              case 77:
                  return RequestType.TokenFeeScheduleUpdate;
              case 78:
                  return RequestType.NetworkGetExecutionTime;
              case 79:
                  return RequestType.TokenPause;
              case 80:
                  return RequestType.TokenUnpause;
              case 81:
                  return RequestType.CryptoApproveAllowance;
              case 82:
                  return RequestType.CryptoDeleteAllowance;
              case 83:
                  return RequestType.GetAccountDetails;
              case 84:
                  return RequestType.EthereumTransaction;
              case 85:
                  return RequestType.NodeStakeUpdate;
              case 86:
                  return RequestType.Prng;
              case 87:
                  return RequestType.TransactionGetFastRecord;
              case 88:
                  return RequestType.TokenUpdateNfts;
              case 89:
                  return RequestType.NodeCreate;
              case 90:
                  return RequestType.NodeUpdate;
              case 91:
                  return RequestType.NodeDelete;
              case 92:
                  return RequestType.TokenReject;
              case 93:
                  return RequestType.TokenAirdrop;
              case 94:
                  return RequestType.TokenCancelAirdrop;
              case 95:
                  return RequestType.TokenClaimAirdrop;
              case 96:
                  return RequestType.TssMessage;
              case 97:
                  return RequestType.TssVote;
              case 98:
                  return RequestType.TssShareSignature;
              case 99:
                  return RequestType.TssEncryptionKey;
              case 100:
                  return RequestType.StateSignatureTransaction;
              case 101:
                  return RequestType.HintsKeyPublication;
              case 102:
                  return RequestType.HintsPreprocessingVote;
              case 103:
                  return RequestType.HintsPartialSignature;
              case 104:
                  return RequestType.HistoryAssemblySignature;
              case 105:
                  return RequestType.HistoryProofKeyPublication;
              case 106:
                  return RequestType.HistoryProofVote;
              case 107:
                  return RequestType.CrsPublication;
              case 108:
                  return RequestType.AtomicBatch;
          }

          throw new Error(
              `(BUG) RequestType.fromCode() does not handle code: ${code}`,
          );
      }

      /**
       * @returns {HieroProto.proto.HederaFunctionality}
       */
      valueOf() {
          return this._code;
      }
  }

  /**
   * UNSPECIFIED - Need to keep first value as unspecified because first element is ignored and
   * not parsed (0 is ignored by parser)
   */
  RequestType.None = new RequestType(0);

  /**
   * crypto transfer
   */
  RequestType.CryptoTransfer = new RequestType(1);

  /**
   * crypto update account
   */
  RequestType.CryptoUpdate = new RequestType(2);

  /**
   * crypto delete account
   */
  RequestType.CryptoDelete = new RequestType(3);

  /**
   * Add a livehash to a crypto account
   */
  RequestType.CryptoAddLiveHash = new RequestType(4);

  /**
   * Delete a livehash from a crypto account
   */
  RequestType.CryptoDeleteLiveHash = new RequestType(5);

  /**
   * Smart Contract Call
   */
  RequestType.ContractCall = new RequestType(6);

  /**
   * Smart Contract Create Contract
   */
  RequestType.ContractCreate = new RequestType(7);

  /**
   * Smart Contract update contract
   */
  RequestType.ContractUpdate = new RequestType(8);

  /**
   * File Operation create file
   */
  RequestType.FileCreate = new RequestType(9);

  /**
   * File Operation append file
   */
  RequestType.FileAppend = new RequestType(10);

  /**
   * File Operation update file
   */
  RequestType.FileUpdate = new RequestType(11);

  /**
   * File Operation delete file
   */
  RequestType.FileDelete = new RequestType(12);

  /**
   * crypto get account balance
   */
  RequestType.CryptoGetAccountBalance = new RequestType(13);

  /**
   * crypto get account record
   */
  RequestType.CryptoGetAccountRecords = new RequestType(14);

  /**
   * Crypto get info
   */
  RequestType.CryptoGetInfo = new RequestType(15);

  /**
   * Smart Contract Call
   */
  RequestType.ContractCallLocal = new RequestType(16);

  /**
   * Smart Contract get info
   */
  RequestType.ContractGetInfo = new RequestType(17);

  /**
   * Smart Contract, get the runtime code
   */
  RequestType.ContractGetBytecode = new RequestType(18);

  /**
   * Smart Contract, get by solidity ID
   */
  RequestType.GetBySolidityID = new RequestType(19);

  /**
   * Smart Contract, get by key
   */
  RequestType.GetByKey = new RequestType(20);

  /**
   * Get a live hash from a crypto account
   */
  RequestType.CryptoGetLiveHash = new RequestType(21);

  /**
   * Crypto, get the stakers for the node
   */
  RequestType.CryptoGetStakers = new RequestType(22);

  /**
   * File Operations get file contents
   */
  RequestType.FileGetContents = new RequestType(23);

  /**
   * File Operations get the info of the file
   */
  RequestType.FileGetInfo = new RequestType(24);

  /**
   * Crypto get the transaction records
   */
  RequestType.TransactionGetRecord = new RequestType(25);

  /**
   * Contract get the transaction records
   */
  RequestType.ContractGetRecords = new RequestType(26);

  /**
   * crypto create account
   */
  RequestType.CryptoCreate = new RequestType(27);

  /**
   * system delete file
   */
  RequestType.SystemDelete = new RequestType(28);

  /**
   * system undelete file
   */
  RequestType.SystemUndelete = new RequestType(29);

  /**
   * delete contract
   */
  RequestType.ContractDelete = new RequestType(30);

  /**
   * freeze
   */
  RequestType.Freeze = new RequestType(31);

  /**
   * Create Tx Record
   */
  RequestType.CreateTransactionRecord = new RequestType(32);

  /**
   * Crypto Auto Renew
   */
  RequestType.CryptoAccountAutoRenew = new RequestType(33);

  /**
   * Contract Auto Renew
   */
  RequestType.ContractAutoRenew = new RequestType(34);

  /**
   * Get Version
   */
  RequestType.GetVersionInfo = new RequestType(35);

  /**
   * Transaction Get Receipt
   */
  RequestType.TransactionGetReceipt = new RequestType(36);

  /**
   * Create Topic
   */
  RequestType.ConsensusCreateTopic = new RequestType(50);

  /**
   * Update Topic
   */
  RequestType.ConsensusUpdateTopic = new RequestType(51);

  /**
   * Delete Topic
   */
  RequestType.ConsensusDeleteTopic = new RequestType(52);

  /**
   * Get Topic information
   */
  RequestType.ConsensusGetTopicInfo = new RequestType(53);

  /**
   * Submit message to topic
   */
  RequestType.ConsensusSubmitMessage = new RequestType(54);

  RequestType.UncheckedSubmit = new RequestType(55);
  /**
   * Create Token
   */
  RequestType.TokenCreate = new RequestType(56);

  /**
   * Get Token information
   */
  RequestType.TokenGetInfo = new RequestType(58);

  /**
   * Freeze Account
   */
  RequestType.TokenFreezeAccount = new RequestType(59);

  /**
   * Unfreeze Account
   */
  RequestType.TokenUnfreezeAccount = new RequestType(60);

  /**
   * Grant KYC to Account
   */
  RequestType.TokenGrantKycToAccount = new RequestType(61);

  /**
   * Revoke KYC from Account
   */
  RequestType.TokenRevokeKycFromAccount = new RequestType(62);

  /**
   * Delete Token
   */
  RequestType.TokenDelete = new RequestType(63);

  /**
   * Update Token
   */
  RequestType.TokenUpdate = new RequestType(64);

  /**
   * Mint tokens to treasury
   */
  RequestType.TokenMint = new RequestType(65);

  /**
   * Burn tokens from treasury
   */
  RequestType.TokenBurn = new RequestType(66);

  /**
   * Wipe token amount from Account holder
   */
  RequestType.TokenAccountWipe = new RequestType(67);

  /**
   * Associate tokens to an account
   */
  RequestType.TokenAssociateToAccount = new RequestType(68);

  /**
   * Dissociate tokens from an account
   */
  RequestType.TokenDissociateFromAccount = new RequestType(69);

  /**
   * Create Scheduled Transaction
   */
  RequestType.ScheduleCreate = new RequestType(70);

  /**
   * Delete Scheduled Transaction
   */
  RequestType.ScheduleDelete = new RequestType(71);

  /**
   * Sign Scheduled Transaction
   */
  RequestType.ScheduleSign = new RequestType(72);

  /**
   * Get Scheduled Transaction Information
   */
  RequestType.ScheduleGetInfo = new RequestType(73);

  /**
   * Get Token Account Nft Information
   */
  RequestType.TokenGetAccountNftInfos = new RequestType(74);

  /**
   * Get Token Nft Information
   */
  RequestType.TokenGetNftInfo = new RequestType(75);

  /**
   * Get Token Nft List Information
   */
  RequestType.TokenGetNftInfos = new RequestType(76);

  /**
   * Update a token's custom fee schedule, if permissible
   */
  RequestType.TokenFeeScheduleUpdate = new RequestType(77);

  /**
   * Get execution time(s) by TransactionID, if available
   */
  RequestType.NetworkGetExecutionTime = new RequestType(78);

  /**
   * Pause the Token
   */
  RequestType.TokenPause = new RequestType(79);

  /**
   * Unpause the Token
   */
  RequestType.TokenUnpause = new RequestType(80);

  /**
   * Approve allowance for a spender relative to the owner account
   */
  RequestType.CryptoApproveAllowance = new RequestType(81);

  /**
   * Deletes granted allowances on owner account
   */
  RequestType.CryptoDeleteAllowance = new RequestType(82);

  /**
   * Gets all the information about an account, including balance and allowances. This does not get the list of
   * account records.
   */
  RequestType.GetAccountDetails = new RequestType(83);

  /**
   * Ethereum Transaction
   */
  RequestType.EthereumTransaction = new RequestType(84);

  /**
   * Updates the staking info at the end of staking period to indicate new staking period has started.
   */
  RequestType.NodeStakeUpdate = new RequestType(85);

  /**
   * Generates a pseudorandom number.
   */
  RequestType.Prng = new RequestType(86);

  /**
   * Get a record for a transaction (lasts 180 seconds)
   */
  RequestType.TransactionGetFastRecord = new RequestType(87);

  /**
   * Update the metadata of one or more NFT's of a specific token type.
   */
  RequestType.TokenUpdateNfts = new RequestType(88);

  /**
   * A transaction body for a `createNode` request.
   */
  RequestType.NodeCreate = new RequestType(89);

  /**
   * A transaction body for an `updateNode` request.
   */
  RequestType.NodeUpdate = new RequestType(90);

  /**
   * A transaction body for a `deleteNode` request.
   */
  RequestType.NodeDelete = new RequestType(91);

  /**
   * Transfer one or more token balances held by the requesting account to the treasury for each token type.
   */
  RequestType.TokenReject = new RequestType(92);

  /**
   * Airdrop one or more tokens to one or more accounts.
   */
  RequestType.TokenAirdrop = new RequestType(93);

  /**
   * Remove one or more pending airdrops from state on behalf of the sender(s) for each airdrop.
   */
  RequestType.TokenCancelAirdrop = new RequestType(94);

  /**
   * Claim one or more pending airdrops
   */
  RequestType.TokenClaimAirdrop = new RequestType(95);

  /**
   * (TSS) Messages for a candidate roster.
   */
  RequestType.TssMessage = new RequestType(96);

  /**
   * Vote on the validity of Threshold Signature Scheme (TSS)
   */
  RequestType.TssVote = new RequestType(97);

  /**
   * Communicates a node's signature of a block hash
   * using its private share within the TSS process
   */
  RequestType.TssShareSignature = new RequestType(98);

  /**
   * Submit a node public tss encryption key as part of the Threshold Signature Scheme (TSS).
   */
  RequestType.TssEncryptionKey = new RequestType(99);

  /**
   * Submit a signature of a state root hash gossiped to other nodes
   */
  RequestType.StateSignatureTransaction = new RequestType(100);

  /**
   * Publish a hinTS key to the network.
   */
  RequestType.HintsKeyPublication = new RequestType(101);

  /**
   * Vote for a particular preprocessing output of a hinTS construction.
   */
  RequestType.HintsPreprocessingVote = new RequestType(102);

  /**
   * Sign a partial signature for the active hinTS construction.
   */
  RequestType.HintsPartialSignature = new RequestType(103);

  /**
   * Sign a particular history assembly.
   */
  RequestType.HistoryAssemblySignature = new RequestType(104);

  /**
   * Publish a roster history proof key to the network.
   */
  RequestType.HistoryProofKeyPublication = new RequestType(105);

  /**
   * Vote for a particular history proof.
   */
  RequestType.HistoryProofVote = new RequestType(106);

  /**
   * Sign a particular CRS publication.
   */
  RequestType.CrsPublication = new RequestType(107);

  /**
   * Sign a particular history assembly.
   */
  RequestType.HistoryAssemblySignature = new RequestType(104);

  /**
   * Publish a roster history proof key to the network.
   */
  RequestType.HistoryProofKeyPublication = new RequestType(105);

  /**
   * Vote for a particular history proof.
   */
  RequestType.HistoryProofVote = new RequestType(106);

  /**
   * Sign a particular atomic batch.
   */
  RequestType.AtomicBatch = new RequestType(108);

  // SPDX-License-Identifier: Apache-2.0


  class TransactionFeeSchedule {
      /**
       * @param {object} [props]
       * @param {RequestType} [props.hederaFunctionality]
       * @param {FeeData} [props.feeData]
       * @param {FeeData[]} [props.fees]
       */
      constructor(props = {}) {
          /*
           * A particular transaction or query
           *
           * @type {RequestType}
           */
          this.hederaFunctionality = props.hederaFunctionality;

          /*
           * Resource price coefficients
           *
           * @type {FeeData}
           */
          this.feeData = props.feeData;

          /*
           * Resource price coefficients
           *
           * @type {FeeData[]}
           */
          this.fees = props.fees;
      }

      /**
       * @param {Uint8Array} bytes
       * @returns {TransactionFeeSchedule}
       */
      static fromBytes(bytes) {
          return TransactionFeeSchedule._fromProtobuf(
              libExports.proto.TransactionFeeSchedule.decode(bytes),
          );
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransactionFeeSchedule} transactionFeeSchedule
       * @returns {TransactionFeeSchedule}
       */
      static _fromProtobuf(transactionFeeSchedule) {
          return new TransactionFeeSchedule({
              hederaFunctionality:
                  transactionFeeSchedule.hederaFunctionality != null
                      ? RequestType._fromCode(
                            transactionFeeSchedule.hederaFunctionality,
                        )
                      : undefined,
              feeData:
                  transactionFeeSchedule.feeData != null
                      ? FeeData._fromProtobuf(transactionFeeSchedule.feeData)
                      : undefined,
              fees:
                  transactionFeeSchedule.fees != null
                      ? transactionFeeSchedule.fees.map((fee) =>
                            FeeData._fromProtobuf(fee),
                        )
                      : undefined,
          });
      }

      /**
       * @internal
       * @returns {HieroProto.proto.ITransactionFeeSchedule}
       */
      _toProtobuf() {
          return {
              hederaFunctionality:
                  this.hederaFunctionality != null
                      ? this.hederaFunctionality.valueOf()
                      : undefined,
              feeData:
                  this.feeData != null ? this.feeData._toProtobuf() : undefined,
              fees:
                  this.fees != null
                      ? this.fees.map((fee) => fee._toProtobuf())
                      : undefined,
          };
      }

      /**
       * @returns {Uint8Array}
       */
      toBytes() {
          return libExports.proto.TransactionFeeSchedule.encode(
              this._toProtobuf(),
          ).finish();
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * A set of fee schedules covering all transaction types and query types, along
   * with a specific time at which this fee schedule will expire.
   */
  class FeeSchedule {
      /**
       * @param {object} [props]
       * @param {TransactionFeeSchedule[]} [props.transactionFeeSchedule]
       * @param {Timestamp} [props.expirationTime]
       */
      constructor(props = {}) {
          /*
           * List of price coefficients for network resources
           *
           * @type {TransactionFeeSchedule}
           */
          this.transactionFeeSchedule = props.transactionFeeSchedule;

          /*
           * FeeSchedule expiry time
           *
           * @type {Timestamp}
           */
          this.expirationTime = props.expirationTime;
      }

      /**
       * @param {Uint8Array} bytes
       * @returns {FeeSchedule}
       */
      static fromBytes(bytes) {
          return FeeSchedule._fromProtobuf(
              libExports.proto.FeeSchedule.decode(bytes),
          );
      }

      /**
       * @internal
       * @param {HieroProto.proto.IFeeSchedule} feeSchedule
       * @returns {FeeSchedule}
       */
      static _fromProtobuf(feeSchedule) {
          return new FeeSchedule({
              transactionFeeSchedule:
                  feeSchedule.transactionFeeSchedule != null
                      ? feeSchedule.transactionFeeSchedule.map((schedule) =>
                            TransactionFeeSchedule._fromProtobuf(schedule),
                        )
                      : undefined,
              expirationTime:
                  feeSchedule.expiryTime != null
                      ? Timestamp._fromProtobuf(feeSchedule.expiryTime)
                      : undefined,
          });
      }

      /**
       * @internal
       * @returns {HieroProto.proto.IFeeSchedule}
       */
      _toProtobuf() {
          return {
              transactionFeeSchedule:
                  this.transactionFeeSchedule != null
                      ? this.transactionFeeSchedule.map((transaction) =>
                            transaction._toProtobuf(),
                        )
                      : undefined,
              expiryTime:
                  this.expirationTime != null
                      ? this.expirationTime._toProtobuf()
                      : undefined,
          };
      }

      /**
       * @returns {Uint8Array}
       */
      toBytes() {
          return libExports.proto.FeeSchedule.encode(this._toProtobuf()).finish();
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * Represents a pair of fee schedules on the Hedera network - the currently active fee schedule
   * and the next upcoming fee schedule. This structure allows for transparent fee updates by making
   * future fee changes visible before they take effect.
   */
  class FeeSchedules {
      /**
       * @param {object} [props]
       * @param {FeeSchedule} [props.currentFeeSchedule]
       * @param {FeeSchedule} [props.nextFeeSchedule]
       */
      constructor(props = {}) {
          /*
           * Contains current Fee Schedule
           *
           * @type {FeeSchedule}
           */
          this.current = props.currentFeeSchedule;

          /*
           * Contains next Fee Schedule
           *
           * @type {FeeSchedule}
           */
          this.next = props.nextFeeSchedule;
      }

      /**
       * @param {Uint8Array} bytes
       * @returns {FeeSchedules}
       */
      static fromBytes(bytes) {
          return FeeSchedules._fromProtobuf(
              libExports.proto.CurrentAndNextFeeSchedule.decode(bytes),
          );
      }

      /**
       * @internal
       * @param {HieroProto.proto.ICurrentAndNextFeeSchedule} feeSchedules
       * @returns {FeeSchedules}
       */
      static _fromProtobuf(feeSchedules) {
          return new FeeSchedules({
              currentFeeSchedule:
                  feeSchedules.currentFeeSchedule != null
                      ? FeeSchedule._fromProtobuf(feeSchedules.currentFeeSchedule)
                      : undefined,
              nextFeeSchedule:
                  feeSchedules.nextFeeSchedule != null
                      ? FeeSchedule._fromProtobuf(feeSchedules.nextFeeSchedule)
                      : undefined,
          });
      }

      /**
       * @internal
       * @returns {HieroProto.proto.ICurrentAndNextFeeSchedule}
       */
      _toProtobuf() {
          return {
              currentFeeSchedule:
                  this.current != null ? this.current._toProtobuf() : undefined,
              nextFeeSchedule:
                  this.next != null ? this.next._toProtobuf() : undefined,
          };
      }

      /**
       * @returns {Uint8Array}
       */
      toBytes() {
          return libExports.proto.CurrentAndNextFeeSchedule.encode(
              this._toProtobuf(),
          ).finish();
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.IQuery} HieroProto.proto.IQuery
   * @typedef {import("@hashgraph/proto").proto.IQueryHeader} HieroProto.proto.IQueryHeader
   * @typedef {import("@hashgraph/proto").proto.IResponse} HieroProto.proto.IResponse
   * @typedef {import("@hashgraph/proto").proto.IResponseHeader} HieroProto.proto.IResponseHeader
   * @typedef {import("@hashgraph/proto").proto.IFileGetContentsQuery} HieroProto.proto.IFileGetContentsQuery
   * @typedef {import("@hashgraph/proto").proto.IFileGetContentsResponse} HieroProto.proto.IFileGetContentsResponse
   * @typedef {import("@hashgraph/proto").proto.FileGetContentsResponse.IFileContents} HieroProto.proto.FileGetContentsResponse.IFileContents
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("../account/AccountId.js").default} AccountId
   */

  /**
   * @augments {Query<Uint8Array>}
   * Retrieve the content of a file in HFS.<br/>
   * Note that this query retrieves _only_ the file content, not any of
   * the metadata for the file.
   */
  class FileContentsQuery extends Query {
      /**
       * @param {object} [props]
       * @param {FileId | string} [props.fileId]
       */
      constructor(props = {}) {
          super();

          /**
           * @type {?FileId}
           * @private
           */
          this._fileId = null;
          if (props.fileId != null) {
              this.setFileId(props.fileId);
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.IQuery} query
       * @returns {FileContentsQuery}
       */
      static _fromProtobuf(query) {
          const contents = /** @type {HieroProto.proto.IFileGetContentsQuery} */ (
              query.fileGetContents
          );

          return new FileContentsQuery({
              fileId:
                  contents.fileID != null
                      ? FileId._fromProtobuf(contents.fileID)
                      : undefined,
          });
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          if (this._fileId != null) {
              this._fileId.validateChecksum(client);
          }
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.IQuery} request
       * @returns {Promise<HieroProto.proto.IResponse>}
       */
      _execute(channel, request) {
          return channel.file.getFileContent(request);
      }

      /**
       * @returns {?FileId}
       */
      get fileId() {
          return this._fileId;
      }

      /**
       * Set the file ID for which the info is being requested.
       *
       * @param {FileId | string} fileId
       * @returns {FileContentsQuery}
       */
      setFileId(fileId) {
          this._fileId =
              typeof fileId === "string"
                  ? FileId.fromString(fileId)
                  : fileId.clone();

          return this;
      }

      /**
       * @override
       * @internal
       * @param {HieroProto.proto.IResponse} response
       * @returns {HieroProto.proto.IResponseHeader}
       */
      _mapResponseHeader(response) {
          const fileGetContents =
              /** @type {HieroProto.proto.IFileGetContentsResponse} */ (
                  response.fileGetContents
              );
          return /** @type {HieroProto.proto.IResponseHeader} */ (
              fileGetContents.header
          );
      }

      /**
       * @protected
       * @override
       * @param {HieroProto.proto.IResponse} response
       * @returns {Promise<Uint8Array>}
       */
      _mapResponse(response) {
          const fileContentsResponse =
              /** @type {HieroProto.proto.IFileGetContentsResponse} */ (
                  response.fileGetContents
              );
          const fileConents =
              /** @type {HieroProto.proto.FileGetContentsResponse.IFileContents} */ (
                  fileContentsResponse.fileContents
              );
          const contents = /** @type {Uint8Array} */ (fileConents.contents);

          return Promise.resolve(contents);
      }

      /**
       * @override
       * @internal
       * @param {HieroProto.proto.IQueryHeader} header
       * @returns {HieroProto.proto.IQuery}
       */
      _onMakeRequest(header) {
          return {
              fileGetContents: {
                  header,
                  fileID:
                      this._fileId != null ? this._fileId._toProtobuf() : null,
              },
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp =
              this._paymentTransactionId != null &&
              this._paymentTransactionId.validStart != null
                  ? this._paymentTransactionId.validStart
                  : this._timestamp;

          return `FileContentsQuery:${timestamp.toString()}`;
      }
  }

  // eslint-disable-next-line @typescript-eslint/unbound-method
  QUERY_REGISTRY.set("fileGetContents", FileContentsQuery._fromProtobuf);

  // SPDX-License-Identifier: Apache-2.0


  const { proto: proto$2 } = HieroProto;

  /**
   * Response when the client sends the node CryptoGetInfoQuery.
   */
  class FileInfo {
      /**
       * @private
       * @param {object} props
       * @param {FileId} props.fileId
       * @param {Long} props.size
       * @param {Timestamp} props.expirationTime
       * @param {boolean} props.isDeleted
       * @param {KeyList} props.keys
       * @param {string} props.fileMemo
       * @param {LedgerId|null} props.ledgerId
       */
      constructor(props) {
          /**
           * The ID of the file for which information is requested.
           *
           * @readonly
           */
          this.fileId = props.fileId;

          /**
           * Number of bytes in contents.
           *
           * @readonly
           */
          this.size = props.size;

          /**
           * The current time at which this account is set to expire.
           *
           * @readonly
           */
          this.expirationTime = props.expirationTime;

          /**
           * True if deleted but not yet expired.
           *
           * @readonly
           */
          this.isDeleted = props.isDeleted;

          /**
           * One of these keys must sign in order to delete the file.
           * All of these keys must sign in order to update the file.
           *
           * @readonly
           */
          this.keys = props.keys;

          this.fileMemo = props.fileMemo;

          this.ledgerId = props.ledgerId;

          Object.freeze(this);
      }

      /**
       * @internal
       * @param {HieroProto.proto.FileGetInfoResponse.IFileInfo} info
       * @returns {FileInfo}
       */
      static _fromProtobuf(info) {
          const size = /** @type {Long | number} */ (info.size);

          return new FileInfo({
              fileId: FileId._fromProtobuf(
                  /** @type {HieroProto.proto.IFileID} */ (info.fileID),
              ),
              size: size instanceof Long ? size : Long.fromValue(size),
              expirationTime: Timestamp._fromProtobuf(
                  /** @type {HieroProto.proto.ITimestamp} */ (
                      info.expirationTime
                  ),
              ),
              isDeleted: /** @type {boolean} */ (info.deleted),
              keys:
                  info.keys != null
                      ? KeyList.__fromProtobufKeyList(info.keys)
                      : new KeyList(),
              fileMemo: info.memo != null ? info.memo : "",
              ledgerId:
                  info.ledgerId != null
                      ? LedgerId.fromBytes(info.ledgerId)
                      : null,
          });
      }

      /**
       * @internal
       * @returns {HieroProto.proto.FileGetInfoResponse.IFileInfo}
       */
      _toProtobuf() {
          return {
              fileID: this.fileId._toProtobuf(),
              size: this.size,
              expirationTime: this.expirationTime._toProtobuf(),
              deleted: this.isDeleted,
              keys: this.keys._toProtobufKey().keyList,
              memo: this.fileMemo,
              ledgerId: this.ledgerId != null ? this.ledgerId.toBytes() : null,
          };
      }

      /**
       * @param {Uint8Array} bytes
       * @returns {FileInfo}
       */
      static fromBytes(bytes) {
          return FileInfo._fromProtobuf(
              libExports.proto.FileGetInfoResponse.FileInfo.decode(bytes),
          );
      }

      /**
       * @returns {Uint8Array}
       */
      toBytes() {
          return proto$2.FileGetInfoResponse.FileInfo.encode(
              this._toProtobuf(),
          ).finish();
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.IQuery} HieroProto.proto.IQuery
   * @typedef {import("@hashgraph/proto").proto.IQueryHeader} HieroProto.proto.IQueryHeader
   * @typedef {import("@hashgraph/proto").proto.IResponse} HieroProto.proto.IResponse
   * @typedef {import("@hashgraph/proto").proto.IResponseHeader} HieroProto.proto.IResponseHeader
   * @typedef {import("@hashgraph/proto").proto.IFileGetInfoQuery} HieroProto.proto.IFileGetInfoQuery
   * @typedef {import("@hashgraph/proto").proto.IFileGetInfoResponse} HieroProto.proto.IFileGetInfoResponse
   * @typedef {import("@hashgraph/proto").proto.FileGetInfoResponse.IFileInfo} HieroProto.proto.IFileInfo
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("../account/AccountId.js").default} AccountId
   */

  /**
   * @augments {Query<FileInfo>}
   * Retrieve the metadata for a file in HFS.<br/>
   * Note that this query does not retrieve the file _content_.
   */
  class FileInfoQuery extends Query {
      /**
       * @param {object} [props]
       * @param {FileId | string} [props.fileId]
       */
      constructor(props = {}) {
          super();

          /**
           * @type {?FileId}
           * @private
           */
          this._fileId = null;
          if (props.fileId != null) {
              this.setFileId(props.fileId);
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.IQuery} query
       * @returns {FileInfoQuery}
       */
      static _fromProtobuf(query) {
          const info = /** @type {HieroProto.proto.IFileGetInfoQuery} */ (
              query.fileGetInfo
          );

          return new FileInfoQuery({
              fileId:
                  info.fileID != null
                      ? FileId._fromProtobuf(info.fileID)
                      : undefined,
          });
      }

      /**
       * @returns {?FileId}
       */
      get fileId() {
          return this._fileId;
      }

      /**
       * Set the file ID for which the info is being requested.
       *
       * @param {FileId | string} fileId
       * @returns {FileInfoQuery}
       */
      setFileId(fileId) {
          this._fileId =
              typeof fileId === "string"
                  ? FileId.fromString(fileId)
                  : fileId.clone();

          return this;
      }

      /**
       * @override
       * @param {import("../client/Client.js").default<Channel, *>} client
       * @returns {Promise<Hbar>}
       */
      async getCost(client) {
          return super.getCost(client);
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          if (this._fileId != null) {
              this._fileId.validateChecksum(client);
          }
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.IQuery} request
       * @returns {Promise<HieroProto.proto.IResponse>}
       */
      _execute(channel, request) {
          return channel.file.getFileInfo(request);
      }

      /**
       * @override
       * @internal
       * @param {HieroProto.proto.IResponse} response
       * @returns {HieroProto.proto.IResponseHeader}
       */
      _mapResponseHeader(response) {
          const fileGetInfo =
              /** @type {HieroProto.proto.IFileGetInfoResponse} */ (
                  response.fileGetInfo
              );
          return /** @type {HieroProto.proto.IResponseHeader} */ (
              fileGetInfo.header
          );
      }

      /**
       * @protected
       * @override
       * @param {HieroProto.proto.IResponse} response
       * @param {AccountId} nodeAccountId
       * @param {HieroProto.proto.IQuery} request
       * @returns {Promise<FileInfo>}
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _mapResponse(response, nodeAccountId, request) {
          const info = /** @type {HieroProto.proto.IFileGetInfoResponse} */ (
              response.fileGetInfo
          );

          return Promise.resolve(
              FileInfo._fromProtobuf(
                  /** @type {HieroProto.proto.IFileInfo} */ (info.fileInfo),
              ),
          );
      }

      /**
       * @override
       * @internal
       * @param {HieroProto.proto.IQueryHeader} header
       * @returns {HieroProto.proto.IQuery}
       */
      _onMakeRequest(header) {
          return {
              fileGetInfo: {
                  header,
                  fileID:
                      this._fileId != null ? this._fileId._toProtobuf() : null,
              },
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp =
              this._paymentTransactionId != null &&
              this._paymentTransactionId.validStart != null
                  ? this._paymentTransactionId.validStart
                  : this._timestamp;

          return `FileInfoQuery:${timestamp.toString()}`;
      }
  }

  // eslint-disable-next-line @typescript-eslint/unbound-method
  QUERY_REGISTRY.set("fileGetInfo", FileInfoQuery._fromProtobuf);

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
   * @typedef {import("@hashgraph/proto").proto.IFileUpdateTransactionBody} HieroProto.proto.IFileUpdateTransactionBody
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("../account/AccountId.js").default} AccountId
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   */

  /**
   * Update a new Hedera crypto-currency file.
   */
  class FileUpdateTransaction extends Transaction {
      /**
       * @param {object} props
       * @param {FileId | string} [props.fileId]
       * @param {Key[] | KeyList} [props.keys]
       * @param {Timestamp | Date} [props.expirationTime]
       * @param {Uint8Array | string} [props.contents]
       * @param {?string} [props.fileMemo]
       */
      constructor(props = {}) {
          super();

          /**
           * @private
           * @type {?FileId}
           */
          this._fileId = null;

          /**
           * @private
           * @type {?Key[]}
           */
          this._keys = null;

          /**
           * @private
           * @type {?Timestamp}
           */
          this._expirationTime = null;

          /**
           * @private
           * @type {?Uint8Array}
           */
          this._contents = null;

          /**
           * @private
           * @type {?string}
           */
          this._fileMemo = null;

          if (props.fileId != null) {
              this.setFileId(props.fileId);
          }

          if (props.keys != null) {
              this.setKeys(props.keys);
          }

          if (props.expirationTime != null) {
              this.setExpirationTime(props.expirationTime);
          }

          if (props.contents != null) {
              this.setContents(props.contents);
          }

          if (props.fileMemo && props.fileMemo != null) {
              this.setFileMemo(props.fileMemo);
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransaction[]} transactions
       * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {HieroProto.proto.ITransactionBody[]} bodies
       * @returns {FileUpdateTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];
          const update =
              /** @type {HieroProto.proto.IFileUpdateTransactionBody} */ (
                  body.fileUpdate
              );

          return Transaction._fromProtobufTransactions(
              new FileUpdateTransaction({
                  fileId:
                      update.fileID != null
                          ? FileId._fromProtobuf(update.fileID)
                          : undefined,
                  keys:
                      update.keys != null
                          ? update.keys.keys != null
                              ? update.keys.keys.map((key) =>
                                    Key._fromProtobufKey(key),
                                )
                              : undefined
                          : undefined,
                  expirationTime:
                      update.expirationTime != null
                          ? Timestamp._fromProtobuf(update.expirationTime)
                          : undefined,
                  contents: update.contents != null ? update.contents : undefined,
                  fileMemo:
                      update.memo != null
                          ? Object.hasOwn(update.memo, "value")
                              ? update.memo.value
                              : undefined
                          : undefined,
              }),
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * @returns {?FileId}
       */
      get fileId() {
          return this._fileId;
      }

      /**
       * Set the keys which must sign any transactions modifying this file. Required.
       *
       * All keys must sign to modify the file's contents or keys. No key is required
       * to sign for extending the expiration time (except the one for the operator account
       * paying for the transaction). Only one key must sign to delete the file, however.
       *
       * To require more than one key to sign to delete a file, add them to a
       * KeyList and pass that here.
       *
       * The network currently requires a file to have at least one key (or key list or threshold key)
       * but this requirement may be lifted in the future.
       *
       * @param {FileId | string} fileId
       * @returns {this}
       */
      setFileId(fileId) {
          this._requireNotFrozen();
          this._fileId =
              typeof fileId === "string"
                  ? FileId.fromString(fileId)
                  : fileId.clone();

          return this;
      }

      /**
       * @returns {?Key[]}
       */
      get keys() {
          return this._keys;
      }

      /**
       * Set the keys which must sign any transactions modifying this file. Required.
       *
       * All keys must sign to modify the file's contents or keys. No key is required
       * to sign for extending the expiration time (except the one for the operator account
       * paying for the transaction). Only one key must sign to delete the file, however.
       *
       * To require more than one key to sign to delete a file, add them to a
       * KeyList and pass that here.
       *
       * The network currently requires a file to have at least one key (or key list or threshold key)
       * but this requirement may be lifted in the future.
       *
       * @param {Key[] | KeyList} keys
       * @returns {this}
       */
      setKeys(keys) {
          this._requireNotFrozen();
          if (keys instanceof KeyList && keys.threshold != null) {
              throw new Error("Cannot set threshold key as file key");
          }

          this._keys = keys instanceof KeyList ? keys.toArray() : keys;

          return this;
      }

      /**
       * @returns {?Timestamp}
       */
      get expirationTime() {
          return this._expirationTime;
      }

      /**
       * Set the instant at which this file will expire, after which its contents will no longer be
       * available.
       *
       * Defaults to 1/4 of a Julian year from the instant FileUpdateTransaction
       * was invoked.
       *
       * May be extended using FileUpdateTransaction#setExpirationTime(Timestamp).
       *
       * @param {Timestamp | Date} expirationTime
       * @returns {this}
       */
      setExpirationTime(expirationTime) {
          this._requireNotFrozen();
          this._expirationTime =
              expirationTime instanceof Timestamp
                  ? expirationTime
                  : Timestamp.fromDate(expirationTime);

          return this;
      }

      /**
       * @returns {?Uint8Array}
       */
      get contents() {
          return this._contents;
      }

      /**
       * Set the given byte array as the file's contents.
       *
       * This may be omitted to update an empty file.
       *
       * Note that total size for a given transaction is limited to 6KiB (as of March 2020) by the
       * network; if you exceed this you may receive a HederaPreCheckStatusException
       * with Status#TransactionOversize.
       *
       * In this case, you will need to break the data into chunks of less than ~6KiB and execute this
       * transaction with the first chunk and then use FileAppendTransaction with
       * FileAppendTransaction#setContents(Uint8Array) for the remaining chunks.
       *
       * @param {Uint8Array | string} contents
       * @returns {this}
       */
      setContents(contents) {
          this._requireNotFrozen();
          this._contents =
              contents instanceof Uint8Array ? contents : encode$1(contents);

          return this;
      }

      /**
       * @returns {?string}
       */
      get fileMemo() {
          return this._fileMemo;
      }

      /**
       * @param {string} memo
       * @returns {this}
       */
      setFileMemo(memo) {
          this._requireNotFrozen();
          this._fileMemo = memo;

          return this;
      }

      /**
       * @returns {this}
       */
      clearFileMemo() {
          this._requireNotFrozen();
          this._fileMemo = null;

          return this;
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          if (this._fileId != null) {
              this._fileId.validateChecksum(client);
          }
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.ITransaction} request
       * @returns {Promise<HieroProto.proto.ITransactionResponse>}
       */
      _execute(channel, request) {
          return channel.file.updateFile(request);
      }

      /**
       * @override
       * @protected
       * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "fileUpdate";
      }

      /**
       * @override
       * @protected
       * @returns {HieroProto.proto.IFileUpdateTransactionBody}
       */
      _makeTransactionData() {
          return {
              fileID: this._fileId != null ? this._fileId._toProtobuf() : null,
              keys:
                  this._keys != null
                      ? {
                            keys: this._keys.map((key) => key._toProtobufKey()),
                        }
                      : null,
              expirationTime:
                  this._expirationTime != null
                      ? this._expirationTime._toProtobuf()
                      : null,
              contents: this._contents,
              memo:
                  this._fileMemo != null
                      ? {
                            value: this._fileMemo,
                        }
                      : null,
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("../Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `FileUpdateTransaction:${timestamp.toString()}`;
      }
  }

  // eslint-disable-next-line @typescript-eslint/unbound-method
  TRANSACTION_REGISTRY.set("fileUpdate", FileUpdateTransaction._fromProtobuf);

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
   * @typedef {import("@hashgraph/proto").proto.ICryptoAddLiveHashTransactionBody} HieroProto.proto.ICryptoAddLiveHashTransactionBody
   * @typedef {import("@hashgraph/proto").proto.ILiveHash} HieroProto.proto.ILiveHash
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   */

  /**
   * @deprecated
   * This transaction is no longer supported.
   */
  class LiveHashAddTransaction extends Transaction {
      /**
       * @param {object} [props]
       * @param {Uint8Array} [props.hash]
       * @param {Key[]} [props.keys]
       * @param {Duration | Long | number} [props.duration]
       * @param {AccountId | string} [props.accountId]
       */
      constructor(props = {}) {
          super();

          /**
           * @private
           * @type {?Uint8Array}
           */
          this._hash = null;

          /**
           * @private
           * @type {?Key[]}
           */
          this._keys = null;

          /**
           * @private
           * @type {?Duration}
           */
          this._duration = null;

          /**
           * @private
           * @type {?AccountId}
           */
          this._accountId = null;

          if (props.hash != null) {
              this.setHash(props.hash);
          }

          if (props.keys != null) {
              this.setKeys(props.keys);
          }

          if (props.duration != null) {
              this.setDuration(props.duration);
          }

          if (props.accountId != null) {
              this.setAccountId(props.accountId);
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransaction[]} transactions
       * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {HieroProto.proto.ITransactionBody[]} bodies
       * @returns {LiveHashAddTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];
          const hashes =
              /** @type {HieroProto.proto.ICryptoAddLiveHashTransactionBody} */ (
                  body.cryptoAddLiveHash
              );
          const liveHash_ = /** @type {HieroProto.proto.ILiveHash} */ (
              hashes.liveHash
          );

          return Transaction._fromProtobufTransactions(
              // eslint-disable-next-line deprecation/deprecation
              new LiveHashAddTransaction({
                  hash: liveHash_.hash != null ? liveHash_.hash : undefined,
                  keys:
                      liveHash_.keys != null
                          ? liveHash_.keys.keys != null
                              ? liveHash_.keys.keys.map((key) =>
                                    Key._fromProtobufKey(key),
                                )
                              : undefined
                          : undefined,
                  duration:
                      liveHash_.duration != null
                          ? liveHash_.duration.seconds != null
                              ? liveHash_.duration.seconds
                              : undefined
                          : undefined,
                  accountId:
                      liveHash_.accountId != null
                          ? AccountId._fromProtobuf(liveHash_.accountId)
                          : undefined,
              }),
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * @returns {?Uint8Array}
       */
      get hash() {
          return this._hash;
      }

      /**
       * @param {Uint8Array} hash
       * @returns {LiveHashAddTransaction}
       */
      setHash(hash) {
          this._requireNotFrozen();
          this._hash = hash;

          return this;
      }

      /**
       * @returns {?Key[]}
       */
      get keys() {
          return this._keys;
      }

      /**
       * @param {Key[] | KeyList} keys
       * @returns {LiveHashAddTransaction}
       */
      setKeys(keys) {
          this._requireNotFrozen();
          this._keys = keys instanceof KeyList ? keys.toArray() : keys;

          return this;
      }

      /**
       * @returns {?Duration}
       */
      get duration() {
          return this._duration;
      }

      /**
       * @param {Duration | Long | number} duration
       * @returns {LiveHashAddTransaction}
       */
      setDuration(duration) {
          this._requireNotFrozen();
          this._duration =
              duration instanceof Duration ? duration : new Duration(duration);

          return this;
      }

      /**
       * @returns {?AccountId}
       */
      get accountId() {
          return this._accountId;
      }

      /**
       * @param {AccountId | string} accountId
       * @returns {LiveHashAddTransaction}
       */
      setAccountId(accountId) {
          this._requireNotFrozen();
          this._accountId =
              typeof accountId === "string"
                  ? AccountId.fromString(accountId)
                  : accountId.clone();

          return this;
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          if (this._accountId != null) {
              this._accountId.validateChecksum(client);
          }
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.ITransaction} request
       * @returns {Promise<HieroProto.proto.ITransactionResponse>}
       */
      _execute(channel, request) {
          return channel.crypto.addLiveHash(request);
      }

      /**
       * @override
       * @protected
       * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "cryptoAddLiveHash";
      }

      /**
       * @override
       * @protected
       * @returns {HieroProto.proto.ICryptoAddLiveHashTransactionBody}
       */
      _makeTransactionData() {
          return {
              liveHash: {
                  hash: this._hash,
                  keys:
                      this._keys != null
                          ? {
                                keys: this._keys.map((key) =>
                                    key._toProtobufKey(),
                                ),
                            }
                          : undefined,
                  duration:
                      this._duration != null
                          ? this._duration._toProtobuf()
                          : null,
                  accountId:
                      this._accountId != null
                          ? this._accountId._toProtobuf()
                          : null,
              },
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("../Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `LiveHashAddTransaction:${timestamp.toString()}`;
      }
  }

  TRANSACTION_REGISTRY.set(
      "cryptoAddLiveHash",
      // eslint-disable-next-line @typescript-eslint/unbound-method, deprecation/deprecation
      LiveHashAddTransaction._fromProtobuf,
  );

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
   * @typedef {import("@hashgraph/proto").proto.ICryptoDeleteLiveHashTransactionBody} HieroProto.proto.ICryptoDeleteLiveHashTransactionBody
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   */

  /**
   * @deprecated
   * This transaction is no longer supported.
   */
  class LiveHashDeleteTransaction extends Transaction {
      /**
       * @param {object} [props]
       * @param {Uint8Array} [props.hash]
       * @param {AccountId | string} [props.accountId]
       */
      constructor(props = {}) {
          super();

          /**
           * @private
           * @type {?Uint8Array}
           */
          this._hash = null;

          /**
           * @private
           * @type {?AccountId}
           */
          this._accountId = null;

          if (props.hash != null) {
              this.setHash(props.hash);
          }

          if (props.accountId != null) {
              this.setAccountId(props.accountId);
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransaction[]} transactions
       * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {HieroProto.proto.ITransactionBody[]} bodies
       * @returns {LiveHashDeleteTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];
          const hashes =
              /** @type {HieroProto.proto.ICryptoDeleteLiveHashTransactionBody} */ (
                  body.cryptoDeleteLiveHash
              );

          return Transaction._fromProtobufTransactions(
              // eslint-disable-next-line deprecation/deprecation
              new LiveHashDeleteTransaction({
                  hash:
                      hashes.liveHashToDelete != null
                          ? hashes.liveHashToDelete
                          : undefined,
                  accountId:
                      hashes.accountOfLiveHash != null
                          ? AccountId._fromProtobuf(hashes.accountOfLiveHash)
                          : undefined,
              }),
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * @returns {?Uint8Array}
       */
      get hash() {
          return this._hash;
      }

      /**
       * @param {Uint8Array} hash
       * @returns {LiveHashDeleteTransaction}
       */
      setHash(hash) {
          this._requireNotFrozen();
          this._hash = hash;

          return this;
      }

      /**
       * @returns {?AccountId}
       */
      get accountId() {
          return this._accountId;
      }

      /**
       * @param {AccountId | string} accountId
       * @returns {LiveHashDeleteTransaction}
       */
      setAccountId(accountId) {
          this._requireNotFrozen();
          this._accountId =
              typeof accountId === "string"
                  ? AccountId.fromString(accountId)
                  : accountId.clone();

          return this;
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          if (this._accountId != null) {
              this._accountId.validateChecksum(client);
          }
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.ITransaction} request
       * @returns {Promise<HieroProto.proto.ITransactionResponse>}
       */
      _execute(channel, request) {
          return channel.crypto.deleteLiveHash(request);
      }

      /**
       * @override
       * @protected
       * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "cryptoDeleteLiveHash";
      }

      /**
       * @override
       * @protected
       * @returns {HieroProto.proto.ICryptoDeleteLiveHashTransactionBody}
       */
      _makeTransactionData() {
          return {
              liveHashToDelete: this._hash,
              accountOfLiveHash:
                  this._accountId != null ? this._accountId._toProtobuf() : null,
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("../Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `LiveHashDeleteTransaction:${timestamp.toString()}`;
      }
  }

  TRANSACTION_REGISTRY.set(
      "cryptoDeleteLiveHash",
      // eslint-disable-next-line @typescript-eslint/unbound-method, deprecation/deprecation
      LiveHashDeleteTransaction._fromProtobuf,
  );

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.IQuery} HieroProto.proto.IQuery
   * @typedef {import("@hashgraph/proto").proto.IQueryHeader} HieroProto.proto.IQueryHeader
   * @typedef {import("@hashgraph/proto").proto.IResponse} HieroProto.proto.IResponse
   * @typedef {import("@hashgraph/proto").proto.IResponseHeader} HieroProto.proto.IResponseHeader
   * @typedef {import("@hashgraph/proto").proto.ICryptoGetLiveHashQuery} HieroProto.proto.ICryptoGetLiveHashQuery
   * @typedef {import("@hashgraph/proto").proto.ICryptoGetLiveHashResponse} HieroProto.proto.ICryptoGetLiveHashResponse
   * @typedef {import("@hashgraph/proto").proto.ILiveHash} HieroProto.proto.ILiveHash
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   */

  /**
   * @augments {Query<LiveHash>}
   * @deprecated
   * his query is no longer supported.
   */
  class LiveHashQuery extends Query {
      /**
       * @param {object} [props]
       * @param {AccountId | string} [props.accountId]
       * @param {Uint8Array} [props.hash]
       */
      constructor(props = {}) {
          super();

          /**
           * @type {?AccountId}
           * @private
           */
          this._accountId = null;

          if (props.accountId != null) {
              this.setAccountId(props.accountId);
          }

          /**
           * @type {?Uint8Array}
           * @private
           */
          this._hash = null;

          if (props.hash != null) {
              this.setHash(props.hash);
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.IQuery} query
       * @returns {LiveHashQuery}
       */
      static _fromProtobuf(query) {
          const hash = /** @type {HieroProto.proto.ICryptoGetLiveHashQuery} */ (
              query.cryptoGetLiveHash
          );

          // eslint-disable-next-line deprecation/deprecation
          return new LiveHashQuery({
              accountId:
                  hash.accountID != null
                      ? AccountId._fromProtobuf(hash.accountID)
                      : undefined,
              hash: hash.hash != null ? hash.hash : undefined,
          });
      }

      /**
       * @returns {?AccountId}
       */
      get accountId() {
          return this._accountId;
      }

      /**
       * Set the account to which the livehash is associated.
       *
       * @param {AccountId | string} accountId
       * @returns {this}
       */
      setAccountId(accountId) {
          this._accountId =
              accountId instanceof AccountId
                  ? accountId
                  : AccountId.fromString(accountId);

          return this;
      }

      /**
       * @returns {?Uint8Array}
       */
      get liveHash() {
          return this._hash;
      }

      /**
       * Set the SHA-384 data in the livehash.
       *
       * @param {Uint8Array} hash
       * @returns {this}
       */
      setHash(hash) {
          this._hash = hash;

          return this;
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          if (this._accountId != null) {
              this._accountId.validateChecksum(client);
          }
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.IQuery} request
       * @returns {Promise<HieroProto.proto.IResponse>}
       */
      _execute(channel, request) {
          return channel.crypto.getLiveHash(request);
      }

      /**
       * @override
       * @internal
       * @param {HieroProto.proto.IResponse} response
       * @returns {HieroProto.proto.IResponseHeader}
       */
      _mapResponseHeader(response) {
          const cryptoGetLiveHash =
              /** @type {HieroProto.proto.ICryptoGetLiveHashResponse} */ (
                  response.cryptoGetLiveHash
              );
          return /** @type {HieroProto.proto.IResponseHeader} */ (
              cryptoGetLiveHash.header
          );
      }

      /**
       * @protected
       * @override
       * @param {HieroProto.proto.IResponse} response
       * @returns {Promise<LiveHash>}
       */
      _mapResponse(response) {
          const hashes =
              /** @type {HieroProto.proto.ICryptoGetLiveHashResponse} */ (
                  response.cryptoGetLiveHash
              );

          return Promise.resolve(
              LiveHash._fromProtobuf(
                  /** @type {HieroProto.proto.ILiveHash} */ (hashes.liveHash),
              ),
          );
      }

      /**
       * @override
       * @internal
       * @param {HieroProto.proto.IQueryHeader} header
       * @returns {HieroProto.proto.IQuery}
       */
      _onMakeRequest(header) {
          return {
              cryptoGetLiveHash: {
                  header,
                  accountID:
                      this._accountId != null
                          ? this._accountId._toProtobuf()
                          : null,
                  hash: this._hash,
              },
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp =
              this._paymentTransactionId != null &&
              this._paymentTransactionId.validStart != null
                  ? this._paymentTransactionId.validStart
                  : this._timestamp;

          return `LiveHashQuery:${timestamp.toString()}`;
      }
  }

  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/unbound-method, deprecation/deprecation
  QUERY_REGISTRY.set("cryptoGetLiveHash", LiveHashQuery._fromProtobuf);

  /**
   * @typedef {import("../contract/ContractId").default} ContractId
   * @typedef {import("../account/AccountId").default} AccountId
   * @typedef {import("../client/Client.js").default<*, *>} Client
   *
   */

  /**
   * @typedef {object} MirrorNodeResponse
   * @property {string} result
   * @property {string} [error]
   * @property {string} [gasUsed]
   * @property {string} [contractAddress]
   * @property {string} [status]
   */

  /**
   * MirrorNodeContractQuery returns a result from EVM execution such as cost-free execution of read-only smart contract
   * queries, gas estimation, and transient simulation of read-write operations.
   * When working with sender that has ECDSA key with alias, you MUST:
   * 1. Retrieve the account's EVM address from the Mirror Node API first
   * 2. Use setSenderEvmAddress() instead of setSender()
   *
   * This is because EVM addresses for accounts with ECDSA keys and aliases cannot be automatically
   * derived and must be fetched from the Mirror Node. Example:
   *
   * ```javascript
   * // For accounts with ECDSA keys and aliases:
   * const evmAddress = // ... fetch from Mirror Node API ...
   * query.setSenderEvmAddress(evmAddress);
   * ```
   */
  class MirrorNodeContractQuery {
      constructor() {
          this._contractId = null;
          this._contractEvmAddress = null;
          this._sender = null;
          this._senderEvmAddress = null;
          this._functionName = null;
          this._functionParameters = null;
          this._value = null;
          this._gasLimit = null;
          this._gasPrice = null;
          this._blockNumber = null;
      }

      /**
       *
       * @param {ContractId} contractId
       * @description Sets the contract instance to call.
       * @returns {this}
       */
      setContractId(contractId) {
          this._contractId = contractId;
          return this;
      }

      /**
       * @param {AccountId} sender
       * @description Sets the sender of the transaction simulation.
       * @returns {this}
       */
      setSender(sender) {
          this._sender = sender;
          return this;
      }

      /**
       * @param {string} sender
       * @description Set the 20-byte EVM address of the sender.
       * This method must be used explicitly when working with accounts that have ECDSA keys with aliases,
       * as their EVM addresses cannot be automatically derived and must be retrieved from the Mirror Node API.
       * The EVM address can be filled using `accountId.populateAccountEvmAddress(client)`
       * @returns {this}
       */
      setSenderEvmAddress(sender) {
          this._senderEvmAddress = sender;
          return this;
      }

      /**
       *
       * @param {string} name
       * @param {ContractFunctionParameters} functionParameters
       * @description Sets the function to call, and the parameters to pass to the function
       * @returns {this}
       */
      setFunction(name, functionParameters) {
          this._functionParameters =
              functionParameters != null
                  ? functionParameters._build(name)
                  : new ContractFunctionParameters()._build(name);

          return this;
      }

      /**
       * @param {Long} value
       * @description Sets the amount of value (in tinybars or wei) to be sent to the contract in the transaction.
       * Use this to specify an amount for a payable function call.
       * @returns {this}
       */
      setValue(value) {
          this._value = value;
          return this;
      }

      /**
       * @param {Long} gasLimit
       * @description Sets the gas limit for the contract call.
       * This specifies the maximum amount of gas that the transaction can consume.
       * @returns {this}
       */
      setGasLimit(gasLimit) {
          this._gasLimit = gasLimit;
          return this;
      }

      /**
       * @param {Long} gasPrice
       * @description Sets the gas price to be used for the contract call. This specifies the price of each unit of gas used in the transaction.
       * @returns {this}
       */
      setGasPrice(gasPrice) {
          this._gasPrice = gasPrice;
          return this;
      }

      /**
       * @param {Long} blockNumber
       * @description  Sets the block number for the simulation of the contract call.
       * The block number determines the context of the contract call simulation within the blockchain.
       * @returns {this}
       */
      setBlockNumber(blockNumber) {
          this._blockNumber = blockNumber;
          return this;
      }

      /**
       * @returns {ContractId?}
       */
      get contractId() {
          return this._contractId;
      }

      /**
       * @returns {string}
       */
      get contractEvmAddress() {
          const solidityAddress = this._contractId?.toEvmAddress();
          if (solidityAddress == null) {
              throw new Error("Contract ID is not set");
          }
          return solidityAddress;
      }

      /**
       * @returns {AccountId?}
       */
      get sender() {
          return this._sender;
      }

      /**
       * @returns {string | null }
       */
      get senderEvmAddress() {
          return this._senderEvmAddress;
      }

      /**
       * @returns {Uint8Array | null | undefined}
       */
      get callData() {
          return this._functionParameters;
      }

      /**
       * @returns {Long?}
       */
      get value() {
          return this._value;
      }

      /**
       * @returns {Long?}
       */
      get gasLimit() {
          return this._gasLimit;
      }

      /**
       * @returns {Long?}
       */
      get gasPrice() {
          return this._gasPrice;
      }

      /**
       * @returns {Long?}
       */
      get blockNumber() {
          return this._blockNumber;
      }

      /**
       *
       * @param {Client} client
       * @param {object} jsonPayload
       * @returns {Promise<MirrorNodeResponse>}
       */
      async performMirrorNodeRequest(client, jsonPayload) {
          if (this.contractId == null) {
              throw new Error("Contract ID is not set");
          }
          this._fillEvmAddress();
          let mirrorRestApiBaseUrl = client.mirrorRestApiBaseUrl;
          const contractCallEndpointPath = "/contracts/call";

          // Check if this is a local environment (localhost or 127.0.0.1)
          const mirrorNode = client._mirrorNetwork.getNextMirrorNode();
          const host = mirrorNode.address.address;
          const isLocalEnvironment = host === "localhost" || host === "127.0.0.1";

          if (isLocalEnvironment) {
              // For local environments, use HTTP scheme and port 8545 for contract calls
              // (different from general mirror node REST API port 5551)
              const url = new URL(mirrorRestApiBaseUrl);
              url.protocol = "http:";
              url.port = "8545";
              mirrorRestApiBaseUrl = url.toString();
          }

          const contractCallEndpointUrl = `${mirrorRestApiBaseUrl}${contractCallEndpointPath}`;

          // eslint-disable-next-line n/no-unsupported-features/node-builtins
          const response = await fetch(contractCallEndpointUrl, {
              method: "POST",
              headers: {
                  "Content-Type": "application/json",
              },
              body: JSON.stringify(jsonPayload),
          });

          if (!response.ok) {
              throw new Error(`HTTP error! status: ${response.status}`);
          }

          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
          const data = /** @type {MirrorNodeResponse} */ (await response.json());
          return data;
      }

      _fillEvmAddress() {
          if (this.senderEvmAddress == null && this.sender != null) {
              this._senderEvmAddress = this.sender.toEvmAddress();
          }
      }
      // eslint-disable-next-line jsdoc/require-returns-check
      /**
       * @returns {object}
       */
      get JSONPayload() {
          throw new Error(
              "JSONPayload getter is not implemented. Please implement this method in the subclass.",
          );
      }
  }

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   */

  /**
   A query that simulates a contract function call using the Hedera Mirror Node.
   * 
   * This query allows you to execute a read-only smart contract call without submitting a transaction
   * to the main network. It's useful for querying contract state or executing view/pure functions.
   * The simulation is performed against the state of the contract at a specific block height.
   */
  class MirrorNodeContractCallQuery extends MirrorNodeContractQuery {
      /**
       * @returns {object}
       */
      get JSONPayload() {
          if (this.callData == null) {
              throw new Error("Call data is required.");
          }

          return {
              data: encode$5(this.callData),
              from: this.senderEvmAddress,
              to: this.contractEvmAddress,
              estimate: false,
              gasPrice: this.gasPrice?.toString(),
              gas: this.gasLimit?.toString(),
              blockNumber: this.blockNumber?.toString(),
              value: this.value?.toString(),
          };
      }

      /**
       * @param {Client} client
       * @returns {Promise<string>}
       */
      async execute(client) {
          const mirrorNodeRequest = await this.performMirrorNodeRequest(
              client,
              this.JSONPayload,
          );

          return mirrorNodeRequest.result;
      }
  }

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   */

  /**
   * A query that estimates the gas required for a contract function call using the Hedera Mirror Node.
   *
   * This query simulates a contract call to estimate the amount of gas that would be required
   * to execute the same call on the main network. It's useful for determining the appropriate
   * gas limit before submitting an actual transaction.
   */
  class MirrorNodeContractEstimateQuery extends MirrorNodeContractQuery {
      /**
       * @returns {object}
       */
      get JSONPayload() {
          if (this.callData == null) {
              throw new Error("Call data is required.");
          }

          return {
              data: encode$5(this.callData),
              from: this.senderEvmAddress,
              to: this.contractEvmAddress,
              estimate: true,
              gasPrice: this.gasPrice?.toString(),
              gas: this.gasLimit?.toString(),
              blockNumber: this.blockNumber?.toString(),
              value: this.value?.toString(),
          };
      }

      /**
       * @param {Client} client
       * @returns {Promise<number>}
       */
      async execute(client) {
          const mirrorNodeRequest = await this.performMirrorNodeRequest(
              client,
              this.JSONPayload,
          );

          return Number(mirrorNodeRequest.result);
      }
  }

  // SPDX-License-Identifier: Apache-2.0

  class IPv4AddressPart {
      /**
       * @param {object} props
       * @param {number} [props.left]
       * @param {number} [props.right]
       */
      constructor(props = {}) {
          /**
           * @type {number | null}
           */
          this._left = null;

          if (props.left != null) {
              this.setLeft(props.left);
          }

          /**
           * @type {number | null}
           */
          this._right = null;

          if (props.right != null) {
              this.setRight(props.right);
          }
      }

      /**
       * @returns {?number}
       */
      get left() {
          return this._left;
      }

      /**
       * @param {number} part
       * @returns {this}
       */
      setLeft(part) {
          this._left = part;
          return this;
      }

      /**
       * @returns {?number}
       */
      get right() {
          return this._right;
      }

      /**
       * @param {number} part
       * @returns {this}
       */
      setRight(part) {
          this._right = part;
          return this;
      }

      /**
       * @returns {string}
       */
      toString() {
          if (this._left != null && this._right != null) {
              return `${this._left.toString()}.${this._right.toString()}`;
          } else {
              return "";
          }
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  class IPv4Address {
      /**
       * @param {object} props
       * @param {IPv4AddressPart} [props.network]
       * @param {IPv4AddressPart} [props.host]
       */
      constructor(props = {}) {
          /**
           * @type {IPv4AddressPart | null}
           */
          this._network = null;

          if (props.network != null) {
              this.setNetwork(props.network);
          }

          /**
           * @type {IPv4AddressPart | null}
           */
          this._host = null;

          if (props.host != null) {
              this.setHost(props.host);
          }
      }

      /**
       * @returns {?IPv4AddressPart}
       */
      get newtork() {
          return this._network;
      }

      /**
       * @param {IPv4AddressPart} part
       * @returns {this}
       */
      setNetwork(part) {
          this._network = part;
          return this;
      }

      /**
       * @returns {?IPv4AddressPart}
       */
      get host() {
          return this._host;
      }

      /**
       * @param {IPv4AddressPart} part
       * @returns {this}
       */
      setHost(part) {
          this._host = part;
          return this;
      }

      /**
       * @internal
       * @param {Uint8Array} bytes
       * @returns {IPv4Address}
       */
      static _fromProtobuf(bytes) {
          return new IPv4Address({
              network: new IPv4AddressPart().setLeft(bytes[0]).setRight(bytes[1]),
              host: new IPv4AddressPart().setLeft(bytes[2]).setRight(bytes[3]),
          });
      }

      /**
       * @returns {Uint8Array}
       */
      _toProtobuf() {
          return Uint8Array.of(
              this._network != null && this._network._left != null
                  ? this._network._left
                  : 0,
              this._network != null && this._network.right != null
                  ? this._network.right
                  : 0,
              this._host != null && this._host.left != null ? this._host.left : 0,
              this._host != null && this._host.right != null
                  ? this._host.right
                  : 0,
          );
      }

      /**
       * @internal
       * @param {string} address - IPv4 address string in format "x.x.x.x"
       * @returns {IPv4Address}
       * @throws {Error} If the address string is invalid
       */
      static _fromString(address) {
          const parts = address.split(".");
          if (parts.length !== 4) {
              throw new Error("Invalid IPv4 address format");
          }

          const network = new IPv4AddressPart()
              .setLeft(Number(parts[0]))
              .setRight(Number(parts[1]));
          const host = new IPv4AddressPart()
              .setLeft(Number(parts[2]))
              .setRight(Number(parts[3]));

          return new IPv4Address({ network, host });
      }

      /**
       * @returns {string}
       */
      toString() {
          if (this._network != null && this._host != null) {
              return `${this._network.toString()}.${this._host.toString()}`;
          } else {
              return "";
          }
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.IServiceEndpoint} HieroProto.proto.IServiceEndpoint
   */

  /**
   * @typedef {object} EndPointJson
   * @property {string | null} address
   * @property {string | null} port
   */

  class EndPoint {
      /**
       * @param {object} props
       * @param {IPv4Address | string} [props.address]
       * @param {number} [props.port]
       */
      constructor(props = {}) {
          /**
           * @type {IPv4Address | string | null}
           */
          this._address = null;

          if (props.address != null) {
              this.setAddress(props.address);
          }

          /**
           * @type {number | null}
           */
          this._port = null;

          if (props.port != null) {
              this.setPort(props.port);
          }
      }

      /**
       * @returns {?IPv4Address | string}
       */
      get address() {
          return this._address;
      }

      /**
       * @param {IPv4Address | string} address
       * @returns {this}
       */
      setAddress(address) {
          this._address = address;
          return this;
      }

      /**
       * @returns {?number}
       */
      get port() {
          return this._port;
      }

      /**
       * @param {number} port
       * @returns {this}
       */
      setPort(port) {
          this._port = port;
          return this;
      }

      /**
       * @internal
       * @param {HieroProto.proto.IServiceEndpoint} endpoint
       * @returns {EndPoint}
       */
      static _fromProtobuf(endpoint) {
          let address;

          if (endpoint.domainName) {
              address = endpoint.domainName;
          } else if (endpoint.ipAddressV4) {
              address = IPv4Address._fromProtobuf(endpoint.ipAddressV4);
          }

          return new EndPoint({
              address: address,
              port: endpoint.port != null ? endpoint.port : undefined,
          });
      }

      /**
       * @returns {HieroProto.proto.IServiceEndpoint}
       */
      _toProtobuf() {
          if (typeof this._address !== "string") {
              return {
                  ipAddressV4:
                      this._address != null ? this._address._toProtobuf() : null,
                  port: this._port,
              };
          }

          return {
              domainName: this._address,
              port: this._port,
          };
      }

      /**
       * @param {EndPointJson} json
       * @returns {EndPoint}
       */
      static fromJSON(json) {
          return new EndPoint({
              address: json.address || undefined,
              port: json.port != null ? parseInt(json.port, 10) : undefined,
          });
      }

      /**
       * @returns {string}
       */
      toString() {
          return `${this._address != null ? this._address.toString() : ""}:${
            this._port != null ? this._port.toString() : ""
        }`;
      }

      /**
       * @returns {EndPointJson}
       */
      toJSON() {
          return {
              address: this._address != null ? this._address.toString() : null,
              port: this._port != null ? this._port.toString() : null,
          };
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.INodeAddress} HieroProto.proto.INodeAddress
   */

  /**
   * @typedef {import("./Endpoint.js").EndPointJson} EndpointJson
   */

  /**
   * @typedef {object} NodeAddressJson
   * @property {string | null} publicKey
   * @property {string | null} nodeId
   * @property {string | null} accountId
   * @property {string | null} certHash
   * @property {EndpointJson[] | null} addresses
   * @property {string | null} description
   * @property {string | null} stake
   */

  class NodeAddress {
      /**
       * @param {object} props
       * @param {string} [props.publicKey]
       * @param {Long} [props.nodeId]
       * @param {AccountId | string} [props.accountId]
       * @param {Uint8Array} [props.certHash]
       * @param {Endpoint[]} [props.addresses]
       * @param {string} [props.description]
       * @param {Long} [props.stake]
       */
      constructor(props = {}) {
          /**
           * @type {string | null}
           */
          this._publicKey = null;

          if (props.publicKey != null) {
              this.setPublicKey(props.publicKey);
          }

          /**
           * @type {Long |null}
           */
          this._nodeId = null;

          if (props.nodeId != null) {
              this.setNodeId(props.nodeId);
          }

          /**
           * @type {AccountId | null}
           */
          this._accountId = null;

          if (props.accountId != null) {
              this.setAccountId(props.accountId);
          }

          /**
           * @type {Uint8Array | null}
           */
          this._certHash = null;

          if (props.certHash != null) {
              this.setCertHash(props.certHash);
          }

          /**
           * @type {Endpoint[]}
           */
          this._addresses = [];

          if (props.addresses != null) {
              this.setAddresses(props.addresses);
          }

          /**
           * @type {string | null}
           */
          this._description = null;

          if (props.description != null) {
              this.setDescription(props.description);
          }

          /**
           * @type {Long | null}
           */
          this._stake = null;

          if (props.stake != null) {
              this.setStake(props.stake);
          }
      }

      /**
       * @returns {?string}
       */
      get publicKey() {
          return this._publicKey;
      }

      /**
       * @param {string} publicKey
       * @returns {this}
       */
      setPublicKey(publicKey) {
          this._publicKey = publicKey;
          return this;
      }

      /**
       * @returns {?Long}
       */
      get nodeId() {
          return this._nodeId;
      }

      /**
       * @param {Long} nodeId
       * @returns {this}
       */
      setNodeId(nodeId) {
          this._nodeId = nodeId;
          return this;
      }

      /**
       * @returns {?AccountId}
       */
      get accountId() {
          return this._accountId;
      }

      /**
       * @param {AccountId | string} accountId
       * @returns {this}
       */
      setAccountId(accountId) {
          this._accountId =
              typeof accountId === "string"
                  ? AccountId.fromString(accountId)
                  : accountId.clone();
          return this;
      }

      /**
       * @returns {?Uint8Array}
       */
      get certHash() {
          return this._certHash;
      }

      /**
       * @param {Uint8Array} certHash
       * @returns {this}
       */
      setCertHash(certHash) {
          this._certHash = certHash;
          return this;
      }

      /**
       * @returns {Endpoint[]}
       */
      get addresses() {
          return this._addresses;
      }

      /**
       * @param {Endpoint[]} addresses
       * @returns {this}
       */
      setAddresses(addresses) {
          this._addresses = addresses;
          return this;
      }

      /**
       * @returns {?string}
       */
      get description() {
          return this._description;
      }

      /**
       * @param {string} description
       * @returns {this}
       */
      setDescription(description) {
          this._description = description;
          return this;
      }

      /**
       * @returns {?Long}
       */
      get stake() {
          return this._stake;
      }

      /**
       * @param {Long} stake
       * @returns {this}
       */
      setStake(stake) {
          this._stake = stake;
          return this;
      }

      /**
       * @internal
       * @param {HieroProto.proto.INodeAddress} nodeAddress
       * @returns {NodeAddress}
       */
      static _fromProtobuf(nodeAddress) {
          return new NodeAddress({
              publicKey:
                  nodeAddress.RSA_PubKey != null
                      ? nodeAddress.RSA_PubKey
                      : undefined,
              nodeId: nodeAddress.nodeId != null ? nodeAddress.nodeId : undefined,
              accountId:
                  nodeAddress.nodeAccountId != null
                      ? AccountId._fromProtobuf(nodeAddress.nodeAccountId)
                      : undefined,
              certHash:
                  nodeAddress.nodeCertHash != null
                      ? nodeAddress.nodeCertHash
                      : undefined,
              addresses:
                  nodeAddress.serviceEndpoint != null
                      ? nodeAddress.serviceEndpoint.map((address) =>
                            EndPoint._fromProtobuf(address),
                        )
                      : undefined,
              description:
                  nodeAddress.description != null
                      ? nodeAddress.description
                      : undefined,
              stake: nodeAddress.stake != null ? nodeAddress.stake : undefined,
          });
      }

      /**
       * @returns {HieroProto.proto.INodeAddress}
       */
      _toProtobuf() {
          return {
              RSA_PubKey: this._publicKey,
              nodeId: this._nodeId,
              nodeAccountId:
                  this._accountId != null ? this._accountId._toProtobuf() : null,
              nodeCertHash: this._certHash,
              serviceEndpoint: this._addresses.map((address) =>
                  address._toProtobuf(),
              ),
              description: this._description,
              stake: this._stake,
          };
      }

      /**
       * @param {NodeAddressJson} json
       * @returns {NodeAddress}
       */
      static fromJSON(json) {
          return new NodeAddress({
              publicKey: json.publicKey ?? undefined,
              nodeId:
                  json.nodeId != null ? Long.fromString(json.nodeId) : undefined,
              accountId: json.accountId
                  ? AccountId.fromString(json.accountId)
                  : undefined,
              certHash:
                  json.certHash != null ? encode$1(json.certHash) : undefined,
              addresses:
                  json.addresses != null
                      ? json.addresses.map((address) =>
                            EndPoint.fromJSON(address),
                        )
                      : undefined,
              description: json.description ?? undefined,
              stake: json.stake != null ? Long.fromString(json.stake) : undefined,
          });
      }

      /**
       * @returns {string}
       */
      toString() {
          return JSON.stringify(this.toJSON());
      }

      /**
       * @returns {NodeAddressJson}
       */
      toJSON() {
          return {
              publicKey: this._publicKey,
              nodeId: this._nodeId != null ? this._nodeId.toString() : null,
              accountId:
                  this._accountId != null ? this._accountId.toString() : null,
              certHash:
                  this._certHash != null ? decode$1(this._certHash) : null,
              addresses: this._addresses.map((address) => address.toJSON()),
              description: this._description,
              stake: this._stake != null ? this._stake.toString() : null,
          };
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {import("./NodeAddress.js").NodeAddressJson} NodeAddressJson
   */

  /**
   * @typedef {object} NodeAddressBookJson
   * @property {NodeAddressJson[]} nodeAddresses
   */

  /**
   * Represents a collection of node addresses in the Hedera network.
   *
   * The NodeAddressBook contains information about the nodes in the Hedera network,
   * including their network addresses, account IDs, and node IDs. This class is used
   * to manage and access the network's node information.
   */
  class NodeAddressBook {
      /**
       * @param {object} props
       * @param {NodeAddress[]} [props.nodeAddresses]
       */
      constructor(props = {}) {
          /**
           * @type {NodeAddress[]}
           */
          this._nodeAddresses = [];

          if (props.nodeAddresses != null) {
              this.setNodeAddresses(props.nodeAddresses);
          }
      }

      /**
       * @returns {NodeAddress[]}
       */
      get nodeAddresses() {
          return this._nodeAddresses;
      }

      /**
       * @param {NodeAddress[]} nodeAddresses
       * @returns {this}
       */
      setNodeAddresses(nodeAddresses) {
          this._nodeAddresses = nodeAddresses;
          return this;
      }

      /**
       * @param {Uint8Array} bytes
       * @returns {NodeAddressBook}
       */
      static fromBytes(bytes) {
          return NodeAddressBook._fromProtobuf(
              libExports.proto.NodeAddressBook.decode(bytes),
          );
      }

      /**
       * @internal
       * @param {HieroProto.proto.INodeAddressBook} nodeAddressBook
       * @returns {NodeAddressBook}
       */
      static _fromProtobuf(nodeAddressBook) {
          return new NodeAddressBook({
              nodeAddresses:
                  nodeAddressBook.nodeAddress != null
                      ? nodeAddressBook.nodeAddress.map((nodeAddress) =>
                            NodeAddress._fromProtobuf(nodeAddress),
                        )
                      : undefined,
          });
      }

      /**
       * @returns {HieroProto.proto.INodeAddressBook}
       */
      _toProtobuf() {
          return {
              nodeAddress: this._nodeAddresses.map((nodeAddress) =>
                  nodeAddress._toProtobuf(),
              ),
          };
      }

      /**
       * @returns {string}
       */
      toString() {
          return JSON.stringify(this.toJSON());
      }

      /**
       * @returns {NodeAddressBookJson}
       */
      toJSON() {
          return {
              nodeAddresses: this._nodeAddresses.map((nodeAddress) =>
                  nodeAddress.toJSON(),
              ),
          };
      }

      toBytes() {
          return libExports.proto.NodeAddressBook.encode(
              this._toProtobuf(),
          ).finish();
      }
  }

  // SPDX-License-Identifier: Apache-2.0

  /**
   * Represents a semantic versioning structure for software components.
   *
   * This class encapsulates the major, minor, and patch version numbers, following
   * the Semantic Versioning (SemVer) specification. It provides methods for creating,
   * comparing, and manipulating version numbers, ensuring that versioning adheres to
   * the SemVer rules.
   */
  class SemanticVersion {
      /**
       * @private
       * @param {object} props
       * @param {number} props.major
       * @param {number} props.minor
       * @param {number} props.patch
       */
      constructor(props) {
          /** @readonly */
          this.major = props.major;
          /** @readonly */
          this.minor = props.minor;
          /** @readonly */
          this.patch = props.patch;

          Object.freeze(this);
      }

      /**
       * @internal
       * @param {HieroProto.proto.ISemanticVersion} version
       * @returns {SemanticVersion}
       */
      static _fromProtobuf(version) {
          return new SemanticVersion({
              major: /** @type {number} */ (version.major),
              minor: /** @type {number} */ (version.minor),
              patch: /** @type {number} */ (version.patch),
          });
      }

      /**
       * @internal
       * @returns {HieroProto.proto.ISemanticVersion}
       */
      _toProtobuf() {
          return {
              major: this.major,
              minor: this.minor,
              patch: this.patch,
          };
      }

      /**
       * @param {Uint8Array} bytes
       * @returns {SemanticVersion}
       */
      static fromBytes(bytes) {
          return SemanticVersion._fromProtobuf(
              libExports.proto.SemanticVersion.decode(bytes),
          );
      }

      /**
       * @returns {Uint8Array}
       */
      toBytes() {
          return libExports.proto.SemanticVersion.encode(
              this._toProtobuf(),
          ).finish();
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * Response when the client sends the node CryptoGetVersionInfoQuery.
   */
  class NetworkVersionInfo {
      /**
       * @private
       * @param {object} props
       * @param {SemanticVersion} props.protobufVersion
       * @param {SemanticVersion} props.servicesVersion
       */
      constructor(props) {
          /**
           * The account ID for which this information applies.
           *
           * @readonly
           */
          this.protobufVersion = props.protobufVersion;

          /**
           * The account ID for which this information applies.
           *
           * @readonly
           */
          this.servicesVersion = props.servicesVersion;

          Object.freeze(this);
      }

      /**
       * @internal
       * @param {HieroProto.proto.INetworkGetVersionInfoResponse} info
       * @returns {NetworkVersionInfo}
       */
      static _fromProtobuf(info) {
          return new NetworkVersionInfo({
              protobufVersion: SemanticVersion._fromProtobuf(
                  /** @type {HieroProto.proto.ISemanticVersion} */
                  (info.hapiProtoVersion),
              ),
              servicesVersion: SemanticVersion._fromProtobuf(
                  /** @type {HieroProto.proto.ISemanticVersion} */
                  (info.hederaServicesVersion),
              ),
          });
      }

      /**
       * @internal
       * @returns {HieroProto.proto.INetworkGetVersionInfoResponse}
       */
      _toProtobuf() {
          return {
              hapiProtoVersion: this.protobufVersion._toProtobuf(),
              hederaServicesVersion: this.servicesVersion._toProtobuf(),
          };
      }

      /**
       * @param {Uint8Array} bytes
       * @returns {NetworkVersionInfo}
       */
      static fromBytes(bytes) {
          return NetworkVersionInfo._fromProtobuf(
              libExports.proto.NetworkGetVersionInfoResponse.decode(bytes),
          );
      }

      /**
       * @returns {Uint8Array}
       */
      toBytes() {
          return libExports.proto.NetworkGetVersionInfoResponse.encode(
              this._toProtobuf(),
          ).finish();
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.IQuery} HieroProto.proto.IQuery
   * @typedef {import("@hashgraph/proto").proto.IQueryHeader} HieroProto.proto.IQueryHeader
   * @typedef {import("@hashgraph/proto").proto.IResponse} HieroProto.proto.IResponse
   * @typedef {import("@hashgraph/proto").proto.IResponseHeader} HieroProto.proto.IResponseHeader
   * @typedef {import("@hashgraph/proto").proto.INetworkGetVersionInfoQuery} HieroProto.proto.INetworkGetVersionInfoQuery
   * @typedef {import("@hashgraph/proto").proto.INetworkGetVersionInfoResponse} HieroProto.proto.INetworkGetVersionInfoResponse
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   */

  /**
   *
   * A query to retrieve version information about the Hedera network.
   *
   * This query returns information about the versions of both the Hedera Services software
   * and the protobuf schema in use by the network. This information is useful for ensuring
   * client-network compatibility and debugging version-related issues.
   *
   * @augments {Query<NetworkVersionInfo>}
   */
  class NetworkVersionInfoQuery extends Query {
      constructor() {
          super();
      }

      /**
       * @param {HieroProto.proto.IQuery} query
       * @returns {NetworkVersionInfoQuery}
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      static _fromProtobuf(query) {
          return new NetworkVersionInfoQuery();
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.IQuery} request
       * @returns {Promise<HieroProto.proto.IResponse>}
       */
      _execute(channel, request) {
          return channel.network.getVersionInfo(request);
      }

      /**
       * @override
       * @internal
       * @param {HieroProto.proto.IResponse} response
       * @returns {HieroProto.proto.IResponseHeader}
       */
      _mapResponseHeader(response) {
          const networkGetVersionInfo =
              /** @type {HieroProto.proto.INetworkGetVersionInfoResponse} */ (
                  response.networkGetVersionInfo
              );
          return /** @type {HieroProto.proto.IResponseHeader} */ (
              networkGetVersionInfo.header
          );
      }

      /**
       * @protected
       * @override
       * @param {HieroProto.proto.IResponse} response
       * @returns {Promise<NetworkVersionInfo>}
       */
      _mapResponse(response) {
          const info =
              /** @type {HieroProto.proto.INetworkGetVersionInfoResponse} */ (
                  response.networkGetVersionInfo
              );
          return Promise.resolve(NetworkVersionInfo._fromProtobuf(info));
      }

      /**
       * @override
       * @internal
       * @param {HieroProto.proto.IQueryHeader} header
       * @returns {HieroProto.proto.IQuery}
       */
      _onMakeRequest(header) {
          return {
              networkGetVersionInfo: {
                  header,
              },
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp =
              this._paymentTransactionId != null &&
              this._paymentTransactionId.validStart != null
                  ? this._paymentTransactionId.validStart
                  : this._timestamp;

          return `NetworkVersionInfoQuery:${timestamp.toString()}`;
      }
  }

  QUERY_REGISTRY.set(
      "networkGetVersionInfo",
      // eslint-disable-next-line @typescript-eslint/unbound-method
      NetworkVersionInfoQuery._fromProtobuf,
  );

  // SPDX-License-Identifier: Apache-2.0

  /**
   * @typedef {import("./LedgerId.js").default} LedgerId
   * @typedef {import("./transaction/TransactionId.js").default} TransactionId
   * @typedef {import("./transaction/Transaction.js").default} Transaction
   * @typedef {import("./transaction/TransactionResponse.js").default} TransactionResponse
   * @typedef {import("./transaction/TransactionReceipt.js").default} TransactionReceipt
   * @typedef {import("./transaction/TransactionRecord.js").default} TransactionRecord
   * @typedef {import("./account/AccountId.js").default} AccountId
   * @typedef {import("./account/AccountBalance.js").default} AccountBalance
   * @typedef {import("./account/AccountInfo.js").default} AccountInfo
   */

  /**
   * @template O
   * @typedef {import("./query/Query.js").default<O>} Query<O>
   */

  /**
   * @template RequestT
   * @template ResponseT
   * @template OutputT
   * @typedef {import("./Executable.js").default<RequestT, ResponseT, OutputT>} Executable<RequestT, ResponseT, OutputT>
   */

  /**
   * @typedef {object} Provider
   * @property {() => LedgerId?} getLedgerId
   * @property {() => {[key: string]: (string | AccountId)}} getNetwork
   * @property {() => string[]} getMirrorNetwork
   * @property {(accountId: AccountId | string) => Promise<AccountBalance>} getAccountBalance
   * @property {(accountId: AccountId | string) => Promise<AccountInfo>} getAccountInfo
   * @property {(accountId: AccountId | string) => Promise<TransactionRecord[]>} getAccountRecords
   * @property {(transactionId: TransactionId | string) => Promise<TransactionReceipt>} getTransactionReceipt
   * @property {(response: TransactionResponse) => Promise<TransactionReceipt>} waitForReceipt
   * @property {<RequestT, ResponseT, OutputT>(request: Executable<RequestT, ResponseT, OutputT>) => Promise<OutputT>} call
   */

  var Provider = {};

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   * @typedef {import("@hashgraph/proto").proto.Transaction} HieroProto.proto.Transaction
   * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.SignedTransaction} HieroProto.proto.SignedTransaction
   * @typedef {import("@hashgraph/proto").proto.IUtilPrngTransactionBody } HieroProto.proto.IUtilPrngTransactionBody
   * @typedef {import("@hashgraph/proto").proto.UtilPrngTransactionBody} HieroProto.proto.UtilPrngTransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.TransactionResponse
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
   * @typedef {import("./account/AccountId.js").default} AccountId
   * @typedef {import("./transaction/TransactionId.js").default} TransactionId
   */

  /**
   * @typedef {import("./client/Client.js").default<*, *>} Client
   *  @typedef {import("./channel/Channel.js").default} Channel
   */

  /**
   * Gets a pseudorandom 32-bit number. Not cryptographically secure. See HIP-351 https://hips.hedera.com/hip/hip-351
   */
  class PrngTransaction extends Transaction {
      /**
       * @param {object} props
       * @param {?number } [props.range]
       */
      constructor(props = {}) {
          super();

          /**
           * @private
           * @type {?number}
           */
          this._range = null;

          if (props.range != null) {
              this.setRange(props.range);
          }
      }

      /**
       * @param {number} newRange
       * @returns {this}
       */
      setRange(newRange) {
          this._range = newRange;
          return this;
      }

      get range() {
          return this._range;
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          if (this._range != null && isNumber(this._range)) {
              this._validateChecksums(client);
          }
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.ITransaction} request
       * @returns {Promise<HieroProto.proto.TransactionResponse>}
       */
      _execute(channel, request) {
          return channel.util.prng(request);
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransaction[]} transactions
       * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {HieroProto.proto.ITransactionBody[]} bodies
       * @returns {PrngTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = /** @type {HieroProto.proto.ITransactionBody} */ (
              bodies[0]
          );
          const transactionRange =
              /** @type {HieroProto.proto.IUtilPrngTransactionBody} */ (
                  body.utilPrng
              );
          return Transaction._fromProtobufTransactions(
              new PrngTransaction({
                  range: transactionRange.range,
              }),
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * @override
       * @protected
       * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "utilPrng";
      }

      /**
       * @override
       * @protected
       * @returns {HieroProto.proto.IUtilPrngTransactionBody}
       */
      _makeTransactionData() {
          return {
              range: this.range,
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("./Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `RandomGenerate:${timestamp.toString()}`;
      }
  }

  TRANSACTION_REGISTRY.set(
      "utilPrng",
      // eslint-disable-next-line @typescript-eslint/unbound-method
      PrngTransaction._fromProtobuf,
  );

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.IProxyStaker} HieroProto.proto.IProxyStaker
   * @typedef {import("@hashgraph/proto").proto.IAccountID} HieroProto.proto.IAccountID
   */

  /**
   * @typedef {import("bignumber.js").default} BigNumber
   */

  /**
   * An account, and the amount that it sends or receives during a cryptocurrency transfer.
   */
  class ProxyStaker {
      /**
       * @private
       * @param {object} props
       * @param {AccountId} props.accountId
       * @param {number | string | Long | BigNumber | Hbar} props.amount
       */
      constructor(props) {
          /**
           * The Account ID that sends or receives cryptocurrency.
           *
           * @readonly
           */
          this.accountId = props.accountId;

          /**
           * The amount of tinybars that the account sends(negative)
           * or receives(positive).
           *
           * @readonly
           */
          this.amount =
              props.amount instanceof Hbar
                  ? props.amount
                  : new Hbar(props.amount);

          Object.freeze(this);
      }

      /**
       * @internal
       * @param {HieroProto.proto.IProxyStaker} transfer
       * @returns {ProxyStaker}
       */
      static _fromProtobuf(transfer) {
          return new ProxyStaker({
              accountId: AccountId._fromProtobuf(
                  /** @type {HieroProto.proto.IAccountID} */ (transfer.accountID),
              ),
              amount: Hbar.fromTinybars(
                  transfer.amount != null ? transfer.amount : 0,
              ),
          });
      }

      /**
       * @internal
       * @returns {HieroProto.proto.IProxyStaker}
       */
      _toProtobuf() {
          return {
              accountID: this.accountId._toProtobuf(),
              amount: this.amount.toTinybars(),
          };
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {import("bignumber.js").default} BigNumber
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   * @typedef {import("../PublicKey.js").default} PublicKey
   * @typedef {import("../PrivateKey.js").default} PrivateKey
   */

  /**
   * Create a new Hedera crypto-currency account.
   */
  class ScheduleCreateTransaction extends Transaction {
      /**
       * @param {object} [props]
       * @param {Key} [props.adminKey]
       * @param {AccountId} [props.payerAccountID]
       * @param {string} [props.scheduleMemo]
       * @param {Timestamp} [props.expirationTime]
       * @param {boolean} [props.waitForExpiry]
       */
      constructor(props = {}) {
          super();

          /**
           * @private
           * @type {?Key}
           */
          this._adminKey = null;

          /**
           * @private
           * @type {?Transaction}
           */
          this._scheduledTransaction = null;

          /**
           * @private
           * @type {?AccountId}
           */
          this._payerAccountId = null;

          /**
           * @private
           * @type {?string}
           */
          this._scheduleMemo = null;

          /**
           * @private
           * @type {Set<string>}
           */
          this._scheduledSignerPublicKeys = new Set();

          /**
           * @private
           * @type {?Timestamp}
           */
          this._expirationTime = null;

          /**
           * @private
           * @type {?boolean}
           */
          this._waitForExpiry = null;

          if (props.adminKey != null) {
              this.setAdminKey(props.adminKey);
          }

          if (props.payerAccountID != null) {
              this.setPayerAccountId(props.payerAccountID);
          }

          if (props.scheduleMemo != null) {
              this.setScheduleMemo(props.scheduleMemo);
          }

          this._defaultMaxTransactionFee = new Hbar(5);
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransaction[]} transactions
       * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {HieroProto.proto.ITransactionBody[]} bodies
       * @returns {ScheduleCreateTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];
          const create =
              /** @type {HieroProto.proto.IScheduleCreateTransactionBody} */ (
                  body.scheduleCreate
              );

          const scheduledTransaction = new ScheduleCreateTransaction({
              adminKey:
                  create.adminKey != null
                      ? Key._fromProtobufKey(create.adminKey)
                      : undefined,
              payerAccountID:
                  create.payerAccountID != null
                      ? AccountId._fromProtobuf(
                            /** @type {HieroProto.proto.IAccountID} */ (
                                create.payerAccountID
                            ),
                        )
                      : undefined,
              scheduleMemo: create.memo != null ? create.memo : undefined,
              waitForExpiry:
                  create.waitForExpiry != null ? create.waitForExpiry : undefined,
              expirationTime:
                  create.expirationTime != null
                      ? Timestamp._fromProtobuf(create.expirationTime)
                      : undefined,
          });
          if (body.scheduleCreate != null) {
              const scheduleCreateBody =
                  body.scheduleCreate.scheduledTransactionBody;

              const scheduleCreateBodyBytes =
                  libExports.proto.TransactionBody.encode(
                      // @ts-ignore
                      scheduleCreateBody,
                  ).finish();

              const signedScheduledCreateTransaction =
                  libExports.proto.SignedTransaction.encode({
                      bodyBytes: scheduleCreateBodyBytes,
                  }).finish();

              const scheduleCreatetransaction = {
                  signedTransactionBytes: signedScheduledCreateTransaction,
              };

              const txlist = libExports.proto.TransactionList.encode({
                  transactionList: [scheduleCreatetransaction],
              }).finish();

              const finalScheduledDecodedTx = Transaction.fromBytes(txlist);

              scheduledTransaction._setScheduledTransaction(
                  finalScheduledDecodedTx,
              );
          }

          return Transaction._fromProtobufTransactions(
              scheduledTransaction,
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * @internal
       * @param {Transaction} tx
       * @returns {this}
       */
      _setScheduledTransaction(tx) {
          this._scheduledTransaction = tx;

          return this;
      }

      /**
       * @returns {?Key}
       */
      get adminKey() {
          return this._adminKey;
      }

      /**
       * Set the key for this account.
       *
       * This is the key that must sign each transfer out of the account.
       *
       * If `receiverSignatureRequired` is true, then the key must also sign
       * any transfer into the account.
       *
       * @param {Key} key
       * @returns {this}
       */
      setAdminKey(key) {
          this._requireNotFrozen();
          this._adminKey = key;

          return this;
      }

      /**
       * @returns {?AccountId}
       */
      get payerAccountId() {
          return this._payerAccountId;
      }

      /**
       * @param {AccountId} account
       * @returns {this}
       */
      setPayerAccountId(account) {
          this._requireNotFrozen();
          this._payerAccountId = account;

          return this;
      }

      /**
       * @param {string} memo
       * @returns {this}
       */
      setScheduleMemo(memo) {
          this._requireNotFrozen();
          this._scheduleMemo = memo;

          return this;
      }

      /**
       * @returns {?string}
       */
      get getScheduleMemo() {
          this._requireNotFrozen();
          return this._scheduleMemo;
      }

      /**
       * @param {Transaction} transaction
       * @returns {this}
       */
      setScheduledTransaction(transaction) {
          this._requireNotFrozen();
          transaction._requireNotFrozen();

          this._scheduledTransaction =
              transaction.schedule()._scheduledTransaction;

          return this;
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          if (this._payerAccountId != null) {
              this._payerAccountId.validateChecksum(client);
          }
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.ITransaction} request
       * @returns {Promise<HieroProto.proto.ITransactionResponse>}
       */
      _execute(channel, request) {
          return channel.schedule.createSchedule(request);
      }

      /**
       * @override
       * @protected
       * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "scheduleCreate";
      }

      /**
       * @override
       * @protected
       * @returns {HieroProto.proto.IScheduleCreateTransactionBody}
       */
      _makeTransactionData() {
          return {
              adminKey:
                  this._adminKey != null ? this._adminKey._toProtobufKey() : null,
              payerAccountID:
                  this._payerAccountId != null
                      ? this._payerAccountId._toProtobuf()
                      : null,
              scheduledTransactionBody:
                  this._scheduledTransaction != null
                      ? this._scheduledTransaction._getScheduledTransactionBody()
                      : null,
              memo: this._scheduleMemo,
              waitForExpiry: this._waitForExpiry,
              expirationTime:
                  this._expirationTime != null
                      ? this._expirationTime._toProtobuf()
                      : null,
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("../Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `ScheduleCreateTransaction:${timestamp.toString()}`;
      }

      /**
       * @param {?Timestamp} expirationTime
       * @returns {this}
       */
      setExpirationTime(expirationTime) {
          this._expirationTime = expirationTime;
          return this;
      }

      /**
       * @returns {?Timestamp}
       */
      get expirationTime() {
          this._requireNotFrozen();
          return this._expirationTime;
      }

      /**
       * @param {boolean} waitForExpiry
       * @returns {this}
       */
      setWaitForExpiry(waitForExpiry) {
          this._waitForExpiry = waitForExpiry;

          return this;
      }

      /**
       * @returns {?boolean}
       */
      get waitForExpiry() {
          this._requireNotFrozen();
          return this._waitForExpiry;
      }
  }

  TRANSACTION_REGISTRY.set(
      "scheduleCreate",
      // eslint-disable-next-line @typescript-eslint/unbound-method
      ScheduleCreateTransaction._fromProtobuf,
  );

  SCHEDULE_CREATE_TRANSACTION.push(() => new ScheduleCreateTransaction());

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
   * @typedef {import("@hashgraph/proto").proto.IScheduleDeleteTransactionBody} HieroProto.proto.IScheduleDeleteTransactionBody
   * @typedef {import("@hashgraph/proto").proto.IScheduleID} HieroProto.proto.IScheduleID
   */

  /**
   * @typedef {import("bignumber.js").default} BigNumber
   * @typedef {import("@hashgraph/cryptography").Key} Key
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("../Timestamp.js").default} Timestamp
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   * @typedef {import("../account/AccountId.js").default} AccountId
   */

  /**
   * Create a new Hedera crypto-currency account.
   */
  class ScheduleDeleteTransaction extends Transaction {
      /**
       * @param {object} [props]
       * @param {ScheduleId | string} [props.scheduleId]
       */
      constructor(props = {}) {
          super();

          /**
           * @private
           * @type {?ScheduleId}
           */
          this._scheduleId = null;

          if (props.scheduleId != null) {
              this.setScheduleId(props.scheduleId);
          }

          this._defaultMaxTransactionFee = new Hbar(5);
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransaction[]} transactions
       * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {HieroProto.proto.ITransactionBody[]} bodies
       * @returns {ScheduleDeleteTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];
          const scheduleDelete =
              /** @type {HieroProto.proto.IScheduleDeleteTransactionBody} */ (
                  body.scheduleDelete
              );

          return Transaction._fromProtobufTransactions(
              new ScheduleDeleteTransaction({
                  scheduleId:
                      scheduleDelete.scheduleID != null
                          ? ScheduleId._fromProtobuf(
                                /** @type {HieroProto.proto.IScheduleID} */ (
                                    scheduleDelete.scheduleID
                                ),
                            )
                          : undefined,
              }),
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * @returns {?ScheduleId}
       */
      get scheduleId() {
          return this._scheduleId;
      }

      /**
       * @param {ScheduleId | string} scheduleId
       * @returns {this}
       */
      setScheduleId(scheduleId) {
          this._requireNotFrozen();
          this._scheduleId =
              typeof scheduleId === "string"
                  ? ScheduleId.fromString(scheduleId)
                  : scheduleId.clone();

          return this;
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          if (this._scheduleId != null) {
              this._scheduleId.validateChecksum(client);
          }
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.ITransaction} request
       * @returns {Promise<HieroProto.proto.ITransactionResponse>}
       */
      _execute(channel, request) {
          return channel.schedule.deleteSchedule(request);
      }

      /**
       * @override
       * @protected
       * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "scheduleDelete";
      }

      /**
       * @override
       * @protected
       * @returns {HieroProto.proto.IScheduleDeleteTransactionBody}
       */
      _makeTransactionData() {
          return {
              scheduleID:
                  this._scheduleId != null
                      ? this._scheduleId._toProtobuf()
                      : null,
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("../Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `ScheduleDeleteTransaction:${timestamp.toString()}`;
      }
  }

  TRANSACTION_REGISTRY.set(
      "scheduleDelete",
      // eslint-disable-next-line @typescript-eslint/unbound-method
      ScheduleDeleteTransaction._fromProtobuf,
  );

  // SPDX-License-Identifier: Apache-2.0


  const { proto: proto$1 } = HieroProto;

  /**
   * Response when the client sends the node ScheduleGetInfoQuery.
   */
  class ScheduleInfo {
      /**
       * @private
       * @param {object} props
       * @param {ScheduleId} props.scheduleId;
       * @param {?AccountId} props.creatorAccountID;
       * @param {?AccountId} props.payerAccountID;
       * @param {?HieroProto.proto.ISchedulableTransactionBody} props.schedulableTransactionBody;
       * @param {?Key} props.adminKey
       * @param {?KeyList} props.signers;
       * @param {?string} props.scheduleMemo;
       * @param {?Timestamp} props.expirationTime;
       * @param {?Timestamp} props.executed;
       * @param {?Timestamp} props.deleted;
       * @param {?TransactionId} props.scheduledTransactionId;
       * @param {boolean} props.waitForExpiry;
       */
      constructor(props) {
          /**
           * @readonly
           */
          this.scheduleId = props.scheduleId;

          /**
           * @readonly
           */
          this.creatorAccountId = props.creatorAccountID;

          /**
           * @readonly
           */
          this.payerAccountId = props.payerAccountID;

          /**
           * @readonly
           */
          this.schedulableTransactionBody = props.schedulableTransactionBody;

          /**
           * @readonly
           */
          this.signers = props.signers;

          /**
           * @readonly
           */
          this.scheduleMemo = props.scheduleMemo;

          /**
           * @readonly
           */
          this.adminKey = props.adminKey != null ? props.adminKey : null;

          /**
           * @readonly
           */
          this.expirationTime = props.expirationTime;

          /**
           * @readonly
           */
          this.executed = props.executed;

          /**
           * @readonly
           */
          this.deleted = props.deleted;

          /**
           * @readonly
           */
          this.scheduledTransactionId = props.scheduledTransactionId;

          /**
           *
           * @readonly
           */
          this.waitForExpiry = props.waitForExpiry;

          Object.freeze(this);
      }

      /**
       * @internal
       * @param {HieroProto.proto.IScheduleInfo} info
       * @returns {ScheduleInfo}
       */
      static _fromProtobuf(info) {
          return new ScheduleInfo({
              scheduleId: ScheduleId._fromProtobuf(
                  /** @type {HieroProto.proto.IScheduleID} */ (info.scheduleID),
              ),
              creatorAccountID:
                  info.creatorAccountID != null
                      ? AccountId._fromProtobuf(
                            /** @type {HieroProto.proto.IAccountID} */ (
                                info.creatorAccountID
                            ),
                        )
                      : null,
              payerAccountID:
                  info.payerAccountID != null
                      ? AccountId._fromProtobuf(
                            /** @type {HieroProto.proto.IAccountID} */ (
                                info.payerAccountID
                            ),
                        )
                      : null,
              schedulableTransactionBody:
                  info.scheduledTransactionBody != null
                      ? info.scheduledTransactionBody
                      : null,
              adminKey:
                  info.adminKey != null
                      ? Key._fromProtobufKey(info.adminKey)
                      : null,
              signers:
                  info.signers != null
                      ? KeyList.__fromProtobufKeyList(info.signers)
                      : null,
              scheduleMemo: info.memo != null ? info.memo : null,
              expirationTime:
                  info.expirationTime != null
                      ? Timestamp._fromProtobuf(
                            /** @type {HieroProto.proto.ITimestamp} */ (
                                info.expirationTime
                            ),
                        )
                      : null,
              executed:
                  info.executionTime != null
                      ? Timestamp._fromProtobuf(
                            /** @type {HieroProto.proto.ITimestamp} */ (
                                info.executionTime
                            ),
                        )
                      : null,
              deleted:
                  info.deletionTime != null
                      ? Timestamp._fromProtobuf(
                            /** @type {HieroProto.proto.ITimestamp} */ (
                                info.deletionTime
                            ),
                        )
                      : null,
              scheduledTransactionId:
                  info.scheduledTransactionID != null
                      ? TransactionId._fromProtobuf(info.scheduledTransactionID)
                      : null,
              waitForExpiry:
                  info.waitForExpiry != null ? info.waitForExpiry : false,
          });
      }

      /**
       * @returns {HieroProto.proto.IScheduleInfo}
       */
      _toProtobuf() {
          return {
              scheduleID:
                  this.scheduleId != null ? this.scheduleId._toProtobuf() : null,
              creatorAccountID:
                  this.creatorAccountId != null
                      ? this.creatorAccountId._toProtobuf()
                      : null,
              payerAccountID:
                  this.payerAccountId != null
                      ? this.payerAccountId._toProtobuf()
                      : null,
              scheduledTransactionBody:
                  this.schedulableTransactionBody != null
                      ? this.schedulableTransactionBody
                      : null,
              adminKey:
                  this.adminKey != null ? this.adminKey._toProtobufKey() : null,
              signers:
                  this.signers != null
                      ? this.signers._toProtobufKey().keyList
                      : null,
              memo: this.scheduleMemo != null ? this.scheduleMemo : "",
              expirationTime:
                  this.expirationTime != null
                      ? this.expirationTime._toProtobuf()
                      : null,
              scheduledTransactionID:
                  this.scheduledTransactionId != null
                      ? this.scheduledTransactionId._toProtobuf()
                      : null,
              waitForExpiry: this.waitForExpiry,
          };
      }

      /**
       * @returns {Transaction}
       */
      get scheduledTransaction() {
          if (this.schedulableTransactionBody == null) {
              throw new Error("Scheduled transaction body is empty");
          }

          const scheduled = new proto$1.SchedulableTransactionBody(
              this.schedulableTransactionBody,
          );
          const data =
              /** @type {NonNullable<HieroProto.proto.SchedulableTransactionBody["data"]>} */ (
                  scheduled.data
              );

          return Transaction.fromBytes(
              proto$1.TransactionList.encode({
                  transactionList: [
                      {
                          signedTransactionBytes: proto$1.SignedTransaction.encode({
                              bodyBytes: proto$1.TransactionBody.encode({
                                  transactionFee:
                                      this.schedulableTransactionBody
                                          .transactionFee,
                                  memo: this.schedulableTransactionBody.memo,
                                  [data]: scheduled[data],
                              }).finish(),
                          }).finish(),
                      },
                  ],
              }).finish(),
          );
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.IQuery} HieroProto.proto.IQuery
   * @typedef {import("@hashgraph/proto").proto.IQueryHeader} HieroProto.proto.IQueryHeader
   * @typedef {import("@hashgraph/proto").proto.IResponse} HieroProto.proto.IResponse
   * @typedef {import("@hashgraph/proto").proto.IResponseHeader} HieroProto.proto.IResponseHeader
   * @typedef {import("@hashgraph/proto").proto.IScheduleInfo} HieroProto.proto.IScheduleInfo
   * @typedef {import("@hashgraph/proto").proto.IScheduleGetInfoQuery} HieroProto.proto.IScheduleGetInfoQuery
   * @typedef {import("@hashgraph/proto").proto.IScheduleGetInfoResponse} HieroProto.proto.IScheduleGetInfoResponse
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("../account/AccountId.js").default} AccountId
   */

  /**
   * Retrieve the metadata for a schedule.
   * @augments {Query<ScheduleInfo>}
   */
  class ScheduleInfoQuery extends Query {
      /**
       * @param {object} properties
       * @param {ScheduleId | string} [properties.scheduleId]
       */
      constructor(properties = {}) {
          super();

          /**
           * @private
           * @type {?ScheduleId}
           */
          this._scheduleId = null;

          if (properties.scheduleId != null) {
              this.setScheduleId(properties.scheduleId);
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.IQuery} query
       * @returns {ScheduleInfoQuery}
       */
      static _fromProtobuf(query) {
          const info = /** @type {HieroProto.proto.IScheduleGetInfoQuery} */ (
              query.scheduleGetInfo
          );

          return new ScheduleInfoQuery({
              scheduleId:
                  info.scheduleID != null
                      ? ScheduleId._fromProtobuf(info.scheduleID)
                      : undefined,
          });
      }

      /**
       * @returns {?ScheduleId}
       */
      get scheduleId() {
          return this._scheduleId;
      }

      /**
       *
       * @param {ScheduleId | string} scheduleId
       * @returns {ScheduleInfoQuery}
       */
      setScheduleId(scheduleId) {
          this._scheduleId =
              typeof scheduleId === "string"
                  ? ScheduleId.fromString(scheduleId)
                  : scheduleId.clone();

          return this;
      }

      /**
       * @override
       * @param {import("../client/Client.js").default<Channel, *>} client
       * @returns {Promise<Hbar>}
       */
      async getCost(client) {
          return super.getCost(client);
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          if (this._scheduleId != null) {
              this._scheduleId.validateChecksum(client);
          }
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.IQuery} request
       * @returns {Promise<HieroProto.proto.IResponse>}
       */
      _execute(channel, request) {
          return channel.schedule.getScheduleInfo(request);
      }

      /**
       * @override
       * @internal
       * @param {HieroProto.proto.IResponse} response
       * @returns {HieroProto.proto.IResponseHeader}
       */
      _mapResponseHeader(response) {
          const scheduleGetInfo =
              /** @type {HieroProto.proto.IScheduleGetInfoResponse} */ (
                  response.scheduleGetInfo
              );
          return /** @type {HieroProto.proto.IResponseHeader} */ (
              scheduleGetInfo.header
          );
      }

      /**
       * @override
       * @internal
       * @param {HieroProto.proto.IResponse} response
       * @param {AccountId} nodeAccountId
       * @param {HieroProto.proto.IQuery} request
       * @returns {Promise<ScheduleInfo>}
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _mapResponse(response, nodeAccountId, request) {
          const info = /** @type {HieroProto.proto.IScheduleGetInfoResponse} */ (
              response.scheduleGetInfo
          );

          return Promise.resolve(
              ScheduleInfo._fromProtobuf(
                  /** @type {HieroProto.proto.IScheduleInfo} */ (
                      info.scheduleInfo
                  ),
              ),
          );
      }

      /**
       * @override
       * @internal
       * @param {HieroProto.proto.IQueryHeader} header
       * @returns {HieroProto.proto.IQuery}
       */
      _onMakeRequest(header) {
          return {
              scheduleGetInfo: {
                  header,
                  scheduleID:
                      this._scheduleId != null
                          ? this._scheduleId._toProtobuf()
                          : null,
              },
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp =
              this._paymentTransactionId != null &&
              this._paymentTransactionId.validStart != null
                  ? this._paymentTransactionId.validStart
                  : this._timestamp;

          return `ScheduleInfoQuery:${timestamp.toString()}`;
      }
  }

  // eslint-disable-next-line @typescript-eslint/unbound-method
  QUERY_REGISTRY.set("scheduleGetInfo", ScheduleInfoQuery._fromProtobuf);

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {object} ProtoSignaturePair
   * @property {(Uint8Array | null)=} pubKeyPrefix
   * @property {(Uint8Array | null)=} ed25519
   */

  /**
   * @typedef {object} ProtoSigMap
   * @property {(ProtoSignaturePair[] | null)=} sigPair
   */

  /**
   * @typedef {object} ProtoSignedTransaction
   * @property {(Uint8Array | null)=} bodyBytes
   * @property {(ProtoSigMap | null)=} sigMap
   */

  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
   * @typedef {import("@hashgraph/proto").proto.IScheduleSignTransactionBody} HieroProto.proto.IScheduleSignTransactionBody
   * @typedef {import("@hashgraph/proto").proto.IAccountID} HieroProto.proto.IAccountID
   * @typedef {import("@hashgraph/proto").proto.ISignatureMap} HieroProto.proto.ISignatureMap
   */

  /**
   * @typedef {import("bignumber.js").default} BigNumber
   * @typedef {import("@hashgraph/cryptography").Key} Key
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("../Timestamp.js").default} Timestamp
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   * @typedef {import("../account/AccountId.js").default} AccountId
   * @typedef {import("@hashgraph/cryptography").PublicKey} PublicKey
   */

  /**
   * Create a new Hedera crypto-currency account.
   */
  class ScheduleSignTransaction extends Transaction {
      /**
       * @param {object} [props]
       * @param {ScheduleId | string} [props.scheduleId]
       */
      constructor(props = {}) {
          super();

          /**
           * @private
           * @type {?ScheduleId}
           */
          this._scheduleId = null;

          if (props.scheduleId != null) {
              this.setScheduleId(props.scheduleId);
          }

          this._defaultMaxTransactionFee = new Hbar(5);
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransaction[]} transactions
       * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {HieroProto.proto.ITransactionBody[]} bodies
       * @returns {ScheduleSignTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];
          const sign =
              /** @type {HieroProto.proto.IScheduleSignTransactionBody} */ (
                  body.scheduleSign
              );

          return Transaction._fromProtobufTransactions(
              new ScheduleSignTransaction({
                  scheduleId:
                      sign.scheduleID != null
                          ? ScheduleId._fromProtobuf(sign.scheduleID)
                          : undefined,
              }),
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * @returns {?ScheduleId}
       */
      get scheduleId() {
          return this._scheduleId;
      }

      /**
       * @param {ScheduleId | string} scheduleId
       * @returns {this}
       */
      setScheduleId(scheduleId) {
          this._requireNotFrozen();
          this._scheduleId =
              typeof scheduleId === "string"
                  ? ScheduleId.fromString(scheduleId)
                  : scheduleId.clone();

          return this;
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          if (this._scheduleId != null) {
              this._scheduleId.validateChecksum(client);
          }
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.ITransaction} request
       * @returns {Promise<HieroProto.proto.ITransactionResponse>}
       */
      _execute(channel, request) {
          return channel.schedule.signSchedule(request);
      }

      /**
       * @override
       * @protected
       * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "scheduleSign";
      }

      /**
       * @override
       * @protected
       * @returns {HieroProto.proto.IScheduleSignTransactionBody}
       */
      _makeTransactionData() {
          return {
              scheduleID:
                  this._scheduleId != null
                      ? this._scheduleId._toProtobuf()
                      : null,
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("../Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `ScheduleSignTransaction:${timestamp.toString()}`;
      }
  }

  TRANSACTION_REGISTRY.set(
      "scheduleSign",
      // eslint-disable-next-line @typescript-eslint/unbound-method
      ScheduleSignTransaction._fromProtobuf,
  );

  // SPDX-License-Identifier: Apache-2.0

  /**
   * @typedef {import("./LedgerId.js").default} LedgerId
   * @typedef {import("./SignerSignature.js").default} SignerSignature
   * @typedef {import("./transaction/TransactionId.js").default} TransactionId
   * @typedef {import("./transaction/Transaction.js").default} Transaction
   * @typedef {import("./transaction/TransactionResponse.js").default} TransactionResponse
   * @typedef {import("./transaction/TransactionReceipt.js").default} TransactionReceipt
   * @typedef {import("./transaction/TransactionRecord.js").default} TransactionRecord
   * @typedef {import("./account/AccountId.js").default} AccountId
   * @typedef {import("./account/AccountBalance.js").default} AccountBalance
   * @typedef {import("./account/AccountInfo.js").default} AccountInfo
   * @typedef {import("./Key.js").default} Key
   */

  /**
   * @template {any} O
   * @typedef {import("./query/Query.js").default<O>} Query<O>
   */

  /**
   * @template RequestT
   * @template ResponseT
   * @template OutputT
   * @typedef {import("./Executable.js").default<RequestT, ResponseT, OutputT>} Executable<RequestT, ResponseT, OutputT>
   */

  /**
   * @typedef {object} Signer
   * @property {() => LedgerId?} getLedgerId
   * @property {() => AccountId} getAccountId
   * @property {() => Key} [getAccountKey]
   * @property {() => {[key: string]: (string | AccountId)}} getNetwork
   * @property {() => string[]} getMirrorNetwork
   * @property {(messages: Uint8Array[]) => Promise<SignerSignature[]>} sign
   * @property {() => Promise<AccountBalance>} getAccountBalance
   * @property {() => Promise<AccountInfo>} getAccountInfo
   * @property {() => Promise<TransactionRecord[]>} getAccountRecords
   * @property {<T extends Transaction>(transaction: T) => Promise<T>} signTransaction
   * @property {<T extends Transaction>(transaction: T) => Promise<T>} checkTransaction
   * @property {<T extends Transaction>(transaction: T) => Promise<T>} populateTransaction
   * @property {<RequestT, ResponseT, OutputT>(request: Executable<RequestT, ResponseT, OutputT>) => Promise<OutputT>} call
   */

  var Signer = {};

  // SPDX-License-Identifier: Apache-2.0

  /**
   * @typedef {import("./PublicKey.js").default} PublicKey
   * @typedef {import("./account/AccountId.js").default} AccountId
   */

  /**
   * Represents a signature associated with a signer in the Hedera network.
   *
   * The `SignerSignature` class encapsulates the public key, signature, and account ID
   * of a signer. It is used to manage and validate signatures in transactions, ensuring
   * that the correct signers are associated with the transaction data.
   */
  class SignerSignature {
      /**
       * @param {object} props
       * @param {PublicKey} props.publicKey
       * @param {Uint8Array} props.signature
       * @param {AccountId} props.accountId
       */
      constructor(props) {
          this.publicKey = props.publicKey;
          this.signature = props.signature;
          this.accountId = props.accountId;
      }
  }

  // SPDX-License-Identifier: Apache-2.0

  /**
   * Represents a handle for managing subscriptions to topics in the Hedera network.
   *
   * The `SubscriptionHandle` class provides methods to manage the lifecycle of a subscription,
   * including setting a callback function to be executed when an event occurs and unsubscribing
   * from the topic notifications. It is primarily used for handling real-time updates from the
   * Hedera network like topic subscriptions.
   */
  class SubscriptionHandle {
      constructor() {
          /** @type {{(): void} | null} */
          this._call = null;

          /** @type {boolean} */
          this._unsubscribed = false;
      }

      /**
       * @param {() => void} call
       * @returns {void}
       */
      _setCall(call) {
          this._call = call;
      }

      unsubscribe() {
          if (this._call != null) {
              this._unsubscribed = true;
              this._call();
          }
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
   * @typedef {import("@hashgraph/proto").proto.ISystemDeleteTransactionBody} HieroProto.proto.ISystemDeleteTransactionBody
   * @typedef {import("@hashgraph/proto").proto.IContractID} HieroProto.proto.IContractID
   * @typedef {import("@hashgraph/proto").proto.IFileID} HieroProto.proto.IFileID
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../account/AccountId.js").default} AccountId
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   */

  /**
   * Deprecated: Do not use.
   * @deprecated
   */
  class SystemDeleteTransaction extends Transaction {
      /**
       * @param {object} [props]
       * @param {FileId | string} [props.fileId]
       * @param {ContractId | string} [props.contractId]
       * @param {Timestamp} [props.expirationTime]
       */
      constructor(props = {}) {
          super();

          /**
           * @private
           * @type {?FileId}
           */
          this._fileId = null;

          /**
           * @private
           * @type {?ContractId}
           */
          this._contractId = null;

          /**
           * @private
           * @type {?Timestamp}
           */
          this._expirationTime = null;

          if (props.fileId != null) {
              this.setFileId(props.fileId);
          }

          if (props.contractId != null) {
              this.setContractId(props.contractId);
          }

          if (props.expirationTime != null) {
              this.setExpirationTime(props.expirationTime);
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransaction[]} transactions
       * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {HieroProto.proto.ITransactionBody[]} bodies
       * @returns {SystemDeleteTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];
          const systemDelete =
              /** @type {HieroProto.proto.ISystemDeleteTransactionBody} */ (
                  body.systemDelete
              );

          return Transaction._fromProtobufTransactions(
              // eslint-disable-next-line deprecation/deprecation
              new SystemDeleteTransaction({
                  fileId:
                      systemDelete.fileID != null
                          ? FileId._fromProtobuf(
                                /** @type {HieroProto.proto.IFileID} */ (
                                    systemDelete.fileID
                                ),
                            )
                          : undefined,
                  contractId:
                      systemDelete.contractID != null
                          ? ContractId._fromProtobuf(
                                /** @type {HieroProto.proto.IContractID} */ (
                                    systemDelete.contractID
                                ),
                            )
                          : undefined,
                  expirationTime:
                      systemDelete.expirationTime != null
                          ? Timestamp._fromProtobuf(systemDelete.expirationTime)
                          : undefined,
              }),
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * @returns {?FileId}
       */
      get fileId() {
          return this._fileId;
      }

      /**
       * @param {FileId | string} fileId
       * @returns {this}
       */
      setFileId(fileId) {
          this._requireNotFrozen();
          this._fileId =
              fileId instanceof FileId ? fileId : FileId.fromString(fileId);

          return this;
      }

      /**
       * @returns {?ContractId}
       */
      get contractId() {
          return this._contractId;
      }

      /**
       * @param {ContractId | string} contractId
       * @returns {this}
       */
      setContractId(contractId) {
          this._requireNotFrozen();
          this._contractId =
              contractId instanceof ContractId
                  ? contractId
                  : ContractId.fromString(contractId);

          return this;
      }

      /**
       * @returns {?Timestamp}
       */
      get expirationTime() {
          return this._expirationTime;
      }

      /**
       * @param {Timestamp} expirationTime
       * @returns {SystemDeleteTransaction}
       */
      setExpirationTime(expirationTime) {
          this._requireNotFrozen();
          this._expirationTime = expirationTime;
          return this;
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.ITransaction} request
       * @returns {Promise<HieroProto.proto.ITransactionResponse>}
       */
      _execute(channel, request) {
          if (this._fileId != null) {
              return channel.file.systemDelete(request);
          } else {
              return channel.smartContract.systemDelete(request);
          }
      }

      /**
       * @override
       * @protected
       * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "systemDelete";
      }

      /**
       * @override
       * @protected
       * @returns {HieroProto.proto.ISystemDeleteTransactionBody}
       */
      _makeTransactionData() {
          return {
              fileID: this._fileId != null ? this._fileId._toProtobuf() : null,
              contractID:
                  this._contractId != null
                      ? this._contractId._toProtobuf()
                      : null,
              expirationTime:
                  this._expirationTime != null
                      ? this._expirationTime._toProtobuf()
                      : null,
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("../Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `SystemDeleteTransaction:${timestamp.toString()}`;
      }
  }

  // eslint-disable-next-line @typescript-eslint/unbound-method, deprecation/deprecation
  TRANSACTION_REGISTRY.set("systemDelete", SystemDeleteTransaction._fromProtobuf);

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
   * @typedef {import("@hashgraph/proto").proto.ISystemUndeleteTransactionBody} HieroProto.proto.ISystemUndeleteTransactionBody
   * @typedef {import("@hashgraph/proto").proto.IContractID} HieroProto.proto.IContractID
   * @typedef {import("@hashgraph/proto").proto.IFileID} HieroProto.proto.IFileID
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../Timestamp.js").default} Timestamp
   * @typedef {import("../account/AccountId.js").default} AccountId
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   */

  /**
   * Deprecated: Do not use.
   * @deprecated
   */
  class SystemUndeleteTransaction extends Transaction {
      /**
       * @param {object} [props]
       * @param {FileId | string} [props.fileId]
       * @param {ContractId | string} [props.contractId]
       * @param {Timestamp} [props.expirationTime]
       */
      constructor(props = {}) {
          super();

          /**
           * @private
           * @type {?FileId}
           */
          this._fileId = null;

          /**
           * @private
           * @type {?ContractId}
           */
          this._contractId = null;

          if (props.fileId != null) {
              this.setFileId(props.fileId);
          }

          if (props.contractId != null) {
              this.setContractId(props.contractId);
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransaction[]} transactions
       * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {HieroProto.proto.ITransactionBody[]} bodies
       * @returns {SystemUndeleteTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];
          const systemUndelete =
              /** @type {HieroProto.proto.ISystemUndeleteTransactionBody} */ (
                  body.systemUndelete
              );

          return Transaction._fromProtobufTransactions(
              // eslint-disable-next-line deprecation/deprecation
              new SystemUndeleteTransaction({
                  fileId:
                      systemUndelete.fileID != null
                          ? FileId._fromProtobuf(
                                /** @type {HieroProto.proto.IFileID} */ (
                                    systemUndelete.fileID
                                ),
                            )
                          : undefined,
                  contractId:
                      systemUndelete.contractID != null
                          ? ContractId._fromProtobuf(
                                /** @type {HieroProto.proto.IContractID} */ (
                                    systemUndelete.contractID
                                ),
                            )
                          : undefined,
              }),
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * @returns {?FileId}
       */
      get fileId() {
          return this._fileId;
      }

      /**
       * @param {FileId | string} fileId
       * @returns {this}
       */
      setFileId(fileId) {
          this._requireNotFrozen();
          this._fileId =
              fileId instanceof FileId ? fileId : FileId.fromString(fileId);

          return this;
      }

      /**
       * @returns {?ContractId}
       */
      get contractId() {
          return this._contractId;
      }

      /**
       * @param {ContractId | string} contractId
       * @returns {this}
       */
      setContractId(contractId) {
          this._requireNotFrozen();
          this._contractId =
              contractId instanceof ContractId
                  ? contractId
                  : ContractId.fromString(contractId);

          return this;
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.ITransaction} request
       * @returns {Promise<HieroProto.proto.ITransactionResponse>}
       */
      _execute(channel, request) {
          if (this._fileId != null) {
              return channel.file.systemUndelete(request);
          } else {
              return channel.smartContract.systemUndelete(request);
          }
      }

      /**
       * @override
       * @protected
       * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "systemUndelete";
      }

      /**
       * @override
       * @protected
       * @returns {HieroProto.proto.ISystemUndeleteTransactionBody}
       */
      _makeTransactionData() {
          return {
              fileID: this._fileId != null ? this._fileId._toProtobuf() : null,
              contractID:
                  this._contractId != null
                      ? this._contractId._toProtobuf()
                      : null,
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("../Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `SystemUndeleteTransaction:${timestamp.toString()}`;
      }
  }

  TRANSACTION_REGISTRY.set(
      "systemUndelete",
      // eslint-disable-next-line @typescript-eslint/unbound-method, deprecation/deprecation
      SystemUndeleteTransaction._fromProtobuf,
  );

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
   * @typedef {import("@hashgraph/proto").proto.ITokenAssociateTransactionBody} HieroProto.proto.ITokenAssociateTransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   */

  /**
   * Associate a new Hedera crypto-currency token.
   */
  class TokenAssociateTransaction extends Transaction {
      /**
       * @param {object} [props]
       * @param {(TokenId | string)[]} [props.tokenIds]
       * @param {AccountId | string} [props.accountId]
       */
      constructor(props = {}) {
          super();

          /**
           * @private
           * @type {?TokenId[]}
           */
          this._tokenIds = null;

          /**
           * @private
           * @type {?AccountId}
           */
          this._accountId = null;

          this._defaultMaxTransactionFee = new Hbar(5);

          if (props.tokenIds != null) {
              this.setTokenIds(props.tokenIds);
          }

          if (props.accountId != null) {
              this.setAccountId(props.accountId);
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransaction[]} transactions
       * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {HieroProto.proto.ITransactionBody[]} bodies
       * @returns {TokenAssociateTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];
          const associateToken =
              /** @type {HieroProto.proto.ITokenAssociateTransactionBody} */ (
                  body.tokenAssociate
              );

          return Transaction._fromProtobufTransactions(
              new TokenAssociateTransaction({
                  tokenIds:
                      associateToken.tokens != null
                          ? associateToken.tokens.map((token) =>
                                TokenId._fromProtobuf(token),
                            )
                          : undefined,
                  accountId:
                      associateToken.account != null
                          ? AccountId._fromProtobuf(associateToken.account)
                          : undefined,
              }),
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * @returns {?TokenId[]}
       */
      get tokenIds() {
          return this._tokenIds;
      }

      /**
       * @param {(TokenId | string)[]} tokenIds
       * @returns {this}
       */
      setTokenIds(tokenIds) {
          this._requireNotFrozen();
          this._tokenIds = tokenIds.map((tokenId) =>
              typeof tokenId === "string"
                  ? TokenId.fromString(tokenId)
                  : tokenId.clone(),
          );

          return this;
      }

      /**
       * @returns {?AccountId}
       */
      get accountId() {
          return this._accountId;
      }

      /**
       * @param {AccountId | string} accountId
       * @returns {this}
       */
      setAccountId(accountId) {
          this._requireNotFrozen();
          this._accountId =
              typeof accountId === "string"
                  ? AccountId.fromString(accountId)
                  : accountId.clone();

          return this;
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          if (this._accountId != null) {
              this._accountId.validateChecksum(client);
          }

          for (const tokenId of this._tokenIds != null ? this._tokenIds : []) {
              if (tokenId != null) {
                  tokenId.validateChecksum(client);
              }
          }
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.ITransaction} request
       * @returns {Promise<HieroProto.proto.ITransactionResponse>}
       */
      _execute(channel, request) {
          return channel.token.associateTokens(request);
      }

      /**
       * @override
       * @protected
       * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "tokenAssociate";
      }

      /**
       * @override
       * @protected
       * @returns {HieroProto.proto.ITokenAssociateTransactionBody}
       */
      _makeTransactionData() {
          return {
              tokens:
                  this._tokenIds != null
                      ? this._tokenIds.map((tokenId) => tokenId._toProtobuf())
                      : null,
              account:
                  this._accountId != null ? this._accountId._toProtobuf() : null,
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("../Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `TokenAssociateTransaction:${timestamp.toString()}`;
      }
  }

  TRANSACTION_REGISTRY.set(
      "tokenAssociate",
      // eslint-disable-next-line @typescript-eslint/unbound-method
      TokenAssociateTransaction._fromProtobuf,
  );

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
   * @typedef {import("@hashgraph/proto").proto.ITokenBurnTransactionBody} HieroProto.proto.ITokenBurnTransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("../account/AccountId.js").default} AccountId
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   * @typedef {import("bignumber.js").default} BigNumber
   */

  /**
   * Burn a new Hedera crypto-currency token.
   */
  class TokenBurnTransaction extends Transaction {
      /**
       * @param {object} [props]
       * @param {TokenId | string} [props.tokenId]
       * @param {Long | number | BigNumber | bigint} [props.amount]
       * @param {(Long | number)[]} [props.serials]
       */
      constructor(props = {}) {
          super();

          /**
           * @private
           * @type {?TokenId}
           */
          this._tokenId = null;

          /**
           * @private
           * @type {?Long}
           */
          this._amount = null;

          /**
           * @private
           * @type {Long[]}
           */
          this._serials = [];

          if (props.tokenId != null) {
              this.setTokenId(props.tokenId);
          }

          if (props.amount != null) {
              this.setAmount(props.amount);
          }

          if (props.serials != null) {
              this.setSerials(props.serials);
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransaction[]} transactions
       * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {HieroProto.proto.ITransactionBody[]} bodies
       * @returns {TokenBurnTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];
          const burnToken =
              /** @type {HieroProto.proto.ITokenBurnTransactionBody} */ (
                  body.tokenBurn
              );

          return Transaction._fromProtobufTransactions(
              new TokenBurnTransaction({
                  tokenId:
                      burnToken.token != null
                          ? TokenId._fromProtobuf(burnToken.token)
                          : undefined,
                  amount: burnToken.amount != null ? burnToken.amount : undefined,
                  serials:
                      burnToken.serialNumbers != null
                          ? burnToken.serialNumbers
                          : undefined,
              }),
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * @returns {?TokenId}
       */
      get tokenId() {
          return this._tokenId;
      }

      /**
       * @param {TokenId | string} tokenId
       * @returns {this}
       */
      setTokenId(tokenId) {
          this._requireNotFrozen();
          this._tokenId =
              typeof tokenId === "string"
                  ? TokenId.fromString(tokenId)
                  : tokenId.clone();

          return this;
      }

      /**
       * @returns {?Long}
       */
      get amount() {
          return this._amount;
      }

      /**
       * @param {Long | number | BigNumber | bigint} amount
       * @returns {this}
       */
      setAmount(amount) {
          this._requireNotFrozen();
          this._amount = convertAmountToLong(amount);

          return this;
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          if (this._tokenId != null) {
              this._tokenId.validateChecksum(client);
          }
      }

      /**
       * @returns {Long[]}
       */
      get serials() {
          return this._serials;
      }

      /**
       * @param {(Long | number)[]} serials
       * @returns {this}
       */
      setSerials(serials) {
          this._requireNotFrozen();
          this._serials = serials.map((serial) =>
              serial instanceof Long ? serial : Long.fromValue(serial),
          );

          return this;
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.ITransaction} request
       * @returns {Promise<HieroProto.proto.ITransactionResponse>}
       */
      _execute(channel, request) {
          return channel.token.burnToken(request);
      }

      /**
       * @override
       * @protected
       * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "tokenBurn";
      }

      /**
       * @override
       * @protected
       * @returns {HieroProto.proto.ITokenBurnTransactionBody}
       */
      _makeTransactionData() {
          return {
              amount: this._amount,
              serialNumbers: this._serials,
              token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("../Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `TokenBurnTransaction:${timestamp.toString()}`;
      }
  }

  TRANSACTION_REGISTRY.set(
      "tokenBurn",
      // eslint-disable-next-line @typescript-eslint/unbound-method
      TokenBurnTransaction._fromProtobuf,
  );

  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.TokenReference} HieroProto.proto.TokenReference
   */

  class TokenReference {
      constructor() {
          /**
           * @public
           * @type {?TokenId}
           */
          this.fungibleToken = null;
          /**
           * @public
           * @type {?NftId}
           */
          this.nft = null;
      }

      /**
       * @public
       * @param {HieroProto.proto.TokenReference} reference
       * @returns {TokenReference}
       */
      static _fromProtobuf(reference) {
          return {
              fungibleToken:
                  reference.fungibleToken != undefined
                      ? TokenId._fromProtobuf(reference.fungibleToken)
                      : null,
              nft:
                  reference.nft != undefined
                      ? NftId._fromProtobuf(reference.nft)
                      : null,
          };
      }
  }

  // SPDX-License-Identifier: Apache-2.0

  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITokenRejectTransactionBody} HieroProto.proto.ITokenRejectTransactionBody
   * @typedef {import("@hashgraph/proto").proto.TokenReference} HieroProto.proto.TokenReference
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   * @typedef {import("../token/TokenId.js").default} TokenId
   * @typedef {import("../token/NftId.js").default} NftId
   */

  /**
   * Reject a new Hedera crypto-currency token.
   */
  class TokenRejectTransaction extends Transaction {
      /**
       *
       * @param {object} [props]
       * @param {?AccountId} [props.owner]
       * @param {NftId[]} [props.nftIds]
       * @param {TokenId[]} [props.tokenIds]
       */
      constructor(props = {}) {
          super();

          /**
           * @private
           * @type {?AccountId}
           */
          this._owner = null;

          if (props.owner != null) {
              this.setOwnerId(props.owner);
          }

          /**
           * @private
           * @type {TokenId[]}
           */
          this._tokenIds = [];

          /**
           * @private
           * @type {NftId[]}
           */
          this._nftIds = [];

          if (props.tokenIds != null) {
              this.setTokenIds(props.tokenIds);
          }

          if (props.nftIds != null) {
              this.setNftIds(props.nftIds);
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransaction[]} transactions
       * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {HieroProto.proto.ITransactionBody[]} bodies
       * @returns {TokenRejectTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];
          const rejectToken =
              /** @type {HieroProto.proto.ITokenRejectTransactionBody} */ (
                  body.tokenReject
              );

          const tokenIds = rejectToken.rejections?.map((rejection) =>
              TokenReference._fromProtobuf(rejection),
          );
          const ftIds = tokenIds
              ?.filter((token) => token.fungibleToken)
              .map(({ fungibleToken }) => {
                  if (fungibleToken == null) {
                      throw new Error("Fungible Token cannot be null");
                  }
                  return fungibleToken;
              });

          const nftIds = tokenIds
              ?.filter((token) => token.nft)
              .map(({ nft }) => {
                  if (nft == null) {
                      throw new Error("Nft cannot be null");
                  }
                  return nft;
              });

          return Transaction._fromProtobufTransactions(
              new TokenRejectTransaction({
                  owner:
                      rejectToken.owner != null
                          ? AccountId._fromProtobuf(rejectToken.owner)
                          : undefined,

                  tokenIds: ftIds,
                  nftIds: nftIds,
              }),
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * @returns {TokenId[]}
       */
      get tokenIds() {
          return this._tokenIds;
      }

      /**
       * @param {TokenId[]} tokenIds
       * @returns {this}
       */
      setTokenIds(tokenIds) {
          this._requireNotFrozen();
          this._tokenIds = tokenIds;
          return this;
      }

      /**
       * @param {TokenId} tokenId
       * @returns {this}
       */
      addTokenId(tokenId) {
          this._requireNotFrozen();
          this._tokenIds?.push(tokenId);
          return this;
      }

      /**
       * @returns {NftId[]}
       *
       */
      get nftIds() {
          return this._nftIds;
      }

      /**
       *
       * @param {NftId[]} nftIds
       * @returns {this}
       */
      setNftIds(nftIds) {
          this._requireNotFrozen();
          this._nftIds = nftIds;
          return this;
      }

      /**
       * @param {NftId} nftId
       * @returns {this}
       */
      addNftId(nftId) {
          this._requireNotFrozen();
          this._nftIds?.push(nftId);
          return this;
      }

      /**
       * @returns {?AccountId}
       */
      get ownerId() {
          return this._owner;
      }

      /**
       * @param {AccountId} owner
       * @returns {this}
       */
      setOwnerId(owner) {
          this._requireNotFrozen();
          this._owner = owner;
          return this;
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.ITransaction} request
       * @returns {Promise<HieroProto.proto.ITransactionResponse>}
       */
      _execute(channel, request) {
          return channel.token.rejectToken(request);
      }

      /**
       * @override
       * @protected
       * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "tokenReject";
      }

      /**
       * @returns {HieroProto.proto.ITokenRejectTransactionBody}
       */
      _makeTransactionData() {
          /** @type {HieroProto.proto.TokenReference[]} */
          const rejections = [];
          for (const tokenId of this._tokenIds) {
              rejections.push({
                  fungibleToken: tokenId._toProtobuf(),
              });
          }

          for (const nftId of this._nftIds) {
              rejections.push({
                  nft: nftId._toProtobuf(),
              });
          }
          return {
              owner: this.ownerId?._toProtobuf() ?? null,
              rejections,
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("../Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `TokenRejectTransaction:${timestamp.toString()}`;
      }
  }
  TRANSACTION_REGISTRY.set(
      "tokenReject",
      // eslint-disable-next-line @typescript-eslint/unbound-method
      TokenRejectTransaction._fromProtobuf,
  );

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
   * @typedef {import("@hashgraph/proto").proto.ITokenDissociateTransactionBody} HieroProto.proto.ITokenDissociateTransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   */

  /**
   * Dissociate a new Hedera crypto-currency token.
   */
  class TokenDissociateTransaction extends Transaction {
      /**
       * @param {object} [props]
       * @param {(TokenId | string)[]} [props.tokenIds]
       * @param {AccountId | string} [props.accountId]
       */
      constructor(props = {}) {
          super();

          /**
           * @private
           * @type {?TokenId[]}
           */
          this._tokenIds = null;

          /**
           * @private
           * @type {?AccountId}
           */
          this._accountId = null;

          this._defaultMaxTransactionFee = new Hbar(5);

          if (props.tokenIds != null) {
              this.setTokenIds(props.tokenIds);
          }

          if (props.accountId != null) {
              this.setAccountId(props.accountId);
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransaction[]} transactions
       * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {HieroProto.proto.ITransactionBody[]} bodies
       * @returns {TokenDissociateTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];
          const dissociateToken =
              /** @type {HieroProto.proto.ITokenDissociateTransactionBody} */ (
                  body.tokenDissociate
              );

          return Transaction._fromProtobufTransactions(
              new TokenDissociateTransaction({
                  tokenIds:
                      dissociateToken.tokens != null
                          ? dissociateToken.tokens.map((token) =>
                                TokenId._fromProtobuf(token),
                            )
                          : undefined,
                  accountId:
                      dissociateToken.account != null
                          ? AccountId._fromProtobuf(dissociateToken.account)
                          : undefined,
              }),
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * @returns {?TokenId[]}
       */
      get tokenIds() {
          return this._tokenIds;
      }

      /**
       * @param {(TokenId | string)[]} tokenIds
       * @returns {this}
       */
      setTokenIds(tokenIds) {
          this._requireNotFrozen();
          this._tokenIds = tokenIds.map((tokenId) =>
              typeof tokenId === "string"
                  ? TokenId.fromString(tokenId)
                  : tokenId.clone(),
          );

          return this;
      }

      /**
       * @returns {?AccountId}
       */
      get accountId() {
          return this._accountId;
      }

      /**
       * @param {AccountId | string} accountId
       * @returns {this}
       */
      setAccountId(accountId) {
          this._requireNotFrozen();
          this._accountId =
              typeof accountId === "string"
                  ? AccountId.fromString(accountId)
                  : accountId.clone();

          return this;
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          if (this._accountId != null) {
              this._accountId.validateChecksum(client);
          }

          for (const tokenId of this._tokenIds != null ? this._tokenIds : []) {
              if (tokenId != null) {
                  tokenId.validateChecksum(client);
              }
          }
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.ITransaction} request
       * @returns {Promise<HieroProto.proto.ITransactionResponse>}
       */
      _execute(channel, request) {
          return channel.token.dissociateTokens(request);
      }

      /**
       * @override
       * @protected
       * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "tokenDissociate";
      }

      /**
       * @override
       * @protected
       * @returns {HieroProto.proto.ITokenDissociateTransactionBody}
       */
      _makeTransactionData() {
          return {
              tokens:
                  this._tokenIds != null
                      ? this._tokenIds.map((tokenId) => tokenId._toProtobuf())
                      : null,
              account:
                  this._accountId != null ? this._accountId._toProtobuf() : null,
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("../Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `TokenDissociateTransaction:${timestamp.toString()}`;
      }
  }

  TRANSACTION_REGISTRY.set(
      "tokenDissociate",
      // eslint-disable-next-line @typescript-eslint/unbound-method
      TokenDissociateTransaction._fromProtobuf,
  );

  // SPDX-License-Identifier: Apache-2.0

  /**
   * @typedef {import("../PrivateKey.js").default} PrivateKey
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("../Signer.js").default} Signer
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   * @typedef {import("../transaction/Transaction.js").default} Transaction
   * @typedef {import("../transaction/TransactionResponse.js").default} TransactionResponse
   * @typedef {import("../token/TokenId.js").default} TokenId
   * @typedef {import("../token/NftId.js").default} NftId
   * @typedef {import("../PublicKey.js").default} PublicKey
   * @typedef {import("../account/AccountId.js").default} AccountId
   */

  /**
   * Reject undesired token(s) and dissociate in a single flow.
   */
  class TokenRejectFlow {
      constructor() {
          /**
           * @private
           * @type {?AccountId}
           */
          this._ownerId = null;

          /**
           * @private
           * @type {TokenId[]}
           */
          this._tokenIds = [];

          /**
           * @private
           * @type {NftId[]}
           */
          this._nftIds = [];

          /**
           * @private
           * @type {?Client}
           */
          this._freezeWithClient = null;

          /**
           * @private
           * @type {?PrivateKey}
           */
          this._signPrivateKey = null;

          /**
           * @private
           * @type {?PublicKey}
           */
          this._signPublicKey = null;

          /**
           * @private
           * @type {?(message: Uint8Array) => Promise<Uint8Array>}
           */
          this._transactionSigner = null;
      }

      /**
       *
       * @param {AccountId} ownerId
       * @returns {this}
       */
      setOwnerId(ownerId) {
          this.requireNotFrozen();
          this._ownerId = ownerId;
          return this;
      }

      /**
       * @returns {?AccountId}
       */
      get ownerId() {
          return this._ownerId;
      }

      /**
       *
       * @param {TokenId[]} ids
       * @returns {this}
       */
      setTokenIds(ids) {
          this.requireNotFrozen();
          this._tokenIds = ids;
          return this;
      }

      /**
       *
       * @param {TokenId} id
       * @returns {this}
       */
      addTokenId(id) {
          this.requireNotFrozen();
          this._tokenIds.push(id);
          return this;
      }

      /**
       *
       * @returns {TokenId[]}
       */
      get tokenIds() {
          return this._tokenIds;
      }

      /**
       *
       * @param {NftId[]} ids
       * @returns {this}
       */
      setNftIds(ids) {
          this.requireNotFrozen();
          this._nftIds = ids;
          return this;
      }

      /**
       *
       * @param {NftId} id
       * @returns {this}
       */
      addNftId(id) {
          this.requireNotFrozen();
          this._nftIds.push(id);
          return this;
      }

      /**
       *
       * @returns {NftId[]}
       */
      get nftIds() {
          return this._nftIds;
      }

      /**
       *
       * @param {PrivateKey} privateKey
       * @returns {this}
       */
      sign(privateKey) {
          this._signPrivateKey = privateKey;
          this._signPublicKey = null;
          this._transactionSigner = null;
          return this;
      }

      /**
       *
       * @param {PublicKey} publicKey
       * @param {((message: Uint8Array) => Promise<Uint8Array>)} signer
       * @returns {this}
       */
      signWith(publicKey, signer) {
          this._signPublicKey = publicKey;
          this._transactionSigner = signer;
          this._signPrivateKey = null;
          return this;
      }

      /**
       * @param {Client} client
       * @returns {this}
       */
      signWithOperator(client) {
          const operator = client.getOperator();
          if (operator == null) {
              throw new Error("Client operator must be set");
          }
          this._signPublicKey = operator.publicKey;
          this._transactionSigner = operator.transactionSigner;
          this._signPrivateKey = null;
          return this;
      }

      /**
       * @private
       * @param {Transaction} transaction
       */
      fillOutTransaction(transaction) {
          if (this._freezeWithClient) {
              transaction.freezeWith(this._freezeWithClient);
          }
          if (this._signPrivateKey) {
              void transaction.sign(this._signPrivateKey);
          } else if (this._signPublicKey && this._transactionSigner) {
              void transaction.signWith(
                  this._signPublicKey,
                  this._transactionSigner,
              );
          }
      }
      /**
       *
       * @param {Client} client
       * @returns {this}
       */
      freezeWith(client) {
          this._freezeWithClient = client;
          return this;
      }

      /**
       * @param {Client} client
       * @returns {Promise<TransactionResponse>}
       */
      async execute(client) {
          const tokenRejectTxn = new TokenRejectTransaction()
              .setTokenIds(this.tokenIds)
              .setNftIds(this.nftIds);

          if (this.ownerId) {
              tokenRejectTxn.setOwnerId(this.ownerId);
          }

          this.fillOutTransaction(tokenRejectTxn);

          /* Get all token ids from NFT and remove duplicates as duplicated IDs 
          will trigger a TOKEN_REFERENCE_REPEATED error. */
          const nftTokenIds = this.nftIds
              .map((nftId) => nftId.tokenId)
              .filter(function (value, index, array) {
                  return array.indexOf(value) === index;
              });

          const tokenDissociateTxn = new TokenDissociateTransaction().setTokenIds(
              [...this.tokenIds, ...nftTokenIds],
          );

          if (this.ownerId != null) {
              tokenDissociateTxn.setAccountId(this.ownerId);
          }

          this.fillOutTransaction(tokenDissociateTxn);

          const tokenRejectResponse = await tokenRejectTxn.execute(client);
          await tokenRejectResponse.getReceipt(client);

          const tokenDissociateResponse =
              await tokenDissociateTxn.execute(client);
          await tokenDissociateResponse.getReceipt(client);

          return tokenRejectResponse;
      }

      requireNotFrozen() {
          if (this._freezeWithClient != null) {
              throw new Error(
                  "Transaction is already frozen and cannot be modified",
              );
          }
      }
  }

  // SPDX-License-Identifier: Apache-2.0

  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.TokenType} HieroProto.proto.TokenType
   */

  class TokenType {
      /**
       * @hideconstructor
       * @internal
       * @param {number} code
       */
      constructor(code) {
          /** @readonly */
          this._code = code;

          Object.freeze(this);
      }

      /**
       * @returns {string}
       */
      toString() {
          switch (this) {
              case TokenType.FungibleCommon:
                  return "FUNGIBLE_COMMON";
              case TokenType.NonFungibleUnique:
                  return "NON_FUNGIBLE_UNIQUE";
              default:
                  return `UNKNOWN (${this._code})`;
          }
      }

      /**
       * @internal
       * @param {number} code
       * @returns {TokenType}
       */
      static _fromCode(code) {
          switch (code) {
              case 0:
                  return TokenType.FungibleCommon;
              case 1:
                  return TokenType.NonFungibleUnique;
          }

          throw new Error(
              `(BUG) TokenType.fromCode() does not handle code: ${code}`,
          );
      }

      /**
       * @returns {HieroProto.proto.TokenType}
       */
      valueOf() {
          return this._code;
      }
  }

  /**
   * Interchangeable value with one another, where any quantity of them has the
   * same value as another equal quantity if they are in the same class. Share
   * a single set of properties, not distinct from one another. Simply represented
   * as a balance or quantity to a given Hedera account.
   */
  TokenType.FungibleCommon = new TokenType(0);

  /**
   * Unique, not interchangeable with other tokens of the same type as they
   * typically have different values. Individually traced and can carry unique
   * properties (e.g. serial number).
   */
  TokenType.NonFungibleUnique = new TokenType(1);

  // SPDX-License-Identifier: Apache-2.0

  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.TokenSupplyType} HieroProto.proto.TokenSupplyType
   */

  class TokenSupplyType {
      /**
       * @hideconstructor
       * @internal
       * @param {number} code
       */
      constructor(code) {
          /** @readonly */
          this._code = code;

          Object.freeze(this);
      }

      /**
       * @returns {string}
       */
      toString() {
          switch (this) {
              case TokenSupplyType.Infinite:
                  return "INFINITE";
              case TokenSupplyType.Finite:
                  return "FINITE";
              default:
                  return `UNKNOWN (${this._code})`;
          }
      }

      /**
       * @internal
       * @param {number} code
       * @returns {TokenSupplyType}
       */
      static _fromCode(code) {
          switch (code) {
              case 0:
                  return TokenSupplyType.Infinite;
              case 1:
                  return TokenSupplyType.Finite;
          }

          throw new Error(
              `(BUG) TokenSupplyType.fromCode() does not handle code: ${code}`,
          );
      }

      /**
       * @returns {HieroProto.proto.TokenSupplyType}
       */
      valueOf() {
          return this._code;
      }
  }

  /**
   * Interchangeable value with one another, where any quantity of them has the
   * same value as another equal quantity if they are in the same class. Share
   * a single set of properties, not distinct from one another. Simply represented
   * as a balance or quantity to a given Hedera account.
   */
  TokenSupplyType.Infinite = new TokenSupplyType(0);

  /**
   * Unique, not interchangeable with other tokens of the same type as they
   * typically have different values. Individually traced and can carry unique
   * properties (e.g. serial number).
   */
  TokenSupplyType.Finite = new TokenSupplyType(1);

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
   * @typedef {import("@hashgraph/proto").proto.ITokenCreateTransactionBody} HieroProto.proto.ITokenCreateTransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
   */

  /**
   * @typedef {import("bignumber.js").default} BigNumber
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   * @typedef {import("./CustomFee.js").default} CustomFee
   */

  /**
   * Create a new Hedera crypto-currency token.
   */
  class TokenCreateTransaction extends Transaction {
      /**
       * @param {object} [props]
       * @param {string} [props.tokenName]
       * @param {string} [props.tokenSymbol]
       * @param {Long | number} [props.decimals]
       * @param {Long | number | BigNumber | bigint} [props.initialSupply]
       * @param {AccountId | string} [props.treasuryAccountId]
       * @param {Key} [props.adminKey]
       * @param {Key} [props.kycKey]
       * @param {Key} [props.freezeKey]
       * @param {Key} [props.pauseKey]
       * @param {Key} [props.wipeKey]
       * @param {Key} [props.supplyKey]
       * @param {Key} [props.feeScheduleKey]
       * @param {boolean} [props.freezeDefault]
       * @param {AccountId | string} [props.autoRenewAccountId]
       * @param {Timestamp | Date} [props.expirationTime]
       * @param {Duration | Long | number} [props.autoRenewPeriod]
       * @param {string} [props.tokenMemo]
       * @param {CustomFee[]} [props.customFees]
       * @param {TokenType} [props.tokenType]
       * @param {TokenSupplyType} [props.supplyType]
       * @param {Long | number | BigNumber | bigint} [props.maxSupply]
       * @param {Key} [props.metadataKey]
       * @param {Uint8Array} [props.metadata]
       */
      constructor(props = {}) {
          super();

          /**
           * @private
           * @type {?string}
           */
          this._tokenName = null;

          /**
           * @private
           * @type {?string}
           */
          this._tokenSymbol = null;

          /**
           * @private
           * @type {?Long}
           */
          this._decimals = null;

          /**
           * @private
           * @type {?Long}
           */
          this._initialSupply = null;

          /**
           * @private
           * @type {?AccountId}
           */
          this._treasuryAccountId = null;

          /**
           * @private
           * @type {?Key}
           */
          this._adminKey = null;

          /**
           * @private
           * @type {?Key}
           */
          this._kycKey = null;

          /**
           * @private
           * @type {?Key}
           */
          this._freezeKey = null;

          /**
           * @private
           * @type {?Key}
           */
          this._pauseKey = null;

          /**
           * @private
           * @type {?Key}
           */
          this._wipeKey = null;

          /**
           * @private
           * @type {?Key}
           */
          this._supplyKey = null;

          /**
           * @private
           * @type {?Key}
           */
          this._feeScheduleKey = null;

          /**
           * @private
           * @type {?boolean}
           */
          this._freezeDefault = null;

          /**
           * @private
           * @type {?AccountId}
           */
          this._autoRenewAccountId = null;

          /**
           * @private
           * @type {?Timestamp}
           */
          this._expirationTime = new Timestamp(
              Math.floor(
                  Date.now() / 1000 + DEFAULT_AUTO_RENEW_PERIOD.toNumber(),
              ),
              0,
          );

          /**
           * @private
           * @type {?Duration}
           */
          this._autoRenewPeriod = new Duration(DEFAULT_AUTO_RENEW_PERIOD);

          /**
           * @private
           * @type {?string}
           */
          this._tokenMemo = null;

          /**
           * @private
           * @type {CustomFee[]}
           */
          this._customFees = [];

          /**
           * @private
           * @type {?TokenType}
           */
          this._tokenType = null;

          /**
           * @private
           * @type {?TokenSupplyType}
           */
          this._supplyType = null;

          /**
           * @private
           * @type {?Long}
           */
          this._maxSupply = null;

          this._defaultMaxTransactionFee = new Hbar(30);

          /**
           * @private
           * @type {?Key}
           */
          this._metadataKey = null;

          /**
           * @private
           * @description Metadata of the created token definition.
           * @type {?Uint8Array}
           */
          this._metadata = null;

          if (props.tokenName != null) {
              this.setTokenName(props.tokenName);
          }

          if (props.tokenSymbol != null) {
              this.setTokenSymbol(props.tokenSymbol);
          }

          if (props.decimals != null) {
              this.setDecimals(props.decimals);
          }

          if (props.initialSupply != null) {
              this.setInitialSupply(props.initialSupply);
          }

          if (props.treasuryAccountId != null) {
              this.setTreasuryAccountId(props.treasuryAccountId);
          }

          if (props.adminKey != null) {
              this.setAdminKey(props.adminKey);
          }

          if (props.kycKey != null) {
              this.setKycKey(props.kycKey);
          }

          if (props.freezeKey != null) {
              this.setFreezeKey(props.freezeKey);
          }

          if (props.pauseKey != null) {
              this.setPauseKey(props.pauseKey);
          }

          if (props.wipeKey != null) {
              this.setWipeKey(props.wipeKey);
          }

          if (props.supplyKey != null) {
              this.setSupplyKey(props.supplyKey);
          }

          if (props.feeScheduleKey != null) {
              this.setFeeScheduleKey(props.feeScheduleKey);
          }

          if (props.freezeDefault != null) {
              this.setFreezeDefault(props.freezeDefault);
          }

          if (props.autoRenewAccountId != null) {
              this.setAutoRenewAccountId(props.autoRenewAccountId);
          }

          if (props.expirationTime != null) {
              this.setExpirationTime(props.expirationTime);
          }

          if (props.autoRenewPeriod != null) {
              this.setAutoRenewPeriod(props.autoRenewPeriod);
          }

          if (props.tokenMemo != null) {
              this.setTokenMemo(props.tokenMemo);
          }

          if (props.customFees != null) {
              this.setCustomFees(props.customFees);
          }

          if (props.tokenType != null) {
              this.setTokenType(props.tokenType);
          }

          if (props.supplyType != null) {
              this.setSupplyType(props.supplyType);
          }

          if (props.maxSupply != null) {
              this.setMaxSupply(props.maxSupply);
          }

          if (props.metadataKey != null) {
              this.setMetadataKey(props.metadataKey);
          }

          if (props.metadata != null) {
              this.setMetadata(props.metadata);
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransaction[]} transactions
       * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {HieroProto.proto.ITransactionBody[]} bodies
       * @returns {TokenCreateTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];
          const create =
              /** @type {HieroProto.proto.ITokenCreateTransactionBody} */ (
                  body.tokenCreation
              );

          return Transaction._fromProtobufTransactions(
              new TokenCreateTransaction({
                  tokenName: create.name != null ? create.name : undefined,
                  tokenSymbol: create.symbol != null ? create.symbol : undefined,
                  decimals: create.decimals != null ? create.decimals : undefined,
                  initialSupply:
                      create.initialSupply != null
                          ? create.initialSupply
                          : undefined,
                  treasuryAccountId:
                      create.treasury != null
                          ? AccountId._fromProtobuf(create.treasury)
                          : undefined,
                  adminKey:
                      create.adminKey != null
                          ? Key._fromProtobufKey(create.adminKey)
                          : undefined,
                  kycKey:
                      create.kycKey != null
                          ? Key._fromProtobufKey(create.kycKey)
                          : undefined,
                  freezeKey:
                      create.freezeKey != null
                          ? Key._fromProtobufKey(create.freezeKey)
                          : undefined,
                  pauseKey:
                      create.pauseKey != null
                          ? Key._fromProtobufKey(create.pauseKey)
                          : undefined,
                  wipeKey:
                      create.wipeKey != null
                          ? Key._fromProtobufKey(create.wipeKey)
                          : undefined,
                  supplyKey:
                      create.supplyKey != null
                          ? Key._fromProtobufKey(create.supplyKey)
                          : undefined,
                  feeScheduleKey:
                      create.feeScheduleKey != null
                          ? Key._fromProtobufKey(create.feeScheduleKey)
                          : undefined,
                  freezeDefault:
                      create.freezeDefault != null
                          ? create.freezeDefault
                          : undefined,
                  autoRenewAccountId:
                      create.autoRenewAccount != null
                          ? AccountId._fromProtobuf(create.autoRenewAccount)
                          : undefined,
                  expirationTime:
                      create.expiry != null
                          ? Timestamp._fromProtobuf(create.expiry)
                          : undefined,
                  autoRenewPeriod:
                      create.autoRenewPeriod != null
                          ? Duration._fromProtobuf(create.autoRenewPeriod)
                          : undefined,
                  tokenMemo: create.memo != null ? create.memo : undefined,
                  customFees:
                      create.customFees != null
                          ? create.customFees.map((fee) => {
                                if (fee.fixedFee != null) {
                                    return CustomFixedFee._fromProtobuf(fee);
                                } else if (fee.fractionalFee != null) {
                                    return CustomFractionalFee._fromProtobuf(fee);
                                } else {
                                    return CustomRoyalyFee._fromProtobuf(fee);
                                }
                            })
                          : undefined,
                  tokenType:
                      create.tokenType != null
                          ? TokenType._fromCode(create.tokenType)
                          : undefined,
                  supplyType:
                      create.supplyType != null
                          ? TokenSupplyType._fromCode(create.supplyType)
                          : undefined,
                  maxSupply:
                      create.maxSupply != null ? create.maxSupply : undefined,
                  metadataKey:
                      create.metadataKey != null
                          ? Key._fromProtobufKey(create.metadataKey)
                          : undefined,
                  metadata: create.metadata != null ? create.metadata : undefined,
              }),
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * @returns {?string}
       */
      get tokenName() {
          return this._tokenName;
      }

      /**
       * @param {string} name
       * @returns {this}
       */
      setTokenName(name) {
          this._requireNotFrozen();
          this._tokenName = name;

          return this;
      }

      /**
       * @returns {?string}
       */
      get tokenSymbol() {
          return this._tokenSymbol;
      }

      /**
       * @param {string} symbol
       * @returns {this}
       */
      setTokenSymbol(symbol) {
          this._requireNotFrozen();
          this._tokenSymbol = symbol;

          return this;
      }

      /**
       * @returns {?Long}
       */
      get decimals() {
          return this._decimals;
      }

      /**
       * @param {Long | number} decimals
       * @returns {this}
       */
      setDecimals(decimals) {
          this._requireNotFrozen();
          this._decimals =
              decimals instanceof Long ? decimals : Long.fromValue(decimals);

          return this;
      }

      /**
       * @returns {?Long}
       */
      get initialSupply() {
          return this._initialSupply;
      }

      /**
       * @param {Long | number | BigNumber | bigint} initialSupply
       * @returns {this}
       */
      setInitialSupply(initialSupply) {
          this._requireNotFrozen();
          this._initialSupply = convertAmountToLong(initialSupply);

          return this;
      }

      /**
       * @returns {?AccountId}
       */
      get treasuryAccountId() {
          return this._treasuryAccountId;
      }

      /**
       * @param {AccountId | string} id
       * @returns {this}
       */
      setTreasuryAccountId(id) {
          this._requireNotFrozen();
          this._treasuryAccountId =
              typeof id === "string" ? AccountId.fromString(id) : id.clone();

          return this;
      }

      /**
       * @returns {?Key}
       */
      get adminKey() {
          return this._adminKey;
      }

      /**
       * @param {Key} key
       * @returns {this}
       */
      setAdminKey(key) {
          this._requireNotFrozen();
          this._adminKey = key;

          return this;
      }

      /**
       * @returns {?Key}
       */
      get kycKey() {
          return this._kycKey;
      }

      /**
       * @param {Key} key
       * @returns {this}
       */
      setKycKey(key) {
          this._requireNotFrozen();
          this._kycKey = key;

          return this;
      }

      /**
       * @returns {?Key}
       */
      get freezeKey() {
          return this._freezeKey;
      }

      /**
       * @override
       * @param {?import("../client/Client.js").default<Channel, *>} client
       * @returns {this}
       */
      freezeWith(client) {
          if (
              !this._autoRenewAccountId &&
              this.transactionId?.accountId &&
              this.autoRenewPeriod != null
          ) {
              this.setAutoRenewAccountId(this.transactionId?.accountId);
          } else if (
              !this._autoRenewAccountId &&
              client?.operatorAccountId &&
              this.autoRenewPeriod != null
          ) {
              this.setAutoRenewAccountId(client.operatorAccountId);
          }
          return super.freezeWith(client);
      }

      /**
       * @param {Key} key
       * @returns {this}
       */
      setFreezeKey(key) {
          this._requireNotFrozen();
          this._freezeKey = key;

          return this;
      }

      /**
       * @returns {?Key}
       */
      get pauseKey() {
          return this._pauseKey;
      }

      /**
       * @param {Key} key
       * @returns {this}
       */
      setPauseKey(key) {
          this._requireNotFrozen();
          this._pauseKey = key;

          return this;
      }

      /**
       * @returns {?Key}
       */
      get wipeKey() {
          return this._wipeKey;
      }

      /**
       * @param {Key} key
       * @returns {this}
       */
      setWipeKey(key) {
          this._requireNotFrozen();
          this._wipeKey = key;

          return this;
      }

      /**
       * @returns {?Key}
       */
      get supplyKey() {
          return this._supplyKey;
      }

      /**
       * @param {Key} key
       * @returns {this}
       */
      setSupplyKey(key) {
          this._requireNotFrozen();
          this._supplyKey = key;

          return this;
      }

      /**
       * @returns {?Key}
       */
      get feeScheduleKey() {
          return this._feeScheduleKey;
      }

      /**
       * @param {Key} key
       * @returns {this}
       */
      setFeeScheduleKey(key) {
          this._requireNotFrozen();
          this._feeScheduleKey = key;

          return this;
      }

      /**
       * @returns {?boolean}
       */
      get freezeDefault() {
          return this._freezeDefault;
      }

      /**
       * @param {boolean} freeze
       * @returns {this}
       */
      setFreezeDefault(freeze) {
          this._requireNotFrozen();
          this._freezeDefault = freeze;

          return this;
      }

      /**
       * @returns {?Timestamp}
       */
      get expirationTime() {
          return this._expirationTime;
      }

      /**
       * If autoRenewPeriod is set - this value will be ignored and the expiration time will be calculated based on the autoRenewPeriod + time.now()
       * Setting this value will clear the autoRenewPeriod as the autoRenewPeriod period has default value of 7890000 seconds and leaving it set will override the expiration time
       * @param {Timestamp | Date} time
       * @returns {this}
       */
      setExpirationTime(time) {
          this._requireNotFrozen();
          this._expirationTime =
              time instanceof Timestamp ? time : Timestamp.fromDate(time);
          this._autoRenewPeriod = null;

          return this;
      }

      /**
       * @returns {?AccountId}
       */
      get autoRenewAccountId() {
          return this._autoRenewAccountId;
      }

      /**
       * @param {AccountId | string} id
       * @returns {this}
       */
      setAutoRenewAccountId(id) {
          this._requireNotFrozen();
          this._autoRenewAccountId =
              id instanceof AccountId ? id : AccountId.fromString(id);

          return this;
      }

      /**
       * @returns {?Duration}
       */
      get autoRenewPeriod() {
          return this._autoRenewPeriod;
      }

      /**
       * If expirationTime is set - autoRenewPeriod will be effectively ignored and it's effect will be replaced by expirationTime
       *
       * @param {Duration | Long | number} autoRenewPeriod
       * @returns {this}
       */
      setAutoRenewPeriod(autoRenewPeriod) {
          this._requireNotFrozen();
          this._autoRenewPeriod =
              autoRenewPeriod instanceof Duration
                  ? autoRenewPeriod
                  : new Duration(autoRenewPeriod);

          return this;
      }

      /**
       * @returns {?string}
       */
      get tokenMemo() {
          return this._tokenMemo;
      }

      /**
       * @param {string} memo
       * @returns {this}
       */
      setTokenMemo(memo) {
          this._requireNotFrozen();
          this._tokenMemo = memo;

          return this;
      }

      /**
       * @returns {CustomFee[]}
       */
      get customFees() {
          return this._customFees;
      }

      /**
       * @param {CustomFee[]} customFees
       * @returns {this}
       */
      setCustomFees(customFees) {
          this._customFees = customFees;
          return this;
      }

      /**
       * @returns {?TokenType}
       */
      get tokenType() {
          return this._tokenType;
      }

      /**
       * @param {TokenType} tokenType
       * @returns {this}
       */
      setTokenType(tokenType) {
          this._tokenType = tokenType;
          return this;
      }

      /**
       * @returns {?TokenSupplyType}
       */
      get supplyType() {
          return this._supplyType;
      }

      /**
       * @param {TokenSupplyType} supplyType
       * @returns {this}
       */
      setSupplyType(supplyType) {
          this._supplyType = supplyType;
          return this;
      }

      /**
       * @returns {?Long}
       */
      get maxSupply() {
          return this._maxSupply;
      }

      /**
       * @param {Long | number | BigNumber | bigint} maxSupply
       * @returns {this}
       */
      setMaxSupply(maxSupply) {
          this._maxSupply = convertAmountToLong(maxSupply);
          return this;
      }

      /**
       * @returns {?Key}
       */
      get metadataKey() {
          return this._metadataKey;
      }

      /**
       * @param {Key} key
       * @returns {this}
       */
      setMetadataKey(key) {
          this._requireNotFrozen();
          this._metadataKey = key;

          return this;
      }

      /**
       * @returns {?Uint8Array}
       */
      get metadata() {
          return this._metadata;
      }

      /**
       * @param {Uint8Array} metadata
       * @returns {this}
       */
      setMetadata(metadata) {
          this._requireNotFrozen();
          this._metadata = metadata;

          return this;
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          if (this._treasuryAccountId != null) {
              this._treasuryAccountId.validateChecksum(client);
          }

          if (this._autoRenewAccountId != null) {
              this._autoRenewAccountId.validateChecksum(client);
          }
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.ITransaction} request
       * @returns {Promise<HieroProto.proto.ITransactionResponse>}
       */
      _execute(channel, request) {
          return channel.token.createToken(request);
      }

      /**
       * @override
       * @protected
       * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "tokenCreation";
      }

      /**
       * @override
       * @protected
       * @returns {HieroProto.proto.ITokenCreateTransactionBody}
       */
      _makeTransactionData() {
          return {
              name: this._tokenName,
              symbol: this._tokenSymbol,
              decimals: this._decimals != null ? this._decimals.toInt() : null,
              initialSupply: this._initialSupply,
              treasury:
                  this._treasuryAccountId != null
                      ? this._treasuryAccountId._toProtobuf()
                      : null,
              adminKey:
                  this._adminKey != null ? this._adminKey._toProtobufKey() : null,
              kycKey: this._kycKey != null ? this._kycKey._toProtobufKey() : null,
              freezeKey:
                  this._freezeKey != null
                      ? this._freezeKey._toProtobufKey()
                      : null,
              pauseKey:
                  this._pauseKey != null ? this._pauseKey._toProtobufKey() : null,
              wipeKey:
                  this._wipeKey != null ? this._wipeKey._toProtobufKey() : null,
              supplyKey:
                  this._supplyKey != null
                      ? this._supplyKey._toProtobufKey()
                      : null,
              feeScheduleKey:
                  this._feeScheduleKey != null
                      ? this._feeScheduleKey._toProtobufKey()
                      : null,
              freezeDefault: this._freezeDefault,
              autoRenewAccount:
                  this._autoRenewAccountId != null
                      ? this._autoRenewAccountId._toProtobuf()
                      : null,
              expiry:
                  this._expirationTime != null
                      ? this._expirationTime._toProtobuf()
                      : null,
              autoRenewPeriod:
                  this._autoRenewPeriod != null
                      ? this._autoRenewPeriod._toProtobuf()
                      : null,
              memo: this._tokenMemo,
              customFees: this.customFees.map((fee) => fee._toProtobuf()),
              tokenType: this._tokenType != null ? this._tokenType._code : null,
              supplyType:
                  this._supplyType != null ? this._supplyType._code : null,
              maxSupply: this.maxSupply,
              metadataKey:
                  this._metadataKey != null
                      ? this._metadataKey._toProtobufKey()
                      : null,
              metadata: this._metadata != null ? this._metadata : undefined,
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("../Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `TokenCreateTransaction:${timestamp.toString()}`;
      }
  }

  TRANSACTION_REGISTRY.set(
      "tokenCreation",
      // eslint-disable-next-line @typescript-eslint/unbound-method
      TokenCreateTransaction._fromProtobuf,
  );

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
   * @typedef {import("@hashgraph/proto").proto.ITokenDeleteTransactionBody} HieroProto.proto.ITokenDeleteTransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("../account/AccountId.js").default} AccountId
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   */

  /**
   * Delete a new Hedera crypto-currency token.
   */
  class TokenDeleteTransaction extends Transaction {
      /**
       * @param {object} [props]
       * @param {TokenId | string} [props.tokenId]
       */
      constructor(props = {}) {
          super();

          /**
           * @private
           * @type {?TokenId}
           */
          this._tokenId = null;

          if (props.tokenId != null) {
              this.setTokenId(props.tokenId);
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransaction[]} transactions
       * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {HieroProto.proto.ITransactionBody[]} bodies
       * @returns {TokenDeleteTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];
          const deleteToken =
              /** @type {HieroProto.proto.ITokenDeleteTransactionBody} */ (
                  body.tokenDeletion
              );

          return Transaction._fromProtobufTransactions(
              new TokenDeleteTransaction({
                  tokenId:
                      deleteToken.token != null
                          ? TokenId._fromProtobuf(deleteToken.token)
                          : undefined,
              }),
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * @returns {?TokenId}
       */
      get tokenId() {
          return this._tokenId;
      }

      /**
       * @param {TokenId | string} tokenId
       * @returns {this}
       */
      setTokenId(tokenId) {
          this._requireNotFrozen();
          this._tokenId =
              typeof tokenId === "string"
                  ? TokenId.fromString(tokenId)
                  : tokenId.clone();

          return this;
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          if (this._tokenId != null) {
              this._tokenId.validateChecksum(client);
          }
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.ITransaction} request
       * @returns {Promise<HieroProto.proto.ITransactionResponse>}
       */
      _execute(channel, request) {
          return channel.token.deleteToken(request);
      }

      /**
       * @override
       * @protected
       * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "tokenDeletion";
      }

      /**
       * @override
       * @protected
       * @returns {HieroProto.proto.ITokenDeleteTransactionBody}
       */
      _makeTransactionData() {
          return {
              token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("../Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `TokenDeleteTransaction:${timestamp.toString()}`;
      }
  }

  TRANSACTION_REGISTRY.set(
      "tokenDeletion",
      // eslint-disable-next-line @typescript-eslint/unbound-method
      TokenDeleteTransaction._fromProtobuf,
  );

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
   * @typedef {import("@hashgraph/proto").proto.ITokenFeeScheduleUpdateTransactionBody} HieroProto.proto.ITokenFeeScheduleUpdateTransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
   */

  /**
   * @typedef {import("bignumber.js").default} BigNumber
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   * @typedef {import("./CustomFee.js").default} CustomFee
   * @typedef {import("../account/AccountId.js").default} AccountId
   */

  /**
   * FeeScheduleUpdate a new Hedera crypto-currency token.
   */
  class TokenFeeScheduleUpdateTransaction extends Transaction {
      /**
       * @param {object} [props]
       * @param {TokenId | string} [props.tokenId]
       * @param {CustomFee[]} [props.customFees]
       */
      constructor(props = {}) {
          super();

          /**
           * @private
           * @type {?TokenId}
           */
          this._tokenId = null;

          /**
           * @private
           * @type {CustomFee[]}
           */
          this._customFees = [];

          if (props.tokenId != null) {
              this.setTokenId(props.tokenId);
          }

          if (props.customFees != null) {
              this.setCustomFees(props.customFees);
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransaction[]} transactions
       * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {HieroProto.proto.ITransactionBody[]} bodies
       * @returns {TokenFeeScheduleUpdateTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];
          const feeScheduleUpdate =
              /** @type {HieroProto.proto.ITokenFeeScheduleUpdateTransactionBody} */ (
                  body.tokenFeeScheduleUpdate
              );

          return Transaction._fromProtobufTransactions(
              new TokenFeeScheduleUpdateTransaction({
                  tokenId:
                      feeScheduleUpdate.tokenId != null
                          ? TokenId._fromProtobuf(feeScheduleUpdate.tokenId)
                          : undefined,
                  customFees:
                      feeScheduleUpdate.customFees != null
                          ? feeScheduleUpdate.customFees.map((fee) => {
                                if (fee.fixedFee != null) {
                                    return CustomFixedFee._fromProtobuf(fee);
                                } else if (fee.fractionalFee != null) {
                                    return CustomFractionalFee._fromProtobuf(fee);
                                } else {
                                    return CustomRoyalyFee._fromProtobuf(fee);
                                }
                            })
                          : undefined,
              }),
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * @returns {?TokenId}
       */
      get tokenId() {
          return this._tokenId;
      }

      /**
       * @param {TokenId | string} tokenId
       * @returns {this}
       */
      setTokenId(tokenId) {
          this._requireNotFrozen();
          this._tokenId =
              typeof tokenId === "string"
                  ? TokenId.fromString(tokenId)
                  : TokenId._fromProtobuf(tokenId._toProtobuf());

          return this;
      }

      /**
       * @returns {CustomFee[]}
       */
      get customFees() {
          return this._customFees;
      }

      /**
       * @param {CustomFee[]} fees
       * @returns {this}
       */
      setCustomFees(fees) {
          this._requireNotFrozen();
          this._customFees = fees;

          return this;
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.ITransaction} request
       * @returns {Promise<HieroProto.proto.ITransactionResponse>}
       */
      _execute(channel, request) {
          return channel.token.updateTokenFeeSchedule(request);
      }

      /**
       * @override
       * @protected
       * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "tokenFeeScheduleUpdate";
      }

      /**
       * @override
       * @protected
       * @returns {HieroProto.proto.ITokenFeeScheduleUpdateTransactionBody}
       */
      _makeTransactionData() {
          return {
              tokenId: this._tokenId != null ? this._tokenId._toProtobuf() : null,
              customFees: this._customFees.map((fee) => fee._toProtobuf()),
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("../Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `TokenFeeScheduleUpdateTransaction:${timestamp.toString()}`;
      }
  }

  TRANSACTION_REGISTRY.set(
      "tokenFeeScheduleUpdate",
      // eslint-disable-next-line @typescript-eslint/unbound-method
      TokenFeeScheduleUpdateTransaction._fromProtobuf,
  );

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
   * @typedef {import("@hashgraph/proto").proto.ITokenFreezeAccountTransactionBody} HieroProto.proto.ITokenFreezeAccountTransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   */

  /**
   * Freeze a new Hedera crypto-currency token.
   */
  class TokenFreezeTransaction extends Transaction {
      /**
       * @param {object} [props]
       * @param {TokenId | string} [props.tokenId]
       * @param {AccountId | string} [props.accountId]
       */
      constructor(props = {}) {
          super();

          /**
           * @private
           * @type {?TokenId}
           */
          this._tokenId = null;

          /**
           * @private
           * @type {?AccountId}
           */
          this._accountId = null;

          if (props.tokenId != null) {
              this.setTokenId(props.tokenId);
          }

          if (props.accountId != null) {
              this.setAccountId(props.accountId);
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransaction[]} transactions
       * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {HieroProto.proto.ITransactionBody[]} bodies
       * @returns {TokenFreezeTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];
          const freezeToken =
              /** @type {HieroProto.proto.ITokenFreezeAccountTransactionBody} */ (
                  body.tokenFreeze
              );

          return Transaction._fromProtobufTransactions(
              new TokenFreezeTransaction({
                  tokenId:
                      freezeToken.token != null
                          ? TokenId._fromProtobuf(freezeToken.token)
                          : undefined,
                  accountId:
                      freezeToken.account != null
                          ? AccountId._fromProtobuf(freezeToken.account)
                          : undefined,
              }),
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * @returns {?TokenId}
       */
      get tokenId() {
          return this._tokenId;
      }

      /**
       * @param {TokenId | string} tokenId
       * @returns {this}
       */
      setTokenId(tokenId) {
          this._requireNotFrozen();
          this._tokenId =
              typeof tokenId === "string"
                  ? TokenId.fromString(tokenId)
                  : tokenId.clone();

          return this;
      }

      /**
       * @returns {?AccountId}
       */
      get accountId() {
          return this._accountId;
      }

      /**
       * @param {AccountId | string} accountId
       * @returns {this}
       */
      setAccountId(accountId) {
          this._requireNotFrozen();
          this._accountId =
              typeof accountId === "string"
                  ? AccountId.fromString(accountId)
                  : accountId.clone();

          return this;
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          if (this._tokenId != null) {
              this._tokenId.validateChecksum(client);
          }

          if (this._accountId != null) {
              this._accountId.validateChecksum(client);
          }
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.ITransaction} request
       * @returns {Promise<HieroProto.proto.ITransactionResponse>}
       */
      _execute(channel, request) {
          return channel.token.freezeTokenAccount(request);
      }

      /**
       * @override
       * @protected
       * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "tokenFreeze";
      }

      /**
       * @override
       * @protected
       * @returns {HieroProto.proto.ITokenFreezeAccountTransactionBody}
       */
      _makeTransactionData() {
          return {
              token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
              account:
                  this._accountId != null ? this._accountId._toProtobuf() : null,
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("../Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `TokenFreezeTransaction:${timestamp.toString()}`;
      }
  }

  TRANSACTION_REGISTRY.set(
      "tokenFreeze",
      // eslint-disable-next-line @typescript-eslint/unbound-method
      TokenFreezeTransaction._fromProtobuf,
  );

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
   * @typedef {import("@hashgraph/proto").proto.ITokenGrantKycTransactionBody} HieroProto.proto.ITokenGrantKycTransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   */

  /**
   * GrantKyc a new Hedera crypto-currency token.
   */
  class TokenGrantKycTransaction extends Transaction {
      /**
       * @param {object} [props]
       * @param {TokenId | string} [props.tokenId]
       * @param {AccountId | string} [props.accountId]
       */
      constructor(props = {}) {
          super();

          /**
           * @private
           * @type {?TokenId}
           */
          this._tokenId = null;

          /**
           * @private
           * @type {?AccountId}
           */
          this._accountId = null;

          if (props.tokenId != null) {
              this.setTokenId(props.tokenId);
          }

          if (props.accountId != null) {
              this.setAccountId(props.accountId);
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransaction[]} transactions
       * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {HieroProto.proto.ITransactionBody[]} bodies
       * @returns {TokenGrantKycTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];
          const grantKycToken =
              /** @type {HieroProto.proto.ITokenGrantKycTransactionBody} */ (
                  body.tokenGrantKyc
              );

          return Transaction._fromProtobufTransactions(
              new TokenGrantKycTransaction({
                  tokenId:
                      grantKycToken.token != null
                          ? TokenId._fromProtobuf(grantKycToken.token)
                          : undefined,
                  accountId:
                      grantKycToken.account != null
                          ? AccountId._fromProtobuf(grantKycToken.account)
                          : undefined,
              }),
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * @returns {?TokenId}
       */
      get tokenId() {
          return this._tokenId;
      }

      /**
       * @param {TokenId | string} tokenId
       * @returns {this}
       */
      setTokenId(tokenId) {
          this._requireNotFrozen();
          this._tokenId =
              typeof tokenId === "string"
                  ? TokenId.fromString(tokenId)
                  : tokenId.clone();

          return this;
      }

      /**
       * @returns {?AccountId}
       */
      get accountId() {
          return this._accountId;
      }

      /**
       * @param {AccountId | string} accountId
       * @returns {this}
       */
      setAccountId(accountId) {
          this._requireNotFrozen();
          this._accountId =
              typeof accountId === "string"
                  ? AccountId.fromString(accountId)
                  : accountId.clone();

          return this;
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          if (this._tokenId != null) {
              this._tokenId.validateChecksum(client);
          }

          if (this._accountId != null) {
              this._accountId.validateChecksum(client);
          }
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.ITransaction} request
       * @returns {Promise<HieroProto.proto.ITransactionResponse>}
       */
      _execute(channel, request) {
          return channel.token.grantKycToTokenAccount(request);
      }

      /**
       * @override
       * @protected
       * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "tokenGrantKyc";
      }

      /**
       * @override
       * @protected
       * @returns {HieroProto.proto.ITokenGrantKycTransactionBody}
       */
      _makeTransactionData() {
          return {
              token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
              account:
                  this._accountId != null ? this._accountId._toProtobuf() : null,
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("../Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `TokenGrantKycTransaction:${timestamp.toString()}`;
      }
  }

  TRANSACTION_REGISTRY.set(
      "tokenGrantKyc",
      // eslint-disable-next-line @typescript-eslint/unbound-method
      TokenGrantKycTransaction._fromProtobuf,
  );

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {import("./CustomFee.js").default} CustomFee
   */

  /**
   * Response when the client sends the node TokenGetInfoQuery.
   */
  class TokenInfo {
      /**
       * @private
       * @param {object} props
       * @param {TokenId} props.tokenId;
       * @param {string} props.name;
       * @param {string} props.symbol;
       * @param {number} props.decimals;
       * @param {Long} props.totalSupply;
       * @param {AccountId | null} props.treasuryAccountId;
       * @param {Key | null} props.adminKey;
       * @param {Key | null} props.kycKey;
       * @param {Key | null} props.freezeKey;
       * @param {Key | null} props.pauseKey;
       * @param {Key | null} props.wipeKey;
       * @param {Key | null} props.supplyKey;
       * @param {Key | null} props.feeScheduleKey;
       * @param {boolean | null} props.defaultFreezeStatus;
       * @param {boolean | null} props.defaultKycStatus;
       * @param {boolean | null} props.pauseStatus;
       * @param {boolean} props.isDeleted;
       * @param {AccountId | null} props.autoRenewAccountId;
       * @param {Duration | null} props.autoRenewPeriod;
       * @param {Timestamp | null} props.expirationTime;
       * @param {string} props.tokenMemo;
       * @param {CustomFee[]} props.customFees;
       * @param {TokenType | null} props.tokenType;
       * @param {TokenSupplyType | null} props.supplyType;
       * @param {Long | null} props.maxSupply;
       * @param {LedgerId|null} props.ledgerId;
       * @param {Key | null} props.metadataKey;
       * @param {Uint8Array | null} props.metadata;
       */
      constructor(props) {
          /**
           * ID of the token instance
           *
           * @readonly
           */
          this.tokenId = props.tokenId;

          /**
           * The name of the token. It is a string of ASCII only characters
           *
           * @readonly
           */
          this.name = props.name;

          /**
           * The symbol of the token. It is a UTF-8 capitalized alphabetical string
           *
           * @readonly
           */
          this.symbol = props.symbol;

          /**
           * The number of decimal places a token is divisible by
           *
           * @readonly
           */
          this.decimals = props.decimals;

          /**
           * The total supply of tokens that are currently in circulation
           *
           * @readonly
           */
          this.totalSupply = props.totalSupply;

          /**
           * The ID of the account which is set as treasuryAccountId
           *
           * @readonly
           */
          this.treasuryAccountId = props.treasuryAccountId;

          /**
           * The key which can perform update/delete operations on the token. If empty, the token can be perceived as
           * immutable (not being able to be updated/deleted)
           *
           * @readonly
           */
          this.adminKey = props.adminKey;

          /**
           * The key which can grant or revoke KYC of an account for the token's transactions. If empty, KYC is not required,
           * and KYC grant or revoke operations are not possible.
           *
           * @readonly
           */
          this.kycKey = props.kycKey;

          /**
           * The key which can freeze or unfreeze an account for token transactions. If empty, freezing is not possible
           *
           * @readonly
           */
          this.freezeKey = props.freezeKey;

          /**
           * The Key which can pause and unpause the Token.
           *
           * @readonly
           */
          this.pauseKey = props.pauseKey;

          /**
           * The key which can wipe token balance of an account. If empty, wipe is not possible
           *
           * @readonly
           */
          this.wipeKey = props.wipeKey;

          /**
           * The key which can change the supply of a token. The key is used to sign Token Mint/Burn operations
           *
           * @readonly
           */
          this.supplyKey = props.supplyKey;

          this.feeScheduleKey = props.feeScheduleKey;

          /**
           * The default Freeze status (not applicable = null, frozen = false, or unfrozen = true) of Hedera accounts relative to this token.
           * FreezeNotApplicable is returned if Token Freeze Key is empty. Frozen is returned if Token Freeze Key is set and
           * defaultFreeze is set to true. Unfrozen is returned if Token Freeze Key is set and defaultFreeze is set to false
           *      FreezeNotApplicable = null;
           *      Frozen = true;
           *      Unfrozen = false;
           *
           * @readonly
           */
          this.defaultFreezeStatus = props.defaultFreezeStatus;

          /**
           * The default KYC status (KycNotApplicable or Revoked) of Hedera accounts relative to this token. KycNotApplicable
           * is returned if KYC key is not set, otherwise Revoked
           *      KycNotApplicable = null;
           *      Granted = true;
           *      Revoked = false;
           *
           * @readonly
           */
          this.defaultKycStatus = props.defaultKycStatus;

          /**
           * The default pause status of Hedera accounts relative to this token.
           * PauseNotApplicable is returned if pauseKey is not set
           *      PauseNotApplicable = null;
           *      Paused = true;
           *      Unpaused = false;
           *
           * @readonly
           */
          this.pauseStatus = props.pauseStatus;

          /**
           * Specifies whether the token was deleted or not
           *
           * @readonly
           */
          this.isDeleted = props.isDeleted;

          /**
           * An account which will be automatically charged to renew the token's expiration, at autoRenewPeriod interval
           *
           * @readonly
           */
          this.autoRenewAccountId = props.autoRenewAccountId;

          /**
           * The interval at which the auto-renew account will be charged to extend the token's expiry
           *
           * @readonly
           */
          this.autoRenewPeriod = props.autoRenewPeriod;

          /**
           * The epoch second at which the token expire: will; if an auto-renew account and period are specified,
           * this is coerced to the current epoch second plus the autoRenewPeriod
           *
           * @readonly
           */
          this.expirationTime = props.expirationTime;

          /**
           * The memo associated with the token.
           *
           * @readonly
           */
          this.tokenMemo = props.tokenMemo;

          this.customFees = props.customFees;

          this.tokenType = props.tokenType;

          this.supplyType = props.supplyType;

          this.maxSupply = props.maxSupply;

          this.ledgerId = props.ledgerId;

          /**
           * @description The key which can change the metadata of a token (token definition and individual NFTs).
           *
           * @readonly
           */
          this.metadataKey = props.metadataKey;

          /**
           * @description Metadata of the created token definition.
           * @readonly
           */
          this.metadata = props.metadata;
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITokenInfo} info
       * @returns {TokenInfo}
       */
      static _fromProtobuf(info) {
          const defaultFreezeStatus =
              /** @type {HieroProto.proto.TokenFreezeStatus} */ (
                  info.defaultFreezeStatus
              );
          const defaultKycStatus =
              /** @type {HieroProto.proto.TokenKycStatus} */ (
                  info.defaultKycStatus
              );
          const pauseStatus = /**@type {HieroProto.proto.TokenPauseStatus} */ (
              info.pauseStatus
          );

          const autoRenewAccountId =
              info.autoRenewAccount != null
                  ? AccountId._fromProtobuf(info.autoRenewAccount)
                  : new AccountId(0);

          return new TokenInfo({
              tokenId: TokenId._fromProtobuf(
                  /** @type {HieroProto.proto.ITokenID} */ (info.tokenId),
              ),
              name: /** @type {string} */ (info.name),
              symbol: /** @type {string} */ (info.symbol),
              decimals: /** @type {number} */ (info.decimals),
              totalSupply: Long.fromValue(/** @type {Long} */ (info.totalSupply)),
              treasuryAccountId:
                  info.treasury != null
                      ? AccountId._fromProtobuf(
                            /** @type {HieroProto.proto.IAccountID} */ (
                                info.treasury
                            ),
                        )
                      : null,
              adminKey:
                  info.adminKey != null
                      ? Key._fromProtobufKey(info.adminKey)
                      : null,
              kycKey:
                  info.kycKey != null ? Key._fromProtobufKey(info.kycKey) : null,
              freezeKey:
                  info.freezeKey != null
                      ? Key._fromProtobufKey(info.freezeKey)
                      : null,
              pauseKey:
                  info.pauseKey != null
                      ? Key._fromProtobufKey(info.pauseKey)
                      : null,
              wipeKey:
                  info.wipeKey != null
                      ? Key._fromProtobufKey(info.wipeKey)
                      : null,
              supplyKey:
                  info.supplyKey != null
                      ? Key._fromProtobufKey(info.supplyKey)
                      : null,
              feeScheduleKey:
                  info.feeScheduleKey != null
                      ? Key._fromProtobufKey(info.feeScheduleKey)
                      : null,
              defaultFreezeStatus:
                  defaultFreezeStatus === 0 ? null : defaultFreezeStatus == 1,
              defaultKycStatus:
                  defaultKycStatus === 0 ? null : defaultKycStatus == 1,
              pauseStatus: pauseStatus === 0 ? null : pauseStatus == 1,
              isDeleted: /** @type {boolean} */ (info.deleted),
              autoRenewAccountId: !(
                  autoRenewAccountId.shard.toInt() == 0 &&
                  autoRenewAccountId.realm.toInt() == 0 &&
                  autoRenewAccountId.num.toInt() == 0
              )
                  ? autoRenewAccountId
                  : null,
              autoRenewPeriod:
                  info.autoRenewPeriod != null
                      ? Duration._fromProtobuf(
                            /** @type {HieroProto.proto.IDuration} */ (
                                info.autoRenewPeriod
                            ),
                        )
                      : null,
              expirationTime:
                  info.expiry != null
                      ? Timestamp._fromProtobuf(
                            /** @type {HieroProto.proto.ITimestamp} */ (
                                info.expiry
                            ),
                        )
                      : null,
              tokenMemo: info.memo != null ? info.memo : "",
              customFees:
                  info.customFees != null
                      ? info.customFees.map((fee) => {
                            if (fee.fixedFee != null) {
                                return CustomFixedFee._fromProtobuf(fee);
                            } else if (fee.fractionalFee != null) {
                                return CustomFractionalFee._fromProtobuf(fee);
                            } else {
                                return CustomRoyalyFee._fromProtobuf(fee);
                            }
                        })
                      : [],
              tokenType:
                  info.tokenType != null
                      ? TokenType._fromCode(info.tokenType)
                      : null,
              supplyType:
                  info.supplyType != null
                      ? TokenSupplyType._fromCode(info.supplyType)
                      : null,
              maxSupply: info.maxSupply != null ? info.maxSupply : null,
              ledgerId:
                  info.ledgerId != null
                      ? LedgerId.fromBytes(info.ledgerId)
                      : null,
              metadataKey:
                  info.metadataKey != null
                      ? Key._fromProtobufKey(info.metadataKey)
                      : null,
              metadata: info.metadata != null ? info.metadata : new Uint8Array(),
          });
      }

      /**
       * @returns {HieroProto.proto.ITokenInfo}
       */
      _toProtobuf() {
          return {
              tokenId: this.tokenId._toProtobuf(),
              name: this.name,
              symbol: this.symbol,
              decimals: this.decimals,
              totalSupply: this.totalSupply,
              treasury:
                  this.treasuryAccountId != null
                      ? this.treasuryAccountId._toProtobuf()
                      : null,
              adminKey:
                  this.adminKey != null ? this.adminKey._toProtobufKey() : null,
              kycKey: this.kycKey != null ? this.kycKey._toProtobufKey() : null,
              freezeKey:
                  this.freezeKey != null ? this.freezeKey._toProtobufKey() : null,
              pauseKey:
                  this.pauseKey != null ? this.pauseKey._toProtobufKey() : null,
              wipeKey:
                  this.wipeKey != null ? this.wipeKey._toProtobufKey() : null,
              supplyKey:
                  this.supplyKey != null ? this.supplyKey._toProtobufKey() : null,
              feeScheduleKey:
                  this.feeScheduleKey != null
                      ? this.feeScheduleKey._toProtobufKey()
                      : null,
              defaultFreezeStatus:
                  this.defaultFreezeStatus == null
                      ? 0
                      : this.defaultFreezeStatus
                      ? 1
                      : 2,
              defaultKycStatus:
                  this.defaultKycStatus == null
                      ? 0
                      : this.defaultKycStatus
                      ? 1
                      : 2,
              pauseStatus:
                  this.pauseStatus == null ? 0 : this.pauseStatus ? 1 : 2,
              deleted: this.isDeleted,
              autoRenewAccount:
                  this.autoRenewAccountId != null
                      ? this.autoRenewAccountId._toProtobuf()
                      : undefined,
              autoRenewPeriod:
                  this.autoRenewPeriod != null
                      ? this.autoRenewPeriod._toProtobuf()
                      : null,
              expiry:
                  this.expirationTime != null
                      ? this.expirationTime._toProtobuf()
                      : null,
              memo: this.tokenMemo,
              customFees: this.customFees.map((fee) => fee._toProtobuf()),
              tokenType: this.tokenType != null ? this.tokenType._code : null,
              supplyType: this.supplyType != null ? this.supplyType._code : null,
              maxSupply: this.maxSupply,
              ledgerId: this.ledgerId != null ? this.ledgerId.toBytes() : null,
              metadataKey:
                  this.metadataKey != null
                      ? this.metadataKey._toProtobufKey()
                      : null,
              metadata: this.metadata != null ? this.metadata : null,
          };
      }

      /**
       * @param {Uint8Array} bytes
       * @returns {TokenInfo}
       */
      static fromBytes(bytes) {
          return TokenInfo._fromProtobuf(
              libExports.proto.TokenInfo.decode(bytes),
          );
      }

      /**
       * @returns {Uint8Array}
       */
      toBytes() {
          return libExports.proto.TokenInfo.encode(this._toProtobuf()).finish();
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.IQuery} HieroProto.proto.IQuery
   * @typedef {import("@hashgraph/proto").proto.IQueryHeader} HieroProto.proto.IQueryHeader
   * @typedef {import("@hashgraph/proto").proto.IResponse} HieroProto.proto.IResponse
   * @typedef {import("@hashgraph/proto").proto.IResponseHeader} HieroProto.proto.IResponseHeader
   * @typedef {import("@hashgraph/proto").proto.ITokenInfo} HieroProto.proto.ITokenInfo
   * @typedef {import("@hashgraph/proto").proto.ITokenGetInfoQuery} HieroProto.proto.ITokenGetInfoQuery
   * @typedef {import("@hashgraph/proto").proto.ITokenGetInfoResponse} HieroProto.proto.ITokenGetInfoResponse
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("../account/AccountId.js").default} AccountId
   */

  /**
   * Retrieve the detail characteristics for a token.
   * @augments {Query<TokenInfo>}
   */
  class TokenInfoQuery extends Query {
      /**
       * @param {object} properties
       * @param {TokenId | string} [properties.tokenId]
       */
      constructor(properties = {}) {
          super();

          /**
           * @private
           * @type {?TokenId}
           */
          this._tokenId = null;
          if (properties.tokenId != null) {
              this.setTokenId(properties.tokenId);
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.IQuery} query
       * @returns {TokenInfoQuery}
       */
      static _fromProtobuf(query) {
          const info = /** @type {HieroProto.proto.ITokenGetInfoQuery} */ (
              query.tokenGetInfo
          );

          return new TokenInfoQuery({
              tokenId:
                  info.token != null
                      ? TokenId._fromProtobuf(info.token)
                      : undefined,
          });
      }

      /**
       * @returns {?TokenId}
       */
      get tokenId() {
          return this._tokenId;
      }

      /**
       * Set the token ID for which the info is being requested.
       *
       * @param {TokenId | string} tokenId
       * @returns {TokenInfoQuery}
       */
      setTokenId(tokenId) {
          this._tokenId =
              typeof tokenId === "string"
                  ? TokenId.fromString(tokenId)
                  : tokenId.clone();

          return this;
      }

      /**
       * @override
       * @param {import("../client/Client.js").default<Channel, *>} client
       * @returns {Promise<Hbar>}
       */
      async getCost(client) {
          return super.getCost(client);
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          if (this._tokenId != null) {
              this._tokenId.validateChecksum(client);
          }
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.IQuery} request
       * @returns {Promise<HieroProto.proto.IResponse>}
       */
      _execute(channel, request) {
          return channel.token.getTokenInfo(request);
      }

      /**
       * @override
       * @internal
       * @param {HieroProto.proto.IResponse} response
       * @returns {HieroProto.proto.IResponseHeader}
       */
      _mapResponseHeader(response) {
          const tokenGetInfo =
              /** @type {HieroProto.proto.ITokenGetInfoResponse} */ (
                  response.tokenGetInfo
              );
          return /** @type {HieroProto.proto.IResponseHeader} */ (
              tokenGetInfo.header
          );
      }

      /**
       * @override
       * @internal
       * @param {HieroProto.proto.IResponse} response
       * @param {AccountId} nodeAccountId
       * @param {HieroProto.proto.IQuery} request
       * @returns {Promise<TokenInfo>}
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _mapResponse(response, nodeAccountId, request) {
          const info = /** @type {HieroProto.proto.ITokenGetInfoResponse} */ (
              response.tokenGetInfo
          );

          return Promise.resolve(
              TokenInfo._fromProtobuf(
                  /** @type {HieroProto.proto.ITokenInfo} */ (info.tokenInfo),
              ),
          );
      }

      /**
       * @override
       * @internal
       * @param {HieroProto.proto.IQueryHeader} header
       * @returns {HieroProto.proto.IQuery}
       */
      _onMakeRequest(header) {
          return {
              tokenGetInfo: {
                  header,
                  token:
                      this._tokenId != null ? this._tokenId._toProtobuf() : null,
              },
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp =
              this._paymentTransactionId != null &&
              this._paymentTransactionId.validStart != null
                  ? this._paymentTransactionId.validStart
                  : this._timestamp;

          return `TokenInfoQuery:${timestamp.toString()}`;
      }
  }

  // eslint-disable-next-line @typescript-eslint/unbound-method
  QUERY_REGISTRY.set("tokenGetInfo", TokenInfoQuery._fromProtobuf);

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
   * @typedef {import("@hashgraph/proto").proto.ITokenMintTransactionBody} HieroProto.proto.ITokenMintTransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("../account/AccountId.js").default} AccountId
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   * @typedef {import("bignumber.js").default} BigNumber
   */

  /**
   * Mint a new Hedera crypto-currency token.
   */
  class TokenMintTransaction extends Transaction {
      /**
       * @param {object} [props]
       * @param {TokenId | string} [props.tokenId]
       * @param {Long | number | BigNumber | bigint} [props.amount]
       * @param {Uint8Array[]} [props.metadata]
       */
      constructor(props = {}) {
          super();

          /**
           * @private
           * @type {?TokenId}
           */
          this._tokenId = null;

          /**
           * @private
           * @type {?Long}
           */
          this._amount = null;

          /**
           * @private
           * @type {Uint8Array[]}
           */
          this._metadata = [];

          if (props.tokenId != null) {
              this.setTokenId(props.tokenId);
          }

          if (props.amount != null) {
              this.setAmount(props.amount);
          }

          if (props.metadata != null) {
              this.setMetadata(props.metadata);
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransaction[]} transactions
       * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {HieroProto.proto.ITransactionBody[]} bodies
       * @returns {TokenMintTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];
          const mintToken =
              /** @type {HieroProto.proto.ITokenMintTransactionBody} */ (
                  body.tokenMint
              );

          return Transaction._fromProtobufTransactions(
              new TokenMintTransaction({
                  tokenId:
                      mintToken.token != null
                          ? TokenId._fromProtobuf(mintToken.token)
                          : undefined,
                  amount: mintToken.amount != null ? mintToken.amount : undefined,
                  metadata:
                      mintToken.metadata != null ? mintToken.metadata : undefined,
              }),
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * @returns {?TokenId}
       */
      get tokenId() {
          return this._tokenId;
      }

      /**
       * @param {TokenId | string} tokenId
       * @returns {this}
       */
      setTokenId(tokenId) {
          this._requireNotFrozen();
          this._tokenId =
              typeof tokenId === "string"
                  ? TokenId.fromString(tokenId)
                  : tokenId.clone();

          return this;
      }

      /**
       * @returns {?Long}
       */
      get amount() {
          return this._amount;
      }

      /**
       * @param {Long | number | BigNumber | bigint} amount
       * @returns {this}
       */
      setAmount(amount) {
          this._requireNotFrozen();
          this._amount = convertAmountToLong(amount);

          return this;
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          if (this._tokenId != null) {
              this._tokenId.validateChecksum(client);
          }
      }

      /**
       * @returns {Uint8Array[]}
       */
      get metadata() {
          return this._metadata;
      }

      /**
       * @param {Uint8Array | string} metadata
       * @returns {this}
       */
      addMetadata(metadata) {
          this._requireNotFrozen();

          if (typeof metadata === "string") {
              console.warn(
                  "Passing a `string` for token metadata is considered a bug, and has been removed. Please provide a `Uint8Array` instead.",
              );
          }

          this._metadata.push(
              typeof metadata === "string" ? decode$8(metadata) : metadata,
          );

          return this;
      }

      /**
       * @param {Uint8Array[]} metadata
       * @returns {this}
       */
      setMetadata(metadata) {
          this._requireNotFrozen();

          for (const data of metadata) {
              if (typeof data === "string") {
                  console.warn(
                      "Passing a `string` for token metadata is considered a bug, and has been removed. Please provide a `Uint8Array` instead.",
                  );
                  break;
              }
          }

          this._metadata = metadata.map((data) =>
              typeof data === "string" ? decode$8(data) : data,
          );

          return this;
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.ITransaction} request
       * @returns {Promise<HieroProto.proto.ITransactionResponse>}
       */
      _execute(channel, request) {
          return channel.token.mintToken(request);
      }

      /**
       * @override
       * @protected
       * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "tokenMint";
      }

      /**
       * @override
       * @protected
       * @returns {HieroProto.proto.ITokenMintTransactionBody}
       */
      _makeTransactionData() {
          return {
              amount: this._amount,
              token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
              metadata: this._metadata,
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("../Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `TokenMintTransaction:${timestamp.toString()}`;
      }
  }

  TRANSACTION_REGISTRY.set(
      "tokenMint",
      // eslint-disable-next-line @typescript-eslint/unbound-method
      TokenMintTransaction._fromProtobuf,
  );

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.TokenFreezeStatus} HieroProto.proto.TokenFreezeStatus
   * @typedef {import("@hashgraph/proto").proto.TokenKycStatus} HieroProto.proto.TokenKycStatus
   * @typedef {import("@hashgraph/proto").proto.TokenPauseStatus} HieroProto.proto.TokenPauseStatus
   * @typedef {import("@hashgraph/proto").proto.ITokenNftInfo} HieroProto.proto.ITokenNftInfo
   * @typedef {import("@hashgraph/proto").proto.INftID} HieroProto.proto.INftID
   * @typedef {import("@hashgraph/proto").proto.ITimestamp} HieroProto.proto.ITimestamp
   * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
   * @typedef {import("@hashgraph/proto").proto.IAccountID} HieroProto.proto.IAccountID
   * @typedef {import("@hashgraph/proto").proto.IKey} HieroProto.proto.IKey
   * @typedef {import("@hashgraph/proto").proto.IDuration} HieroProto.proto.IDuration
   */

  class TokenNftInfo {
      /**
       * @private
       * @param {object} props
       * @param {NftId} props.nftId
       * @param {AccountId} props.accountId
       * @param {Timestamp} props.creationTime
       * @param {Uint8Array | null} props.metadata
       * @param {LedgerId|null} props.ledgerId
       * @param {AccountId|null} props.spenderId
       */
      constructor(props) {
          /**
           * ID of the nft instance
           *
           * @readonly
           */
          this.nftId = props.nftId;

          /**
           * @readonly
           */
          this.accountId = props.accountId;

          /**
           * @readonly
           */
          this.creationTime = props.creationTime;

          /**
           * @readonly
           */
          this.metadata = props.metadata;

          this.ledgerId = props.ledgerId;

          this.spenderId = props.spenderId;

          Object.freeze(this);
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITokenNftInfo} info
       * @returns {TokenNftInfo}
       */
      static _fromProtobuf(info) {
          return new TokenNftInfo({
              nftId: NftId._fromProtobuf(
                  /** @type {HieroProto.proto.INftID} */ (info.nftID),
              ),
              accountId: AccountId._fromProtobuf(
                  /** @type {HieroProto.proto.IAccountID} */ (info.accountID),
              ),
              creationTime: Timestamp._fromProtobuf(
                  /** @type {HieroProto.proto.ITimestamp} */ (info.creationTime),
              ),
              metadata: info.metadata !== undefined ? info.metadata : null,
              ledgerId:
                  info.ledgerId != null
                      ? LedgerId.fromBytes(info.ledgerId)
                      : null,
              spenderId:
                  info.spenderId != null
                      ? AccountId._fromProtobuf(info.spenderId)
                      : null,
          });
      }

      /**
       * @returns {HieroProto.proto.ITokenNftInfo}
       */
      _toProtobuf() {
          return {
              nftID: this.nftId._toProtobuf(),
              accountID: this.accountId._toProtobuf(),
              creationTime: this.creationTime._toProtobuf(),
              metadata: this.metadata,
              ledgerId: this.ledgerId != null ? this.ledgerId.toBytes() : null,
              spenderId:
                  this.spenderId != null ? this.spenderId._toProtobuf() : null,
          };
      }

      /**
       * @typedef {object} TokenNftInfoJson
       * @property {string} nftId
       * @property {string} accountId
       * @property {string} creationTime
       * @property {string | null} metadata
       * @property {string | null} ledgerId
       * @property {string | null} spenderId
       * @returns {TokenNftInfoJson}
       */
      toJson() {
          return {
              nftId: this.nftId.toString(),
              accountId: this.accountId.toString(),
              creationTime: this.creationTime.toString(),
              metadata: this.metadata != null ? encode$5(this.metadata) : null,
              ledgerId: this.ledgerId != null ? this.ledgerId.toString() : null,
              spenderId:
                  this.spenderId != null ? this.spenderId.toString() : null,
          };
      }

      /**
       * @returns {string}
       */
      toString() {
          return JSON.stringify(this.toJson());
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.IQuery} HieroProto.proto.IQuery
   * @typedef {import("@hashgraph/proto").proto.IQueryHeader} HieroProto.proto.IQueryHeader
   * @typedef {import("@hashgraph/proto").proto.IResponse} HieroProto.proto.IResponse
   * @typedef {import("@hashgraph/proto").proto.ITokenNftInfo} HieroProto.proto.ITokenNftInfo
   * @typedef {import("@hashgraph/proto").proto.IResponseHeader} HieroProto.proto.IResponseHeader
   * @typedef {import("@hashgraph/proto").proto.ITokenGetNftInfoQuery} HieroProto.proto.ITokenGetNftInfoQuery
   * @typedef {import("@hashgraph/proto").proto.ITokenGetNftInfosQuery} HieroProto.proto.ITokenGetNftInfosQuery
   * @typedef {import("@hashgraph/proto").proto.ITokenGetAccountNftInfosQuery} HieroProto.proto.ITokenGetAccountNftInfosQuery
   * @typedef {import("@hashgraph/proto").proto.ITokenGetNftInfoResponse} HieroProto.proto.ITokenGetNftInfoResponse
   * @typedef {import("@hashgraph/proto").proto.ITokenGetNftInfosResponse} HieroProto.proto.ITokenGetNftInfosResponse
   * @typedef {import("@hashgraph/proto").proto.ITokenGetAccountNftInfosResponse} HieroProto.proto.ITokenGetAccountNftInfosResponse
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   */

  /**
   * @augments {Query<TokenNftInfo[]>}
   */
  class TokenNftInfoQuery extends Query {
      /**
       * @param {object} properties
       * @param {NftId | string} [properties.nftId]
       * @param {AccountId | string} [properties.accountId]
       * @param {TokenId | string} [properties.tokenId]
       * @param {Long | number} [properties.start]
       * @param {Long | number} [properties.end]
       */
      constructor(properties = {}) {
          super();

          /**
           * @private
           * @type {?NftId}
           */
          this._nftId = null;
          if (properties.nftId != null) {
              this.setNftId(properties.nftId);
          }

          /**
           * @private
           * @type {?AccountId}
           */
          this._accountId = null;
          if (properties.accountId != null) {
              // eslint-disable-next-line deprecation/deprecation
              this.setAccountId(properties.accountId);
          }

          /**
           * @private
           * @type {?TokenId}
           */
          this._tokenId = null;
          if (properties.tokenId != null) {
              // eslint-disable-next-line deprecation/deprecation
              this.setTokenId(properties.tokenId);
          }

          /**
           * @private
           * @type {?Long}
           */
          this._start = null;
          if (properties.start != null) {
              // eslint-disable-next-line deprecation/deprecation
              this.setStart(properties.start);
          }

          /**
           * @private
           * @type {?Long}
           */
          this._end = null;
          if (properties.end != null) {
              // eslint-disable-next-line deprecation/deprecation
              this.setEnd(properties.end);
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.IQuery} query
       * @returns {TokenNftInfoQuery}
       */
      static _fromProtobuf(query) {
          if (query.tokenGetNftInfo != null) {
              const info = /** @type {HieroProto.proto.ITokenGetNftInfoQuery} */ (
                  query.tokenGetNftInfo
              );

              return new TokenNftInfoQuery({
                  nftId:
                      info.nftID != null
                          ? NftId._fromProtobuf(info.nftID)
                          : undefined,
              });
          } else if (query.tokenGetAccountNftInfos != null) {
              const info =
                  /** @type {HieroProto.proto.ITokenGetAccountNftInfosQuery} */ (
                      query.tokenGetAccountNftInfos
                  );

              return new TokenNftInfoQuery({
                  accountId:
                      info.accountID != null
                          ? AccountId._fromProtobuf(info.accountID)
                          : undefined,
                  start: info.start != null ? info.start : undefined,
                  end: info.end != null ? info.end : undefined,
              });
          } else {
              const info =
                  /** @type {HieroProto.proto.ITokenGetNftInfosQuery} */ (
                      query.tokenGetNftInfos
                  );

              return new TokenNftInfoQuery({
                  tokenId:
                      info.tokenID != null
                          ? TokenId._fromProtobuf(info.tokenID)
                          : undefined,
                  start: info.start != null ? info.start : undefined,
                  end: info.end != null ? info.end : undefined,
              });
          }
      }

      /**
       * @returns {?NftId}
       */
      get nftId() {
          return this._nftId;
      }

      /**
       * Set the token ID for which the info is being requested.
       *
       * @param {NftId | string} nftId
       * @returns {TokenNftInfoQuery}
       */
      setNftId(nftId) {
          this._nftId =
              typeof nftId === "string"
                  ? NftId.fromString(nftId)
                  : NftId._fromProtobuf(nftId._toProtobuf());

          return this;
      }

      /**
       * @deprecated with no replacement
       * @returns {?AccountId}
       */
      get accountId() {
          console.warn(
              "`TokenNftInfoQuery.accountId` is deprecated with no replacement",
          );
          return this._accountId;
      }

      /**
       * @deprecated with no replacement
       * Set the token ID for which the info is being requested.
       * @param {AccountId | string} accountId
       * @returns {TokenNftInfoQuery}
       */
      setAccountId(accountId) {
          console.warn(
              "`TokenNftInfoQuery.setAccountId()` is deprecated with no replacement",
          );
          this._accountId =
              typeof accountId === "string"
                  ? AccountId.fromString(accountId)
                  : AccountId._fromProtobuf(accountId._toProtobuf());

          return this;
      }

      /**
       * @deprecated with no replacement
       * @returns {?TokenId}
       */
      get tokenId() {
          console.warn(
              "`TokenNftInfoQuery.tokenId` is deprecated with no replacement",
          );
          return this._tokenId;
      }

      /**
       * @deprecated with no replacement
       * Set the token ID for which the info is being requested.
       * @param {TokenId | string} tokenId
       * @returns {TokenNftInfoQuery}
       */
      setTokenId(tokenId) {
          console.warn(
              "`TokenNftInfoQuery.setTokenId()` is deprecated with no replacement",
          );
          this._tokenId =
              typeof tokenId === "string"
                  ? TokenId.fromString(tokenId)
                  : TokenId._fromProtobuf(tokenId._toProtobuf());

          return this;
      }

      /**
       * @deprecated with no replacement
       * @returns {?Long}
       */
      get start() {
          console.warn(
              "`TokenNftInfoQuery.start` is deprecated with no replacement",
          );
          return this._start;
      }

      /**
       * @deprecated with no replacement
       * Set the token ID for which the info is being requested.
       * @param {Long | number} start
       * @returns {TokenNftInfoQuery}
       */
      setStart(start) {
          console.warn(
              "`TokenNftInfoQuery.setStart()` is deprecated with no replacement",
          );
          this._start =
              typeof start === "number" ? Long.fromNumber(start) : start;

          return this;
      }

      /**
       * @deprecated with no replacement
       * @returns {?Long}
       */
      get end() {
          console.warn(
              "`TokenNftInfoQuery.end` is deprecated with no replacement",
          );
          return this._end;
      }

      /**
       * @deprecated with no replacement
       * Set the token ID for which the info is being requested.
       * @param {Long | number} end
       * @returns {TokenNftInfoQuery}
       */
      setEnd(end) {
          console.warn(
              "`TokenNftInfoQuery.setEnd()` is deprecated with no replacement",
          );
          this._end = typeof end === "number" ? Long.fromNumber(end) : end;

          return this;
      }

      /**
       * @override
       * @param {import("../client/Client.js").default<Channel, *>} client
       * @returns {Promise<Hbar>}
       */
      async getCost(client) {
          return super.getCost(client);
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.IQuery} request
       * @returns {Promise<HieroProto.proto.IResponse>}
       */
      _execute(channel, request) {
          return channel.token.getTokenNftInfo(request);
      }

      /**
       * @override
       * @internal
       * @param {HieroProto.proto.IResponse} response
       * @returns {HieroProto.proto.IResponseHeader}
       */
      _mapResponseHeader(response) {
          const infos = /** @type {HieroProto.proto.ITokenGetNftInfoResponse} */ (
              response.tokenGetNftInfo
          );

          return /** @type {HieroProto.proto.IResponseHeader} */ (infos.header);
      }

      /**
       * @override
       * @internal
       * @param {HieroProto.proto.IResponse} response
       * @param {AccountId} nodeAccountId
       * @param {HieroProto.proto.IQuery} request
       * @returns {Promise<TokenNftInfo[]>}
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _mapResponse(response, nodeAccountId, request) {
          const nfts = [
              /** @type {HieroProto.proto.ITokenNftInfo} */
              (
                  /** @type {HieroProto.proto.ITokenGetNftInfoResponse} */ (
                      response.tokenGetNftInfo
                  ).nft
              ),
          ];

          return Promise.resolve(
              nfts.map((nft) =>
                  TokenNftInfo._fromProtobuf(
                      /** @type {HieroProto.proto.ITokenNftInfo} */ (nft),
                  ),
              ),
          );
      }

      /**
       * @override
       * @internal
       * @param {HieroProto.proto.IQueryHeader} header
       * @returns {HieroProto.proto.IQuery}
       */
      _onMakeRequest(header) {
          return {
              tokenGetNftInfo: {
                  header,
                  nftID: this._nftId != null ? this._nftId._toProtobuf() : null,
              },
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp =
              this._paymentTransactionId != null &&
              this._paymentTransactionId.validStart != null
                  ? this._paymentTransactionId.validStart
                  : this._timestamp;

          return `TokenNftInfoQuery:${timestamp.toString()}`;
      }
  }

  // eslint-disable-next-line @typescript-eslint/unbound-method
  QUERY_REGISTRY.set("tokenGetNftInfo", TokenNftInfoQuery._fromProtobuf);

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
   * @typedef {import("@hashgraph/proto").proto.ITokenPauseTransactionBody} HieroProto.proto.ITokenPauseTransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   * @typedef {import("../account/AccountId.js").default} AccountId
   */

  /**
   * Pause a new Hedera crypto-currency token.
   */
  class TokenPauseTransaction extends Transaction {
      /**
       * @param {object} [props]
       * @param {TokenId | string} [props.tokenId]
       */
      constructor(props = {}) {
          super();

          /**
           * @private
           * @type {?TokenId}
           */
          this._tokenId = null;

          if (props.tokenId != null) {
              this.setTokenId(props.tokenId);
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransaction[]} transactions
       * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {HieroProto.proto.ITransactionBody[]} bodies
       * @returns {TokenPauseTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];
          const pauseToken =
              /** @type {HieroProto.proto.ITokenPauseTransactionBody} */ (
                  body.tokenPause
              );

          return Transaction._fromProtobufTransactions(
              new TokenPauseTransaction({
                  tokenId:
                      pauseToken.token != null
                          ? TokenId._fromProtobuf(pauseToken.token)
                          : undefined,
              }),
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * @returns {?TokenId}
       */
      get tokenId() {
          return this._tokenId;
      }

      /**
       * @param {TokenId | string} tokenId
       * @returns {this}
       */
      setTokenId(tokenId) {
          this._requireNotFrozen();
          this._tokenId =
              typeof tokenId === "string"
                  ? TokenId.fromString(tokenId)
                  : tokenId.clone();

          return this;
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          if (this._tokenId != null) {
              this._tokenId.validateChecksum(client);
          }
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.ITransaction} request
       * @returns {Promise<HieroProto.proto.ITransactionResponse>}
       */
      _execute(channel, request) {
          return channel.token.pauseToken(request);
      }

      /**
       * @override
       * @protected
       * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "tokenPause";
      }

      /**
       * @override
       * @protected
       * @returns {HieroProto.proto.ITokenPauseTransactionBody}
       */
      _makeTransactionData() {
          return {
              token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("../Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `TokenPauseTransaction:${timestamp.toString()}`;
      }
  }

  TRANSACTION_REGISTRY.set(
      "tokenPause",
      // eslint-disable-next-line @typescript-eslint/unbound-method
      TokenPauseTransaction._fromProtobuf,
  );

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
   * @typedef {import("@hashgraph/proto").proto.ITokenRevokeKycTransactionBody} HieroProto.proto.ITokenRevokeKycTransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   */

  /**
   * RevokeKyc a new Hedera crypto-currency token.
   */
  class TokenRevokeKycTransaction extends Transaction {
      /**
       * @param {object} [props]
       * @param {TokenId | string} [props.tokenId]
       * @param {AccountId | string} [props.accountId]
       */
      constructor(props = {}) {
          super();

          /**
           * @private
           * @type {?TokenId}
           */
          this._tokenId = null;

          /**
           * @private
           * @type {?AccountId}
           */
          this._accountId = null;

          if (props.tokenId != null) {
              this.setTokenId(props.tokenId);
          }

          if (props.accountId != null) {
              this.setAccountId(props.accountId);
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransaction[]} transactions
       * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {HieroProto.proto.ITransactionBody[]} bodies
       * @returns {TokenRevokeKycTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];
          const revokeKycToken =
              /** @type {HieroProto.proto.ITokenRevokeKycTransactionBody} */ (
                  body.tokenRevokeKyc
              );

          return Transaction._fromProtobufTransactions(
              new TokenRevokeKycTransaction({
                  tokenId:
                      revokeKycToken.token != null
                          ? TokenId._fromProtobuf(revokeKycToken.token)
                          : undefined,
                  accountId:
                      revokeKycToken.account != null
                          ? AccountId._fromProtobuf(revokeKycToken.account)
                          : undefined,
              }),
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * @returns {?TokenId}
       */
      get tokenId() {
          return this._tokenId;
      }

      /**
       * @param {TokenId | string} tokenId
       * @returns {this}
       */
      setTokenId(tokenId) {
          this._requireNotFrozen();
          this._tokenId =
              typeof tokenId === "string"
                  ? TokenId.fromString(tokenId)
                  : tokenId.clone();

          return this;
      }

      /**
       * @returns {?AccountId}
       */
      get accountId() {
          return this._accountId;
      }

      /**
       * @param {AccountId | string} accountId
       * @returns {this}
       */
      setAccountId(accountId) {
          this._requireNotFrozen();
          this._accountId =
              typeof accountId === "string"
                  ? AccountId.fromString(accountId)
                  : accountId.clone();

          return this;
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          if (this._tokenId != null) {
              this._tokenId.validateChecksum(client);
          }

          if (this._accountId != null) {
              this._accountId.validateChecksum(client);
          }
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.ITransaction} request
       * @returns {Promise<HieroProto.proto.ITransactionResponse>}
       */
      _execute(channel, request) {
          return channel.token.revokeKycFromTokenAccount(request);
      }

      /**
       * @override
       * @protected
       * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "tokenRevokeKyc";
      }

      /**
       * @override
       * @protected
       * @returns {HieroProto.proto.ITokenRevokeKycTransactionBody}
       */
      _makeTransactionData() {
          return {
              token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
              account:
                  this._accountId != null ? this._accountId._toProtobuf() : null,
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("../Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `TokenRevokeKycTransaction:${timestamp.toString()}`;
      }
  }

  TRANSACTION_REGISTRY.set(
      "tokenRevokeKyc",
      // eslint-disable-next-line @typescript-eslint/unbound-method
      TokenRevokeKycTransaction._fromProtobuf,
  );

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
   * @typedef {import("@hashgraph/proto").proto.ITokenUnfreezeAccountTransactionBody} HieroProto.proto.ITokenUnfreezeAccountTransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   */

  /**
   * Unfreeze a new Hedera crypto-currency token.
   */
  class TokenUnfreezeTransaction extends Transaction {
      /**
       * @param {object} [props]
       * @param {TokenId | string} [props.tokenId]
       * @param {AccountId | string} [props.accountId]
       */
      constructor(props = {}) {
          super();

          /**
           * @private
           * @type {?TokenId}
           */
          this._tokenId = null;

          /**
           * @private
           * @type {?AccountId}
           */
          this._accountId = null;

          if (props.tokenId != null) {
              this.setTokenId(props.tokenId);
          }

          if (props.accountId != null) {
              this.setAccountId(props.accountId);
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransaction[]} transactions
       * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {HieroProto.proto.ITransactionBody[]} bodies
       * @returns {TokenUnfreezeTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];
          const unfreezeToken =
              /** @type {HieroProto.proto.ITokenUnfreezeAccountTransactionBody} */ (
                  body.tokenUnfreeze
              );

          return Transaction._fromProtobufTransactions(
              new TokenUnfreezeTransaction({
                  tokenId:
                      unfreezeToken.token != null
                          ? TokenId._fromProtobuf(unfreezeToken.token)
                          : undefined,
                  accountId:
                      unfreezeToken.account != null
                          ? AccountId._fromProtobuf(unfreezeToken.account)
                          : undefined,
              }),
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * @returns {?TokenId}
       */
      get tokenId() {
          return this._tokenId;
      }

      /**
       * @param {TokenId | string} tokenId
       * @returns {this}
       */
      setTokenId(tokenId) {
          this._requireNotFrozen();
          this._tokenId =
              typeof tokenId === "string"
                  ? TokenId.fromString(tokenId)
                  : tokenId.clone();

          return this;
      }

      /**
       * @returns {?AccountId}
       */
      get accountId() {
          return this._accountId;
      }

      /**
       * @param {AccountId | string} accountId
       * @returns {this}
       */
      setAccountId(accountId) {
          this._requireNotFrozen();
          this._accountId =
              typeof accountId === "string"
                  ? AccountId.fromString(accountId)
                  : accountId.clone();

          return this;
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          if (this._tokenId != null) {
              this._tokenId.validateChecksum(client);
          }

          if (this._accountId != null) {
              this._accountId.validateChecksum(client);
          }
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.ITransaction} request
       * @returns {Promise<HieroProto.proto.ITransactionResponse>}
       */
      _execute(channel, request) {
          return channel.token.unfreezeTokenAccount(request);
      }

      /**
       * @override
       * @protected
       * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "tokenUnfreeze";
      }

      /**
       * @override
       * @protected
       * @returns {HieroProto.proto.ITokenUnfreezeAccountTransactionBody}
       */
      _makeTransactionData() {
          return {
              token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
              account:
                  this._accountId != null ? this._accountId._toProtobuf() : null,
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("../Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `TokenUnfreezeTransaction:${timestamp.toString()}`;
      }
  }

  TRANSACTION_REGISTRY.set(
      "tokenUnfreeze",
      // eslint-disable-next-line @typescript-eslint/unbound-method
      TokenUnfreezeTransaction._fromProtobuf,
  );

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
   * @typedef {import("@hashgraph/proto").proto.ITokenUnpauseTransactionBody} HieroProto.proto.ITokenUnpauseTransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   * @typedef {import("../account/AccountId.js").default} AccountId
   */

  /**
   * Unpause a new Hedera crypto-currency token.
   */
  class TokenUnpauseTransaction extends Transaction {
      /**
       * @param {object} [props]
       * @param {TokenId | string} [props.tokenId]
       */
      constructor(props = {}) {
          super();

          /**
           * @private
           * @type {?TokenId}
           */
          this._tokenId = null;

          if (props.tokenId != null) {
              this.setTokenId(props.tokenId);
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransaction[]} transactions
       * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {HieroProto.proto.ITransactionBody[]} bodies
       * @returns {TokenUnpauseTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];
          const unpauseToken =
              /** @type {HieroProto.proto.ITokenUnpauseTransactionBody} */ (
                  body.tokenUnpause
              );

          return Transaction._fromProtobufTransactions(
              new TokenUnpauseTransaction({
                  tokenId:
                      unpauseToken.token != null
                          ? TokenId._fromProtobuf(unpauseToken.token)
                          : undefined,
              }),
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * @returns {?TokenId}
       */
      get tokenId() {
          return this._tokenId;
      }

      /**
       * @param {TokenId | string} tokenId
       * @returns {this}
       */
      setTokenId(tokenId) {
          this._requireNotFrozen();
          this._tokenId =
              typeof tokenId === "string"
                  ? TokenId.fromString(tokenId)
                  : tokenId.clone();

          return this;
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          if (this._tokenId != null) {
              this._tokenId.validateChecksum(client);
          }
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.ITransaction} request
       * @returns {Promise<HieroProto.proto.ITransactionResponse>}
       */
      _execute(channel, request) {
          return channel.token.unpauseToken(request);
      }

      /**
       * @override
       * @protected
       * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "tokenUnpause";
      }

      /**
       * @override
       * @protected
       * @returns {HieroProto.proto.ITokenUnpauseTransactionBody}
       */
      _makeTransactionData() {
          return {
              token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("../Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `TokenUnpauseTransaction:${timestamp.toString()}`;
      }
  }

  TRANSACTION_REGISTRY.set(
      "tokenUnpause",
      // eslint-disable-next-line @typescript-eslint/unbound-method
      TokenUnpauseTransaction._fromProtobuf,
  );

  // SPDX-License-Identifier: Apache-2.0

  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.TokenKeyValidation} HieroProto.proto.TokenKeyValidation
   */

  /** Types of validation strategies for token keys. */
  class TokenKeyValidation {
      /**
       * @hideconstructor
       * @internal
       * @param {number} code
       */
      constructor(code) {
          /** @readonly */
          this._code = code;

          Object.freeze(this);
      }

      /**
       * @returns {string}
       */
      toString() {
          switch (this) {
              case TokenKeyValidation.FullValidation:
                  return "FULL_VALIDATION";
              case TokenKeyValidation.NoValidation:
                  return "NO_VALIDATION";
              default:
                  return `UNKNOWN (${this._code})`;
          }
      }

      /**
       * @internal
       * @param {number} code
       * @returns {TokenKeyValidation}
       */
      static _fromCode(code) {
          switch (code) {
              case 0:
                  return TokenKeyValidation.FullValidation;
              case 1:
                  return TokenKeyValidation.NoValidation;
          }

          throw new Error(
              `(BUG) TokenKeyValidation.fromCode() does not handle code: ${code}`,
          );
      }

      /**
       * @returns {HieroProto.proto.TokenKeyValidation}
       */
      valueOf() {
          return this._code;
      }
  }

  /**
   * Currently the default behaviour. It will perform all token key validations.
   */
  TokenKeyValidation.FullValidation = new TokenKeyValidation(0);

  /**
   * Perform no validations at all for all passed token keys.
   */
  TokenKeyValidation.NoValidation = new TokenKeyValidation(1);

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
   * @typedef {import("@hashgraph/proto").proto.ITokenUpdateTransactionBody} HieroProto.proto.ITokenUpdateTransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
   */

  /**
   * @typedef {import("bignumber.js").default} BigNumber
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   */

  /**
   * Update a new Hedera crypto-currency token.
   */
  class TokenUpdateTransaction extends Transaction {
      /**
       * @param {object} [props]
       * @param {TokenId | string} [props.tokenId]
       * @param {?string} [props.tokenName]
       * @param {?string} [props.tokenSymbol]
       * @param {AccountId | string} [props.treasuryAccountId]
       * @param {Key} [props.adminKey]
       * @param {Key} [props.kycKey]
       * @param {Key} [props.freezeKey]
       * @param {Key} [props.wipeKey]
       * @param {Key} [props.supplyKey]
       * @param {AccountId | string} [props.autoRenewAccountId]
       * @param {Timestamp | Date} [props.expirationTime]
       * @param {Duration | Long | number} [props.autoRenewPeriod]
       * @param {?string} [props.tokenMemo]
       * @param {Key} [props.feeScheduleKey]
       * @param {Key} [props.pauseKey]
       * @param {Key} [props.metadataKey]
       * @param {?Uint8Array} [props.metadata]
       * @param {TokenKeyValidation} [props.keyVerificationMode]
       */
      constructor(props = {}) {
          super();

          /**
           * @private
           * @type {?TokenId}
           */
          this._tokenId = null;

          /**
           * @private
           * @type {?string}
           */
          this._tokenName = null;

          /**
           * @private
           * @type {?string}
           */
          this._tokenSymbol = null;

          /**
           * @private
           * @type {?AccountId}
           */
          this._treasuryAccountId = null;

          /**
           * @private
           * @type {?Key}
           */
          this._adminKey = null;

          /**
           * @private
           * @type {?Key}
           */
          this._kycKey = null;

          /**
           * @private
           * @type {?Key}
           */
          this._freezeKey = null;

          /**
           * @private
           * @type {?Key}
           */
          this._wipeKey = null;

          /**
           * @private
           * @type {?Key}
           */
          this._supplyKey = null;

          /**
           * @private
           * @type {?AccountId}
           */
          this._autoRenewAccountId = null;

          /**
           * @private
           * @type {?Timestamp}
           */
          this._expirationTime = null;

          /**
           * @private
           * @type {?Duration}
           */
          this._autoRenewPeriod = null;

          /**
           * @private
           * @type {?string}
           */
          this._tokenMemo = null;

          /**
           * @private
           * @type {?Key}
           */
          this._feeScheduleKey = null;

          /**
           * @private
           * @type {?Key}
           */
          this._pauseKey = null;

          /**
           * @private
           * @type {?Key}
           */
          this._metadataKey = null;

          /**
           * @private
           * @type {?Uint8Array}
           */
          this._metadata = null;

          /**
           * @private
           * @type {?TokenKeyValidation}
           * Determines whether the system should check the validity of the passed keys for update.
           * Defaults to FULL_VALIDATION
           */
          this._keyVerificationMode = TokenKeyValidation.FullValidation;

          if (props.tokenId != null) {
              this.setTokenId(props.tokenId);
          }

          if (props.tokenName != null) {
              this.setTokenName(props.tokenName);
          }

          if (props.tokenSymbol != null) {
              this.setTokenSymbol(props.tokenSymbol);
          }

          if (props.treasuryAccountId != null) {
              this.setTreasuryAccountId(props.treasuryAccountId);
          }

          if (props.adminKey != null) {
              this.setAdminKey(props.adminKey);
          }

          if (props.kycKey != null) {
              this.setKycKey(props.kycKey);
          }

          if (props.freezeKey != null) {
              this.setFreezeKey(props.freezeKey);
          }

          if (props.wipeKey != null) {
              this.setWipeKey(props.wipeKey);
          }

          if (props.supplyKey != null) {
              this.setSupplyKey(props.supplyKey);
          }

          if (props.autoRenewAccountId != null) {
              this.setAutoRenewAccountId(props.autoRenewAccountId);
          }

          if (props.expirationTime != null) {
              this.setExpirationTime(props.expirationTime);
          }

          if (props.autoRenewPeriod != null) {
              this.setAutoRenewPeriod(props.autoRenewPeriod);
          }

          if (props.tokenMemo != null) {
              this.setTokenMemo(props.tokenMemo);
          }

          if (props.feeScheduleKey != null) {
              this.setFeeScheduleKey(props.feeScheduleKey);
          }

          if (props.pauseKey != null) {
              this.setPauseKey(props.pauseKey);
          }

          if (props.metadataKey != null) {
              this.setMetadataKey(props.metadataKey);
          }

          if (props.metadata != null) {
              this.setMetadata(props.metadata);
          }

          if (props.keyVerificationMode != null) {
              this.setKeyVerificationMode(props.keyVerificationMode);
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransaction[]} transactions
       * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {HieroProto.proto.ITransactionBody[]} bodies
       * @returns {TokenUpdateTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];
          const update =
              /** @type {HieroProto.proto.ITokenUpdateTransactionBody} */ (
                  body.tokenUpdate
              );

          return Transaction._fromProtobufTransactions(
              new TokenUpdateTransaction({
                  tokenId:
                      update.token != null
                          ? TokenId._fromProtobuf(update.token)
                          : undefined,
                  tokenName: Object.hasOwn(update, "name")
                      ? update.name
                      : undefined,
                  tokenSymbol: Object.hasOwn(update, "symbol")
                      ? update.symbol
                      : undefined,
                  treasuryAccountId:
                      update.treasury != null
                          ? AccountId._fromProtobuf(update.treasury)
                          : undefined,
                  adminKey:
                      update.adminKey != null
                          ? Key._fromProtobufKey(update.adminKey)
                          : undefined,
                  kycKey:
                      update.kycKey != null
                          ? Key._fromProtobufKey(update.kycKey)
                          : undefined,
                  freezeKey:
                      update.freezeKey != null
                          ? Key._fromProtobufKey(update.freezeKey)
                          : undefined,
                  wipeKey:
                      update.wipeKey != null
                          ? Key._fromProtobufKey(update.wipeKey)
                          : undefined,
                  supplyKey:
                      update.supplyKey != null
                          ? Key._fromProtobufKey(update.supplyKey)
                          : undefined,
                  autoRenewAccountId:
                      update.autoRenewAccount != null
                          ? AccountId._fromProtobuf(update.autoRenewAccount)
                          : undefined,
                  expirationTime:
                      update.expiry != null
                          ? Timestamp._fromProtobuf(update.expiry)
                          : undefined,
                  autoRenewPeriod:
                      update.autoRenewPeriod != null
                          ? Duration._fromProtobuf(update.autoRenewPeriod)
                          : undefined,
                  tokenMemo:
                      update.memo != null
                          ? Object.hasOwn(update.memo, "value")
                              ? update.memo.value
                              : undefined
                          : undefined,
                  feeScheduleKey:
                      update.feeScheduleKey != null
                          ? Key._fromProtobufKey(update.feeScheduleKey)
                          : undefined,
                  pauseKey:
                      update.pauseKey != null
                          ? Key._fromProtobufKey(update.pauseKey)
                          : undefined,
                  metadataKey:
                      update.metadataKey != null
                          ? Key._fromProtobufKey(update.metadataKey)
                          : undefined,
                  metadata:
                      update.metadata != null
                          ? Object.hasOwn(update.metadata, "value")
                              ? update.metadata.value
                              : undefined
                          : undefined,
                  keyVerificationMode:
                      update.keyVerificationMode != null
                          ? TokenKeyValidation._fromCode(
                                update.keyVerificationMode,
                            )
                          : undefined,
              }),
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * @returns {?TokenId}
       */
      get tokenId() {
          return this._tokenId;
      }

      /**
       * @param {TokenId | string} tokenId
       * @returns {this}
       */
      setTokenId(tokenId) {
          this._requireNotFrozen();
          this._tokenId =
              typeof tokenId === "string"
                  ? TokenId.fromString(tokenId)
                  : tokenId.clone();

          return this;
      }

      /**
       * @returns {?string}
       */
      get tokenName() {
          return this._tokenName;
      }

      /**
       * @param {string} name
       * @returns {this}
       */
      setTokenName(name) {
          this._requireNotFrozen();
          this._tokenName = name;

          return this;
      }

      /**
       * @returns {?string}
       */
      get tokenSymbol() {
          return this._tokenSymbol;
      }

      /**
       * @param {string} symbol
       * @returns {this}
       */
      setTokenSymbol(symbol) {
          this._requireNotFrozen();
          this._tokenSymbol = symbol;

          return this;
      }

      /**
       * @returns {?AccountId}
       */
      get treasuryAccountId() {
          return this._treasuryAccountId;
      }

      /**
       * @param {AccountId | string} id
       * @returns {this}
       */
      setTreasuryAccountId(id) {
          this._requireNotFrozen();
          this._treasuryAccountId =
              typeof id === "string" ? AccountId.fromString(id) : id.clone();

          return this;
      }

      /**
       * @returns {?Key}
       */
      get adminKey() {
          return this._adminKey;
      }

      /**
       * @param {Key} key
       * @returns {this}
       */
      setAdminKey(key) {
          this._requireNotFrozen();
          this._adminKey = key;

          return this;
      }

      /**
       * @returns {?Key}
       */
      get kycKey() {
          return this._kycKey;
      }

      /**
       * @param {Key} key
       * @returns {this}
       */
      setKycKey(key) {
          this._requireNotFrozen();
          this._kycKey = key;

          return this;
      }

      /**
       * @returns {?Key}
       */
      get freezeKey() {
          return this._freezeKey;
      }

      /**
       * @param {Key} key
       * @returns {this}
       */
      setFreezeKey(key) {
          this._requireNotFrozen();
          this._freezeKey = key;

          return this;
      }

      /**
       * @returns {?Key}
       */
      get wipeKey() {
          return this._wipeKey;
      }

      /**
       * @param {Key} key
       * @returns {this}
       */
      setWipeKey(key) {
          this._requireNotFrozen();
          this._wipeKey = key;

          return this;
      }

      /**
       * @returns {?Key}
       */
      get supplyKey() {
          return this._supplyKey;
      }

      /**
       * @param {Key} key
       * @returns {this}
       */
      setSupplyKey(key) {
          this._requireNotFrozen();
          this._supplyKey = key;

          return this;
      }

      /**
       * @deprecated
       * @param {Key} key
       * @returns {this}
       */
      setsupplyKey(key) {
          this._requireNotFrozen();
          this._supplyKey = key;

          return this;
      }

      /**
       * @returns {?Timestamp}
       */
      get expirationTime() {
          return this._expirationTime;
      }

      /**
       * @param {Timestamp | Date} time
       * @returns {this}
       */
      setExpirationTime(time) {
          this._requireNotFrozen();
          this._expirationTime =
              time instanceof Timestamp ? time : Timestamp.fromDate(time);

          return this;
      }

      /**
       * @returns {?AccountId}
       */
      get autoRenewAccountId() {
          return this._autoRenewAccountId;
      }

      /**
       * @param {AccountId | string} id
       * @returns {this}
       */
      setAutoRenewAccountId(id) {
          this._requireNotFrozen();
          this._autoRenewAccountId =
              id instanceof AccountId ? id : AccountId.fromString(id);

          return this;
      }

      /**
       * @returns {?Duration}
       */
      get autoRenewPeriod() {
          return this._autoRenewPeriod;
      }

      /**
       * Set the auto renew period for this token.
       *
       * @param {Duration | Long | number} autoRenewPeriod
       * @returns {this}
       */
      setAutoRenewPeriod(autoRenewPeriod) {
          this._requireNotFrozen();
          this._autoRenewPeriod =
              autoRenewPeriod instanceof Duration
                  ? autoRenewPeriod
                  : new Duration(autoRenewPeriod);

          return this;
      }

      /**
       * @returns {?string}
       */
      get tokenMemo() {
          return this._tokenMemo;
      }

      /**
       * @param {string} tokenMemo
       * @returns {this}
       */
      setTokenMemo(tokenMemo) {
          this._requireNotFrozen();
          this._tokenMemo = tokenMemo;

          return this;
      }

      /**
       * @returns {?Key}
       */
      get feeScheduleKey() {
          return this._feeScheduleKey;
      }

      /**
       * @param {Key} feeScheduleKey
       * @returns {this}
       */
      setFeeScheduleKey(feeScheduleKey) {
          this._requireNotFrozen();
          this._feeScheduleKey = feeScheduleKey;

          return this;
      }

      /**
       * @returns {?Key}
       */
      get pauseKey() {
          return this._pauseKey;
      }

      /**
       * @param {Key} pauseKey
       * @returns {this}
       */
      setPauseKey(pauseKey) {
          this._requireNotFrozen();
          this._pauseKey = pauseKey;
          return this;
      }

      /**
       * @returns {?Key}
       */
      get metadataKey() {
          return this._metadataKey;
      }

      /**
       * @param {Key} metadataKey
       * @returns {this}
       */
      setMetadataKey(metadataKey) {
          this._requireNotFrozen();
          this._metadataKey = metadataKey;

          return this;
      }

      /**
       * @returns {?Uint8Array}
       */
      get metadata() {
          return this._metadata;
      }

      /**
       * @param {Uint8Array} metadata
       * @returns {this}
       */
      setMetadata(metadata) {
          this._requireNotFrozen();
          this._metadata = metadata;

          return this;
      }

      /**
       * @returns {?TokenKeyValidation}
       */
      get keyVerificationMode() {
          return this._keyVerificationMode;
      }

      /**
       * @param {TokenKeyValidation} keyVerificationMode
       * @returns {this}
       */
      setKeyVerificationMode(keyVerificationMode) {
          this._requireNotFrozen();
          this._keyVerificationMode = keyVerificationMode;

          return this;
      }

      /**
       * @returns {this}
       */
      clearTokenMemo() {
          this._requireNotFrozen();
          this._tokenMemo = null;

          return this;
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          if (this._tokenId != null) {
              this._tokenId.validateChecksum(client);
          }

          if (this._treasuryAccountId != null) {
              this._treasuryAccountId.validateChecksum(client);
          }

          if (this._autoRenewAccountId != null) {
              this._autoRenewAccountId.validateChecksum(client);
          }
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.ITransaction} request
       * @returns {Promise<HieroProto.proto.ITransactionResponse>}
       */
      _execute(channel, request) {
          return channel.token.updateToken(request);
      }

      /**
       * @override
       * @protected
       * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "tokenUpdate";
      }

      /**
       * @override
       * @protected
       * @returns {HieroProto.proto.ITokenUpdateTransactionBody}
       */
      _makeTransactionData() {
          return {
              token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
              name: this.tokenName != null ? this.tokenName : null,
              symbol: this.tokenSymbol,
              treasury:
                  this._treasuryAccountId != null
                      ? this._treasuryAccountId._toProtobuf()
                      : null,
              adminKey:
                  this._adminKey != null ? this._adminKey._toProtobufKey() : null,
              kycKey: this._kycKey != null ? this._kycKey._toProtobufKey() : null,
              freezeKey:
                  this._freezeKey != null
                      ? this._freezeKey._toProtobufKey()
                      : null,
              pauseKey:
                  this._pauseKey != null ? this._pauseKey._toProtobufKey() : null,
              wipeKey:
                  this._wipeKey != null ? this._wipeKey._toProtobufKey() : null,
              supplyKey:
                  this._supplyKey != null
                      ? this._supplyKey._toProtobufKey()
                      : null,
              autoRenewAccount:
                  this._autoRenewAccountId != null
                      ? this._autoRenewAccountId._toProtobuf()
                      : null,
              expiry:
                  this._expirationTime != null
                      ? this._expirationTime._toProtobuf()
                      : null,
              autoRenewPeriod:
                  this._autoRenewPeriod != null
                      ? this._autoRenewPeriod._toProtobuf()
                      : null,
              memo:
                  this._tokenMemo != null
                      ? {
                            value: this._tokenMemo,
                        }
                      : null,
              feeScheduleKey:
                  this._feeScheduleKey != null
                      ? this._feeScheduleKey._toProtobufKey()
                      : null,
              metadataKey:
                  this._metadataKey != null
                      ? this._metadataKey._toProtobufKey()
                      : null,
              metadata:
                  this._metadata != null
                      ? {
                            value: this._metadata,
                        }
                      : null,
              keyVerificationMode:
                  this._keyVerificationMode != null
                      ? this._keyVerificationMode._code
                      : undefined,
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("../Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `TokenUpdateTransaction:${timestamp.toString()}`;
      }
  }

  TRANSACTION_REGISTRY.set(
      "tokenUpdate",
      // eslint-disable-next-line @typescript-eslint/unbound-method
      TokenUpdateTransaction._fromProtobuf,
  );

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
   * @typedef {import("@hashgraph/proto").proto.ITokenWipeAccountTransactionBody} HieroProto.proto.ITokenWipeAccountTransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   * @typedef {import("bignumber.js").default} BigNumber
   */

  /**
   * Wipe a new Hedera crypto-currency token.
   */
  class TokenWipeTransaction extends Transaction {
      /**
       * @param {object} [props]
       * @param {TokenId | string} [props.tokenId]
       * @param {AccountId | string} [props.accountId]
       * @param {Long | number | BigNumber | bigint} [props.amount]
       * @param {(Long | number)[]} [props.serials]
       */
      constructor(props = {}) {
          super();

          /**
           * @private
           * @type {?TokenId}
           */
          this._tokenId = null;

          /**
           * @private
           * @type {?AccountId}
           */
          this._accountId = null;

          /**
           * @private
           * @type {?Long[]}
           */
          this._serials = [];

          /**
           * @private
           * @type {?Long}
           */
          this._amount = null;

          if (props.tokenId != null) {
              this.setTokenId(props.tokenId);
          }

          if (props.accountId != null) {
              this.setAccountId(props.accountId);
          }

          if (props.amount != null) {
              this.setAmount(props.amount);
          }

          if (props.serials != null) {
              this.setSerials(props.serials);
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransaction[]} transactions
       * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {HieroProto.proto.ITransactionBody[]} bodies
       * @returns {TokenWipeTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];
          const wipeToken =
              /** @type {HieroProto.proto.ITokenWipeAccountTransactionBody} */ (
                  body.tokenWipe
              );

          return Transaction._fromProtobufTransactions(
              new TokenWipeTransaction({
                  tokenId:
                      wipeToken.token != null
                          ? TokenId._fromProtobuf(wipeToken.token)
                          : undefined,
                  accountId:
                      wipeToken.account != null
                          ? AccountId._fromProtobuf(wipeToken.account)
                          : undefined,
                  amount: wipeToken.amount != null ? wipeToken.amount : undefined,
                  serials:
                      wipeToken.serialNumbers != null
                          ? wipeToken.serialNumbers
                          : undefined,
              }),
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * @returns {?TokenId}
       */
      get tokenId() {
          return this._tokenId;
      }

      /**
       * @param {TokenId | string} tokenId
       * @returns {this}
       */
      setTokenId(tokenId) {
          this._requireNotFrozen();
          this._tokenId =
              typeof tokenId === "string"
                  ? TokenId.fromString(tokenId)
                  : tokenId.clone();

          return this;
      }

      /**
       * @returns {?AccountId}
       */
      get accountId() {
          return this._accountId;
      }

      /**
       * @param {AccountId | string} accountId
       * @returns {this}
       */
      setAccountId(accountId) {
          this._requireNotFrozen();
          this._accountId =
              typeof accountId === "string"
                  ? AccountId.fromString(accountId)
                  : accountId.clone();

          return this;
      }

      /**
       * @returns {?Long}
       */
      get amount() {
          return this._amount;
      }

      /**
       * @param {Long | number | BigNumber | bigint} amount
       * @returns {this}
       */
      setAmount(amount) {
          this._requireNotFrozen();
          this._amount = convertAmountToLong(amount);

          return this;
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          if (this._tokenId != null) {
              this._tokenId.validateChecksum(client);
          }

          if (this._accountId != null) {
              this._accountId.validateChecksum(client);
          }
      }

      /**
       * @returns {?Long[]}
       */
      get serials() {
          return this._serials;
      }

      /**
       * @param {(Long | number)[]} serials
       * @returns {this}
       */
      setSerials(serials) {
          this._requireNotFrozen();
          this._serials = serials.map((serial) =>
              typeof serial === "number" ? Long.fromNumber(serial) : serial,
          );

          return this;
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.ITransaction} request
       * @returns {Promise<HieroProto.proto.ITransactionResponse>}
       */
      _execute(channel, request) {
          return channel.token.wipeTokenAccount(request);
      }

      /**
       * @override
       * @protected
       * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "tokenWipe";
      }

      /**
       * @override
       * @protected
       * @returns {HieroProto.proto.ITokenWipeAccountTransactionBody}
       */
      _makeTransactionData() {
          return {
              amount: this._amount,
              token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
              account:
                  this._accountId != null ? this._accountId._toProtobuf() : null,
              serialNumbers: this.serials,
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("../Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `TokenWipeTransaction:${timestamp.toString()}`;
      }
  }

  TRANSACTION_REGISTRY.set(
      "tokenWipe",
      // eslint-disable-next-line @typescript-eslint/unbound-method
      TokenWipeTransaction._fromProtobuf,
  );

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.IConsensusCreateTopicTransactionBody} HieroProto.proto.IConsensusCreateTopicTransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   */

  /**
   * Create a topic to be used for consensus.
   */
  class TopicCreateTransaction extends Transaction {
      /**
       * @param {object} props
       * @param {Key} [props.adminKey]
       * @param {Key} [props.submitKey]
       * @param {Key} [props.feeScheduleKey]
       * @param {Duration | Long | number} [props.autoRenewPeriod]
       * @param {AccountId | string} [props.autoRenewAccountId]
       * @param {CustomFixedFee[]} [props.customFees]
       * @param {Key[]} [props.feeExemptKeys]
       * @param {string} [props.topicMemo]
       */
      constructor(props = {}) {
          super();

          this._defaultMaxTransactionFee = new Hbar(25);

          /**
           * @private
           * @type {?Key}
           */
          this._adminKey = null;

          /**
           * @private
           * @type {?Key}
           */
          this._submitKey = null;

          /**
           * @private
           * @type {?Key}
           */
          this._feeScheduleKey = null;

          /**
           * @private
           * @type {Key[]}
           */
          this._feeExemptKeys = [];

          /**
           * @private
           * @type {?AccountId}
           */
          this._autoRenewAccountId = null;

          /**
           * @private
           * @type {Duration}
           */
          this._autoRenewPeriod = new Duration(DEFAULT_AUTO_RENEW_PERIOD);

          /**
           * @private
           * @type {CustomFixedFee[]}
           */
          this._customFees = [];

          /**
           * @private
           * @type {?string}
           */
          this._topicMemo = null;

          if (props.adminKey != null) {
              this.setAdminKey(props.adminKey);
          }

          if (props.submitKey != null) {
              this.setSubmitKey(props.submitKey);
          }

          if (props.feeScheduleKey != null) {
              this.setFeeScheduleKey(props.feeScheduleKey);
          }

          if (props.feeExemptKeys != null) {
              this.setFeeExemptKeys(props.feeExemptKeys);
          }

          if (props.autoRenewAccountId != null) {
              this.setAutoRenewAccountId(props.autoRenewAccountId);
          }

          if (props.autoRenewPeriod != null) {
              this.setAutoRenewPeriod(props.autoRenewPeriod);
          }

          if (props.customFees != null) {
              this.setCustomFees(props.customFees);
          }

          if (props.topicMemo != null) {
              this.setTopicMemo(props.topicMemo);
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransaction[]} transactions
       * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {HieroProto.proto.ITransactionBody[]} bodies
       * @returns {TopicCreateTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];
          const create =
              /** @type {HieroProto.proto.IConsensusCreateTopicTransactionBody} */ (
                  body.consensusCreateTopic
              );

          return Transaction._fromProtobufTransactions(
              new TopicCreateTransaction({
                  adminKey:
                      create.adminKey != null
                          ? Key._fromProtobufKey(create.adminKey)
                          : undefined,
                  submitKey:
                      create.submitKey != null
                          ? Key._fromProtobufKey(create.submitKey)
                          : undefined,
                  feeScheduleKey:
                      create.feeScheduleKey != null
                          ? Key._fromProtobufKey(create.feeScheduleKey)
                          : undefined,
                  feeExemptKeys:
                      create.feeExemptKeyList != null
                          ? create.feeExemptKeyList.map((key) =>
                                Key._fromProtobufKey(key),
                            )
                          : undefined,
                  autoRenewAccountId:
                      create.autoRenewAccount != null
                          ? AccountId._fromProtobuf(create.autoRenewAccount)
                          : undefined,
                  autoRenewPeriod:
                      create.autoRenewPeriod != null
                          ? create.autoRenewPeriod.seconds != null
                              ? create.autoRenewPeriod.seconds
                              : undefined
                          : undefined,
                  customFees:
                      create.customFees != null
                          ? create.customFees.map((customFee) =>
                                CustomFixedFee._fromProtobuf(customFee),
                            )
                          : undefined,
                  topicMemo: create.memo != null ? create.memo : undefined,
              }),
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * @deprecated  - Use `getTopicMemo()` instead
       * @returns {?string}
       */
      get topicMemo() {
          return this._topicMemo;
      }

      /**
       * @returns {?string}
       */
      getTopicMemo() {
          return this._topicMemo;
      }

      /**
       * @param {string} topicMemo
       * @returns {this}
       */
      setTopicMemo(topicMemo) {
          this._requireNotFrozen();
          this._topicMemo = topicMemo;

          return this;
      }

      /**
       * @deprecated  - Use `getAdminKey()` instead
       * @returns {?Key}
       */
      get adminKey() {
          return this._adminKey;
      }

      /**
       * @returns {?Key}
       */
      getAdminKey() {
          return this._adminKey;
      }

      /**
       * @param {Key} adminKey
       * @returns {this}
       */
      setAdminKey(adminKey) {
          this._requireNotFrozen();
          this._adminKey = adminKey;

          return this;
      }

      /**
       * @deprecated  - Use `getSubmitKey()` instead
       * @returns {?Key}
       */
      get submitKey() {
          return this._submitKey;
      }

      /**
       * @returns {?Key}
       */
      getSubmitKey() {
          return this._submitKey;
      }

      /**
       * @param {Key} submitKey
       * @returns {this}
       */
      setSubmitKey(submitKey) {
          this._requireNotFrozen();
          this._submitKey = submitKey;

          return this;
      }

      /**
       * Returns the key which allows updates to the new topics fees.
       * @returns {?Key}
       */
      getFeeScheduleKey() {
          return this._feeScheduleKey;
      }

      /**
       * Sets the key which allows updates to the new topics fees.
       * @param {Key} feeScheduleKey
       * @returns {this}
       */
      setFeeScheduleKey(feeScheduleKey) {
          this._requireNotFrozen();
          this._feeScheduleKey = feeScheduleKey;

          return this;
      }

      /**
       * Returns the keys that will be exempt from paying fees.
       * @returns {Key[]}
       */
      getFeeExemptKeys() {
          return this._feeExemptKeys;
      }

      /**
       * Sets the keys that will be exempt from paying fees.
       * @param {Key[]} feeExemptKeys
       * @returns {this}
       */
      setFeeExemptKeys(feeExemptKeys) {
          this._requireNotFrozen();
          this._feeExemptKeys = feeExemptKeys;

          return this;
      }

      /**
       * Adds a key that will be exempt from paying fees.
       * @param {Key} key
       * @returns {this}
       */
      addFeeExemptKey(key) {
          this._requireNotFrozen();
          this._feeExemptKeys.push(key);

          return this;
      }

      /**
       * Clears all keys that will be exempt from paying fees.
       * @returns {this}
       */
      clearFeeExemptKeys() {
          this._requireNotFrozen();
          this._feeExemptKeys = [];

          return this;
      }

      /**
       * @deprecated  - Use `getAutoRenewAccountId()` instead
       * @returns {?AccountId}
       */
      get autoRenewAccountId() {
          return this._autoRenewAccountId;
      }

      /**
       * @returns {?AccountId}
       */
      getAutoRenewAccountId() {
          return this._autoRenewAccountId;
      }

      /**
       * @param {AccountId | string} autoRenewAccountId
       * @returns {this}
       */
      setAutoRenewAccountId(autoRenewAccountId) {
          this._requireNotFrozen();
          this._autoRenewAccountId =
              autoRenewAccountId instanceof AccountId
                  ? autoRenewAccountId
                  : AccountId.fromString(autoRenewAccountId);

          return this;
      }

      /**
       * @deprecated  - Use `getAutoRenewPeriod()` instead
       * @returns {Duration}
       */
      get autoRenewPeriod() {
          return this._autoRenewPeriod;
      }

      /**
       * @returns {Duration}
       */
      getAutoRenewPeriod() {
          return this._autoRenewPeriod;
      }

      /**
       * Set the auto renew period for this account.
       *
       * @param {Duration | Long | number} autoRenewPeriod
       * @returns {this}
       */
      setAutoRenewPeriod(autoRenewPeriod) {
          this._requireNotFrozen();
          this._autoRenewPeriod =
              autoRenewPeriod instanceof Duration
                  ? autoRenewPeriod
                  : new Duration(autoRenewPeriod);

          return this;
      }

      /**
       * Returns the fixed fees to assess when a message is submitted to the new topic.
       * @returns {CustomFixedFee[]}
       */
      getCustomFees() {
          return this._customFees;
      }

      /**
       * Sets the fixed fees to assess when a message is submitted to the new topic.
       *
       * @param {CustomFixedFee[]} customFees
       * @returns {this}
       */
      setCustomFees(customFees) {
          this._requireNotFrozen();
          this._customFees = customFees;

          return this;
      }

      /**
       * Adds fixed fee to assess when a message is submitted to the new topic.
       *
       * @param {CustomFixedFee} customFee
       * @returns {this}
       */
      addCustomFee(customFee) {
          this._requireNotFrozen();

          this._customFees.push(customFee);

          return this;
      }

      /**
       * Clears fixed fees.
       *
       * @returns {this}
       */
      clearCustomFees() {
          this._requireNotFrozen();

          this._customFees = [];

          return this;
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          if (this._autoRenewAccountId != null) {
              this._autoRenewAccountId.validateChecksum(client);
          }
      }

      /*
       * Temporarily disabled due to issues with consensus node version 0.60.
       * This will be reintroduced once all networks (previewnet, testnet, mainnet)
       * are on version 0.60.
       *
       * @override
       * @param {?import("../client/Client.js").default<Channel, *>} client
       * @returns {this}
       */
      /*
      freezeWith(client) {
          if (!this._autoRenewAccountId && this.transactionId?.accountId) {
              this.setAutoRenewAccountId(this.transactionId?.accountId);
          } else if (!this._autoRenewAccountId && client?.operatorAccountId) {
              this.setAutoRenewAccountId(client.operatorAccountId);
          }
          return super.freezeWith(client);
      }
      */

      /**
       * @override
       * @param {?import("../client/Client.js").default<Channel, *>} client
       * @returns {this}
       */
      freezeWith(client) {
          if (!this._autoRenewAccountId && this.transactionId?.accountId) {
              this.setAutoRenewAccountId(this.transactionId?.accountId);
          } else if (!this._autoRenewAccountId && client?.operatorAccountId) {
              this.setAutoRenewAccountId(client.operatorAccountId);
          }
          return super.freezeWith(client);
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.ITransaction} request
       * @returns {Promise<HieroProto.proto.ITransactionResponse>}
       */
      _execute(channel, request) {
          return channel.consensus.createTopic(request);
      }

      /**
       * @override
       * @protected
       * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "consensusCreateTopic";
      }

      /**
       * @override
       * @protected
       * @returns {HieroProto.proto.IConsensusCreateTopicTransactionBody}
       */
      _makeTransactionData() {
          return {
              adminKey:
                  this._adminKey != null ? this._adminKey._toProtobufKey() : null,
              submitKey:
                  this._submitKey != null
                      ? this._submitKey._toProtobufKey()
                      : null,
              feeScheduleKey:
                  this._feeScheduleKey != null
                      ? this._feeScheduleKey._toProtobufKey()
                      : null,
              feeExemptKeyList: this._feeExemptKeys.map((key) =>
                  key._toProtobufKey(),
              ),
              autoRenewAccount:
                  this._autoRenewAccountId != null
                      ? this._autoRenewAccountId._toProtobuf()
                      : null,
              autoRenewPeriod: this._autoRenewPeriod._toProtobuf(),
              customFees: this._customFees.map((customFee) =>
                  customFee._toTopicFeeProtobuf(),
              ),
              memo: this._topicMemo,
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("../Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `TopicCreateTransaction:${timestamp.toString()}`;
      }
  }

  TRANSACTION_REGISTRY.set(
      "consensusCreateTopic",
      // eslint-disable-next-line @typescript-eslint/unbound-method
      TopicCreateTransaction._fromProtobuf,
  );

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.IConsensusDeleteTopicTransactionBody} HieroProto.proto.IConsensusDeleteTopicTransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("../account/AccountId.js").default} AccountId
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   */

  /**
   * Delete a topic.
   *
   * No more transactions or queries on the topic will succeed.
   *
   * If an adminKey is set, this transaction must be signed by that key.
   * If there is no adminKey, this transaction will fail with Status#Unautorized.
   */
  class TopicDeleteTransaction extends Transaction {
      /**
       * @param {object} props
       * @param {TopicId | string} [props.topicId]
       */
      constructor(props = {}) {
          super();

          /**
           * @private
           * @type {?TopicId}
           */
          this._topicId = null;

          if (props.topicId != null) {
              this.setTopicId(props.topicId);
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransaction[]} transactions
       * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {HieroProto.proto.ITransactionBody[]} bodies
       * @returns {TopicDeleteTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];
          const topicDelete =
              /** @type {HieroProto.proto.IConsensusDeleteTopicTransactionBody} */ (
                  body.consensusDeleteTopic
              );

          return Transaction._fromProtobufTransactions(
              new TopicDeleteTransaction({
                  topicId:
                      topicDelete.topicID != null
                          ? TopicId._fromProtobuf(topicDelete.topicID)
                          : undefined,
              }),
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * @returns {?TopicId}
       */
      get topicId() {
          return this._topicId;
      }

      /**
       * Set the topic ID which is being deleted in this transaction.
       *
       * @param {TopicId | string} topicId
       * @returns {TopicDeleteTransaction}
       */
      setTopicId(topicId) {
          this._requireNotFrozen();
          this._topicId =
              typeof topicId === "string"
                  ? TopicId.fromString(topicId)
                  : topicId.clone();

          return this;
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          if (this._topicId != null) {
              this._topicId.validateChecksum(client);
          }
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.ITransaction} request
       * @returns {Promise<HieroProto.proto.ITransactionResponse>}
       */
      _execute(channel, request) {
          return channel.consensus.deleteTopic(request);
      }

      /**
       * @override
       * @protected
       * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "consensusDeleteTopic";
      }

      /**
       * @override
       * @protected
       * @returns {HieroProto.proto.IConsensusDeleteTopicTransactionBody}
       */
      _makeTransactionData() {
          return {
              topicID: this._topicId != null ? this._topicId._toProtobuf() : null,
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("../Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `TopicDeleteTransaction:${timestamp.toString()}`;
      }
  }

  TRANSACTION_REGISTRY.set(
      "consensusDeleteTopic",
      // eslint-disable-next-line @typescript-eslint/unbound-method
      TopicDeleteTransaction._fromProtobuf,
  );

  // SPDX-License-Identifier: Apache-2.0


  /**
   * Current state of a topic.
   */
  class TopicInfo {
      /**
       * @private
       * @param {object} props
       * @param {TopicId} props.topicId
       * @param {string} props.topicMemo
       * @param {Uint8Array} props.runningHash
       * @param {Long} props.sequenceNumber
       * @param {?Timestamp} props.expirationTime
       * @param {?Key} props.adminKey
       * @param {?Key} props.submitKey
       * @param {?Key} props.feeScheduleKey
       * @param {?Key[]} props.feeExemptKeys
       * @param {?Duration} props.autoRenewPeriod
       * @param {?AccountId} props.autoRenewAccountId
       * @param {?CustomFixedFee[]} props.customFees
       * @param {LedgerId|null} props.ledgerId
       */
      constructor(props) {
          /**
           * The ID of the topic for which information is requested.
           *
           * @readonly
           */
          this.topicId = props.topicId;

          /**
           * Short publicly visible memo about the topic. No guarantee of uniqueness.
           *
           * @readonly
           */
          this.topicMemo = props.topicMemo;

          /**
           * SHA-384 running hash of (previousRunningHash, topicId, consensusTimestamp, sequenceNumber, message).
           *
           * @readonly
           */
          this.runningHash = props.runningHash;

          /**
           * Sequence number (starting at 1 for the first submitMessage) of messages on the topic.
           *
           * @readonly
           */
          this.sequenceNumber = props.sequenceNumber;

          /**
           * Effective consensus timestamp at (and after) which submitMessage calls will no longer succeed on the topic.
           *
           * @readonly
           */
          this.expirationTime = props.expirationTime;

          /**
           * Access control for update/delete of the topic. Null if there is no key.
           *
           * @readonly
           */
          this.adminKey = props.adminKey;

          /**
           * Access control for ConsensusService.submitMessage. Null if there is no key.
           *
           * @readonly
           */
          this.submitKey = props.submitKey;

          /**
           * Access control for updating topic fees. Null If there is no key.
           *
           * @readonly
           */
          this.feeScheduleKey = props.feeScheduleKey;

          /**
           * The keys that will are exempt from paying fees.
           * @readonly
           */
          this.feeExemptKeys = props.feeExemptKeys;
          /**
           * @readonly
           */
          this.autoRenewPeriod = props.autoRenewPeriod;

          /**
           * @readonly
           */
          this.autoRenewAccountId = props.autoRenewAccountId;

          /**
           * The fixed fees assessed when a message is submitted to the topic.
           * @readonly
           */
          this.customFees = props.customFees;

          this.ledgerId = props.ledgerId;

          Object.freeze(this);
      }

      /**
       * @internal
       * @param {HieroProto.proto.IConsensusGetTopicInfoResponse} infoResponse
       * @returns {TopicInfo}
       */
      static _fromProtobuf(infoResponse) {
          const info = /** @type {HieroProto.proto.IConsensusTopicInfo} */ (
              infoResponse.topicInfo
          );

          return new TopicInfo({
              topicId: TopicId._fromProtobuf(
                  /** @type {HieroProto.proto.ITopicID} */ (infoResponse.topicID),
              ),
              topicMemo: info.memo != null ? info.memo : "",
              runningHash:
                  info.runningHash != null ? info.runningHash : new Uint8Array(),
              sequenceNumber:
                  info.sequenceNumber != null
                      ? info.sequenceNumber instanceof Long
                          ? info.sequenceNumber
                          : Long.fromValue(info.sequenceNumber)
                      : Long.ZERO,
              expirationTime:
                  info.expirationTime != null
                      ? Timestamp._fromProtobuf(info.expirationTime)
                      : null,
              adminKey:
                  info.adminKey != null
                      ? Key._fromProtobufKey(info.adminKey)
                      : null,
              submitKey:
                  info.submitKey != null
                      ? Key._fromProtobufKey(info.submitKey)
                      : null,
              feeScheduleKey:
                  info.feeScheduleKey != null
                      ? Key._fromProtobufKey(info.feeScheduleKey)
                      : null,
              feeExemptKeys:
                  info.feeExemptKeyList != null
                      ? info.feeExemptKeyList.map((key) =>
                            Key._fromProtobufKey(key),
                        )
                      : null,
              autoRenewPeriod:
                  info.autoRenewPeriod != null
                      ? new Duration(
                            /** @type {Long} */ (info.autoRenewPeriod.seconds),
                        )
                      : null,
              autoRenewAccountId:
                  info.autoRenewAccount != null
                      ? AccountId._fromProtobuf(info.autoRenewAccount)
                      : null,
              customFees:
                  info.customFees != null
                      ? info.customFees.map((customFee) =>
                            CustomFixedFee._fromProtobuf(customFee),
                        )
                      : null,
              ledgerId:
                  info.ledgerId != null
                      ? LedgerId.fromBytes(info.ledgerId)
                      : null,
          });
      }

      /**
       * @internal
       * @returns {HieroProto.proto.IConsensusGetTopicInfoResponse}
       */
      _toProtobuf() {
          return {
              topicID: this.topicId._toProtobuf(),
              topicInfo: {
                  memo: this.topicMemo,
                  runningHash: this.runningHash,
                  sequenceNumber: this.sequenceNumber,
                  expirationTime:
                      this.expirationTime != null
                          ? this.expirationTime._toProtobuf()
                          : null,
                  adminKey:
                      this.adminKey != null
                          ? this.adminKey._toProtobufKey()
                          : null,
                  submitKey:
                      this.submitKey != null
                          ? this.submitKey._toProtobufKey()
                          : null,
                  feeScheduleKey:
                      this.feeScheduleKey != null
                          ? this.feeScheduleKey._toProtobufKey()
                          : null,
                  feeExemptKeyList:
                      this.feeExemptKeys != null
                          ? this.feeExemptKeys.map((key) => key._toProtobufKey())
                          : null,
                  autoRenewPeriod:
                      this.autoRenewPeriod != null
                          ? this.autoRenewPeriod._toProtobuf()
                          : null,
                  autoRenewAccount:
                      this.autoRenewAccountId != null
                          ? this.autoRenewAccountId._toProtobuf()
                          : null,
                  customFees:
                      this.customFees != null
                          ? this.customFees.map((customFee) =>
                                customFee._toProtobuf(),
                            )
                          : null,
              },
          };
      }

      /**
       * @param {Uint8Array} bytes
       * @returns {TopicInfo}
       */
      static fromBytes(bytes) {
          return TopicInfo._fromProtobuf(
              libExports.proto.ConsensusGetTopicInfoResponse.decode(bytes),
          );
      }

      /**
       * @returns {Uint8Array}
       */
      toBytes() {
          return libExports.proto.ConsensusGetTopicInfoResponse.encode(
              /** @type {HieroProto.proto.ConsensusGetTopicInfoResponse} */ (
                  this._toProtobuf()
              ),
          ).finish();
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.IQuery} HieroProto.proto.IQuery
   * @typedef {import("@hashgraph/proto").proto.IQueryHeader} HieroProto.proto.IQueryHeader
   * @typedef {import("@hashgraph/proto").proto.IResponse} HieroProto.proto.IResponse
   * @typedef {import("@hashgraph/proto").proto.IResponseHeader} HieroProto.proto.IResponseHeader
   * @typedef {import("@hashgraph/proto").proto.IConsensusGetTopicInfoResponse} HieroProto.proto.IConsensusGetTopicInfoResponse
   * @typedef {import("@hashgraph/proto").proto.IConsensusGetTopicInfoQuery} HieroProto.proto.IConsensusGetTopicInfoQuery
   */

  /**
   * @namespace com
   * @typedef {import("@hashgraph/proto").com.hedera.mirror.api.proto.IConsensusTopicResponse} com.hedera.mirror.api.proto.IConsensusTopicResponse
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("../account/AccountId.js").default} AccountId
   */

  /**
   * Retrieve the latest state of a topic.
   *
   * @augments {Query<TopicInfo>}
   */
  class TopicInfoQuery extends Query {
      /**
       * @param {object} [props]
       * @param {TopicId | string} [props.topicId]
       */
      constructor(props = {}) {
          super();

          /**
           * @private
           * @type {?TopicId}
           */
          this._topicId = null;

          if (props.topicId != null) {
              this.setTopicId(props.topicId);
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.IQuery} query
       * @returns {TopicInfoQuery}
       */
      static _fromProtobuf(query) {
          const info =
              /** @type {HieroProto.proto.IConsensusGetTopicInfoQuery} */ (
                  query.consensusGetTopicInfo
              );

          return new TopicInfoQuery({
              topicId:
                  info.topicID != null
                      ? TopicId._fromProtobuf(info.topicID)
                      : undefined,
          });
      }

      /**
       * @returns {?TopicId}
       */
      get topicId() {
          return this._topicId;
      }

      /**
       * Set the topic ID for which the info is being requested.
       *
       * @param {TopicId | string} topicId
       * @returns {TopicInfoQuery}
       */
      setTopicId(topicId) {
          this._topicId =
              typeof topicId === "string"
                  ? TopicId.fromString(topicId)
                  : topicId.clone();

          return this;
      }

      /**
       * @override
       * @param {import("../client/Client.js").default<Channel, *>} client
       * @returns {Promise<Hbar>}
       */
      async getCost(client) {
          return super.getCost(client);
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          if (this._topicId != null) {
              this._topicId.validateChecksum(client);
          }
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.IQuery} request
       * @returns {Promise<HieroProto.proto.IResponse>}
       */
      _execute(channel, request) {
          return channel.consensus.getTopicInfo(request);
      }

      /**
       * @override
       * @internal
       * @param {HieroProto.proto.IResponse} response
       * @returns {HieroProto.proto.IResponseHeader}
       */
      _mapResponseHeader(response) {
          const consensusGetTopicInfo =
              /** @type {HieroProto.proto.IConsensusGetTopicInfoResponse} */ (
                  response.consensusGetTopicInfo
              );
          return /** @type {HieroProto.proto.IResponseHeader} */ (
              consensusGetTopicInfo.header
          );
      }

      /**
       * @protected
       * @override
       * @param {HieroProto.proto.IResponse} response
       * @param {AccountId} nodeAccountId
       * @param {HieroProto.proto.IQuery} request
       * @returns {Promise<TopicInfo>}
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _mapResponse(response, nodeAccountId, request) {
          return Promise.resolve(
              TopicInfo._fromProtobuf(
                  /** @type {HieroProto.proto.IConsensusGetTopicInfoResponse} */ (
                      response.consensusGetTopicInfo
                  ),
              ),
          );
      }

      /**
       * @override
       * @internal
       * @param {HieroProto.proto.IQueryHeader} header
       * @returns {HieroProto.proto.IQuery}
       */
      _onMakeRequest(header) {
          return {
              consensusGetTopicInfo: {
                  header,
                  topicID:
                      this._topicId != null ? this._topicId._toProtobuf() : null,
              },
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp =
              this._paymentTransactionId != null &&
              this._paymentTransactionId.validStart != null
                  ? this._paymentTransactionId.validStart
                  : this._timestamp;

          return `TopicInfoQuery:${timestamp.toString()}`;
      }
  }

  // eslint-disable-next-line @typescript-eslint/unbound-method
  QUERY_REGISTRY.set("consensusGetTopicInfo", TopicInfoQuery._fromProtobuf);

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITimestamp} HieroProto.proto.ITimestamp
   */

  /**
   * @namespace com
   * @typedef {import("@hashgraph/proto").com.hedera.mirror.api.proto.IConsensusTopicResponse} com.hedera.mirror.api.proto.IConsensusTopicResponse
   */

  class TopicMessageChunk {
      /**
       * @private
       * @param {object} props
       * @param {Timestamp} props.consensusTimestamp
       * @param {Uint8Array} props.contents
       * @param {Uint8Array} props.runningHash
       * @param {Long} props.sequenceNumber
       */
      constructor(props) {
          /** @readonly */
          this.consensusTimestamp = props.consensusTimestamp;
          /** @readonly */
          this.contents = props.contents;
          /** @readonly */
          this.runningHash = props.runningHash;
          /** @readonly */
          this.sequenceNumber = props.sequenceNumber;

          Object.freeze(this);
      }

      /**
       * @internal
       * @param {com.hedera.mirror.api.proto.IConsensusTopicResponse} response
       * @returns {TopicMessageChunk}
       */
      static _fromProtobuf(response) {
          return new TopicMessageChunk({
              consensusTimestamp: Timestamp._fromProtobuf(
                  /** @type {HieroProto.proto.ITimestamp} */
                  (response.consensusTimestamp),
              ),
              contents:
                  response.message != null ? response.message : new Uint8Array(),
              runningHash:
                  response.runningHash != null
                      ? response.runningHash
                      : new Uint8Array(),
              sequenceNumber:
                  response.sequenceNumber != null
                      ? response.sequenceNumber instanceof Long
                          ? response.sequenceNumber
                          : Long.fromValue(response.sequenceNumber)
                      : Long.ZERO,
          });
      }

      /**
       * @internal
       * @returns {com.hedera.mirror.api.proto.IConsensusTopicResponse}
       */
      _toProtobuf() {
          return {
              consensusTimestamp: this.consensusTimestamp._toProtobuf(),
              message: this.contents,
              runningHash: this.runningHash,
              sequenceNumber: this.sequenceNumber,
          };
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITimestamp} HieroProto.proto.ITimestamp
   */

  /**
   * @namespace com
   * @typedef {import("@hashgraph/proto").com.hedera.mirror.api.proto.IConsensusTopicResponse} com.hedera.mirror.api.proto.IConsensusTopicResponse
   */

  class TopicMessage {
      /**
       * @private
       * @param {object} props
       * @param {Timestamp} props.consensusTimestamp
       * @param {Uint8Array} props.contents
       * @param {Uint8Array} props.runningHash
       * @param {Long} props.sequenceNumber
       * @param {?TransactionId} props.initialTransactionId
       * @param {TopicMessageChunk[]} props.chunks
       */
      constructor(props) {
          /** @readonly */
          this.consensusTimestamp = props.consensusTimestamp;
          /** @readonly */
          this.contents = props.contents;
          /** @readonly */
          this.runningHash = props.runningHash;
          /** @readonly */
          this.sequenceNumber = props.sequenceNumber;
          /** @readonly */
          this.chunks = props.chunks;
          /** @readonly */
          this.initialTransactionId = props.initialTransactionId;

          Object.freeze(this);
      }

      /**
       * @internal
       * @param {com.hedera.mirror.api.proto.IConsensusTopicResponse} response
       * @returns {TopicMessage}
       */
      static _ofSingle(response) {
          return new TopicMessage({
              consensusTimestamp: Timestamp._fromProtobuf(
                  /** @type {HieroProto.proto.ITimestamp} */
                  (response.consensusTimestamp),
              ),
              contents:
                  response.message != null ? response.message : new Uint8Array(),
              runningHash:
                  response.runningHash != null
                      ? response.runningHash
                      : new Uint8Array(),
              sequenceNumber:
                  response.sequenceNumber != null
                      ? response.sequenceNumber instanceof Long
                          ? response.sequenceNumber
                          : Long.fromNumber(response.sequenceNumber)
                      : Long.ZERO,
              initialTransactionId:
                  response.chunkInfo != null &&
                  response.chunkInfo.initialTransactionID != null
                      ? TransactionId._fromProtobuf(
                            response.chunkInfo.initialTransactionID,
                        )
                      : null,
              chunks: [TopicMessageChunk._fromProtobuf(response)],
          });
      }

      /**
       * @internal
       * @param {com.hedera.mirror.api.proto.IConsensusTopicResponse[]} responses
       * @returns {TopicMessage}
       */
      static _ofMany(responses) {
          const length = responses.length;

          const last =
              /** @type {com.hedera.mirror.api.proto.IConsensusTopicResponse} */ (
                  responses[length - 1]
              );

          const consensusTimestamp = Timestamp._fromProtobuf(
              /** @type {HieroProto.proto.ITimestamp} */
              (last.consensusTimestamp),
          );

          const runningHash = /** @type {Uint8Array} */ (last.runningHash);

          /**
           * @type {Long}
           */
          const sequenceNumber =
              last.sequenceNumber != null
                  ? last.sequenceNumber instanceof Long
                      ? last.sequenceNumber
                      : Long.fromValue(last.sequenceNumber)
                  : Long.ZERO;

          responses.sort((a, b) =>
              (a != null
                  ? a.chunkInfo != null
                      ? a.chunkInfo.number != null
                          ? a.chunkInfo.number
                          : 0
                      : 0
                  : 0) <
              (b != null
                  ? b.chunkInfo != null
                      ? b.chunkInfo.number != null
                          ? b.chunkInfo.number
                          : 0
                      : 0
                  : 0)
                  ? -1
                  : 1,
          );

          /**
           * @type {TopicMessageChunk[]}
           */
          const chunks = responses.map(
              /**
               * @type {com.hedera.mirror.api.proto.IConsensusTopicResponse}
               */ (m) => TopicMessageChunk._fromProtobuf(m),
          );

          const size = chunks
              .map((chunk) => chunk.contents.length)
              .reduce((sum, current) => sum + current, 0);

          const contents = new Uint8Array(size);
          let offset = 0;

          responses.forEach((value) => {
              contents.set(/** @type {Uint8Array} */ (value.message), offset);
              offset += /** @type {Uint8Array} */ (value.message).length;
          });

          let initialTransactionId = null;
          if (
              responses.length > 0 &&
              responses[0].chunkInfo != null &&
              responses[0].chunkInfo.initialTransactionID != null
          ) {
              initialTransactionId = TransactionId._fromProtobuf(
                  responses[0].chunkInfo.initialTransactionID,
              );
          }

          return new TopicMessage({
              consensusTimestamp,
              contents,
              runningHash,
              sequenceNumber,
              chunks,
              initialTransactionId,
          });
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../channel/MirrorChannel.js").default} MirrorChannel
   * @typedef {import("../channel/MirrorChannel.js").MirrorError} MirrorError
   */

  /**
   * @template {Channel} ChannelT
   * @typedef {import("../client/Client.js").default<ChannelT, MirrorChannel>} Client<ChannelT, MirrorChannel>
   */

  /**
   * Represents a class that you can use to subscribe to
   * different topics on Hedera network.
   * @augments {Query<TopicMessageQuery>}
   */
  class TopicMessageQuery {
      /**
       * @param {object} props
       * @param {TopicId | string} [props.topicId]
       * @param {Timestamp} [props.startTime]
       * @param {Timestamp} [props.endTime]
       * @param {(message: TopicMessage | null, error: Error)=> void} [props.errorHandler]
       * @param {() => void} [props.completionHandler]
       * @param {(error: MirrorError | Error | null) => boolean} [props.retryHandler]
       * @param {Long | number} [props.limit]
       */
      constructor(props = {}) {
          /**
           * @private
           * @type {?TopicId}
           */
          this._topicId = null;
          if (props.topicId != null) {
              this.setTopicId(props.topicId);
          }

          /**
           * @private
           * @type {?Timestamp}
           */
          this._startTime = null;
          if (props.startTime != null) {
              this.setStartTime(props.startTime);
          }

          /**
           * @private
           * @type {?Timestamp}
           */
          this._endTime = null;
          if (props.endTime != null) {
              this.setEndTime(props.endTime);
          }

          /**
           * @private
           * @type {?Long}
           */
          this._limit = null;
          if (props.limit != null) {
              this.setLimit(props.limit);
          }

          /**
           * @private
           * @type {(message: TopicMessage | null, error: Error) => void}
           */
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          this._errorHandler = (message, error) => {
              console.error(
                  `Error attempting to subscribe to topic: ${
                    this._topicId != null ? this._topicId.toString() : ""
                }`,
              );
          };

          if (props.errorHandler != null) {
              this._errorHandler = props.errorHandler;
          }

          /*
           * @private
           * @type {((message: TopicMessage) => void) | null}
           */
          this._listener = null;

          /**
           * @private
           * @type {() => void}
           */
          this._completionHandler = () => {
              console.log(
                  `Subscription to topic ${
                    this._topicId != null ? this._topicId.toString() : ""
                } complete`,
              );
          };

          if (props.completionHandler != null) {
              this._completionHandler = props.completionHandler;
          }

          /* The number of times we can retry the grpc call
           *
           * @internal
           * @type {number}
           */
          this._maxAttempts = 20;

          /**
           * This is the request's max backoff
           *
           * @internal
           * @type {number}
           */
          this._maxBackoff = 8000;

          /**
           * @private
           * @type {(error: MirrorError | Error | null) => boolean}
           */
          this._retryHandler = (error) => {
              if (error != null) {
                  if (error instanceof Error) {
                      // Retry on all errors which are not `MirrorError` because they're
                      // likely lower level HTTP/2 errors
                      return true;
                  } else {
                      // Retry on `NOT_FOUND`, `RESOURCE_EXHAUSTED`, `UNAVAILABLE`, and conditionally on `INTERNAL`
                      // if the message matches the right regex.
                      switch (error.code) {
                          // INTERNAL
                          // eslint-disable-next-line no-fallthrough
                          case 13:
                              return RST_STREAM.test(error.details.toString());
                          // NOT_FOUND
                          // eslint-disable-next-line no-fallthrough
                          case 5:
                          // RESOURCE_EXHAUSTED
                          // eslint-disable-next-line no-fallthrough
                          case 8:
                          // UNAVAILABLE
                          // eslint-disable-next-line no-fallthrough
                          case 14:
                          case 17:
                              return true;
                          default:
                              return false;
                      }
                  }
              }

              return false;
          };

          if (props.retryHandler != null) {
              this._retryHandler = props.retryHandler;
          }

          /**
           * @private
           * @type {number}
           */
          this._attempt = 0;

          /**
           * @private
           * @type {SubscriptionHandle | null}
           */
          this._handle = null;

          this.setMaxBackoff(8000);
      }

      /**
       * @returns {?TopicId}
       */
      get topicId() {
          return this._topicId;
      }

      /**
       * @param {TopicId | string} topicId
       * @returns {TopicMessageQuery}
       */
      setTopicId(topicId) {
          this.requireNotSubscribed();

          this._topicId =
              typeof topicId === "string"
                  ? TopicId.fromString(topicId)
                  : topicId.clone();

          return this;
      }

      /**
       * @returns {?Timestamp}
       */
      get startTime() {
          return this._startTime;
      }

      /**
       * @param {Timestamp | Date | number} startTime
       * @returns {TopicMessageQuery}
       */
      setStartTime(startTime) {
          this.requireNotSubscribed();

          this._startTime =
              startTime instanceof Timestamp
                  ? startTime
                  : startTime instanceof Date
                  ? Timestamp.fromDate(startTime)
                  : new Timestamp(startTime, 0);
          return this;
      }

      /**
       * @returns {?Timestamp}
       */
      get endTime() {
          return this._endTime;
      }

      /**
       * @param {Timestamp | Date | number} endTime
       * @returns {TopicMessageQuery}
       */
      setEndTime(endTime) {
          this.requireNotSubscribed();

          this._endTime =
              endTime instanceof Timestamp
                  ? endTime
                  : endTime instanceof Date
                  ? Timestamp.fromDate(endTime)
                  : new Timestamp(endTime, 0);
          return this;
      }

      /**
       * @returns {?Long}
       */
      get limit() {
          return this._limit;
      }

      /**
       * @param {Long | number} limit
       * @returns {TopicMessageQuery}
       */
      setLimit(limit) {
          this.requireNotSubscribed();

          this._limit = limit instanceof Long ? limit : Long.fromValue(limit);

          return this;
      }

      /**
       * @param {(message: TopicMessage | null, error: Error)=> void} errorHandler
       * @returns {TopicMessageQuery}
       */
      setErrorHandler(errorHandler) {
          this._errorHandler = errorHandler;

          return this;
      }

      /**
       * @param {() => void} completionHandler
       * @returns {TopicMessageQuery}
       */
      setCompletionHandler(completionHandler) {
          this.requireNotSubscribed();

          this._completionHandler = completionHandler;

          return this;
      }

      /**
       * @param {number} attempts
       * @returns {this}
       */
      setMaxAttempts(attempts) {
          this.requireNotSubscribed();
          this._maxAttempts = attempts;
          return this;
      }

      /**
       * @param {number} backoff
       * @returns {this}
       */
      setMaxBackoff(backoff) {
          this.requireNotSubscribed();
          this._maxBackoff = backoff;
          return this;
      }

      /**
       * @param {Client<Channel>} client
       * @param {((message: TopicMessage | null, error: Error) => void) | null} errorHandler
       * @param {(message: TopicMessage) => void} listener
       * @returns {SubscriptionHandle}
       */
      subscribe(client, errorHandler, listener) {
          this._handle = new SubscriptionHandle();
          this._listener = listener;

          if (errorHandler != null) {
              this._errorHandler = errorHandler;
          }

          this._makeServerStreamRequest(client);

          return this._handle;
      }

      /**
       * Makes a server stream request to subscribe to topic messages
       * @private
       * @param {Client<Channel>} client
       * @returns {void}
       */
      _makeServerStreamRequest(client) {
          const request = this._buildConsensusRequest();
          /** @type {Map<string, HieroProto.com.hedera.mirror.api.proto.ConsensusTopicResponse[]>} */
          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
          const list = new Map();

          const streamHandler = client._mirrorNetwork
              .getNextMirrorNode()
              .getChannel()
              .makeServerStreamRequest(
                  "ConsensusService",
                  "subscribeTopic",
                  request,
                  (data) => this._handleMessage(data, list),
                  (error) => this._handleError(error, client),
                  this._completionHandler,
              );

          if (this._handle != null) {
              this._handle._setCall(() => streamHandler());
          }
      }

      requireNotSubscribed() {
          if (this._handle != null) {
              throw new Error(
                  "Cannot change fields on an already subscribed query",
              );
          }
      }

      /**
       * @private
       * @param {TopicMessage} topicMessage
       */
      _passTopicMessage(topicMessage) {
          try {
              if (this._listener != null) {
                  this._listener(topicMessage);
              } else {
                  throw new Error("(BUG) listener is unexpectedly not set");
              }
          } catch (error) {
              this._errorHandler(topicMessage, /** @type {Error} */ (error));
          }
      }

      /**
       * Builds the consensus topic query request
       * @private
       * @returns {Uint8Array} Encoded consensus topic query
       */
      _buildConsensusRequest() {
          return libExports.com.hedera.mirror.api.proto.ConsensusTopicQuery.encode(
              {
                  topicID: this._topicId?._toProtobuf() ?? null,
                  consensusStartTime: this._startTime?._toProtobuf() ?? null,
                  consensusEndTime: this._endTime?._toProtobuf() ?? null,
                  limit: this._limit,
              },
          ).finish();
      }

      /**
       * Handles an incoming message from the topic subscription
       * @private
       * @param {Uint8Array} data - Raw message data
       * @param {Map<string, HieroProto.com.hedera.mirror.api.proto.ConsensusTopicResponse[]>} list
       */
      _handleMessage(data, list) {
          const message =
              libExports.com.hedera.mirror.api.proto.ConsensusTopicResponse.decode(
                  data,
              );

          if (this._limit?.gt(0)) {
              this._limit = this._limit.sub(1);
          }

          this._startTime = Timestamp._fromProtobuf(
              /** @type {HieroProto.proto.ITimestamp} */ (
                  message.consensusTimestamp
              ),
          ).plusNanos(1);

          if (
              message.chunkInfo == null ||
              (message.chunkInfo != null && message.chunkInfo.total === 1)
          ) {
              this._passTopicMessage(TopicMessage._ofSingle(message));
          } else {
              this._handleChunkedMessage(message, list);
          }
      }

      /**
       * Handles a chunked message from the topic subscription
       * @private
       * @param {HieroProto.com.hedera.mirror.api.proto.ConsensusTopicResponse} message - The message response
       * @param {Map<string, HieroProto.com.hedera.mirror.api.proto.ConsensusTopicResponse[]>} list
       */
      _handleChunkedMessage(message, list) {
          const chunkInfo =
              /** @type {HieroProto.proto.IConsensusMessageChunkInfo} */ (
                  message.chunkInfo
              );
          const initialTransactionID =
              /** @type {HieroProto.proto.ITransactionID} */ (
                  chunkInfo.initialTransactionID
              );
          const total = /** @type {number} */ (chunkInfo.total);
          const transactionId =
              TransactionId._fromProtobuf(initialTransactionID).toString();

          /** @type {HieroProto.com.hedera.mirror.api.proto.ConsensusTopicResponse[]} */
          let responses = [];

          const temp = list.get(transactionId);
          if (temp == null) {
              list.set(transactionId, responses);
          } else {
              responses = temp;
          }

          responses.push(message);

          if (responses.length === total) {
              const topicMessage = TopicMessage._ofMany(responses);
              list.delete(transactionId);
              this._passTopicMessage(topicMessage);
          }
      }

      /**
       * Handles errors from the topic subscription
       * @private
       * @param {MirrorError | Error} error - The error that occurred
       * @param {Client<Channel>} client - The client to use for retries
       * @returns {void}
       */
      _handleError(error, client) {
          const message = error instanceof Error ? error.message : error.details;

          if (this._handle?._unsubscribed) {
              return;
          }

          if (this.shouldRetry(error)) {
              this._scheduleRetry(client, message);
          } else {
              this._errorHandler(null, new Error(message));
          }
      }

      /**
       * Determines if a retry should be attempted
       * @private
       * @param {MirrorError | Error} error - The error to check
       * @returns {boolean} - Whether to retry
       */
      shouldRetry(error) {
          return this._attempt < this._maxAttempts && this._retryHandler(error);
      }

      /**
       * Schedules a retry of the server stream request
       * @private
       * @param {Client<Channel>} client - The client to use for the retry
       * @param {string} errorMessage - The error message for logging
       * @returns {void}
       */
      _scheduleRetry(client, errorMessage) {
          const delay = Math.min(250 * 2 ** this._attempt, this._maxBackoff);

          console.warn(
              `Error subscribing to topic ${
                this._topicId?.toString() ?? "UNKNOWN"
            } ` +
                  `during attempt ${this._attempt}. Waiting ${delay} ms before next attempt: ${errorMessage}`,
          );

          this._attempt += 1;
          setTimeout(() => this._makeServerStreamRequest(client), delay);
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.IConsensusSubmitMessageTransactionBody} HieroProto.proto.IConsensusSubmitMessageTransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
   * @typedef {import("@hashgraph/proto").proto.IConsensusMessageChunkInfo} HieroProto.proto.IConsensusMessageChunkInfo
   * @typedef {import("@hashgraph/proto").proto.IFixedFee} HieroProto.proto.IFixedFee
   * @typedef {import("@hashgraph/proto").proto.ICustomFeeLimit} HieroProto.proto.ICustomFeeLimit
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../token/CustomFixedFee.js").default} CustomFixedFee
   * @typedef {import("../account/AccountId.js").default} AccountId
   * @typedef {import("../transaction/TransactionResponse.js").default} TransactionResponse
   * @typedef {import("../schedule/ScheduleCreateTransaction.js").default} ScheduleCreateTransaction
   * @typedef {import("../transaction/CustomFeeLimit.js").default} CustomFeeLimit
   */

  /**
   * <p>
   * Valid and authorized messages on valid topics will be ordered by the
   * consensus service, published in the block stream, and available to all
   * subscribers on this topic via the mirror nodes.<br/>
   * If this transaction succeeds the resulting TransactionReceipt SHALL
   * contain the latest topicSequenceNumber and topicRunningHash for the
   * topic.<br/>
   * If the topic has a `submitKey` then that key MUST sign this
   * transaction.<br/>
   */
  class TopicMessageSubmitTransaction extends Transaction {
      /**
       * @param {object} props
       * @param {TopicId | string} [props.topicId]
       * @param {Uint8Array | string} [props.message]
       * @param {number} [props.maxChunks]
       * @param {number} [props.chunkSize]
       */
      constructor(props = {}) {
          super();

          /**
           * @private
           * @type {?TopicId}
           */
          this._topicId = null;

          if (props.topicId != null) {
              this.setTopicId(props.topicId);
          }

          /**
           * @private
           * @type {?Uint8Array}
           */
          this._message = null;

          if (props.message != null) {
              this.setMessage(props.message);
          }

          /**
           * @private
           * @type {number}
           * The maximum number of chunks a topic message can be split into.
           * Default max chunk size: 20
           * This value can be overridden with `setMaxChunks`
           */
          this._maxChunks = 20;

          /**
           * @private
           * @type {number}
           * The size of each chunk for a given topic message in bytes.
           */
          this._chunkSize = CHUNK_SIZE;

          if (props.maxChunks != null) {
              this.setMaxChunks(props.maxChunks);
          }

          if (props.chunkSize != null) {
              this.setChunkSize(props.chunkSize);
          }

          /** @type {HieroProto.proto.IConsensusMessageChunkInfo | null} */
          this._chunkInfo = null;
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransaction[]} transactions
       * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {HieroProto.proto.ITransactionBody[]} bodies
       * @returns {TopicMessageSubmitTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];
          const message =
              /** @type {HieroProto.proto.IConsensusSubmitMessageTransactionBody} */ (
                  body.consensusSubmitMessage
              );

          return Transaction._fromProtobufTransactions(
              new TopicMessageSubmitTransaction({
                  topicId:
                      message.topicID != null
                          ? TopicId._fromProtobuf(message.topicID)
                          : undefined,
                  message: message.message != null ? message.message : undefined,
              }),
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * @returns {?TopicId}
       */
      get topicId() {
          return this._topicId;
      }

      /**
       * @param {TopicId | string} topicId
       * @returns {this}
       */
      setTopicId(topicId) {
          this._requireNotFrozen();

          this._topicId =
              typeof topicId === "string"
                  ? TopicId.fromString(topicId)
                  : topicId.clone();

          return this;
      }

      /**
       * @deprecated  - Use `getMessage()` instead
       * @returns {?Uint8Array}
       */
      get message() {
          return this._message;
      }

      /**
       * @returns {?Uint8Array}
       */
      getMessage() {
          return this._message;
      }

      /**
       * @param {string | Uint8Array} message
       * @returns {this}
       */
      setMessage(message) {
          this._requireNotFrozen();
          message = requireStringOrUint8Array(message);
          this._message =
              message instanceof Uint8Array ? message : encode$1(message);
          return this;
      }

      /**
       * Gets the maximum custom fee that the user is willing to pay for the message.
       * @returns {CustomFeeLimit[]}
       */
      getCustomFeeLimits() {
          return this._customFeeLimits;
      }

      /**
       * Sets the maximum custom fee that the user is willing to pay for message submission.
       * @param {CustomFeeLimit[]} customFeeLimits
       * @returns {this}
       */
      setCustomFeeLimits(customFeeLimits) {
          this._requireNotFrozen();

          this._customFeeLimits = customFeeLimits;

          return this;
      }

      /**
       * Adds a maximum custom fee that the user is willing to pay for message submission.
       * @param {CustomFeeLimit} customFeeLimit
       * @returns {this}
       */
      addCustomFeeLimit(customFeeLimit) {
          this._requireNotFrozen();

          this._customFeeLimits.push(customFeeLimit);

          return this;
      }

      /**
       * @deprecated  - Use `getMaxChunks()` instead
       * @returns {?number}
       */
      get maxChunks() {
          return this._maxChunks;
      }

      /**
       * @returns {?number}
       */
      getMaxChunks() {
          return this._maxChunks;
      }

      /**
       * @param {number} maxChunks
       * @returns {this}
       */
      setMaxChunks(maxChunks) {
          this._requireNotFrozen();
          this._maxChunks = maxChunks;
          return this;
      }

      /**
       * @deprecated  - Use `getChunkSize()` instead
       * @returns {?number}
       */
      get chunkSize() {
          return this._chunkSize;
      }

      /**
       * @returns {?number}
       */
      getChunkSize() {
          return this._chunkSize;
      }

      /**
       * @param {number} chunkSize
       * @returns {this}
       */
      setChunkSize(chunkSize) {
          this._chunkSize = chunkSize;
          return this;
      }

      /**
       * @override
       * @returns {number}
       */
      getRequiredChunks() {
          if (this._message == null) {
              return 1;
          }

          const result = Math.ceil(this._message.length / this._chunkSize);
          return result;
      }

      /**
       * Freeze this transaction from further modification to prepare for
       * signing or serialization.
       *
       * Will use the `Client`, if available, to generate a default Transaction ID and select 1/3
       * nodes to prepare this transaction for.
       *
       * @param {?import("../client/Client.js").default<Channel, *>} client
       * @returns {this}
       */
      freezeWith(client) {
          super.freezeWith(client);

          if (this._message == null) {
              return this;
          }

          const chunks = Math.floor(
              (this._message.length + (this._chunkSize - 1)) / this._chunkSize,
          );

          if (chunks > this._maxChunks) {
              throw new Error(
                  `Message with size ${this._message.length} too long for ${this._maxChunks} chunks`,
              );
          }

          const initialTransactionId = this._getTransactionId()._toProtobuf();
          let nextTransactionId = this._getTransactionId();

          // Hack around the locked list. Should refactor a bit to remove such code
          this._transactionIds.locked = false;

          this._transactions.clear();
          this._transactionIds.clear();
          this._signedTransactions.clear();

          for (let chunk = 0; chunk < chunks; chunk++) {
              this._chunkInfo = {
                  initialTransactionID: initialTransactionId,
                  total: chunks,
                  number: chunk + 1,
              };

              this._transactionIds.push(nextTransactionId);
              this._transactionIds.advance();

              for (const nodeAccountId of this._nodeAccountIds.list) {
                  this._signedTransactions.push(
                      this._makeSignedTransaction(nodeAccountId),
                  );
              }

              nextTransactionId = new TransactionId(
                  /** @type {AccountId} */ (nextTransactionId.accountId),
                  new Timestamp(
                      /** @type {Timestamp} */ (
                          nextTransactionId.validStart
                      ).seconds,
                      /** @type {Timestamp} */ (
                          nextTransactionId.validStart
                      ).nanos.add(1),
                  ),
              );
          }

          this._transactionIds.advance();
          this._chunkInfo = null;

          return this;
      }

      /**
       * @returns {ScheduleCreateTransaction}
       */
      schedule() {
          this._requireNotFrozen();

          if (this._message != null && this._message.length > this._chunkSize) {
              throw new Error(
                  `cannot schedule \`TopicMessageSubmitTransaction\` with message over ${this._chunkSize} bytes`,
              );
          }

          return super.schedule();
      }

      /**
       * @param {import("../client/Client.js").default<Channel, *>} client
       * @param {number=} requestTimeout
       * @returns {Promise<TransactionResponse>}
       */
      async execute(client, requestTimeout) {
          return (await this.executeAll(client, requestTimeout))[0];
      }

      /**
       * @param {import("../client/Client.js").default<Channel, *>} client
       * @param {number=} requestTimeout
       * @returns {Promise<TransactionResponse[]>}
       */
      async executeAll(client, requestTimeout) {
          if (!super._isFrozen()) {
              this.freezeWith(client);
          }

          // on execute, sign each transaction with the operator, if present
          // and we are signing a transaction that used the default transaction ID

          const transactionId = this._getTransactionId();
          const operatorAccountId = client.operatorAccountId;

          if (
              operatorAccountId != null &&
              operatorAccountId.equals(
                  /** @type {AccountId} */ (transactionId.accountId),
              )
          ) {
              await super.signWithOperator(client);
          }

          const responses = [];
          let remainingTimeout = requestTimeout;
          for (let i = 0; i < this._transactionIds.length; i++) {
              const startTimestamp = Date.now();
              responses.push(await super.execute(client, remainingTimeout));

              if (remainingTimeout != null) {
                  remainingTimeout = Date.now() - startTimestamp;
              }
          }

          return responses;
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.ITransaction} request
       * @returns {Promise<HieroProto.proto.ITransactionResponse>}
       */
      _execute(channel, request) {
          return channel.consensus.submitMessage(request);
      }

      /**
       * @override
       * @protected
       * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "consensusSubmitMessage";
      }

      /**
       * @override
       * @protected
       * @returns {HieroProto.proto.IConsensusSubmitMessageTransactionBody}
       */
      _makeTransactionData() {
          if (this._chunkInfo != null && this._message != null) {
              const num = /** @type {number} */ (this._chunkInfo.number);
              const startIndex = (num - 1) * this._chunkSize;
              let endIndex = startIndex + this._chunkSize;

              if (endIndex > this._message.length) {
                  endIndex = this._message.length;
              }

              return {
                  topicID:
                      this._topicId != null ? this._topicId._toProtobuf() : null,
                  message: this._message.slice(startIndex, endIndex),
                  chunkInfo: this._chunkInfo,
              };
          } else {
              return {
                  topicID:
                      this._topicId != null ? this._topicId._toProtobuf() : null,
                  message: this._message,
              };
          }
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("../Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `TopicMessageSubmitTransaction:${timestamp.toString()}`;
      }
  }

  TRANSACTION_REGISTRY.set(
      "consensusSubmitMessage",
      // eslint-disable-next-line @typescript-eslint/unbound-method
      TopicMessageSubmitTransaction._fromProtobuf,
  );

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.IConsensusUpdateTopicTransactionBody} HieroProto.proto.IConsensusUpdateTopicTransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   */

  /**
   * Update a topic.
   *
   * If there is no adminKey, the only authorized update (available to anyone) is to extend the expirationTime.
   * Otherwise transaction must be signed by the adminKey.
   *
   * If an adminKey is updated, the transaction must be signed by the pre-update adminKey and post-update adminKey.
   *
   * If a new autoRenewAccount is specified (not just being removed), that account must also sign the transaction.
   */
  class TopicUpdateTransaction extends Transaction {
      /**
       * @param {object} props
       * @param {TopicId | string} [props.topicId]
       * @param {Key} [props.adminKey]
       * @param {Key} [props.submitKey]
       * @param {Key} [props.feeScheduleKey]
       * @param {Key[]} [props.feeExemptKeys]
       * @param {Duration | Long | number} [props.autoRenewPeriod]
       * @param {AccountId | string} [props.autoRenewAccountId]
       * @param {CustomFixedFee[]} [props.customFees]
       * @param {?string} [props.topicMemo]
       * @param {Timestamp | Date} [props.expirationTime]
       */
      constructor(props = {}) {
          super();

          /**
           * @private
           * @type {?TopicId}
           */
          this._topicId = null;

          if (props.topicId != null) {
              this.setTopicId(props.topicId);
          }

          /**
           * @private
           * @type {?string}
           */
          this._topicMemo = null;

          if (props.topicMemo != null) {
              this.setTopicMemo(props.topicMemo);
          }

          /**
           * @private
           * @type {?Key}
           */
          this._submitKey = null;

          if (props.submitKey != null) {
              this.setSubmitKey(props.submitKey);
          }

          /**
           * @private
           * @type {?Key}
           */
          this._adminKey = null;

          if (props.adminKey != null) {
              this.setAdminKey(props.adminKey);
          }
          /**
           * @private
           * @type {?Key}
           */
          this._feeScheduleKey = null;

          if (props.feeScheduleKey != null) {
              this.setFeeScheduleKey(props.feeScheduleKey);
          }

          /**
           * @private
           * @type {?Key[]}
           */
          this._feeExemptKeys = null;

          if (props.feeExemptKeys != null) {
              this.setFeeExemptKeys(props.feeExemptKeys);
          }

          /**
           * @private
           * @type {?AccountId}
           */
          this._autoRenewAccountId = null;

          if (props.autoRenewAccountId != null) {
              this.setAutoRenewAccountId(props.autoRenewAccountId);
          }

          /**
           * @private
           * @type {?Duration}
           */
          this._autoRenewPeriod = null;

          if (props.autoRenewPeriod != null) {
              this.setAutoRenewPeriod(props.autoRenewPeriod);
          }

          /**
           * @private
           * @type {?CustomFixedFee[]}
           */
          this._customFees = null;

          if (props.customFees != null) {
              this.setCustomFees(props.customFees);
          }

          /**
           * @private
           * @type {?Timestamp}
           */
          this._expirationTime = null;

          if (props.expirationTime != null) {
              this.setExpirationTime(props.expirationTime);
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransaction[]} transactions
       * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {HieroProto.proto.ITransactionBody[]} bodies
       * @returns {TopicUpdateTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];
          const update =
              /** @type {HieroProto.proto.IConsensusUpdateTopicTransactionBody} */ (
                  body.consensusUpdateTopic
              );

          return Transaction._fromProtobufTransactions(
              new TopicUpdateTransaction({
                  topicId:
                      update.topicID != null
                          ? TopicId._fromProtobuf(update.topicID)
                          : undefined,
                  adminKey:
                      update.adminKey != null
                          ? Key._fromProtobufKey(update.adminKey)
                          : undefined,
                  submitKey:
                      update.submitKey != null
                          ? Key._fromProtobufKey(update.submitKey)
                          : undefined,
                  feeScheduleKey:
                      update.feeScheduleKey != null
                          ? Key._fromProtobufKey(update.feeScheduleKey)
                          : undefined,
                  feeExemptKeys:
                      update.feeExemptKeyList != null &&
                      update.feeExemptKeyList.keys != null
                          ? update?.feeExemptKeyList.keys.map((key) =>
                                Key._fromProtobufKey(key),
                            )
                          : undefined,
                  autoRenewAccountId:
                      update.autoRenewAccount != null
                          ? AccountId._fromProtobuf(update.autoRenewAccount)
                          : undefined,
                  autoRenewPeriod:
                      update.autoRenewPeriod != null
                          ? update.autoRenewPeriod.seconds != null
                              ? update.autoRenewPeriod.seconds
                              : undefined
                          : undefined,
                  customFees:
                      update.customFees != null && update.customFees.fees != null
                          ? update.customFees.fees.map((customFee) =>
                                CustomFixedFee._fromProtobuf(customFee),
                            )
                          : undefined,
                  topicMemo:
                      update.memo != null
                          ? Object.hasOwn(update.memo, "value")
                              ? update.memo.value
                              : undefined
                          : undefined,
                  expirationTime:
                      update.expirationTime != null
                          ? Timestamp._fromProtobuf(update.expirationTime)
                          : undefined,
              }),
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * @returns {?Timestamp}
       */
      get expirationTime() {
          return this._expirationTime;
      }

      /**
       * @param {Timestamp | Date | null} expirationTime
       * @returns {TopicUpdateTransaction}
       */
      setExpirationTime(expirationTime) {
          this._requireNotFrozen();

          this._expirationTime =
              expirationTime instanceof Date
                  ? Timestamp.fromDate(expirationTime)
                  : expirationTime;

          return this;
      }

      /**
       * @returns {?TopicId}
       */
      get topicId() {
          return this._topicId;
      }

      /**
       * @param {TopicId | string} topicId
       * @returns {TopicUpdateTransaction}
       */
      setTopicId(topicId) {
          this._requireNotFrozen();
          this._topicId =
              typeof topicId === "string"
                  ? TopicId.fromString(topicId)
                  : topicId.clone();

          return this;
      }

      /**
       * @returns {TopicUpdateTransaction}
       */
      clearTopicId() {
          this._requireNotFrozen();
          this._topicId = null;

          return this;
      }

      /**
       * @returns {?string}
       */
      get topicMemo() {
          return this._topicMemo;
      }

      /**
       * @param {string} topicMemo
       * @returns {TopicUpdateTransaction}
       */
      setTopicMemo(topicMemo) {
          this._requireNotFrozen();
          this._topicMemo = topicMemo;

          return this;
      }

      /**
       * @returns {TopicUpdateTransaction}
       */
      clearTopicMemo() {
          this._requireNotFrozen();
          this._topicMemo = null;

          return this;
      }

      /**
       * @returns {?Key}
       */
      get adminKey() {
          return this._adminKey;
      }

      /**
       * @param {Key} adminKey
       * @returns {TopicUpdateTransaction}
       */
      setAdminKey(adminKey) {
          this._requireNotFrozen();
          this._adminKey = adminKey;

          return this;
      }

      /**
       * @returns {TopicUpdateTransaction}
       */
      clearAdminKey() {
          this._requireNotFrozen();
          this._adminKey = null;

          return this;
      }

      /**
       * @returns {?Key}
       */
      get submitKey() {
          return this._submitKey;
      }

      /**
       * @param {Key} submitKey
       * @returns {TopicUpdateTransaction}
       */
      setSubmitKey(submitKey) {
          this._requireNotFrozen();
          this._submitKey = submitKey;

          return this;
      }

      /**
       * @returns {TopicUpdateTransaction}
       */
      clearSubmitKey() {
          this._requireNotFrozen();
          this._submitKey = null;

          return this;
      }

      /**
       * Returns the key which allows updates to the new topics fees.
       * @returns {?Key}
       */
      getFeeScheduleKey() {
          return this._feeScheduleKey;
      }

      /**
       * Sets the key which allows updates to the new topics fees.
       * @param {Key} feeScheduleKey
       * @returns {this}
       */
      setFeeScheduleKey(feeScheduleKey) {
          this._requireNotFrozen();
          this._feeScheduleKey = feeScheduleKey;

          return this;
      }

      /**
       * @returns {TopicUpdateTransaction}
       */
      clearFeeScheduleKey() {
          this._requireNotFrozen();
          this._feeScheduleKey = null;

          return this;
      }

      /**
       * Returns the keys that will be exempt from paying fees.
       * @returns {?Key[]}
       */
      getFeeExemptKeys() {
          return this._feeExemptKeys;
      }

      /**
       * Sets the keys that will be exempt from paying fees.
       * @param {Key[]} feeExemptKeys
       * @returns {this}
       */
      setFeeExemptKeys(feeExemptKeys) {
          this._requireNotFrozen();
          this._feeExemptKeys = feeExemptKeys;

          return this;
      }

      /**
       * Adds a key that will be exempt from paying fees.
       * @param {Key} key
       * @returns {this}
       */
      addFeeExemptKey(key) {
          this._requireNotFrozen();
          if (this._feeExemptKeys == null) {
              this._feeExemptKeys = [];
          }

          this._feeExemptKeys.push(key);

          return this;
      }

      /**
       * Clears all keys that will be exempt from paying fees, effectively removing them from the network state.
       * @returns {this}
       */
      clearFeeExemptKeys() {
          this._requireNotFrozen();
          this._feeExemptKeys = [];

          return this;
      }

      /**
       * @returns {?AccountId}
       */
      get autoRenewAccountId() {
          return this._autoRenewAccountId;
      }

      /**
       * @param {AccountId | string} autoRenewAccountId
       * @returns {TopicUpdateTransaction}
       */
      setAutoRenewAccountId(autoRenewAccountId) {
          this._requireNotFrozen();
          this._autoRenewAccountId =
              autoRenewAccountId instanceof AccountId
                  ? autoRenewAccountId
                  : AccountId.fromString(autoRenewAccountId);

          return this;
      }

      /**
       * @returns {TopicUpdateTransaction}
       */
      clearAutoRenewAccountId() {
          this._requireNotFrozen();
          this._autoRenewAccountId = null;

          return this;
      }

      /**
       * @returns {?Duration}
       */
      get autoRenewPeriod() {
          return this._autoRenewPeriod;
      }

      /**
       * Set the auto renew period for this account.
       *
       * @param {Duration | Long | number} autoRenewPeriod
       * @returns {TopicUpdateTransaction}
       */
      setAutoRenewPeriod(autoRenewPeriod) {
          this._requireNotFrozen();
          this._autoRenewPeriod =
              autoRenewPeriod instanceof Duration
                  ? autoRenewPeriod
                  : new Duration(autoRenewPeriod);

          return this;
      }

      /**
       * Returns the fixed fees to assess when a message is submitted to the new topic.
       * @returns {?CustomFixedFee[]}
       */
      getCustomFees() {
          return this._customFees;
      }

      /**
       * Sets the fixed fees to assess when a message is submitted to the new topic.
       *
       * @param {CustomFixedFee[]} customFees
       * @returns {this}
       */
      setCustomFees(customFees) {
          this._requireNotFrozen();
          this._customFees = customFees;

          return this;
      }

      /**
       * Adds fixed fee to assess when a message is submitted to the new topic.
       *
       * @param {CustomFixedFee} customFee
       * @returns {this}
       */
      addCustomFee(customFee) {
          this._requireNotFrozen();
          if (this._customFees == null) {
              this._customFees = [];
          }

          this._customFees.push(customFee);

          return this;
      }

      /**
       * Clears fixed fees, effectively removing them from the network state.
       *
       * @returns {this}
       */
      clearCustomFees() {
          this._requireNotFrozen();
          this._customFees = [];

          return this;
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          if (this._topicId != null) {
              this._topicId.validateChecksum(client);
          }

          if (this._autoRenewAccountId != null) {
              this._autoRenewAccountId.validateChecksum(client);
          }
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.ITransaction} request
       * @returns {Promise<HieroProto.proto.ITransactionResponse>}
       */
      _execute(channel, request) {
          return channel.consensus.updateTopic(request);
      }

      /**
       * @override
       * @protected
       * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "consensusUpdateTopic";
      }

      /**
       * @override
       * @protected
       * @returns {HieroProto.proto.IConsensusUpdateTopicTransactionBody}
       */
      _makeTransactionData() {
          return {
              topicID: this._topicId != null ? this._topicId._toProtobuf() : null,
              adminKey:
                  this._adminKey != null ? this._adminKey._toProtobufKey() : null,
              submitKey:
                  this._submitKey != null
                      ? this._submitKey._toProtobufKey()
                      : null,
              feeScheduleKey:
                  this._feeScheduleKey != null
                      ? this._feeScheduleKey._toProtobufKey()
                      : null,
              feeExemptKeyList:
                  this._feeExemptKeys != null
                      ? {
                            keys: this._feeExemptKeys.map((key) =>
                                key._toProtobufKey(),
                            ),
                        }
                      : null,
              memo:
                  this._topicMemo != null
                      ? {
                            value: this._topicMemo,
                        }
                      : null,
              autoRenewAccount:
                  this._autoRenewAccountId != null
                      ? this._autoRenewAccountId._toProtobuf()
                      : null,
              autoRenewPeriod:
                  this._autoRenewPeriod != null
                      ? this._autoRenewPeriod._toProtobuf()
                      : null,
              customFees:
                  this._customFees != null
                      ? {
                            fees: this._customFees.map((customFee) =>
                                customFee._toTopicFeeProtobuf(),
                            ),
                        }
                      : null,
              expirationTime:
                  this._expirationTime != null
                      ? this._expirationTime._toProtobuf()
                      : null,
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("../Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `TopicUpdateTransaction:${timestamp.toString()}`;
      }
  }

  TRANSACTION_REGISTRY.set(
      "consensusUpdateTopic",
      // eslint-disable-next-line @typescript-eslint/unbound-method
      TopicUpdateTransaction._fromProtobuf,
  );

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITransferList} HieroProto.proto.ITransferList
   * @typedef {import("@hashgraph/proto").proto.IAccountID} HieroProto.proto.IAccountID
   */

  /**
   * @typedef {import("../long.js").LongObject} LongObject
   * @typedef {import("bignumber.js").default} BigNumber
   */

  /**
   * @augments {ObjectMap<AccountId, Hbar>}
   */
  class HbarTransferMap extends ObjectMap {
      constructor() {
          super((s) => AccountId.fromString(s));
      }

      /**
       * @param {HieroProto.proto.ITransferList} transfers
       * @returns {HbarTransferMap}
       */
      static _fromProtobuf(transfers) {
          const accountTransfers = new HbarTransferMap();

          for (const transfer of transfers.accountAmounts != null
              ? transfers.accountAmounts
              : []) {
              const account = AccountId._fromProtobuf(
                  /** @type {HieroProto.proto.IAccountID} */ (transfer.accountID),
              );

              accountTransfers._set(
                  account,
                  Hbar.fromTinybars(/** @type {Long} */ (transfer.amount)),
              );
          }

          return accountTransfers;
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {import("../long.js").LongObject} LongObject
   * @typedef {import("bignumber.js").default} BigNumber
   */

  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
   * @typedef {import("@hashgraph/proto").proto.ICryptoTransferTransactionBody} HieroProto.proto.ICryptoTransferTransactionBody
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   */

  /**
   * @typedef {object} TransferTokensInput
   * @property {TokenId | string} tokenId
   * @property {AccountId | string} accountId
   * @property {Long | number} amount
   */

  /**
   * @typedef {object} TransferTokenObject
   * @property {TokenId} tokenId
   * @property {AccountId} accountId
   * @property {Long} amount
   */

  /**
   * @typedef {object} TransferHbarInput
   * @property {AccountId | string} accountId
   * @property {number | string | Long | BigNumber | Hbar} amount
   */

  /**
   * @typedef {object} TransferNftInput
   * @property {TokenId | string} tokenId
   * @property {AccountId | string} sender
   * @property {AccountId | string} recipient
   * @property {Long | number} serial
   */

  /**
   * Transfers a new Hedera crypto-currency token.
   */
  class TransferTransaction extends AbstractTokenTransferTransaction {
      /**
       * @param {object} [props]
       * @param {(TransferTokensInput)[]} [props.tokenTransfers]
       * @param {(TransferHbarInput)[]} [props.hbarTransfers]
       * @param {(TransferNftInput)[]} [props.nftTransfers]
       */
      constructor(props = {}) {
          super();

          /**
           * @private
           * @type {Transfer[]}
           */
          this._hbarTransfers = [];

          this._defaultMaxTransactionFee = new Hbar(1);

          for (const transfer of props.hbarTransfers != null
              ? props.hbarTransfers
              : []) {
              this.addHbarTransfer(transfer.accountId, transfer.amount);
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransaction[]} transactions
       * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {HieroProto.proto.ITransactionBody[]} bodies
       * @returns {TransferTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];
          const cryptoTransfer =
              /** @type {HieroProto.proto.ICryptoTransferTransactionBody} */ (
                  body.cryptoTransfer
              );

          const transfers = new TransferTransaction();

          transfers._tokenTransfers = TokenTransfer._fromProtobuf(
              cryptoTransfer.tokenTransfers != null
                  ? cryptoTransfer.tokenTransfers
                  : [],
          );

          transfers._hbarTransfers = Transfer._fromProtobuf(
              cryptoTransfer.transfers != null
                  ? cryptoTransfer.transfers.accountAmounts != null
                      ? cryptoTransfer.transfers.accountAmounts
                      : []
                  : [],
          );

          transfers._nftTransfers = TokenNftTransfer._fromProtobuf(
              cryptoTransfer.tokenTransfers != null
                  ? cryptoTransfer.tokenTransfers
                  : [],
          );

          return Transaction._fromProtobufTransactions(
              transfers,
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * @returns {HbarTransferMap}
       */
      get hbarTransfers() {
          const map = new HbarTransferMap();

          for (const transfer of this._hbarTransfers) {
              map._set(transfer.accountId, transfer.amount);
          }

          return map;
      }

      /**
       * @returns {Transfer[]}
       */
      get hbarTransfersList() {
          return this._hbarTransfers;
      }

      /**
       * @internal
       * @param {AccountId | string} accountId
       * @param {number | string | Long | LongObject | BigNumber | Hbar} amount
       * @param {boolean} isApproved
       * @returns {TransferTransaction}
       */
      _addHbarTransfer(accountId, amount, isApproved) {
          this._requireNotFrozen();

          const account =
              accountId instanceof AccountId
                  ? accountId.clone()
                  : AccountId.fromString(accountId);
          const hbars = amount instanceof Hbar ? amount : new Hbar(amount);

          for (const transfer of this._hbarTransfers) {
              if (transfer.accountId.compare(account) === 0) {
                  transfer.amount = Hbar.fromTinybars(
                      transfer.amount.toTinybars().add(hbars.toTinybars()),
                  );
                  return this;
              }
          }

          this._hbarTransfers.push(
              new Transfer({
                  accountId: account,
                  amount: hbars,
                  isApproved,
              }),
          );

          return this;
      }

      /**
       * @internal
       * @param {AccountId | string} accountId
       * @param {number | string | Long | LongObject | BigNumber | Hbar} amount
       * @returns {TransferTransaction}
       */
      addHbarTransfer(accountId, amount) {
          return this._addHbarTransfer(accountId, amount, false);
      }

      /**
       * @internal
       * @param {AccountId | string} accountId
       * @param {number | string | Long | LongObject | BigNumber | Hbar} amount
       * @returns {TransferTransaction}
       */
      addApprovedHbarTransfer(accountId, amount) {
          return this._addHbarTransfer(accountId, amount, true);
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          for (const transfer of this._hbarTransfers) {
              transfer.accountId.validateChecksum(client);
          }

          for (const transfer of this._tokenTransfers) {
              transfer.tokenId.validateChecksum(client);
              transfer.accountId.validateChecksum(client);
          }

          for (const transfer of this._nftTransfers) {
              transfer.tokenId.validateChecksum(client);
              transfer.senderAccountId.validateChecksum(client);
              transfer.receiverAccountId.validateChecksum(client);
          }
      }

      /**
       * @deprecated - Use `addApprovedHbarTransfer()` instead
       * @param {AccountId | string} accountId
       * @param {boolean} isApproved
       * @returns {TransferTransaction}
       */
      setHbarTransferApproval(accountId, isApproved) {
          const account =
              typeof accountId === "string"
                  ? AccountId.fromString(accountId)
                  : accountId;

          for (const transfer of this._hbarTransfers) {
              if (transfer.accountId.compare(account) === 0) {
                  transfer.isApproved = isApproved;
              }
          }

          return this;
      }

      /**
       * @deprecated - Use `addApprovedTokenTransfer()` instead
       * @param {TokenId | string} tokenId
       * @param {AccountId | string} accountId
       * @param {boolean} isApproved
       * @returns {TransferTransaction}
       */
      setTokenTransferApproval(tokenId, accountId, isApproved) {
          const token =
              typeof tokenId === "string" ? TokenId.fromString(tokenId) : tokenId;
          const account =
              typeof accountId === "string"
                  ? AccountId.fromString(accountId)
                  : accountId;

          for (const tokenTransfer of this._tokenTransfers) {
              if (
                  tokenTransfer.tokenId.compare(token) === 0 &&
                  tokenTransfer.accountId.compare(account) === 0
              ) {
                  tokenTransfer.isApproved = isApproved;
              }
          }

          return this;
      }

      /**
       * @deprecated - Use `addApprovedNftTransfer()` instead
       * @param {NftId | string} nftId
       * @param {boolean} isApproved
       * @returns {TransferTransaction}
       */
      setNftTransferApproval(nftId, isApproved) {
          const nft = typeof nftId === "string" ? NftId.fromString(nftId) : nftId;

          for (const transfer of this._nftTransfers) {
              if (
                  transfer.tokenId.compare(nft.tokenId) === 0 &&
                  transfer.serialNumber.compare(nft.serial) === 0
              ) {
                  transfer.isApproved = isApproved;
              }
          }

          return this;
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.ITransaction} request
       * @returns {Promise<HieroProto.proto.ITransactionResponse>}
       */
      _execute(channel, request) {
          return channel.crypto.cryptoTransfer(request);
      }

      /**
       * @override
       * @protected
       * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "cryptoTransfer";
      }

      /**
       * @override
       * @protected
       * @returns {HieroProto.proto.ICryptoTransferTransactionBody}
       */
      _makeTransactionData() {
          const { tokenTransfers } = super._makeTransactionData();

          this._hbarTransfers.sort((a, b) => a.accountId.compare(b.accountId));

          return {
              transfers: {
                  accountAmounts: this._hbarTransfers.map((transfer) => {
                      return {
                          accountID: transfer.accountId._toProtobuf(),
                          amount: transfer.amount.toTinybars(),
                          isApproval: transfer.isApproved,
                      };
                  }),
              },
              tokenTransfers,
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("../Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `TransferTransaction:${timestamp.toString()}`;
      }
  }

  TRANSACTION_REGISTRY.set(
      "cryptoTransfer",
      // eslint-disable-next-line @typescript-eslint/unbound-method
      TransferTransaction._fromProtobuf,
  );

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @template RequestT
   * @template ResponseT
   * @template OutputT
   * @typedef {import("./Executable.js").default<RequestT, ResponseT, OutputT>} Executable<RequestT, ResponseT, OutputT>
   */

  /**
   * @typedef {import("./Signer.js").Signer} Signer
   * @typedef {import("./Provider.js").Provider} Provider
   * @typedef {import("./LedgerId.js").default} LedgerId
   * @typedef {import("./Key.js").default} Key
   * @typedef {import("./transaction/Transaction.js").default} Transaction
   * @typedef {import("./transaction/TransactionResponse.js").default} TransactionResponse
   * @typedef {import("./transaction/TransactionReceipt.js").default} TransactionReceipt
   * @typedef {import("./transaction/TransactionRecord.js").default} TransactionRecord
   * @typedef {import("./account/AccountBalance.js").default} AccountBalance
   * @typedef {import("./account/AccountInfo.js").default} AccountInfo
   */

  /**
   * @template {any} O
   * @typedef {import("./query/Query.js").default<O>} Query<O>
   */

  /**
   * @implements {Signer}
   */
  class Wallet {
      /**
       * NOTE: When using string for private key, the string needs to contain DER headers
       *
       * @param {AccountId | string} accountId
       * @param {PrivateKey | string} privateKey
       * @param {Provider=} provider
       */
      constructor(accountId, privateKey, provider) {
          /*
          TODO: deprecate on a major version 
          the following lines were added because we didnt have
          a way to check the algorithm of a der encoded private key
          We need to keep the old behavior for the transition period.
          */
          let key;
          if (typeof privateKey === "string" && PrivateKey.isDerKey(privateKey)) {
              key = PrivateKey.fromStringDer(privateKey);
          } else if (typeof privateKey === "string") {
              // eslint-disable-next-line deprecation/deprecation
              key = PrivateKey.fromString(privateKey);
          } else {
              key = privateKey;
          }

          this.publicKey = key.publicKey;
          /**
           * @type {(message: Uint8Array) => Promise<Uint8Array>}
           */
          this.signer = (message) => Promise.resolve(key.sign(message));
          this.provider = provider;
          this.accountId =
              typeof accountId === "string"
                  ? AccountId.fromString(accountId)
                  : accountId;
      }

      /**
       * @returns {Promise<Wallet>}
       * @deprecated
       */
      static createRandomED25519() {
          const privateKey = PrivateKey.generateED25519();
          const publicKey = privateKey.publicKey;
          const accountId = publicKey.toAccountId(0, 0);
          return Promise.resolve(new Wallet(accountId, privateKey));
      }

      /**
       * @returns {Promise<Wallet>}
       * @deprecated
       */
      static createRandomECDSA() {
          const privateKey = PrivateKey.generateECDSA();
          const publicKey = privateKey.publicKey;
          const accountId = publicKey.toAccountId(0, 0);
          return Promise.resolve(new Wallet(accountId, privateKey));
      }

      /**
       * @returns {Provider=}
       */
      getProvider() {
          return this.provider;
      }

      /**
       * @abstract
       * @returns {AccountId}
       */
      getAccountId() {
          return this.accountId;
      }

      /**
       * @returns {Key}
       */
      getAccountKey() {
          return this.publicKey;
      }

      /**
       * @returns {LedgerId?}
       */
      getLedgerId() {
          return this.provider == null ? null : this.provider.getLedgerId();
      }

      /**
       * @abstract
       * @returns {{[key: string]: (string | AccountId)}}
       */
      getNetwork() {
          return this.provider == null ? {} : this.provider.getNetwork();
      }

      /**
       * @abstract
       * @returns {string[]}
       */
      getMirrorNetwork() {
          return this.provider == null ? [] : this.provider.getMirrorNetwork();
      }

      /**
       * @param {Uint8Array[]} messages
       * @returns {Promise<SignerSignature[]>}
       */
      async sign(messages) {
          const sigantures = [];

          for (const message of messages) {
              sigantures.push(
                  new SignerSignature({
                      publicKey: this.publicKey,
                      signature: await this.signer(message),
                      accountId: this.accountId,
                  }),
              );
          }

          return sigantures;
      }

      /**
       * @returns {Promise<AccountBalance>}
       */
      getAccountBalance() {
          return this.call(
              new AccountBalanceQuery().setAccountId(this.accountId),
          );
      }

      /**
       * @abstract
       * @returns {Promise<AccountInfo>}
       */
      getAccountInfo() {
          return this.call(new AccountInfoQuery().setAccountId(this.accountId));
      }

      /**
       * @abstract
       * @returns {Promise<TransactionRecord[]>}
       */
      getAccountRecords() {
          return this.call(
              new AccountRecordsQuery().setAccountId(this.accountId),
          );
      }

      /**
       * @template {Transaction} T
       * @param {T} transaction
       * @returns {Promise<T>}
       */
      signTransaction(transaction) {
          return transaction.signWith(this.publicKey, this.signer);
      }

      /**
       * @template {Transaction} T
       * @param {T} transaction
       * @returns {Promise<T>}
       */
      checkTransaction(transaction) {
          const transactionId = transaction.transactionId;
          if (
              transactionId != null &&
              transactionId.accountId != null &&
              transactionId.accountId.compare(this.accountId) != 0
          ) {
              throw new Error(
                  "transaction's ID constructed with a different account ID",
              );
          }

          if (this.provider == null) {
              return Promise.resolve(transaction);
          }

          const nodeAccountIds = (
              transaction.nodeAccountIds != null ? transaction.nodeAccountIds : []
          ).map((nodeAccountId) => nodeAccountId.toString());
          const network = Object.values(this.provider.getNetwork()).map(
              (nodeAccountId) => nodeAccountId.toString(),
          );

          if (
              !nodeAccountIds.reduce(
                  (previous, current) => previous && network.includes(current),
                  true,
              )
          ) {
              throw new Error(
                  "Transaction already set node account IDs to values not within the current network",
              );
          }

          return Promise.resolve(transaction);
      }

      /**
       * @template {Transaction} T
       * @param {T} transaction
       * @returns {Promise<T>}
       */
      populateTransaction(transaction) {
          transaction._freezeWithAccountId(this.accountId);

          if (transaction.transactionId == null) {
              transaction.setTransactionId(
                  TransactionId.generate(this.accountId),
              );
          }

          if (
              transaction.nodeAccountIds != null &&
              transaction.nodeAccountIds.length != 0
          ) {
              return Promise.resolve(transaction.freeze());
          }

          if (this.provider == null) {
              return Promise.resolve(transaction);
          }

          const nodeAccountIds = Object.values(this.provider.getNetwork()).map(
              (id) => (typeof id === "string" ? AccountId.fromString(id) : id),
          );
          shuffle(nodeAccountIds);
          transaction.setNodeAccountIds(
              nodeAccountIds.slice(0, (nodeAccountIds.length + 3 - 1) / 3),
          );

          return Promise.resolve(transaction.freeze());
      }

      /**
       * @template RequestT
       * @template ResponseT
       * @template OutputT
       * @param {Executable<RequestT, ResponseT, OutputT>} request
       * @returns {Promise<OutputT>}
       */
      call(request) {
          if (this.provider == null) {
              throw new Error(
                  "cannot send request with an wallet that doesn't contain a provider",
              );
          }

          return this.provider.call(
              request._setOperatorWith(
                  this.accountId,
                  this.publicKey,
                  this.signer,
              ),
          );
      }
  }

  var browser = {exports: {}};

  var quickFormatUnescaped;
  var hasRequiredQuickFormatUnescaped;

  function requireQuickFormatUnescaped () {
  	if (hasRequiredQuickFormatUnescaped) return quickFormatUnescaped;
  	hasRequiredQuickFormatUnescaped = 1;
  	function tryStringify (o) {
  	  try { return JSON.stringify(o) } catch(e) { return '"[Circular]"' }
  	}

  	quickFormatUnescaped = format;

  	function format(f, args, opts) {
  	  var ss = (opts && opts.stringify) || tryStringify;
  	  var offset = 1;
  	  if (typeof f === 'object' && f !== null) {
  	    var len = args.length + offset;
  	    if (len === 1) return f
  	    var objects = new Array(len);
  	    objects[0] = ss(f);
  	    for (var index = 1; index < len; index++) {
  	      objects[index] = ss(args[index]);
  	    }
  	    return objects.join(' ')
  	  }
  	  if (typeof f !== 'string') {
  	    return f
  	  }
  	  var argLen = args.length;
  	  if (argLen === 0) return f
  	  var str = '';
  	  var a = 1 - offset;
  	  var lastPos = -1;
  	  var flen = (f && f.length) || 0;
  	  for (var i = 0; i < flen;) {
  	    if (f.charCodeAt(i) === 37 && i + 1 < flen) {
  	      lastPos = lastPos > -1 ? lastPos : 0;
  	      switch (f.charCodeAt(i + 1)) {
  	        case 100: // 'd'
  	        case 102: // 'f'
  	          if (a >= argLen)
  	            break
  	          if (args[a] == null)  break
  	          if (lastPos < i)
  	            str += f.slice(lastPos, i);
  	          str += Number(args[a]);
  	          lastPos = i + 2;
  	          i++;
  	          break
  	        case 105: // 'i'
  	          if (a >= argLen)
  	            break
  	          if (args[a] == null)  break
  	          if (lastPos < i)
  	            str += f.slice(lastPos, i);
  	          str += Math.floor(Number(args[a]));
  	          lastPos = i + 2;
  	          i++;
  	          break
  	        case 79: // 'O'
  	        case 111: // 'o'
  	        case 106: // 'j'
  	          if (a >= argLen)
  	            break
  	          if (args[a] === undefined) break
  	          if (lastPos < i)
  	            str += f.slice(lastPos, i);
  	          var type = typeof args[a];
  	          if (type === 'string') {
  	            str += '\'' + args[a] + '\'';
  	            lastPos = i + 2;
  	            i++;
  	            break
  	          }
  	          if (type === 'function') {
  	            str += args[a].name || '<anonymous>';
  	            lastPos = i + 2;
  	            i++;
  	            break
  	          }
  	          str += ss(args[a]);
  	          lastPos = i + 2;
  	          i++;
  	          break
  	        case 115: // 's'
  	          if (a >= argLen)
  	            break
  	          if (lastPos < i)
  	            str += f.slice(lastPos, i);
  	          str += String(args[a]);
  	          lastPos = i + 2;
  	          i++;
  	          break
  	        case 37: // '%'
  	          if (lastPos < i)
  	            str += f.slice(lastPos, i);
  	          str += '%';
  	          lastPos = i + 2;
  	          i++;
  	          a--;
  	          break
  	      }
  	      ++a;
  	    }
  	    ++i;
  	  }
  	  if (lastPos === -1)
  	    return f
  	  else if (lastPos < flen) {
  	    str += f.slice(lastPos);
  	  }

  	  return str
  	}
  	return quickFormatUnescaped;
  }

  var hasRequiredBrowser;

  function requireBrowser () {
  	if (hasRequiredBrowser) return browser.exports;
  	hasRequiredBrowser = 1;

  	const format = requireQuickFormatUnescaped();

  	browser.exports = pino;

  	const _console = pfGlobalThisOrFallback().console || {};
  	const stdSerializers = {
  	  mapHttpRequest: mock,
  	  mapHttpResponse: mock,
  	  wrapRequestSerializer: passthrough,
  	  wrapResponseSerializer: passthrough,
  	  wrapErrorSerializer: passthrough,
  	  req: mock,
  	  res: mock,
  	  err: asErrValue,
  	  errWithCause: asErrValue
  	};
  	function levelToValue (level, logger) {
  	  return level === 'silent'
  	    ? Infinity
  	    : logger.levels.values[level]
  	}
  	const baseLogFunctionSymbol = Symbol('pino.logFuncs');
  	const hierarchySymbol = Symbol('pino.hierarchy');

  	const logFallbackMap = {
  	  error: 'log',
  	  fatal: 'error',
  	  warn: 'error',
  	  info: 'log',
  	  debug: 'log',
  	  trace: 'log'
  	};

  	function appendChildLogger (parentLogger, childLogger) {
  	  const newEntry = {
  	    logger: childLogger,
  	    parent: parentLogger[hierarchySymbol]
  	  };
  	  childLogger[hierarchySymbol] = newEntry;
  	}

  	function setupBaseLogFunctions (logger, levels, proto) {
  	  const logFunctions = {};
  	  levels.forEach(level => {
  	    logFunctions[level] = proto[level] ? proto[level] : (_console[level] || _console[logFallbackMap[level] || 'log'] || noop);
  	  });
  	  logger[baseLogFunctionSymbol] = logFunctions;
  	}

  	function shouldSerialize (serialize, serializers) {
  	  if (Array.isArray(serialize)) {
  	    const hasToFilter = serialize.filter(function (k) {
  	      return k !== '!stdSerializers.err'
  	    });
  	    return hasToFilter
  	  } else if (serialize === true) {
  	    return Object.keys(serializers)
  	  }

  	  return false
  	}

  	function pino (opts) {
  	  opts = opts || {};
  	  opts.browser = opts.browser || {};

  	  const transmit = opts.browser.transmit;
  	  if (transmit && typeof transmit.send !== 'function') { throw Error('pino: transmit option must have a send function') }

  	  const proto = opts.browser.write || _console;
  	  if (opts.browser.write) opts.browser.asObject = true;
  	  const serializers = opts.serializers || {};
  	  const serialize = shouldSerialize(opts.browser.serialize, serializers);
  	  let stdErrSerialize = opts.browser.serialize;

  	  if (
  	    Array.isArray(opts.browser.serialize) &&
  	    opts.browser.serialize.indexOf('!stdSerializers.err') > -1
  	  ) stdErrSerialize = false;

  	  const customLevels = Object.keys(opts.customLevels || {});
  	  const levels = ['error', 'fatal', 'warn', 'info', 'debug', 'trace'].concat(customLevels);

  	  if (typeof proto === 'function') {
  	    levels.forEach(function (level) {
  	      proto[level] = proto;
  	    });
  	  }
  	  if (opts.enabled === false || opts.browser.disabled) opts.level = 'silent';
  	  const level = opts.level || 'info';
  	  const logger = Object.create(proto);
  	  if (!logger.log) logger.log = noop;

  	  setupBaseLogFunctions(logger, levels, proto);
  	  // setup root hierarchy entry
  	  appendChildLogger({}, logger);

  	  Object.defineProperty(logger, 'levelVal', {
  	    get: getLevelVal
  	  });
  	  Object.defineProperty(logger, 'level', {
  	    get: getLevel,
  	    set: setLevel
  	  });

  	  const setOpts = {
  	    transmit,
  	    serialize,
  	    asObject: opts.browser.asObject,
  	    asObjectBindingsOnly: opts.browser.asObjectBindingsOnly,
  	    formatters: opts.browser.formatters,
  	    levels,
  	    timestamp: getTimeFunction(opts),
  	    messageKey: opts.messageKey || 'msg',
  	    onChild: opts.onChild || noop
  	  };
  	  logger.levels = getLevels(opts);
  	  logger.level = level;

  	  logger.isLevelEnabled = function (level) {
  	    if (!this.levels.values[level]) {
  	      return false
  	    }

  	    return this.levels.values[level] >= this.levels.values[this.level]
  	  };
  	  logger.setMaxListeners = logger.getMaxListeners =
  	  logger.emit = logger.addListener = logger.on =
  	  logger.prependListener = logger.once =
  	  logger.prependOnceListener = logger.removeListener =
  	  logger.removeAllListeners = logger.listeners =
  	  logger.listenerCount = logger.eventNames =
  	  logger.write = logger.flush = noop;
  	  logger.serializers = serializers;
  	  logger._serialize = serialize;
  	  logger._stdErrSerialize = stdErrSerialize;
  	  logger.child = function (...args) { return child.call(this, setOpts, ...args) };

  	  if (transmit) logger._logEvent = createLogEventShape();

  	  function getLevelVal () {
  	    return levelToValue(this.level, this)
  	  }

  	  function getLevel () {
  	    return this._level
  	  }
  	  function setLevel (level) {
  	    if (level !== 'silent' && !this.levels.values[level]) {
  	      throw Error('unknown level ' + level)
  	    }
  	    this._level = level;

  	    set(this, setOpts, logger, 'error'); // <-- must stay first
  	    set(this, setOpts, logger, 'fatal');
  	    set(this, setOpts, logger, 'warn');
  	    set(this, setOpts, logger, 'info');
  	    set(this, setOpts, logger, 'debug');
  	    set(this, setOpts, logger, 'trace');

  	    customLevels.forEach((level) => {
  	      set(this, setOpts, logger, level);
  	    });
  	  }

  	  function child (setOpts, bindings, childOptions) {
  	    if (!bindings) {
  	      throw new Error('missing bindings for child Pino')
  	    }
  	    childOptions = childOptions || {};
  	    if (serialize && bindings.serializers) {
  	      childOptions.serializers = bindings.serializers;
  	    }
  	    const childOptionsSerializers = childOptions.serializers;
  	    if (serialize && childOptionsSerializers) {
  	      var childSerializers = Object.assign({}, serializers, childOptionsSerializers);
  	      var childSerialize = opts.browser.serialize === true
  	        ? Object.keys(childSerializers)
  	        : serialize;
  	      delete bindings.serializers;
  	      applySerializers([bindings], childSerialize, childSerializers, this._stdErrSerialize);
  	    }
  	    function Child (parent) {
  	      this._childLevel = (parent._childLevel | 0) + 1;

  	      // make sure bindings are available in the `set` function
  	      this.bindings = bindings;

  	      if (childSerializers) {
  	        this.serializers = childSerializers;
  	        this._serialize = childSerialize;
  	      }
  	      if (transmit) {
  	        this._logEvent = createLogEventShape(
  	          [].concat(parent._logEvent.bindings, bindings)
  	        );
  	      }
  	    }
  	    Child.prototype = this;
  	    const newLogger = new Child(this);

  	    // must happen before the level is assigned
  	    appendChildLogger(this, newLogger);
  	    newLogger.child = function (...args) { return child.call(this, setOpts, ...args) };
  	    // required to actually initialize the logger functions for any given child
  	    newLogger.level = childOptions.level || this.level; // allow level to be set by childOptions
  	    setOpts.onChild(newLogger);

  	    return newLogger
  	  }
  	  return logger
  	}

  	function getLevels (opts) {
  	  const customLevels = opts.customLevels || {};

  	  const values = Object.assign({}, pino.levels.values, customLevels);
  	  const labels = Object.assign({}, pino.levels.labels, invertObject(customLevels));

  	  return {
  	    values,
  	    labels
  	  }
  	}

  	function invertObject (obj) {
  	  const inverted = {};
  	  Object.keys(obj).forEach(function (key) {
  	    inverted[obj[key]] = key;
  	  });
  	  return inverted
  	}

  	pino.levels = {
  	  values: {
  	    fatal: 60,
  	    error: 50,
  	    warn: 40,
  	    info: 30,
  	    debug: 20,
  	    trace: 10
  	  },
  	  labels: {
  	    10: 'trace',
  	    20: 'debug',
  	    30: 'info',
  	    40: 'warn',
  	    50: 'error',
  	    60: 'fatal'
  	  }
  	};

  	pino.stdSerializers = stdSerializers;
  	pino.stdTimeFunctions = Object.assign({}, { nullTime, epochTime, unixTime, isoTime });

  	function getBindingChain (logger) {
  	  const bindings = [];
  	  if (logger.bindings) {
  	    bindings.push(logger.bindings);
  	  }

  	  // traverse up the tree to get all bindings
  	  let hierarchy = logger[hierarchySymbol];
  	  while (hierarchy.parent) {
  	    hierarchy = hierarchy.parent;
  	    if (hierarchy.logger.bindings) {
  	      bindings.push(hierarchy.logger.bindings);
  	    }
  	  }

  	  return bindings.reverse()
  	}

  	function set (self, opts, rootLogger, level) {
  	  // override the current log functions with either `noop` or the base log function
  	  Object.defineProperty(self, level, {
  	    value: (levelToValue(self.level, rootLogger) > levelToValue(level, rootLogger)
  	      ? noop
  	      : rootLogger[baseLogFunctionSymbol][level]),
  	    writable: true,
  	    enumerable: true,
  	    configurable: true
  	  });

  	  if (self[level] === noop) {
  	    if (!opts.transmit) return

  	    const transmitLevel = opts.transmit.level || self.level;
  	    const transmitValue = levelToValue(transmitLevel, rootLogger);
  	    const methodValue = levelToValue(level, rootLogger);
  	    if (methodValue < transmitValue) return
  	  }

  	  // make sure the log format is correct
  	  self[level] = createWrap(self, opts, rootLogger, level);

  	  // prepend bindings if it is not the root logger
  	  const bindings = getBindingChain(self);
  	  if (bindings.length === 0) {
  	    // early exit in case for rootLogger
  	    return
  	  }
  	  self[level] = prependBindingsInArguments(bindings, self[level]);
  	}

  	function prependBindingsInArguments (bindings, logFunc) {
  	  return function () {
  	    return logFunc.apply(this, [...bindings, ...arguments])
  	  }
  	}

  	function createWrap (self, opts, rootLogger, level) {
  	  return (function (write) {
  	    return function LOG () {
  	      const ts = opts.timestamp();
  	      const args = new Array(arguments.length);
  	      const proto = (Object.getPrototypeOf && Object.getPrototypeOf(this) === _console) ? _console : this;
  	      for (var i = 0; i < args.length; i++) args[i] = arguments[i];

  	      var argsIsSerialized = false;
  	      if (opts.serialize) {
  	        applySerializers(args, this._serialize, this.serializers, this._stdErrSerialize);
  	        argsIsSerialized = true;
  	      }
  	      if (opts.asObject || opts.formatters) {
  	        write.call(proto, ...asObject(this, level, args, ts, opts));
  	      } else write.apply(proto, args);

  	      if (opts.transmit) {
  	        const transmitLevel = opts.transmit.level || self._level;
  	        const transmitValue = levelToValue(transmitLevel, rootLogger);
  	        const methodValue = levelToValue(level, rootLogger);
  	        if (methodValue < transmitValue) return
  	        transmit(this, {
  	          ts,
  	          methodLevel: level,
  	          methodValue,
  	          transmitValue: rootLogger.levels.values[opts.transmit.level || self._level],
  	          send: opts.transmit.send,
  	          val: levelToValue(self._level, rootLogger)
  	        }, args, argsIsSerialized);
  	      }
  	    }
  	  })(self[baseLogFunctionSymbol][level])
  	}

  	function asObject (logger, level, args, ts, opts) {
  	  const {
  	    level: levelFormatter,
  	    log: logObjectFormatter = (obj) => obj
  	  } = opts.formatters || {};
  	  const argsCloned = args.slice();
  	  let msg = argsCloned[0];
  	  const logObject = {};

  	  let lvl = (logger._childLevel | 0) + 1;
  	  if (lvl < 1) lvl = 1;

  	  if (ts) {
  	    logObject.time = ts;
  	  }

  	  if (levelFormatter) {
  	    const formattedLevel = levelFormatter(level, logger.levels.values[level]);
  	    Object.assign(logObject, formattedLevel);
  	  } else {
  	    logObject.level = logger.levels.values[level];
  	  }

  	  if (opts.asObjectBindingsOnly) {
  	    if (msg !== null && typeof msg === 'object') {
  	      while (lvl-- && typeof argsCloned[0] === 'object') {
  	        Object.assign(logObject, argsCloned.shift());
  	      }
  	    }

  	    const formattedLogObject = logObjectFormatter(logObject);
  	    return [formattedLogObject, ...argsCloned]
  	  } else {
  	    // deliberate, catching objects, arrays
  	    if (msg !== null && typeof msg === 'object') {
  	      while (lvl-- && typeof argsCloned[0] === 'object') {
  	        Object.assign(logObject, argsCloned.shift());
  	      }
  	      msg = argsCloned.length ? format(argsCloned.shift(), argsCloned) : undefined;
  	    } else if (typeof msg === 'string') msg = format(argsCloned.shift(), argsCloned);
  	    if (msg !== undefined) logObject[opts.messageKey] = msg;

  	    const formattedLogObject = logObjectFormatter(logObject);
  	    return [formattedLogObject]
  	  }
  	}

  	function applySerializers (args, serialize, serializers, stdErrSerialize) {
  	  for (const i in args) {
  	    if (stdErrSerialize && args[i] instanceof Error) {
  	      args[i] = pino.stdSerializers.err(args[i]);
  	    } else if (typeof args[i] === 'object' && !Array.isArray(args[i]) && serialize) {
  	      for (const k in args[i]) {
  	        if (serialize.indexOf(k) > -1 && k in serializers) {
  	          args[i][k] = serializers[k](args[i][k]);
  	        }
  	      }
  	    }
  	  }
  	}

  	function transmit (logger, opts, args, argsIsSerialized = false) {
  	  const send = opts.send;
  	  const ts = opts.ts;
  	  const methodLevel = opts.methodLevel;
  	  const methodValue = opts.methodValue;
  	  const val = opts.val;
  	  const bindings = logger._logEvent.bindings;

  	  if (!argsIsSerialized) {
  	    applySerializers(
  	      args,
  	      logger._serialize || Object.keys(logger.serializers),
  	      logger.serializers,
  	      logger._stdErrSerialize === undefined ? true : logger._stdErrSerialize
  	    );
  	  }

  	  logger._logEvent.ts = ts;
  	  logger._logEvent.messages = args.filter(function (arg) {
  	    // bindings can only be objects, so reference equality check via indexOf is fine
  	    return bindings.indexOf(arg) === -1
  	  });

  	  logger._logEvent.level.label = methodLevel;
  	  logger._logEvent.level.value = methodValue;

  	  send(methodLevel, logger._logEvent, val);

  	  logger._logEvent = createLogEventShape(bindings);
  	}

  	function createLogEventShape (bindings) {
  	  return {
  	    ts: 0,
  	    messages: [],
  	    bindings: bindings || [],
  	    level: { label: '', value: 0 }
  	  }
  	}

  	function asErrValue (err) {
  	  const obj = {
  	    type: err.constructor.name,
  	    msg: err.message,
  	    stack: err.stack
  	  };
  	  for (const key in err) {
  	    if (obj[key] === undefined) {
  	      obj[key] = err[key];
  	    }
  	  }
  	  return obj
  	}

  	function getTimeFunction (opts) {
  	  if (typeof opts.timestamp === 'function') {
  	    return opts.timestamp
  	  }
  	  if (opts.timestamp === false) {
  	    return nullTime
  	  }
  	  return epochTime
  	}

  	function mock () { return {} }
  	function passthrough (a) { return a }
  	function noop () {}

  	function nullTime () { return false }
  	function epochTime () { return Date.now() }
  	function unixTime () { return Math.round(Date.now() / 1000.0) }
  	function isoTime () { return new Date(Date.now()).toISOString() } // using Date.now() for testability

  	/* eslint-disable */
  	/* istanbul ignore next */
  	function pfGlobalThisOrFallback () {
  	  function defd (o) { return typeof o !== 'undefined' && o }
  	  try {
  	    if (typeof globalThis !== 'undefined') return globalThis
  	    Object.defineProperty(Object.prototype, 'globalThis', {
  	      get: function () {
  	        delete Object.prototype.globalThis;
  	        return (this.globalThis = this)
  	      },
  	      configurable: true
  	    });
  	    return globalThis
  	  } catch (e) {
  	    return defd(self) || defd(window) || defd(this) || {}
  	  }
  	}
  	/* eslint-enable */

  	browser.exports.default = pino;
  	browser.exports.pino = pino;
  	return browser.exports;
  }

  var browserExports = requireBrowser();
  var pino = /*@__PURE__*/getDefaultExportFromCjs(browserExports);

  // SPDX-License-Identifier: Apache-2.0

  class LogLevel {
      /**
       * @hideconstructor
       * @internal
       * @param {string} name
       */
      constructor(name) {
          /** @readonly */
          this._name = name;

          Object.freeze(this);
      }

      /**
       * @returns {string}
       */
      toString() {
          switch (this) {
              case LogLevel.Silent:
                  return "silent";
              case LogLevel.Trace:
                  return "trace";
              case LogLevel.Debug:
                  return "debug";
              case LogLevel.Info:
                  return "info";
              case LogLevel.Warn:
                  return "warn";
              case LogLevel.Error:
                  return "error";
              case LogLevel.Fatal:
                  return "fatal";
              default:
                  return `Unknown log level (${this._name})`;
          }
      }

      /**
       * @param {string} level
       * @returns {LogLevel}
       */
      static _fromString(level) {
          switch (level) {
              case "silent":
                  return LogLevel.Silent;
              case "trace":
                  return LogLevel.Trace;
              case "debug":
                  return LogLevel.Debug;
              case "info":
                  return LogLevel.Info;
              case "warn":
                  return LogLevel.Warn;
              case "error":
                  return LogLevel.Error;
              case "fatal":
                  return LogLevel.Fatal;
              default:
                  throw new Error(`Unknown log level: ${level}`);
          }
      }
  }

  LogLevel.Silent = new LogLevel("silent");
  LogLevel.Trace = new LogLevel("trace");
  LogLevel.Debug = new LogLevel("debug");
  LogLevel.Info = new LogLevel("info");
  LogLevel.Warn = new LogLevel("warn");
  LogLevel.Error = new LogLevel("error");
  LogLevel.Fatal = new LogLevel("fatal");

  // SPDX-License-Identifier: Apache-2.0

  /**
   * A Logger class for logging messages in the Hiero JavaScript SDK.
   * This class provides a flexible logging mechanism that can log messages
   * to various outputs, including the console and log files. It supports
   * different log levels (e.g., trace, debug, info, warn, error, fatal)
   * and allows for configuration of logging behavior, such as synchronous
   * writes and file management.
   *
   * The Logger can be initialized with a specific log level, a log file path,
   * and options for synchronous writes and file synchronization. It also
   * provides methods to change the logging level and to enable or disable
   * silent mode, which suppresses all log messages.
   */
  class Logger {
      /**
       * @param {LogLevel} level
       * @param {string} logFile the file to log to, if empty, logs to console
       * @param {boolean} sync perform writes synchronously (similar to console.log)
       * @param {boolean} fsync perform a fsyncSync every time a write is completed
       * @param {boolean} mkdir ensure directory for dest file exists when true (default false)
       * @param {number} minLength the minimum length of the internal buffer that is required to be full before flushing
       */
      constructor(
          level,
          logFile = "",
          sync = true,
          fsync = true,
          mkdir = true,
          minLength = 0,
      ) {
          const fileTransport = logFile
              ? pino.destination({
                    dest: logFile,
                    sync,
                    fsync,
                    mkdir,
                    minLength,
                })
              : null;

          const loggerOptions = fileTransport
              ? {
                    level: level.toString(),
                    timestamp: pino.stdTimeFunctions.isoTime,
                    formatters: {
                        bindings: () => {
                            return {};
                        },
                        // @ts-ignore
                        level: (label) => {
                            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-call,@typescript-eslint/no-unsafe-member-access
                            return { level: label.toUpperCase() };
                        },
                    },
                }
              : {
                    level: level.toString(),
                    transport: {
                        target: "pino-pretty",
                        options: {
                            translateTime: "SYS:dd-mm-yyyy HH:MM:ss",
                            ignore: "pid,hostname",
                        },
                    },
                };

          /**
           * @private
           * @type {import("pino").Logger}
           */
          this._logger = fileTransport
              ? pino(loggerOptions, fileTransport)
              : pino(loggerOptions);

          /**
           * @private
           * @type {LogLevel}
           */
          this._previousLevel = level;
      }

      /**
       * Set logger
       *
       * @public
       * @param {import("pino").Logger} logger
       * @returns {this}
       */
      setLogger(logger) {
          this._logger = logger;
          return this;
      }

      /**
       * Set log level
       *
       * @public
       * @param {LogLevel} level
       * @returns {this}
       */
      setLevel(level) {
          this._previousLevel = LogLevel._fromString(this._logger.level);
          this._logger.level = level.toString();
          return this;
      }

      /**
       * Get logging level
       *
       * @public
       * @returns {LogLevel}
       */
      get level() {
          return LogLevel._fromString(this._logger.level);
      }

      /**
       * Get logging level
       *
       * @public
       * @returns {{[level: number]: string}}
       */
      get levels() {
          return this._logger.levels.labels;
      }

      /**
       * Set silent mode on/off
       *
       * @public
       * @description If set to true, the logger will not display any log messages
       * - This can also be achieved by calling `.setLevel(LogLevel.Silent)`
       * @param {boolean} silent
       * @returns {this}
       */
      setSilent(silent) {
          if (silent) {
              this._logger.level = LogLevel.Silent.toString();
          } else {
              // Here we are setting the level to the previous level, before silencing the logger
              this._logger.level = this._previousLevel.toString();
          }
          return this;
      }

      /**
       * Get silent mode
       *
       * @public
       * @returns {boolean}
       */
      get silent() {
          return this._logger.level == LogLevel.Silent.toString();
      }

      /**
       * Log trace
       *
       * @public
       * @param {string} message
       * @returns {void}
       */
      trace(message) {
          this._logger.trace(message);
      }

      /**
       * Log debug
       *
       * @public
       * @param {string} message
       * @returns {void}
       */
      debug(message) {
          this._logger.debug(message);
      }

      /**
       * Log info
       *
       * @public
       * @param {string} message
       * @returns {void}
       */
      info(message) {
          this._logger.info(message);
      }

      /**
       * Log warn
       *
       * @public
       * @param {string} message
       * @returns {void}
       */
      warn(message) {
          this._logger.warn(message);
      }

      /**
       * Log error
       *
       * @public
       * @param {string} message
       * @returns {void}
       */
      error(message) {
          this._logger.error(message);
      }

      /**
       * Log fatal
       *
       * @public
       * @param {string} message
       * @returns {void}
       */
      fatal(message) {
          this._logger.fatal(message);
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
   * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
   * @typedef {import("@hashgraph/proto").proto.ITokenUpdateNftsTransactionBody} HieroProto.proto.ITokenUpdateNftsTransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   * @typedef {import("../account/AccountId.js").default} AccountId
   */

  /**
   * At consensus, updates an already created Non Fungible Token to the given values.
   *
   * If no value is given for a field, that field is left unchanged.
   * Only certain fields such as metadata can be updated.
   *
   * Updating the metadata of an NFT does not affect its ownership or transferability.
   * This operation is intended for updating attributes of individual NFTs in a collection.
   */
  class TokenUpdateNftsTransaction extends Transaction {
      /**
       * @param {object} [props]
       * @param {TokenId | string} [props.tokenId]
       * @param {Long[]} [props.serialNumbers]
       * @param {?Uint8Array} [props.metadata]
       */
      constructor(props = {}) {
          super();

          /**
           * @private
           * @type {?TokenId}
           */
          this._tokenId = null;

          /**
           * @private
           * @type {?Long[]}
           */
          this._serialNumbers = [];

          /**
           * @private
           * @type {?Uint8Array}
           */
          this._metadata = null;

          if (props.tokenId != null) {
              this.setTokenId(props.tokenId);
          }

          if (props.serialNumbers != null) {
              this.setSerialNumbers(props.serialNumbers);
          }

          if (props.metadata != null) {
              this.setMetadata(props.metadata);
          }
      }

      /**
       * @internal
       * @param {HieroProto.proto.ITransaction[]} transactions
       * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {HieroProto.proto.ITransactionBody[]} bodies
       * @returns {TokenUpdateNftsTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];
          const tokenUpdate =
              /** @type {HieroProto.proto.ITokenUpdateNftsTransactionBody} */ (
                  body.tokenUpdateNfts
              );

          return Transaction._fromProtobufTransactions(
              new TokenUpdateNftsTransaction({
                  tokenId:
                      tokenUpdate.token != null
                          ? TokenId._fromProtobuf(tokenUpdate.token)
                          : undefined,
                  serialNumbers:
                      tokenUpdate.serialNumbers != null
                          ? tokenUpdate.serialNumbers
                          : [],
                  metadata:
                      tokenUpdate.metadata != null
                          ? Object.hasOwn(tokenUpdate.metadata, "value")
                              ? tokenUpdate.metadata.value
                              : undefined
                          : undefined,
              }),
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * @description Assign the token id.
       * @param {TokenId | string} tokenId
       * @returns {this}
       */
      setTokenId(tokenId) {
          this._requireNotFrozen();
          this._tokenId =
              typeof tokenId === "string"
                  ? TokenId.fromString(tokenId)
                  : tokenId.clone();

          return this;
      }

      /**
       * @description Assign the list of serial numbers.
       * @param {Long[]} serialNumbers
       * @returns {this}
       */
      setSerialNumbers(serialNumbers) {
          this._requireNotFrozen();
          this._serialNumbers = serialNumbers;

          return this;
      }

      /**
       * @param {Uint8Array} metadata
       * @returns {this}
       */
      setMetadata(metadata) {
          this._requireNotFrozen();
          this._metadata = metadata;

          return this;
      }

      /**
       * @param {Client} client
       */
      _validateChecksums(client) {
          if (this._tokenId != null) {
              this._tokenId.validateChecksum(client);
          }
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {HieroProto.proto.ITransaction} request
       * @returns {Promise<HieroProto.proto.ITransactionResponse>}
       */
      _execute(channel, request) {
          return channel.token.pauseToken(request);
      }

      /**
       * @override
       * @protected
       * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "tokenUpdateNfts";
      }

      /**
       * @override
       * @protected
       * @returns {HieroProto.proto.ITokenUpdateNftsTransactionBody}
       */
      _makeTransactionData() {
          return {
              token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
              serialNumbers:
                  this._serialNumbers != null ? this._serialNumbers : [],
              ...(this._metadata != null
                  ? {
                        metadata: {
                            value: this._metadata,
                        },
                    }
                  : null),
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("../Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `TokenUpdateNftsTransaction:${timestamp.toString()}`;
      }
  }

  TRANSACTION_REGISTRY.set(
      "tokenUpdateNfts",
      // eslint-disable-next-line @typescript-eslint/unbound-method
      TokenUpdateNftsTransaction._fromProtobuf,
  );

  // SPDX-License-Identifier: Apache-2.0

  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.IServiceEndpoint} IServiceEndpoint
   */

  class ServiceEndpoint {
      /**
       * @param {object} [props]
       * @param {?Uint8Array} [props.ipAddressV4]
       * @param {?number} [props.port]
       * @param {?string} [props.domainName]
       */
      constructor(props) {
          /**
           * @type {?Uint8Array}
           * @description The 4-byte IPv4 address of the endpoint
           * encoded in left to right order
           * (e.g. 127.0.0.1 has bytes [127, 0, 0, 1]).
           */
          this._ipAddressV4 =
              props?.ipAddressV4 != null ? props.ipAddressV4 : null;

          /**
           * @type {?number}
           * @description The port of the service endpoint. It's required.
           */
          this._port = props?.port != null ? props.port : null;

          /**
           * @type {?string}
           * @description A node domain name. This MUST be the
           * fully qualified domain(DNS) name of the node. This
           * value MUST NOT be more than 253 characters.
           * domain_name and ipAddressV4 are mutually exclusive.
           * When the `domain_name` field is set, the `ipAddressV4`
           * field MUST NOT be set. When the `ipAddressV4` field
           * is set, the `domain_name` field MUST NOT be set.
           */
          this._domainName = props?.domainName != null ? props.domainName : null;
      }

      /**
       * @param {Uint8Array} ipAddressV4
       * @description Set 4-byte IPv4 address of the endpoint.
       * @returns {ServiceEndpoint}
       *
       */
      setIpAddressV4(ipAddressV4) {
          if (this._domainName != null) {
              throw new Error(
                  "Cannot set IP address when domain name is already set.",
              );
          }
          this._ipAddressV4 = ipAddressV4;
          return this;
      }

      /**
       * @description Get 4-byte IPv4 address of the endpoint.
       * @returns {?Uint8Array}
       *
       */
      get getIpAddressV4() {
          return this._ipAddressV4;
      }

      /**
       * @param {number} port
       * @description Set port of the endpoint.
       * @returns {ServiceEndpoint}
       *
       */
      setPort(port) {
          this._port = port;
          return this;
      }

      /**
       * @description Get port of the endpoint.
       * @returns {?number}
       *
       */
      get getPort() {
          return this._port;
      }

      /**
       * @param {string} domainName
       * @description Set domain name of the endpoint.
       * @returns {ServiceEndpoint}
       *
       */
      setDomainName(domainName) {
          if (this._ipAddressV4 != null) {
              throw new Error(
                  "Cannot set domain name when IP address is already set.",
              );
          }
          this._domainName = domainName;
          return this;
      }

      /**
       * @description Get domain name of the endpoint.
       * @returns {?string}
       *
       */
      get getDomainName() {
          return this._domainName;
      }

      /**
       * @internal
       * @param {IServiceEndpoint} serviceEndpoint
       * @returns {ServiceEndpoint}
       */
      static _fromProtobuf(serviceEndpoint) {
          return new ServiceEndpoint({
              ipAddressV4:
                  serviceEndpoint.ipAddressV4 != null
                      ? serviceEndpoint.ipAddressV4
                      : undefined,
              port:
                  serviceEndpoint.port != null ? serviceEndpoint.port : undefined,
              domainName:
                  serviceEndpoint.domainName != null
                      ? serviceEndpoint.domainName
                      : undefined,
          });
      }

      /**
       * @internal
       * @returns {IServiceEndpoint}
       */
      _toProtobuf() {
          return {
              ipAddressV4: this._ipAddressV4,
              port: this._port,
              domainName: this._domainName,
          };
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  const DESCRIPTION_MAX_LENGTH$1 = 100;
  const GOSSIP_ENDPOINTS_MAX_LENGTH$1 = 10;
  const SERVICE_ENDPOINTS_MAX_LENGTH$1 = 8;

  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITransaction} ITransaction
   * @typedef {import("@hashgraph/proto").proto.ITransaction} ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} ITransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} ITransactionResponse
   */

  /**
   * @namespace com.hedera.hapi.node.addressbook
   * @typedef {import("@hashgraph/proto").com.hedera.hapi.node.addressbook.INodeCreateTransactionBody} INodeCreateTransactionBody
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   * @typedef {import("../client/Client.js").default<*, *>} Client
   */

  /**
   * A transaction to create a new consensus node in the network.
   */
  class NodeCreateTransaction extends Transaction {
      /**
       * @param {object} [props]
       * @param {AccountId} [props.accountId]
       * @param {?string} [props.description]
       * @param {Array<ServiceEndpoint>} [props.gossipEndpoints]
       * @param {?Array<ServiceEndpoint>} [props.serviceEndpoints]
       * @param {Uint8Array} [props.gossipCaCertificate]
       * @param {Uint8Array} [props.grpcCertificateHash]
       * @param {ServiceEndpoint} [props.grpcWebProxyEndpoint]
       * @param {Key} [props.adminKey]
       * @param {boolean} [props.declineReward]
       */
      constructor(props) {
          super();

          /**
           * @private
           * @type {?AccountId}
           * @description Node account identifier. It's required.
           */
          this._accountId = props?.accountId != null ? props.accountId : null;

          /**
           * @private
           * @type {?string}
           * @description Short description of the node.
           */
          this._description =
              props?.description != null ? props.description : null;

          /**
           * @private
           * @type {?Array<ServiceEndpoint>}
           * @description List of service endpoints for gossip. It's required.
           */
          this._gossipEndpoints =
              props?.gossipEndpoints != null ? props.gossipEndpoints : null;

          /**
           * @private
           * @type {?Array<ServiceEndpoint>}
           * @description List of service endpoints for gRPC calls.
           */
          this._serviceEndpoints =
              props?.serviceEndpoints != null ? props.serviceEndpoints : null;

          /**
           * @private
           * @type {?Uint8Array}
           * @description Certificate used to sign gossip events. It's required.
           */
          this._gossipCaCertificate =
              props?.gossipCaCertificate != null
                  ? props.gossipCaCertificate
                  : null;

          /**
           * @private
           * @type {?Uint8Array}
           * @description Hash of the node gRPC TLS certificate.
           */
          this._grpcCertificateHash =
              props?.grpcCertificateHash != null
                  ? props.grpcCertificateHash
                  : null;

          /**
           * @private
           * @type {?ServiceEndpoint}
           * @description Proxy endpoint for gRPC web calls.
           */
          this._grpcWebProxyEndpoint = props?.grpcWebProxyEndpoint || null;

          /**
           * @private
           * @type {?Key}
           * @description Administrative key controlled by the node operator. It's required.
           */
          this._adminKey = props?.adminKey != null ? props.adminKey : null;

          /**
           * @private
           * @type {?boolean}
           * @description Whether the node declines rewards.
           */
          this._declineReward =
              props?.declineReward != null ? props.declineReward : null;
      }

      /**
       * @internal
       * @param {ITransaction[]} transactions
       * @param {ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {ITransactionBody[]} bodies
       * @returns {NodeCreateTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];
          const nodeCreate = /** @type {INodeCreateTransactionBody} */ (
              body.nodeCreate
          );

          return Transaction._fromProtobufTransactions(
              new NodeCreateTransaction({
                  accountId:
                      nodeCreate.accountId != null
                          ? AccountId._fromProtobuf(nodeCreate.accountId)
                          : undefined,
                  description:
                      nodeCreate.description != null
                          ? nodeCreate.description
                          : undefined,
                  gossipEndpoints:
                      nodeCreate.gossipEndpoint != null
                          ? nodeCreate.gossipEndpoint.map((endpoint) =>
                                ServiceEndpoint._fromProtobuf(endpoint),
                            )
                          : undefined,
                  serviceEndpoints:
                      nodeCreate.serviceEndpoint != null
                          ? nodeCreate.serviceEndpoint.map((endpoint) =>
                                ServiceEndpoint._fromProtobuf(endpoint),
                            )
                          : undefined,
                  gossipCaCertificate:
                      nodeCreate.gossipCaCertificate != null
                          ? nodeCreate.gossipCaCertificate
                          : undefined,
                  grpcCertificateHash:
                      nodeCreate.grpcCertificateHash != null
                          ? nodeCreate.grpcCertificateHash
                          : undefined,
                  adminKey:
                      nodeCreate.adminKey != null
                          ? Key._fromProtobufKey(nodeCreate.adminKey)
                          : undefined,
                  declineReward:
                      nodeCreate.declineReward != null
                          ? nodeCreate.declineReward
                          : undefined,
                  grpcWebProxyEndpoint:
                      nodeCreate.grpcProxyEndpoint != null
                          ? ServiceEndpoint._fromProtobuf(
                                nodeCreate.grpcProxyEndpoint,
                            )
                          : undefined,
              }),
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * @param {AccountId | string} accountId
       * @description Set node account identifier.
       * @returns {NodeCreateTransaction}
       */
      setAccountId(accountId) {
          this._requireNotFrozen();
          this._accountId =
              accountId instanceof AccountId
                  ? accountId
                  : AccountId.fromString(accountId);

          return this;
      }

      /**
       * @description Get node account identifier.
       * @returns {?AccountId}
       */
      get accountId() {
          return this._accountId;
      }

      /**
       * @param {string} description
       * @description Set description of the node.
       * @returns {NodeCreateTransaction}
       */
      setDescription(description) {
          this._requireNotFrozen();
          if (description.length > DESCRIPTION_MAX_LENGTH$1) {
              throw new Error(
                  `Description must be at most ${DESCRIPTION_MAX_LENGTH$1} characters.`,
              );
          }
          this._description = description;

          return this;
      }

      /**
       * @description Get description of the node.
       * @returns {?string}
       */
      get description() {
          return this._description;
      }

      /**
       * @param {ServiceEndpoint[]} gossipEndpoints
       * @description Set list of service endpoints for gossip.
       * @returns {NodeCreateTransaction}
       */
      setGossipEndpoints(gossipEndpoints) {
          this._requireNotFrozen();
          if (gossipEndpoints.length == 0) {
              throw new Error("GossipEndpoints list must not be empty.");
          }

          if (gossipEndpoints.length > GOSSIP_ENDPOINTS_MAX_LENGTH$1) {
              throw new Error(
                  `GossipEndpoints list must not contain more than ${GOSSIP_ENDPOINTS_MAX_LENGTH$1} entries.`,
              );
          }

          this._gossipEndpoints = [...gossipEndpoints];

          return this;
      }

      /**
       * @description Get list of service endpoints for gossip.
       * @returns {?Array<ServiceEndpoint>}
       */
      get gossipEndpoints() {
          return this._gossipEndpoints;
      }

      /**
       * @param {ServiceEndpoint} endpoint
       * @description Add an endpoint to the list of service endpoints for gossip.
       * @returns {NodeCreateTransaction}
       */
      addGossipEndpoint(endpoint) {
          if (this._gossipEndpoints != null) {
              this._gossipEndpoints.push(endpoint);
          }
          return this;
      }

      /**
       * @param {ServiceEndpoint[]} serviceEndpoints
       * @description Set list of service endpoints for gRPC calls.
       * @returns {NodeCreateTransaction}
       */
      setServiceEndpoints(serviceEndpoints) {
          this._requireNotFrozen();
          if (serviceEndpoints.length == 0) {
              throw new Error("ServiceEndpoints list must not be empty.");
          }

          if (serviceEndpoints.length > SERVICE_ENDPOINTS_MAX_LENGTH$1) {
              throw new Error(
                  `ServiceEndpoints list must not contain more than ${SERVICE_ENDPOINTS_MAX_LENGTH$1} entries.`,
              );
          }

          this._serviceEndpoints = [...serviceEndpoints];

          return this;
      }

      /**
       * @description Get list of service endpoints for gRPC calls.
       * @returns {?Array<ServiceEndpoint>}
       */
      get serviceEndpoints() {
          return this._serviceEndpoints;
      }

      /**
       * @param {ServiceEndpoint} endpoint
       * @description Add an endpoint to the list of service endpoints for gRPC calls.
       * @returns {NodeCreateTransaction}
       */
      addServiceEndpoint(endpoint) {
          if (this._serviceEndpoints != null) {
              this._serviceEndpoints.push(endpoint);
          }
          return this;
      }

      /**
       * @param {Uint8Array} bytes
       * @description Set certificate used to sign gossip events.
       * @returns {NodeCreateTransaction}
       */
      setGossipCaCertificate(bytes) {
          this._requireNotFrozen();
          if (bytes.length == 0) {
              throw new Error("GossipCaCertificate must not be empty.");
          }

          this._gossipCaCertificate = bytes;

          return this;
      }

      /**
       * @description Get certificate used to sign gossip events.
       * @returns {?Uint8Array}
       */
      get gossipCaCertificate() {
          return this._gossipCaCertificate;
      }

      /**
       * @param {Uint8Array} bytes
       * @description Set hash of the node gRPC TLS certificate.
       * @returns {NodeCreateTransaction}
       */
      setCertificateHash(bytes) {
          this._requireNotFrozen();
          this._grpcCertificateHash = bytes;

          return this;
      }

      /**
       * @description Get hash of the node gRPC TLS certificate.
       * @returns {?Uint8Array}
       */
      get certificateHash() {
          return this._grpcCertificateHash;
      }

      /**
       * @param {ServiceEndpoint} endpoint
       * @description Set proxy endpoint for gRPC web calls.
       * @returns {NodeCreateTransaction}
       */
      setGrpcWebProxyEndpoint(endpoint) {
          this._requireNotFrozen();
          this._grpcWebProxyEndpoint = endpoint;
          return this;
      }

      /**
       * @description Get proxy endpoint for gRPC web calls.
       * @returns {?ServiceEndpoint}
       */
      get grpcWebProxyEndpoint() {
          return this._grpcWebProxyEndpoint;
      }

      /**
       * @param {Key} adminKey
       * @description Set administrative key controlled by the node operator.
       * @returns {NodeCreateTransaction}
       */
      setAdminKey(adminKey) {
          this._requireNotFrozen();
          this._adminKey = adminKey;

          return this;
      }

      /**
       * @description Get administrative key controlled by the node operator.
       * @returns {?Key}
       */
      get adminKey() {
          return this._adminKey;
      }

      /**
       * @param {boolean} declineReward
       * @description Set whether the node declines rewards.
       * @returns {NodeCreateTransaction}
       */
      setDeclineReward(declineReward) {
          this._requireNotFrozen();
          this._declineReward = declineReward;
          return this;
      }

      /**
       * @description Get whether the node declines rewards.
       * @returns {?boolean}
       */
      get declineReward() {
          return this._declineReward;
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {ITransaction} request
       * @returns {Promise<ITransactionResponse>}
       */
      _execute(channel, request) {
          return channel.addressBook.createNode(request);
      }

      /**
       * @override
       * @protected
       * @returns {NonNullable<TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "nodeCreate";
      }

      /**
       * @override
       * @protected
       * @returns {INodeCreateTransactionBody}
       */
      _makeTransactionData() {
          return {
              accountId:
                  this._accountId != null ? this._accountId._toProtobuf() : null,
              description: this._description != null ? this._description : null,
              gossipEndpoint:
                  this._gossipEndpoints != null
                      ? this._gossipEndpoints.map(
                            (/** @type {ServiceEndpoint} */ endpoint) =>
                                endpoint._toProtobuf(),
                        )
                      : null,
              serviceEndpoint:
                  this._serviceEndpoints != null
                      ? this._serviceEndpoints.map(
                            (/** @type {ServiceEndpoint} */ endpoint) =>
                                endpoint._toProtobuf(),
                        )
                      : null,
              gossipCaCertificate:
                  this._gossipCaCertificate != null
                      ? this._gossipCaCertificate
                      : null,
              grpcCertificateHash:
                  this._grpcCertificateHash != null
                      ? this._grpcCertificateHash
                      : null,
              adminKey:
                  this._adminKey != null ? this._adminKey._toProtobufKey() : null,
              declineReward:
                  this._declineReward != null ? this._declineReward : null,
              grpcProxyEndpoint:
                  this._grpcWebProxyEndpoint != null
                      ? this._grpcWebProxyEndpoint._toProtobuf()
                      : null,
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("../Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `NodeCreateTransaction:${timestamp.toString()}`;
      }
  }

  TRANSACTION_REGISTRY.set(
      "nodeCreate",
      // eslint-disable-next-line @typescript-eslint/unbound-method
      NodeCreateTransaction._fromProtobuf,
  );

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITransaction} ITransaction
   * @typedef {import("@hashgraph/proto").proto.ITransaction} ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} ITransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} ITransactionResponse
   */

  /**
   * @namespace com.hedera.hapi.node.addressbook
   * @typedef {import("@hashgraph/proto").com.hedera.hapi.node.addressbook.INodeDeleteTransactionBody} INodeDeleteTransactionBody
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   * @typedef {import("../client/Client.js").default<*, *>} Client
   * @typedef {import("../account/AccountId.js").default} AccountId
   */

  /**
   * A transaction to delete a consensus node in the network.
   */
  class NodeDeleteTransaction extends Transaction {
      /**
       * @param {object} [props]
       * @param {Long} [props.nodeId]
       */
      constructor(props) {
          super();

          /**
           * @private
           * @type {?Long}
           * @description Consensus node identifier in the network state. It's required.
           */
          this._nodeId = props?.nodeId != null ? props.nodeId : null;
      }

      /**
       * @internal
       * @param {ITransaction[]} transactions
       * @param {ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {ITransactionBody[]} bodies
       * @returns {NodeDeleteTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];
          const nodeDelete = /** @type {INodeDeleteTransactionBody} */ (
              body.nodeDelete
          );

          return Transaction._fromProtobufTransactions(
              new NodeDeleteTransaction({
                  nodeId:
                      nodeDelete.nodeId != null ? nodeDelete.nodeId : undefined,
              }),
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * @param {Long} nodeId
       * @description Set consensus node identifier.
       * @returns {NodeDeleteTransaction}
       */
      setNodeId(nodeId) {
          this._requireNotFrozen();

          if (nodeId == null) {
              this._nodeId = null;
              return this;
          }

          // Convert to Long if it's a plain number
          const longNodeId = Long.isLong(nodeId)
              ? nodeId
              : Long.fromValue(nodeId);

          if (longNodeId.toNumber() < 0) {
              throw new Error(
                  "NodeDeleteTransaction: 'nodeId' must be positive.",
              );
          }

          this._nodeId = longNodeId;

          return this;
      }

      /**
       * @description Get consensus node identifier.
       * @returns {?Long}
       */
      get nodeId() {
          return this._nodeId;
      }

      /**
       * @override
       * @param {?import("../client/Client.js").default<Channel, *>} client
       * @returns {this}
       */
      freezeWith(client) {
          if (this.nodeId == null) {
              throw new Error(
                  "NodeDeleteTransaction: 'nodeId' must be explicitly set before calling freeze().",
              );
          }

          return super.freezeWith(client);
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {ITransaction} request
       * @returns {Promise<ITransactionResponse>}
       */
      _execute(channel, request) {
          return channel.addressBook.deleteNode(request);
      }

      /**
       * @override
       * @protected
       * @returns {NonNullable<TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "nodeDelete";
      }

      /**
       * @override
       * @protected
       * @returns {INodeDeleteTransactionBody}
       */
      _makeTransactionData() {
          return {
              nodeId: this._nodeId != null ? this._nodeId : null,
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("../Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `NodeDeleteTransaction:${timestamp.toString()}`;
      }
  }

  TRANSACTION_REGISTRY.set(
      "nodeDelete",
      // eslint-disable-next-line @typescript-eslint/unbound-method
      NodeDeleteTransaction._fromProtobuf,
  );

  // SPDX-License-Identifier: Apache-2.0


  const DESCRIPTION_MAX_LENGTH = 100;
  const GOSSIP_ENDPOINTS_MAX_LENGTH = 10;
  const SERVICE_ENDPOINTS_MAX_LENGTH = 8;

  /**
   * @namespace proto
   * @typedef {import("@hashgraph/proto").proto.ITransaction} ITransaction
   * @typedef {import("@hashgraph/proto").proto.ITransaction} ISignedTransaction
   * @typedef {import("@hashgraph/proto").proto.TransactionBody} TransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionBody} ITransactionBody
   * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} ITransactionResponse
   */

  /**
   * @namespace com.hedera.hapi.node.addressbook
   * @typedef {import("@hashgraph/proto").com.hedera.hapi.node.addressbook.INodeUpdateTransactionBody} INodeUpdateTransactionBody
   */

  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../transaction/TransactionId.js").default} TransactionId
   * @typedef {import("../client/Client.js").default<*, *>} Client
   */

  /**
   * @description A transaction to update a consensus node in the network.
   */
  class NodeUpdateTransaction extends Transaction {
      /**
       * @param {object} [props]
       * @param {Long} [props.nodeId]
       * @param {AccountId} [props.accountId]
       * @param {?string} [props.description]
       * @param {Array<ServiceEndpoint>} [props.gossipEndpoints]
       * @param {?Array<ServiceEndpoint>} [props.serviceEndpoints]
       * @param {?Uint8Array} [props.gossipCaCertificate]
       * @param {?Uint8Array} [props.grpcCertificateHash]
       * @param {ServiceEndpoint} [props.grpcWebProxyEndpoint]
       * @param {Key} [props.adminKey]
       * @param {boolean} [props.declineReward]
       */
      constructor(props) {
          super();

          /**
           * @private
           * @type {?Long}
           * @description A consensus node identifier in the network state. It's required.
           */
          this._nodeId = props?.nodeId != null ? props.nodeId : null;

          /**
           * @private
           * @type {?AccountId}
           * @description Desired new account identifier of the node.
           */
          this._accountId = props?.accountId != null ? props.accountId : null;

          /**
           * @private
           * @type {?string}
           * @description Short description of the node. If set, this value SHALL replace the previous value.
           */
          this._description =
              props?.description != null ? props.description : null;

          /**
           * @private
           * @type {?Array<ServiceEndpoint>}
           * @description List of service endpoints for gossip.
           */
          this._gossipEndpoints =
              props?.gossipEndpoints != null ? props.gossipEndpoints : null;

          /**
           * @private
           * @type {?Array<ServiceEndpoint>}
           * @description List of service endpoints for gRPC calls.
           */
          this._serviceEndpoints =
              props?.serviceEndpoints != null ? props.serviceEndpoints : null;

          /**
           * @private
           * @type {?Uint8Array}
           * @description Certificate used to sign gossip events.
           */
          this._gossipCaCertificate =
              props?.gossipCaCertificate != null
                  ? props.gossipCaCertificate
                  : null;

          /**
           * @private
           * @type {?Uint8Array}
           * @description Hash of the node gRPC TLS certificate.
           */
          this._grpcCertificateHash =
              props?.grpcCertificateHash != null
                  ? props.grpcCertificateHash
                  : null;

          /**
           * @private
           * @type {?ServiceEndpoint}
           * @description Proxy endpoint for gRPC web calls.
           */
          this._grpcWebProxyEndpoint = props?.grpcWebProxyEndpoint || null;

          /**
           * @private
           * @type {?Key}
           * @description Administrative key controlled by the node operator.
           */
          this._adminKey = props?.adminKey != null ? props.adminKey : null;

          /**
           * @private
           * @type {?boolean}
           * @description Whether the node declines rewards.
           */
          this._declineReward =
              props?.declineReward != null ? props.declineReward : null;
      }

      /**
       * @internal
       * @param {ITransaction[]} transactions
       * @param {ISignedTransaction[]} signedTransactions
       * @param {TransactionId[]} transactionIds
       * @param {AccountId[]} nodeIds
       * @param {ITransactionBody[]} bodies
       * @returns {NodeUpdateTransaction}
       */
      static _fromProtobuf(
          transactions,
          signedTransactions,
          transactionIds,
          nodeIds,
          bodies,
      ) {
          const body = bodies[0];
          const nodeUpdate = /** @type {INodeUpdateTransactionBody} */ (
              body.nodeUpdate
          );

          return Transaction._fromProtobufTransactions(
              new NodeUpdateTransaction({
                  nodeId:
                      nodeUpdate.nodeId != null ? nodeUpdate.nodeId : undefined,
                  accountId:
                      nodeUpdate.accountId != null
                          ? AccountId._fromProtobuf(nodeUpdate.accountId)
                          : undefined,
                  description:
                      nodeUpdate.description != null
                          ? Object.hasOwn(nodeUpdate.description, "value")
                              ? nodeUpdate.description.value
                              : undefined
                          : undefined,
                  gossipEndpoints:
                      nodeUpdate.gossipEndpoint != null
                          ? nodeUpdate.gossipEndpoint.map((endpoint) =>
                                ServiceEndpoint._fromProtobuf(endpoint),
                            )
                          : undefined,
                  serviceEndpoints:
                      nodeUpdate.serviceEndpoint != null
                          ? nodeUpdate.serviceEndpoint.map((endpoint) =>
                                ServiceEndpoint._fromProtobuf(endpoint),
                            )
                          : undefined,
                  gossipCaCertificate:
                      nodeUpdate.gossipCaCertificate != null
                          ? Object.hasOwn(nodeUpdate.gossipCaCertificate, "value")
                              ? nodeUpdate.gossipCaCertificate.value
                              : undefined
                          : undefined,
                  grpcCertificateHash:
                      nodeUpdate.grpcCertificateHash != null
                          ? Object.hasOwn(nodeUpdate.grpcCertificateHash, "value")
                              ? nodeUpdate.grpcCertificateHash.value
                              : undefined
                          : undefined,
                  grpcWebProxyEndpoint:
                      nodeUpdate.grpcProxyEndpoint != null
                          ? ServiceEndpoint._fromProtobuf(
                                nodeUpdate.grpcProxyEndpoint,
                            )
                          : undefined,
                  adminKey:
                      nodeUpdate.adminKey != null
                          ? Key._fromProtobufKey(nodeUpdate.adminKey)
                          : undefined,
                  declineReward:
                      nodeUpdate.declineReward?.value != null
                          ? nodeUpdate.declineReward.value
                          : undefined,
              }),
              transactions,
              signedTransactions,
              transactionIds,
              nodeIds,
              bodies,
          );
      }

      /**
       * @param {Long} nodeId
       * @description Set consensus node identifier in the network state.
       * @returns {NodeUpdateTransaction}
       */
      setNodeId(nodeId) {
          this._requireNotFrozen();

          if (nodeId == null) {
              this._nodeId = null;
              return this;
          }

          // Convert to Long if it's a plain number
          const longNodeId = Long.isLong(nodeId)
              ? nodeId
              : Long.fromValue(nodeId);

          if (longNodeId.toNumber() < 0) {
              throw new Error(
                  "NodeUpdateTransaction: 'nodeId' must be positive.",
              );
          }

          this._nodeId = longNodeId;

          return this;
      }

      /**
       * @description Get consensus node identifier in the network state.
       * @returns {?Long}
       */
      get nodeId() {
          return this._nodeId;
      }

      /**
       * @param {AccountId | string} accountId
       * @description Set desired new account identifier of the node.
       * @returns {NodeUpdateTransaction}
       */
      setAccountId(accountId) {
          this._requireNotFrozen();
          this._accountId =
              accountId instanceof AccountId
                  ? accountId
                  : AccountId.fromString(accountId);

          return this;
      }

      /**
       * @description Get desired new account identifier of the node.
       * @returns {?AccountId}
       */
      get accountId() {
          return this._accountId;
      }

      /**
       * @param {string} description
       * @description Set description of the node.
       * @returns {NodeUpdateTransaction}
       */
      setDescription(description) {
          this._requireNotFrozen();
          if (description.length > DESCRIPTION_MAX_LENGTH) {
              throw new Error(
                  `Description must be at most ${DESCRIPTION_MAX_LENGTH} characters.`,
              );
          }
          this._description = description;

          return this;
      }

      /**
       * @description Clear description of the node.
       * @returns {void}
       */
      clearDescription() {
          this._description = "";
      }

      /**
       * @description Get description of the node.
       * @returns {?string}
       */
      get description() {
          return this._description;
      }

      /**
       * @param {ServiceEndpoint[]} gossipEndpoints
       * @description Set list of service endpoints for gossip.
       * @returns {NodeUpdateTransaction}
       */
      setGossipEndpoints(gossipEndpoints) {
          this._requireNotFrozen();
          if (gossipEndpoints.length == 0) {
              throw new Error("GossipEndpoints list must not be empty.");
          }

          if (gossipEndpoints.length > GOSSIP_ENDPOINTS_MAX_LENGTH) {
              throw new Error(
                  `GossipEndpoints list must not contain more than ${GOSSIP_ENDPOINTS_MAX_LENGTH} entries.`,
              );
          }

          this._gossipEndpoints = [...gossipEndpoints];

          return this;
      }

      /**
       * @description Get list of service endpoints for gossip.
       * @returns {?Array<ServiceEndpoint>}
       */
      get gossipEndpoints() {
          return this._gossipEndpoints;
      }

      /**
       * @param {ServiceEndpoint} endpoint
       * @description Add an endpoint to the list of service endpoints for gossip.
       * @returns {NodeUpdateTransaction}
       */
      addGossipEndpoint(endpoint) {
          this._requireNotFrozen();
          if (this._gossipEndpoints != null) {
              this._gossipEndpoints.push(endpoint);
          }
          return this;
      }

      /**
       * @param {ServiceEndpoint[]} serviceEndpoints
       * @description Set list of service endpoints for gRPC calls.
       * @returns {NodeUpdateTransaction}
       */
      setServiceEndpoints(serviceEndpoints) {
          this._requireNotFrozen();
          if (serviceEndpoints.length == 0) {
              throw new Error("ServiceEndpoints list must not be empty.");
          }

          if (serviceEndpoints.length > SERVICE_ENDPOINTS_MAX_LENGTH) {
              throw new Error(
                  `ServiceEndpoints list must not contain more than ${SERVICE_ENDPOINTS_MAX_LENGTH} entries.`,
              );
          }

          this._serviceEndpoints = [...serviceEndpoints];

          return this;
      }

      /**
       * @description Get list of service endpoints for gRPC calls.
       * @returns {?Array<ServiceEndpoint>}
       */
      get serviceEndpoints() {
          return this._serviceEndpoints;
      }

      /**
       * @param {ServiceEndpoint} endpoint
       * @description Add an endpoint to the list of service endpoints for gRPC calls.
       * @returns {NodeUpdateTransaction}
       */
      addServiceEndpoint(endpoint) {
          this._requireNotFrozen();
          if (this._serviceEndpoints != null) {
              this._serviceEndpoints.push(endpoint);
          }
          return this;
      }

      /**
       * @param {Uint8Array} bytes
       * @description Set certificate used to sign gossip events.
       * @returns {NodeUpdateTransaction}
       */
      setGossipCaCertificate(bytes) {
          this._requireNotFrozen();
          if (bytes.length == 0) {
              throw new Error("GossipCaCertificate must not be empty.");
          }

          this._gossipCaCertificate = bytes;

          return this;
      }

      /**
       * @description Get certificate used to sign gossip events.
       * @returns {?Uint8Array}
       */
      get gossipCaCertificate() {
          return this._gossipCaCertificate;
      }

      /**
       * @param {Uint8Array} bytes
       * @description Set hash of the node gRPC TLS certificate.
       * @returns {NodeUpdateTransaction}
       */
      setCertificateHash(bytes) {
          this._requireNotFrozen();
          this._grpcCertificateHash = bytes;

          return this;
      }

      /**
       * @description Get hash of the node gRPC TLS certificate.
       * @returns {?Uint8Array}
       */
      get certificateHash() {
          return this._grpcCertificateHash;
      }

      /**
       * @param {ServiceEndpoint} endpoint
       * @description Set proxy endpoint for gRPC web calls.
       * @returns {NodeUpdateTransaction}
       */
      setGrpcWebProxyEndpoint(endpoint) {
          this._requireNotFrozen();
          this._grpcWebProxyEndpoint = endpoint;
          return this;
      }

      /**
       * @description Get proxy endpoint for gRPC web calls.
       * @returns {?ServiceEndpoint}
       */
      get grpcWebProxyEndpoint() {
          return this._grpcWebProxyEndpoint;
      }

      /**
       * @param {Key} adminKey
       * @description Set administrative key controlled by the node operator.
       * @returns {NodeUpdateTransaction}
       */
      setAdminKey(adminKey) {
          this._requireNotFrozen();
          this._adminKey = adminKey;

          return this;
      }

      /**
       * @description Get administrative key controlled by the node operator.
       * @returns {?Key}
       */
      get adminKey() {
          return this._adminKey;
      }

      /**
       * @param {boolean} declineReward
       * @description Set whether the node declines rewards.
       * @returns {NodeUpdateTransaction}
       */
      setDeclineReward(declineReward) {
          this._requireNotFrozen();
          this._declineReward = declineReward;
          return this;
      }

      /**
       * @description Get whether the node declines rewards.
       * @returns {?boolean}
       */
      get declineReward() {
          return this._declineReward;
      }

      /**
       * @description Deletes the gRPC proxy endpoint and sets it to null in the mirror node, effectively removing it from the network state.
       * @returns {NodeUpdateTransaction}
       */
      deleteGrpcWebProxyEndpoint() {
          this._grpcWebProxyEndpoint = new ServiceEndpoint();
          return this;
      }

      /**
       * @override
       * @param {?import("../client/Client.js").default<Channel, *>} client
       * @returns {this}
       */
      freezeWith(client) {
          if (this.nodeId == null) {
              throw new Error(
                  "NodeUpdateTransaction: 'nodeId' must be explicitly set before calling freeze().",
              );
          }

          return super.freezeWith(client);
      }

      /**
       * @override
       * @internal
       * @param {Channel} channel
       * @param {ITransaction} request
       * @returns {Promise<ITransactionResponse>}
       */
      _execute(channel, request) {
          return channel.addressBook.updateNode(request);
      }

      /**
       * @override
       * @protected
       * @returns {NonNullable<TransactionBody["data"]>}
       */
      _getTransactionDataCase() {
          return "nodeUpdate";
      }

      /**
       * @override
       * @protected
       * @returns {INodeUpdateTransactionBody}
       */
      _makeTransactionData() {
          return {
              accountId:
                  this._accountId != null ? this._accountId._toProtobuf() : null,
              description: {
                  value: this._description != null ? this._description : null,
              },
              gossipEndpoint:
                  this._gossipEndpoints != null
                      ? this._gossipEndpoints.map(
                            (/** @type {ServiceEndpoint} */ endpoint) =>
                                endpoint._toProtobuf(),
                        )
                      : null,
              serviceEndpoint:
                  this._serviceEndpoints != null
                      ? this._serviceEndpoints.map(
                            (/** @type {ServiceEndpoint} */ endpoint) =>
                                endpoint._toProtobuf(),
                        )
                      : null,
              gossipCaCertificate:
                  this._gossipCaCertificate != null
                      ? {
                            value: this._gossipCaCertificate,
                        }
                      : null,
              grpcCertificateHash:
                  this._grpcCertificateHash != null
                      ? {
                            value: this._grpcCertificateHash,
                        }
                      : null,
              grpcProxyEndpoint:
                  this._grpcWebProxyEndpoint != null
                      ? this._grpcWebProxyEndpoint._toProtobuf()
                      : null,
              adminKey:
                  this._adminKey != null ? this._adminKey._toProtobufKey() : null,
              nodeId: this._nodeId != null ? this._nodeId : null,
              declineReward:
                  this._declineReward != null
                      ? { value: this._declineReward }
                      : null,
          };
      }

      /**
       * @returns {string}
       */
      _getLogId() {
          const timestamp = /** @type {import("../Timestamp.js").default} */ (
              this._transactionIds.current.validStart
          );
          return `NodeUpdateTransaction:${timestamp.toString()}`;
      }
  }

  TRANSACTION_REGISTRY.set(
      "nodeUpdate",
      // eslint-disable-next-line @typescript-eslint/unbound-method
      NodeUpdateTransaction._fromProtobuf,
  );

  // SPDX-License-Identifier: Apache-2.0

  /**
   * @typedef {import("./account/AccountId.js").default} AccountId
   * @typedef {import("./channel/Channel.js").default} Channel
   * @typedef {import("./channel/MirrorChannel.js").default} MirrorChannel
   * @typedef {import("./address_book/NodeAddress.js").default} NodeAddress
   */

  const HOST_AND_PORT = /^(\S+):(\d+)$/;

  class ManagedNodeAddress {
      /**
       * @param {object} props
       * @param {string} [props.address]
       * @param {string} [props.host]
       * @param {number | null} [props.port]
       */
      constructor(props = {}) {
          if (props.address != null) {
              const hostAndPortResult = HOST_AND_PORT.exec(props.address);

              if (hostAndPortResult == null) {
                  throw new Error(`failed to parse address: ${props.address}`);
              }

              /** @type {string} */
              this._address = /** @type {string} */ (hostAndPortResult[1]);

              /** @type {number | null} */
              this._port =
                  hostAndPortResult[2] != null
                      ? parseInt(/** @type {string }*/ (hostAndPortResult[2]))
                      : null;
          } else if (props.host != null && props.port != null) {
              /** @type {string} */
              this._address = props.host;

              /** @type {number | null} */
              this._port = props.port;
          } else {
              throw new Error(
                  `failed to create a managed node address: ${JSON.stringify(
                    props,
                )}`,
              );
          }

          Object.freeze(this);
      }

      /**
       * @param {string} address
       * @returns {ManagedNodeAddress};
       */
      static fromString(address) {
          return new ManagedNodeAddress({ address });
      }

      toInsecure() {
          let port = this.port === 50212 ? 50211 : this.port;
          return new ManagedNodeAddress({ host: this.address, port });
      }

      toSecure() {
          let port = this.port === 50211 ? 50212 : this.port;
          return new ManagedNodeAddress({ host: this.address, port });
      }

      /**
       * @returns {string}
       */
      get address() {
          return this._address;
      }

      /**
       * @returns {number | null}
       */
      get port() {
          return this._port;
      }

      /**
       * @returns {boolean}
       */
      isTransportSecurity() {
          return this._port == 50212 || this._port == 443;
      }

      /**
       * @returns {string}
       */
      toString() {
          if (this.port == null) {
              return this.address;
          } else {
              return `${this.address}:${this.port}`;
          }
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {import("./account/AccountId.js").default} AccountId
   * @typedef {import("./channel/Channel.js").default} Channel
   * @typedef {import("./channel/MirrorChannel.js").default} MirrorChannel
   * @typedef {import("./address_book/NodeAddress.js").default} NodeAddress
   */

  /**
   * @template {Channel | MirrorChannel} ChannelT
   * @typedef {object} NewNode
   * @property {string | ManagedNodeAddress} address
   * @property {(address: string, cert?: string) => ChannelT} channelInitFunction
   */

  /**
   * @template {Channel | MirrorChannel} ChannelT
   * @typedef {object} CloneNode
   * @property {ManagedNode<ChannelT>} node
   * @property {ManagedNodeAddress} address
   */

  /**
   * @abstract
   * @template {Channel | MirrorChannel} ChannelT
   */
  class ManagedNode {
      /**
       * @param {object} props
       * @param {NewNode<ChannelT>=} [props.newNode]
       * @param {CloneNode<ChannelT>=} [props.cloneNode]
       */
      constructor(props = {}) {
          if (props.newNode != null) {
              this._address =
                  typeof props.newNode.address === "string"
                      ? ManagedNodeAddress.fromString(props.newNode.address)
                      : props.newNode.address;

              /** @type {string=} */
              this._cert = undefined;

              /** @type {ChannelT | null} */
              this._channel = null;

              /** @type {(address: string, cert?: string) => ChannelT} */
              this._channelInitFunction = props.newNode.channelInitFunction;

              this._lastUsed = Date.now();
              this._readmitTime = Date.now();
              this._useCount = 0;
              this._badGrpcStatusCount = 0;
              this._minBackoff = 8000;
              this._maxBackoff = 1000 * 60 * 60;
              this._currentBackoff = this._minBackoff;
          } else if (props.cloneNode != null) {
              /** @type {ManagedNodeAddress} */
              this._address = props.cloneNode.address;

              /** @type {string=} */
              this._cert = props.cloneNode.node._cert;

              /** @type {ChannelT | null} */
              this._channel = props.cloneNode.node._channel;

              /** @type {(address: string, cert?: string) => ChannelT} */
              this._channelInitFunction =
                  props.cloneNode.node._channelInitFunction;

              /** @type {number} */
              this._currentBackoff = props.cloneNode.node._currentBackoff;

              /** @type {number} */
              this._lastUsed = props.cloneNode.node._lastUsed;

              /** @type {number} */
              this._readmitTime = props.cloneNode.node._readmitTime;

              /** @type {number} */
              this._useCount = props.cloneNode.node._useCount;

              /** @type {number} */
              this._badGrpcStatusCount = props.cloneNode.node._badGrpcStatusCount;

              /** @type {number} */
              this._minBackoff = props.cloneNode.node._minBackoff;

              /** @type {number} */
              this._maxBackoff = props.cloneNode.node._minBackoff;
          } else {
              throw new Error(
                  `failed to create ManagedNode: ${JSON.stringify(props)}`,
              );
          }
      }

      /**
       * @abstract
       * @returns {string}
       */
      // eslint-disable-next-line jsdoc/require-returns-check
      getKey() {
          throw new Error("not implemented");
      }

      /**
       * @param {string} ledgerId
       * @returns {this}
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      setCert(ledgerId) {
          return this;
      }

      /**
       * @returns {ManagedNodeAddress}
       */
      get address() {
          return this._address;
      }

      /**
       * @returns {number}
       */
      get attempts() {
          return this._badGrpcStatusCount;
      }

      /**
       * @returns {number}
       */
      get minBackoff() {
          return this._minBackoff;
      }

      /**
       * @param {number} minBackoff
       * @returns {this}
       */
      setMinBackoff(minBackoff) {
          if (this._currentBackoff <= minBackoff) {
              this._currentBackoff = minBackoff;
          }

          this._minBackoff = minBackoff;
          return this;
      }

      /**
       * @returns {number}
       */
      get maxBackoff() {
          return this._maxBackoff;
      }

      /**
       * @param {number} maxBackoff
       * @returns {this}
       */
      setMaxBackoff(maxBackoff) {
          if (this._currentBackoff <= maxBackoff) {
              this._currentBackoff = maxBackoff;
          }

          this._maxBackoff = maxBackoff;
          return this;
      }

      getChannel() {
          this._useCount++;
          this.__lastUsed = Date.now();

          if (this._channel != null) {
              return this._channel;
          }

          this._channel = this._channelInitFunction(
              this.address.toString(),
              this._cert,
          );
          return this._channel;
      }

      /**
       * Determines if this node is healthy by checking if this node hasn't been
       * in use for a the required `_currentBackoff` period. Since this looks at `this._lastUsed`
       * and that value is only set in the `wait()` method, any node that has not
       * returned a bad gRPC status will always be considered healthy.
       *
       * @returns {boolean}
       */
      isHealthy() {
          return this._readmitTime <= Date.now();
      }

      increaseBackoff() {
          this._currentBackoff = Math.min(
              this._currentBackoff * 2,
              this._maxBackoff,
          );
          this._readmitTime = Date.now() + this._currentBackoff;
      }

      decreaseBackoff() {
          this._currentBackoff = Math.max(
              this._currentBackoff / 2,
              this._minBackoff,
          );
      }

      /**
       * @returns {number}
       */
      getRemainingTime() {
          return this._readmitTime - this._lastUsed;
      }

      /**
       * This is only ever called if the node itself is down.
       * A node returning a transaction with a bad status code does not indicate
       * the node is down, and hence this method will not be called.
       *
       * @returns {Promise<void>}
       */
      backoff() {
          return new Promise((resolve) =>
              setTimeout(resolve, this.getRemainingTime()),
          );
      }

      /**
       * @param {ManagedNode<*>} node
       * @returns {number}
       */
      compare(node) {
          let comparison = this.getRemainingTime() - node.getRemainingTime();
          if (comparison != 0) {
              return comparison;
          }

          comparison = this._currentBackoff - node._currentBackoff;
          if (comparison != 0) {
              return comparison;
          }

          comparison = this._badGrpcStatusCount - node._badGrpcStatusCount;
          if (comparison != 0) {
              return comparison;
          }

          comparison = this._useCount - node._useCount;
          if (comparison != 0) {
              return comparison;
          }

          return this._lastUsed - node._lastUsed;
      }

      close() {
          if (this._channel != null) {
              this._channel.close();
          }

          this._channel = null;
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {import("./account/AccountId.js").default} AccountId
   * @typedef {import("./address_book/NodeAddress.js").default} NodeAddress
   * @typedef {import("./channel/Channel.js").default} Channel
   * @typedef {import("./ManagedNodeAddress.js").default} ManagedNodeAddress
   * @typedef {import("./LedgerId.js").default} LedgerId
   */

  /**
   * @typedef {object} NewNode
   * @property {AccountId} accountId
   * @property {string} address
   * @property {(address: string) => Channel} channelInitFunction
   */

  /**
   * @typedef {object} CloneNode
   * @property {Node} node
   * @property {ManagedNodeAddress} address
   */

  /**
   * @augments {ManagedNode<Channel>}
   */
  class Node extends ManagedNode {
      /**
       * @param {object} props
       * @param {NewNode=} [props.newNode]
       * @param {CloneNode=} [props.cloneNode]
       */
      constructor(props = {}) {
          super(props);

          if (props.newNode != null) {
              /** @type {AccountId} */
              this._accountId = props.newNode.accountId;

              /** @type {NodeAddress | null} */
              this._nodeAddress = null;
          } else if (props.cloneNode != null) {
              /** @type {AccountId} */
              this._accountId = props.cloneNode.node._accountId;

              /** @type {NodeAddress | null} */
              this._nodeAddress = props.cloneNode.node._nodeAddress;
          } else {
              throw new Error(`failed to create node: ${JSON.stringify(props)}`);
          }
      }

      /**
       * @returns {string}
       */
      getKey() {
          return this._accountId.toString();
      }

      /**
       * @returns {ManagedNode<Channel>}
       */
      toInsecure() {
          return /** @type {this} */ (
              new Node({
                  cloneNode: { node: this, address: this._address.toInsecure() },
              })
          );
      }

      /**
       * @returns {ManagedNode<Channel>}
       */
      toSecure() {
          return /** @type {this} */ (
              new Node({
                  cloneNode: { node: this, address: this._address.toSecure() },
              })
          );
      }

      /**
       * @returns {AccountId}
       */
      get accountId() {
          return this._accountId;
      }

      /**
       * @returns {NodeAddress | null}
       */
      get nodeAddress() {
          return this._nodeAddress;
      }

      /**
       * @param {NodeAddress} nodeAddress
       * @returns {this}
       */
      setNodeAddress(nodeAddress) {
          this._nodeAddress = nodeAddress;
          return this;
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  const PREVIEWNET_ADDRESS_BOOK = NodeAddressBook._fromProtobuf(
      libExports.proto.NodeAddressBook.decode(
          decode$8(
              "0ad0070a0e33352e3233312e3230382e31343810a388031a05302e302e3322cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303039663166386131323163326664366337366664353038643365343239663063363462636234346338326137303537333535326161646361643037313536396537323139353866356135643039663935383766666166636662653533343161326630313134616361653334366566336339303231336433343336656262323766343335306339393063356338633366386531653336373037626330386434323536303832336533663234653039613033616430393535613530393830313936323964643034623237623235316463653035356633646463623061343164363666303934316230623837636466653334393864343630333861623564663036663632613561646530383539383537336138386338663538363064633134393261366531383634383561396231333235306536643137623830636433396335633831393130396537336361373332646232336566386261613737366563383563653030393162656362326564656662616135656433653564626662643166383835613466613838316166336631343461386135363538353335333364383933393335393230383662326431643336326534356266653166623435363833616261366336343039373961643662343638373731383437323663366562643538623265616538356337636665336662616265663566366363656438353030333462333834373230366332643637386333363138373630323662386433353165303032616635653066666536663562316632393566646332663436396361613264323338316561306234386361393837636332633865363335653862313963653565313732613933373631613864343930613961343531386437323535383830613134643737623762613737343839326239326134306262383133363265333466633664353137386439623330313132393334323035636237376662396132383234323733393435363461383535346561343732383661343766383632333965373563393437383963653938633939383434373832343632393434663631333136376437623530323033303130303031320218033a606666643661646137346133613334613930346265613437363033303836663862656633623662653138616265643434633464343065313266623133306239376264366238353561656335643062393062306238633733353464356633623065340acf070a0d332e3231312e3234382e31373210a388031a05302e302e3322cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303039663166386131323163326664366337366664353038643365343239663063363462636234346338326137303537333535326161646361643037313536396537323139353866356135643039663935383766666166636662653533343161326630313134616361653334366566336339303231336433343336656262323766343335306339393063356338633366386531653336373037626330386434323536303832336533663234653039613033616430393535613530393830313936323964643034623237623235316463653035356633646463623061343164363666303934316230623837636466653334393864343630333861623564663036663632613561646530383539383537336138386338663538363064633134393261366531383634383561396231333235306536643137623830636433396335633831393130396537336361373332646232336566386261613737366563383563653030393162656362326564656662616135656433653564626662643166383835613466613838316166336631343461386135363538353335333364383933393335393230383662326431643336326534356266653166623435363833616261366336343039373961643662343638373731383437323663366562643538623265616538356337636665336662616265663566366363656438353030333462333834373230366332643637386333363138373630323662386433353165303032616635653066666536663562316632393566646332663436396361613264323338316561306234386361393837636332633865363335653862313963653565313732613933373631613864343930613961343531386437323535383830613134643737623762613737343839326239326134306262383133363265333466633664353137386439623330313132393334323035636237376662396132383234323733393435363461383535346561343732383661343766383632333965373563393437383963653938633939383434373832343632393434663631333136376437623530323033303130303031320218033a606666643661646137346133613334613930346265613437363033303836663862656633623662653138616265643434633464343065313266623133306239376264366238353561656335643062393062306238633733353464356633623065340ace070a0c34302e3132312e36342e343810a388031a05302e302e3322cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303039663166386131323163326664366337366664353038643365343239663063363462636234346338326137303537333535326161646361643037313536396537323139353866356135643039663935383766666166636662653533343161326630313134616361653334366566336339303231336433343336656262323766343335306339393063356338633366386531653336373037626330386434323536303832336533663234653039613033616430393535613530393830313936323964643034623237623235316463653035356633646463623061343164363666303934316230623837636466653334393864343630333861623564663036663632613561646530383539383537336138386338663538363064633134393261366531383634383561396231333235306536643137623830636433396335633831393130396537336361373332646232336566386261613737366563383563653030393162656362326564656662616135656433653564626662643166383835613466613838316166336631343461386135363538353335333364383933393335393230383662326431643336326534356266653166623435363833616261366336343039373961643662343638373731383437323663366562643538623265616538356337636665336662616265663566366363656438353030333462333834373230366332643637386333363138373630323662386433353165303032616635653066666536663562316632393566646332663436396361613264323338316561306234386361393837636332633865363335653862313963653565313732613933373631613864343930613961343531386437323535383830613134643737623762613737343839326239326134306262383133363265333466633664353137386439623330313132393334323035636237376662396132383234323733393435363461383535346561343732383661343766383632333965373563393437383963653938633939383434373832343632393434663631333136376437623530323033303130303031320218033a606666643661646137346133613334613930346265613437363033303836663862656633623662653138616265643434633464343065313266623133306239376264366238353561656335643062393062306238633733353464356633623065340ad1070a0d33352e3139392e31352e31373710a388031a05302e302e3422cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633535376166353739666138333530316265383939623238393037373635626664666364353261623433326230313935613166316563643836666330306162366335353039623066646439376564643363623563656135366132393566333132616262353530383331646266393633663435303131386234666363366532326366343637363230306365396363386564666262663535386463363966303234323634616437643364616232336265643231333363323734653639333434383931353564623130383766393033373039303563363431383561363231316463373432666239613639303964383231383639343762323737343633646662336666306163643437656666313265616431663639373265663263313230333739336334356537373537356265346661313130633765343066613864623963363138376431313366343730343031343137393037316162663539626537643262306465383264653432313564633235353036623163396332366534393137343031633939373530366533373765366266303362363838373237653739343066616436396335653064613363643563626432626537373733353061656132643064343765393761343438633834626536636531333464363462656530393835633239313632663463316535363763636139336430366133633162653861626365333562353537666237376634666536373161363664656337393037353664306538383138313635663262616361613839316161653761633734333766633731373562366562366465623734373233373837353162623662663962306531343833663936363865396664626435363034633339623134643965326265646565633834366139383064373034643137316537626134623766636431613330643934356361313266343761333235643933393861613138663937303636303534643464313566633839393465326465626537336539323731643534383638336636316561343466623235303731653335313861373865643365623337653731613036393166323637303230333031303030312801320218043a606630643934616363663664666633373238373463396462643864373939326562333137616635303031636134313936616261323635383039636233643230306261393631613534333863336135656430356338336264663963643131356432320ad1070a0d332e3133332e3231332e31343610a388031a05302e302e3422cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633535376166353739666138333530316265383939623238393037373635626664666364353261623433326230313935613166316563643836666330306162366335353039623066646439376564643363623563656135366132393566333132616262353530383331646266393633663435303131386234666363366532326366343637363230306365396363386564666262663535386463363966303234323634616437643364616232336265643231333363323734653639333434383931353564623130383766393033373039303563363431383561363231316463373432666239613639303964383231383639343762323737343633646662336666306163643437656666313265616431663639373265663263313230333739336334356537373537356265346661313130633765343066613864623963363138376431313366343730343031343137393037316162663539626537643262306465383264653432313564633235353036623163396332366534393137343031633939373530366533373765366266303362363838373237653739343066616436396335653064613363643563626432626537373733353061656132643064343765393761343438633834626536636531333464363462656530393835633239313632663463316535363763636139336430366133633162653861626365333562353537666237376634666536373161363664656337393037353664306538383138313635663262616361613839316161653761633734333766633731373562366562366465623734373233373837353162623662663962306531343833663936363865396664626435363034633339623134643965326265646565633834366139383064373034643137316537626134623766636431613330643934356361313266343761333235643933393861613138663937303636303534643464313566633839393465326465626537336539323731643534383638336636316561343466623235303731653335313861373865643365623337653731613036393166323637303230333031303030312801320218043a606630643934616363663664666633373238373463396462643864373939326562333137616635303031636134313936616261323635383039636233643230306261393631613534333863336135656430356338336264663963643131356432320ad0070a0c34302e37302e31312e32303210a388031a05302e302e3422cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633535376166353739666138333530316265383939623238393037373635626664666364353261623433326230313935613166316563643836666330306162366335353039623066646439376564643363623563656135366132393566333132616262353530383331646266393633663435303131386234666363366532326366343637363230306365396363386564666262663535386463363966303234323634616437643364616232336265643231333363323734653639333434383931353564623130383766393033373039303563363431383561363231316463373432666239613639303964383231383639343762323737343633646662336666306163643437656666313265616431663639373265663263313230333739336334356537373537356265346661313130633765343066613864623963363138376431313366343730343031343137393037316162663539626537643262306465383264653432313564633235353036623163396332366534393137343031633939373530366533373765366266303362363838373237653739343066616436396335653064613363643563626432626537373733353061656132643064343765393761343438633834626536636531333464363462656530393835633239313632663463316535363763636139336430366133633162653861626365333562353537666237376634666536373161363664656337393037353664306538383138313635663262616361613839316161653761633734333766633731373562366562366465623734373233373837353162623662663962306531343833663936363865396664626435363034633339623134643965326265646565633834366139383064373034643137316537626134623766636431613330643934356361313266343761333235643933393861613138663937303636303534643464313566633839393465326465626537336539323731643534383638336636316561343466623235303731653335313861373865643365623337653731613036393166323637303230333031303030312801320218043a606630643934616363663664666633373238373463396462643864373939326562333137616635303031636134313936616261323635383039636233643230306261393631613534333863336135656430356338336264663963643131356432320ad2070a0e33352e3232352e3230312e31393510a388031a05302e302e3522cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030396261343537623733333035663034613931636334366231623936356334653834313735316162633862313431356130626164666431663332633234383233383661323237323565623765633734646561323165353036313764363438656135616333393337343161623031623865666233323132333962386434666462316466626562396533663339616134363538306464303435643138636134346430303263333764646235323763636534646463333262666337333431393637316634636134343634613366326138346663383563373161636630653561383936323664663639613831343734656431363532396638303161386166613937653433356334653034613936346133353735323732383838343365353866306130356366353135336565343530376232633638623364376662353461653661393561393539633837613132663633306539356337623162336333363935653835383636323431373932366437366331363938336661663631323235303338373435393037653963663133643637633261636435303363613435316338353933336163343131386163633237393830316362393638333439393033313435636564323736323964643038393136333137303933353837613737633232303563666135323534336235336333623665613135623834653364326333306331656437353261343633336333366232356239383933656130326164353632656239623738363862336234663437663461323565333536303634393632616337623235653538323934346630306433303739386132363266393231346438633565373464306138333736636332643662613634653138663565346134306166616336323530363264326361323363643238303037303833323164333833343331346630653538343438353932333236373361333265373061653064373131653331303538316263646231346538373133343639346336653039333066343662333762393664343961363435373339343733333165376535303764396535366465356536313436663266303230333031303030312802320218053a606361363738656263626433646338363438663765643033666235396630653231616636373531336561656535313331386536623534396265356163653930366564633166666132366439336135376163656339626537376634306561656564370ad1070a0d35322e31352e3130352e31333010a388031a05302e302e3522cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030396261343537623733333035663034613931636334366231623936356334653834313735316162633862313431356130626164666431663332633234383233383661323237323565623765633734646561323165353036313764363438656135616333393337343161623031623865666233323132333962386434666462316466626562396533663339616134363538306464303435643138636134346430303263333764646235323763636534646463333262666337333431393637316634636134343634613366326138346663383563373161636630653561383936323664663639613831343734656431363532396638303161386166613937653433356334653034613936346133353735323732383838343365353866306130356366353135336565343530376232633638623364376662353461653661393561393539633837613132663633306539356337623162336333363935653835383636323431373932366437366331363938336661663631323235303338373435393037653963663133643637633261636435303363613435316338353933336163343131386163633237393830316362393638333439393033313435636564323736323964643038393136333137303933353837613737633232303563666135323534336235336333623665613135623834653364326333306331656437353261343633336333366232356239383933656130326164353632656239623738363862336234663437663461323565333536303634393632616337623235653538323934346630306433303739386132363266393231346438633565373464306138333736636332643662613634653138663565346134306166616336323530363264326361323363643238303037303833323164333833343331346630653538343438353932333236373361333265373061653064373131653331303538316263646231346538373133343639346336653039333066343662333762393664343961363435373339343733333165376535303764396535366465356536313436663266303230333031303030312802320218053a606361363738656263626433646338363438663765643033666235396630653231616636373531336561656535313331386536623534396265356163653930366564633166666132366439336135376163656339626537376634306561656564370ad1070a0d3130342e34332e3234382e363310a388031a05302e302e3522cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030396261343537623733333035663034613931636334366231623936356334653834313735316162633862313431356130626164666431663332633234383233383661323237323565623765633734646561323165353036313764363438656135616333393337343161623031623865666233323132333962386434666462316466626562396533663339616134363538306464303435643138636134346430303263333764646235323763636534646463333262666337333431393637316634636134343634613366326138346663383563373161636630653561383936323664663639613831343734656431363532396638303161386166613937653433356334653034613936346133353735323732383838343365353866306130356366353135336565343530376232633638623364376662353461653661393561393539633837613132663633306539356337623162336333363935653835383636323431373932366437366331363938336661663631323235303338373435393037653963663133643637633261636435303363613435316338353933336163343131386163633237393830316362393638333439393033313435636564323736323964643038393136333137303933353837613737633232303563666135323534336235336333623665613135623834653364326333306331656437353261343633336333366232356239383933656130326164353632656239623738363862336234663437663461323565333536303634393632616337623235653538323934346630306433303739386132363266393231346438633565373464306138333736636332643662613634653138663565346134306166616336323530363264326361323363643238303037303833323164333833343331346630653538343438353932333236373361333265373061653064373131653331303538316263646231346538373133343639346336653039333066343662333762393664343961363435373339343733333165376535303764396535366465356536313436663266303230333031303030312802320218053a606361363738656263626433646338363438663765643033666235396630653231616636373531336561656535313331386536623534396265356163653930366564633166666132366439336135376163656339626537376634306561656564370ad2070a0e33352e3234372e3130392e31333510a388031a05302e302e3622cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633432636361633566626336393166626265626461383766666431653735626463643839323234393463663434666462636365653439373838353231633337386266373764623039333465633064323138336437633531646236366638363463313161623764653161633363346366646331663039336132643666333765326233346362653463383133316639363833616434323837386338336433353534633634356161313637626366623036346138336463343563356231313538343939663964393235383766666637616263643566323231636438313530353438343133303030666136653536353930383962316466643635373636656137386561656466636136623435343535666438616235393834646265333565353739356432633633356561373937346434336538656165346665626666653439326537303762343862316230666336343831616539653039643339313333303039623764323634303265366535326535653931623262333830643838663062653766623462333033653730323139373835303537616139346365393234633439323665393136353639323836653836623362613635316361326130613633646634663639303766656665333438336439336234636531643464303363373134323131313337356232633263353164346562383339653337616635333062326362643666353064346362333665323739333731373064396364646163306163653263633234623830346230613237333531636638333062373635323565323664666239646266343961303536363234613736383632343934653732363364306437306365626165393532393433653535383432663563616431336663663630613265366463663761316435333366336135626235346563323139313863373665353235626132393134363637353833316531376533366336316665383534393838323864303962373632303135343132623265353237383439626165633163666663373764653463323934633535303831316535393866663234646131356133343536396464303230333031303030312803320218063a603234373166336665383134303638316665393139313364326363303633663036356534343930616536326666356435343861356162653133316432616639366362653361633235626265323433363663613466386630653736636639343566330acf070a0b35342e3234312e33382e3110a388031a05302e302e3622cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633432636361633566626336393166626265626461383766666431653735626463643839323234393463663434666462636365653439373838353231633337386266373764623039333465633064323138336437633531646236366638363463313161623764653161633363346366646331663039336132643666333765326233346362653463383133316639363833616434323837386338336433353534633634356161313637626366623036346138336463343563356231313538343939663964393235383766666637616263643566323231636438313530353438343133303030666136653536353930383962316466643635373636656137386561656466636136623435343535666438616235393834646265333565353739356432633633356561373937346434336538656165346665626666653439326537303762343862316230666336343831616539653039643339313333303039623764323634303265366535326535653931623262333830643838663062653766623462333033653730323139373835303537616139346365393234633439323665393136353639323836653836623362613635316361326130613633646634663639303766656665333438336439336234636531643464303363373134323131313337356232633263353164346562383339653337616635333062326362643666353064346362333665323739333731373064396364646163306163653263633234623830346230613237333531636638333062373635323565323664666239646266343961303536363234613736383632343934653732363364306437306365626165393532393433653535383432663563616431336663663630613265366463663761316435333366336135626235346563323139313863373665353235626132393134363637353833316531376533366336316665383534393838323864303962373632303135343132623265353237383439626165633163666663373764653463323934633535303831316535393866663234646131356133343536396464303230333031303030312803320218063a603234373166336665383134303638316665393139313364326363303633663036356534343930616536326666356435343861356162653133316432616639366362653361633235626265323433363663613466386630653736636639343566330acf070a0b31332e38382e32322e343710a388031a05302e302e3622cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633432636361633566626336393166626265626461383766666431653735626463643839323234393463663434666462636365653439373838353231633337386266373764623039333465633064323138336437633531646236366638363463313161623764653161633363346366646331663039336132643666333765326233346362653463383133316639363833616434323837386338336433353534633634356161313637626366623036346138336463343563356231313538343939663964393235383766666637616263643566323231636438313530353438343133303030666136653536353930383962316466643635373636656137386561656466636136623435343535666438616235393834646265333565353739356432633633356561373937346434336538656165346665626666653439326537303762343862316230666336343831616539653039643339313333303039623764323634303265366535326535653931623262333830643838663062653766623462333033653730323139373835303537616139346365393234633439323665393136353639323836653836623362613635316361326130613633646634663639303766656665333438336439336234636531643464303363373134323131313337356232633263353164346562383339653337616635333062326362643666353064346362333665323739333731373064396364646163306163653263633234623830346230613237333531636638333062373635323565323664666239646266343961303536363234613736383632343934653732363364306437306365626165393532393433653535383432663563616431336663663630613265366463663761316435333366336135626235346563323139313863373665353235626132393134363637353833316531376533366336316665383534393838323864303962373632303135343132623265353237383439626165633163666663373764653463323934633535303831316535393866663234646131356133343536396464303230333031303030312803320218063a603234373166336665383134303638316665393139313364326363303633663036356534343930616536326666356435343861356162653133316432616639366362653361633235626265323433363663613466386630653736636639343566330ad0070a0c33352e3233352e36352e353110a388031a05302e302e3722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393032663034393061396237663564326364316330643936633661363939306635373362356630656235626462626133393636316566303233303932343139333434363639393639613638613463373037316433323939393066623137393265393030316362353539386561373163326436363736383234333230656534636162663164643335376165376632616462656463316231623061396439353632333737396234633463376234376334373837613136656537313838633732313731373736323461393236346162333963343166376666306234356138396264613430633461643037633464353936643566303964373035366263623561333566343466393561353963323636653039383932646362653436616435316632643262336539393161386636363538653166326362393463373733656234346334346538393264316535356331303736663136303833313965653635376534306631393239363735343361623432616232323233383664313735383665323533373438646162643032356535306235306165363035303732306532333964363465653666623435303763303631346464346265376166646231333330383930666633613665313736353237633331313661663132396139616335653333366439663630316537313237613664376438323061643266393032646163396232343836363861316261623038643130333432656136396137303937313332666637313230636336346663646537383430633635366261313733326261393565396333363735313137356534656333643834613765306432383834326234316262626264366632386534366333613636333365313832373936356335353832306435306461653262303436356363306434326531393562396431353332653632323565623939386436613439303739613861316364346430313735646533633837663937363134383437623363626231376161333462653832306237623361643938616333666165663939336136373738393734373832633063346165336661626263633433303230333031303030312804320218073a606633353738373364343131346131616566303361646336626136396566616632363930653232376162633136613666633665353034396136336662643936383830303462313465343633633230653338343336613361323464333138326464380ad1070a0d35342e3137372e35312e31323710a388031a05302e302e3722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393032663034393061396237663564326364316330643936633661363939306635373362356630656235626462626133393636316566303233303932343139333434363639393639613638613463373037316433323939393066623137393265393030316362353539386561373163326436363736383234333230656534636162663164643335376165376632616462656463316231623061396439353632333737396234633463376234376334373837613136656537313838633732313731373736323461393236346162333963343166376666306234356138396264613430633461643037633464353936643566303964373035366263623561333566343466393561353963323636653039383932646362653436616435316632643262336539393161386636363538653166326362393463373733656234346334346538393264316535356331303736663136303833313965653635376534306631393239363735343361623432616232323233383664313735383665323533373438646162643032356535306235306165363035303732306532333964363465653666623435303763303631346464346265376166646231333330383930666633613665313736353237633331313661663132396139616335653333366439663630316537313237613664376438323061643266393032646163396232343836363861316261623038643130333432656136396137303937313332666637313230636336346663646537383430633635366261313733326261393565396333363735313137356534656333643834613765306432383834326234316262626264366632386534366333613636333365313832373936356335353832306435306461653262303436356363306434326531393562396431353332653632323565623939386436613439303739613861316364346430313735646533633837663937363134383437623363626231376161333462653832306237623361643938616333666165663939336136373738393734373832633063346165336661626263633433303230333031303030312804320218073a606633353738373364343131346131616566303361646336626136396566616632363930653232376162633136613666633665353034396136336662643936383830303462313465343633633230653338343336613361323464333138326464380ad0070a0c31332e36342e3137302e343010a388031a05302e302e3722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393032663034393061396237663564326364316330643936633661363939306635373362356630656235626462626133393636316566303233303932343139333434363639393639613638613463373037316433323939393066623137393265393030316362353539386561373163326436363736383234333230656534636162663164643335376165376632616462656463316231623061396439353632333737396234633463376234376334373837613136656537313838633732313731373736323461393236346162333963343166376666306234356138396264613430633461643037633464353936643566303964373035366263623561333566343466393561353963323636653039383932646362653436616435316632643262336539393161386636363538653166326362393463373733656234346334346538393264316535356331303736663136303833313965653635376534306631393239363735343361623432616232323233383664313735383665323533373438646162643032356535306235306165363035303732306532333964363465653666623435303763303631346464346265376166646231333330383930666633613665313736353237633331313661663132396139616335653333366439663630316537313237613664376438323061643266393032646163396232343836363861316261623038643130333432656136396137303937313332666637313230636336346663646537383430633635366261313733326261393565396333363735313137356534656333643834613765306432383834326234316262626264366632386534366333613636333365313832373936356335353832306435306461653262303436356363306434326531393562396431353332653632323565623939386436613439303739613861316364346430313735646533633837663937363134383437623363626231376161333462653832306237623361643938616333666165663939336136373738393734373832633063346165336661626263633433303230333031303030312804320218073a606633353738373364343131346131616566303361646336626136396566616632363930653232376162633136613666633665353034396136336662643936383830303462313465343633633230653338343336613361323464333138326464380ad1070a0d33342e3130362e3234372e363510a388031a05302e302e3822cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393164376466666637386634656662653538393034353063356263396533353334626666616461643933666237616662313562633762636636376433643362343133626439393934306464383235363461646130346162326534656466306131633062386662376531613830393265393133386539363062653263633638623562393766353764323831633538373265393761343739666338343833363331363065333836336235376233336534383639623138356163653565333662643433616535666136373863396562363666316634303134373836383236623266386661376530303630663434303563306138663964613732303566663436383361323433666130663331356631616662623461346431343064303232333465343437336662393266636233386633656232386336306366376362666236346530363963313830383665346464363139333839323061653066643763313933653665313034653635623831376564393339386532333232333766646630383332326339636563303964343039393237326137633031356432326234646363393639663665613166353138393032313035646636303039326235356134316234663332623935376235376438346535623232333930356538363938393531373333656139663265323436316563306436353232656538313664353835306661636665623431326366663962393939343361383764633064303436343437636539336239376531366437336239366234323633393632663831666366393435386535373537376337383061366631363135616137613132333236373338653236396262373331663839653839313632326535373765613534343230626630636134366265366663346637316366323638316163303235326161383835653133626536373263643238343539303432376463643133376366333131363235653862656533623038666463616166343635623338376365376362333338313666326331346136623939616337643733343331386366633539623765643933396261666566383739303230333031303030312805320218083a603439333161373832303264353566313062333135373537383563336634333964623638313962643131303033646637626332636539326532396135313762376332313838306465623463303137393537343462353736636434336238343938640ad0070a0c33352e38332e38392e31373110a388031a05302e302e3822cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393164376466666637386634656662653538393034353063356263396533353334626666616461643933666237616662313562633762636636376433643362343133626439393934306464383235363461646130346162326534656466306131633062386662376531613830393265393133386539363062653263633638623562393766353764323831633538373265393761343739666338343833363331363065333836336235376233336534383639623138356163653565333662643433616535666136373863396562363666316634303134373836383236623266386661376530303630663434303563306138663964613732303566663436383361323433666130663331356631616662623461346431343064303232333465343437336662393266636233386633656232386336306366376362666236346530363963313830383665346464363139333839323061653066643763313933653665313034653635623831376564393339386532333232333766646630383332326339636563303964343039393237326137633031356432326234646363393639663665613166353138393032313035646636303039326235356134316234663332623935376235376438346535623232333930356538363938393531373333656139663265323436316563306436353232656538313664353835306661636665623431326366663962393939343361383764633064303436343437636539336239376531366437336239366234323633393632663831666366393435386535373537376337383061366631363135616137613132333236373338653236396262373331663839653839313632326535373765613534343230626630636134366265366663346637316366323638316163303235326161383835653133626536373263643238343539303432376463643133376366333131363235653862656533623038666463616166343635623338376365376362333338313666326331346136623939616337643733343331386366633539623765643933396261666566383739303230333031303030312805320218083a603439333161373832303264353566313062333135373537383563336634333964623638313962643131303033646637626332636539326532396135313762376332313838306465623463303137393537343462353736636434336238343938640ad1070a0d31332e37382e3233322e31393210a388031a05302e302e3822cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393164376466666637386634656662653538393034353063356263396533353334626666616461643933666237616662313562633762636636376433643362343133626439393934306464383235363461646130346162326534656466306131633062386662376531613830393265393133386539363062653263633638623562393766353764323831633538373265393761343739666338343833363331363065333836336235376233336534383639623138356163653565333662643433616535666136373863396562363666316634303134373836383236623266386661376530303630663434303563306138663964613732303566663436383361323433666130663331356631616662623461346431343064303232333465343437336662393266636233386633656232386336306366376362666236346530363963313830383665346464363139333839323061653066643763313933653665313034653635623831376564393339386532333232333766646630383332326339636563303964343039393237326137633031356432326234646363393639663665613166353138393032313035646636303039326235356134316234663332623935376235376438346535623232333930356538363938393531373333656139663265323436316563306436353232656538313664353835306661636665623431326366663962393939343361383764633064303436343437636539336239376531366437336239366234323633393632663831666366393435386535373537376337383061366631363135616137613132333236373338653236396262373331663839653839313632326535373765613534343230626630636134366265366663346637316366323638316163303235326161383835653133626536373263643238343539303432376463643133376366333131363235653862656533623038666463616166343635623338376365376362333338313666326331346136623939616337643733343331386366633539623765643933396261666566383739303230333031303030312805320218083a603439333161373832303264353566313062333135373537383563336634333964623638313962643131303033646637626332636539326532396135313762376332313838306465623463303137393537343462353736636434336238343938640ad0070a0c33342e3132352e32332e343910a388031a05302e302e3922cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633665313863386662663463643465623130343534326362323061616161323532643935663035326631303836643538316334346164373337626636363736633063336637383961663532363562386166623739623530393132646138346530616663663735343763623166666630386430353237303137656236646335636466383362353139363964343433333661363338376364373062393462663463396261663230323938343065356634663836336437303831663066613831653038363361646564623862383961356461633262623535326436653762396662613232326163323863353730373535333866633935373939323934326433343166613238373665366235303765396365376564353732653863666461356465666133363466646638643865323338323961346363626234373866313165656533623332616238356530373239353163356439343230313135666261333237303733343934663433623566366265626638343135326533353665376231366261373634623761336235326362323733343634303136336265313436356536643166613463366536663636363834613633356339613535366161373130306462653634356466386634633432336165343561303863623335623462633138373838366532323939623563303231306135666261336239343439663438336566393465643932326531653938633131336265313636623839633733353832323433313335643434323330366162653561373162373730313866663333356436646437393534323639376231363832333862393637323766643133333962356638326133623661353937643937363033376165323530363435366338623334653966626633626333323431303434316334626663386562613538353937323534656665626661613738383039613563383835343732396135626137386563653139666338343037646438383934613662633738343430333764383738636163653663313532633265383965386136346230363861366332333765303939393362653830363839303230333031303030312806320218093a603634653039383631356266343035663765643561343031333434366238396334383863666364366262323561346136373664633737656561313164333364373032363832663061363961383033306538633537373764306534323230333739390acf070a0b35302e31382e31372e393310a388031a05302e302e3922cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633665313863386662663463643465623130343534326362323061616161323532643935663035326631303836643538316334346164373337626636363736633063336637383961663532363562386166623739623530393132646138346530616663663735343763623166666630386430353237303137656236646335636466383362353139363964343433333661363338376364373062393462663463396261663230323938343065356634663836336437303831663066613831653038363361646564623862383961356461633262623535326436653762396662613232326163323863353730373535333866633935373939323934326433343166613238373665366235303765396365376564353732653863666461356465666133363466646638643865323338323961346363626234373866313165656533623332616238356530373239353163356439343230313135666261333237303733343934663433623566366265626638343135326533353665376231366261373634623761336235326362323733343634303136336265313436356536643166613463366536663636363834613633356339613535366161373130306462653634356466386634633432336165343561303863623335623462633138373838366532323939623563303231306135666261336239343439663438336566393465643932326531653938633131336265313636623839633733353832323433313335643434323330366162653561373162373730313866663333356436646437393534323639376231363832333862393637323766643133333962356638326133623661353937643937363033376165323530363435366338623334653966626633626333323431303434316334626663386562613538353937323534656665626661613738383039613563383835343732396135626137386563653139666338343037646438383934613662633738343430333764383738636163653663313532633265383965386136346230363861366332333765303939393362653830363839303230333031303030312806320218093a603634653039383631356266343035663765643561343031333434366238396334383863666364366262323561346136373664633737656561313164333364373032363832663061363961383033306538633537373764306534323230333739390ad1070a0d32302e3135302e3133362e383910a388031a05302e302e3922cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633665313863386662663463643465623130343534326362323061616161323532643935663035326631303836643538316334346164373337626636363736633063336637383961663532363562386166623739623530393132646138346530616663663735343763623166666630386430353237303137656236646335636466383362353139363964343433333661363338376364373062393462663463396261663230323938343065356634663836336437303831663066613831653038363361646564623862383961356461633262623535326436653762396662613232326163323863353730373535333866633935373939323934326433343166613238373665366235303765396365376564353732653863666461356465666133363466646638643865323338323961346363626234373866313165656533623332616238356530373239353163356439343230313135666261333237303733343934663433623566366265626638343135326533353665376231366261373634623761336235326362323733343634303136336265313436356536643166613463366536663636363834613633356339613535366161373130306462653634356466386634633432336165343561303863623335623462633138373838366532323939623563303231306135666261336239343439663438336566393465643932326531653938633131336265313636623839633733353832323433313335643434323330366162653561373162373730313866663333356436646437393534323639376231363832333862393637323766643133333962356638326133623661353937643937363033376165323530363435366338623334653966626633626333323431303434316334626663386562613538353937323534656665626661613738383039613563383835343732396135626137386563653139666338343037646438383934613662633738343430333764383738636163653663313532633265383965386136346230363861366332333765303939393362653830363839303230333031303030312806320218093a60363465303938363135626634303566376564356134303133343436623839633438386366636436626232356134613637366463373765656131316433336437303236383266306136396138303330653863353737376430653432323033373939",
          ),
      ),
  );
  const TESTNET_ADDRESS_BOOK = NodeAddressBook._fromProtobuf(
      libExports.proto.NodeAddressBook.decode(
          decode$8(
              "0a7f0a0c33342e39342e3130362e363110a388031a05302e302e33320218033a606131373165336261383334373637343761656232653261633464306531313563616161623931383230336230646665316364656162343433343338666332383961626338626138613661666638336462356631623333343034366461383863380a80010a0d35302e31382e3133322e32313110a388031a05302e302e33320218033a606131373165336261383334373637343761656232653261633464306531313563616161623931383230336230646665316364656162343433343338666332383961626338626138613661666638336462356631623333343034366461383863380a81010a0e3133382e39312e3134322e32313910a388031a05302e302e33320218033a606131373165336261383334373637343761656232653261633464306531313563616161623931383230336230646665316364656162343433343338666332383961626338626138613661666638336462356631623333343034366461383863380a82010a0d33352e3233372e3131392e353510a388031a05302e302e342801320218043a603734303964656332653439346236323765653439633639623239346265316365616562636133666463616633363738396538386663376435623065656635353631663532623832643335313931613339633266626564363032373236373136360a7f0a0a332e3231322e362e313310a388031a05302e302e342801320218043a603734303964656332653439346236323765653439633639623239346265316365616562636133666463616633363738396538386663376435623065656635353631663532623832643335313931613339633266626564363032373236373136360a82010a0d35322e3136382e37362e32343110a388031a05302e302e342801320218043a603734303964656332653439346236323765653439633639623239346265316365616562636133666463616633363738396538386663376435623065656635353631663532623832643335313931613339633266626564363032373236373136360a82010a0d33352e3234352e32372e31393310a388031a05302e302e352802320218053a603962313431363538346134613338306262383661366337643732303764386165646462633362363365613330353939383235356263653833353162613462356463613532633932383261353461366265643630646536336365303361616132340a80010a0b35322e32302e31382e383610a388031a05302e302e352802320218053a603962313431363538346134613338306262383661366337643732303764386165646462633362363365613330353939383235356263653833353162613462356463613532633932383261353461366265643630646536336365303361616132340a81010a0c34302e37392e38332e31323410a388031a05302e302e352802320218053a603962313431363538346134613338306262383661366337643732303764386165646462633362363365613330353939383235356263653833353162613462356463613532633932383261353461366265643630646536336365303361616132340a82010a0d33342e38332e3131322e31313610a388031a05302e302e362803320218063a603634383636383562346536653063623936333437326330316665393939333166643965346334343838376261383334323361653766656564323264363438343834636638613362633563636361366133373338376266393664333836373238300a81010a0c35342e37302e3139322e333310a388031a05302e302e362803320218063a603634383636383562346536653063623936333437326330316665393939333166643965346334343838376261383334323361653766656564323264363438343834636638613362633563636361366133373338376266393664333836373238300a81010a0c35322e3138332e34352e363510a388031a05302e302e362803320218063a603634383636383562346536653063623936333437326330316665393939333166643965346334343838376261383334323361653766656564323264363438343834636638613362633563636361366133373338376266393664333836373238300a80010a0b33342e39342e3136302e3410a388031a05302e302e372804320218073a603339653930393931356138353238303330313534613663373730393530633762343737376261343031333537633065363138373635343231356363323061616363646438653566663239653963346439356366343130316661363862653435630a83010a0e35342e3137362e3139392e31303910a388031a05302e302e372804320218073a603339653930393931356138353238303330313534613663373730393530633762343737376261343031333537633065363138373635343231356363323061616363646438653566663239653963346439356366343130316661363862653435630a82010a0d31332e36342e3138312e31333610a388031a05302e302e372804320218073a603339653930393931356138353238303330313534613663373730393530633762343737376261343031333537633065363138373635343231356363323061616363646438653566663239653963346439356366343130316661363862653435630a83010a0e33342e3130362e3130322e32313810a388031a05302e302e382805320218083a606134343837346137616131623337373431613037316164616165373866623135326236393664316335386438646566626531643832333034353332613063303139656539366363313964373536383635373864333961316536633331613165650a82010a0d33352e3135352e34392e31343710a388031a05302e302e382805320218083a606134343837346137616131623337373431613037316164616165373866623135326236393664316335386438646566626531643832333034353332613063303139656539366363313964373536383635373864333961316536633331613165650a81010a0c31332e37382e3233382e333210a388031a05302e302e382805320218083a606134343837346137616131623337373431613037316164616165373866623135326236393664316335386438646566626531643832333034353332613063303139656539366363313964373536383635373864333961316536633331613165650a83010a0e33342e3133332e3139372e32333010a388031a05302e302e392806320218093a603639383332613733613336303265386431666265356164353864316332363337613162363732643731656538376166313064623634386562393161666232323832353362316634376535376433643461343466663534376233333934616132320a82010a0d35322e31342e3235322e32303710a388031a05302e302e392806320218093a603639383332613733613336303265386431666265356164353864316332363337613162363732643731656538376166313064623634386562393161666232323832353362316634376535376433643461343466663534376233333934616132320a82010a0d35322e3136352e31372e32333110a388031a05302e302e392806320218093a60363938333261373361333630326538643166626535616435386431633236333761316236373264373165653837616631306462363438656239316166623232383235336231663437653537643364346134346666353437623333393461613232",
          ),
      ),
  );
  const MAINNET_ADDRESS_BOOK = NodeAddressBook._fromProtobuf(
      libExports.proto.NodeAddressBook.decode(
          decode$8(
              "0ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633435363165336332373863643635306538306334313363613434343233633163336331336366313437356636663639373664353937616534333262343961623432303836623739623834313332363035346238623364636635376438666364373962666330353831383363613234636434633163626335373465643131313765326635623762336336336365376230366439623465666366373337353633376234316665366635336338313162396465363134336633613532393537636466393536373735313230623333373033666635373632313430376162393537356263326433356330643434663039383366633165663633613466663532303966303730633932616631303632393536303163393662636564303634656331393031393730313963363831316334633864643830636234663461633731663961643736653761633839343536666266346630313166393061626432643930353336653832333436353166366265663932376533643564386237626634353930353039383362656361336162656632613964393761663334353737326137373430653936393932373562303138656130646632383661646436636539323365663930386662653736326137356632313131363836326462343464336463613164343462346432653864633130363663353030366262356137643935346164323535643462363033323733343735653531316165623438356430363961303637633061623563323435333863393333633036623561366165666139343030356332393135323133653463636461653663393432663632373266396464353238326436623839306631663230656664323339396364363734393234666135373034366163366461333265373339353161373331313365393166633262376666323965343835316238336666333966383362613965633666303863656664626236636262626666616266646661613931643933306637323030646134383133376333393463626431336537303165636463323631366664323162616436383161613466303031303230333031303030312804320218073a603665396138616263646364653665313134396133656265313766643538643839303538333961383664623732623036613365613230616131373666383638623235343838353261653432336437613963366237636666396537313436323961320ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030613163343037373135343330336363373263346662373639326333663934323531626465633132333961316637613839373261626539316133353332336662656361363235613766666165363430366338353564633261663231313039303062306466306536653664623736333634646661316666653835656461353637393336653239383562383536333461333261613532613635393964643663333062653166376136633562386635656563616632363231643861343539363832666364326462616164313536316431316633336663636237663535303061633536386431363564626561616365333238366432383934663634313239643738316436633732666437643539396339653164336166346161343333633233623931306661653463343834313634316636313532366164373837656265613533393837343136376539643361373363633066623135363432396431356563373633613664306630363131356137396239616637383364373762393864383330393661613437343366393734303864396531346263663464646666653435393137363838343762343063623864613763613337353235366432623933356430393566653235326661653831666636653337663834643761393064376535373061346638656633633764373636656564613437326630393230313939303135613839303832353961383733633534353466636262646361643265353238646538353435356234303833633764633461646335613938386530636464666463313539643564373132616264353434616137336563303239303839383134633938613434663236666330363434363539633138336533313834616132373266386431646330626661336530613536303438346362303535626134646262356363333339656338306264313164363432646333613730326538633730336162323139333038346439626436336630646665313261343333633235373665616637383163666164383637656637306264613631373638623262656631346635306336633362386230393666303230333031303030312805320218083a606464336233653763643361323537643832373665343635333533363162303138623730303931663438363635653832303031306538316563303539326236396264346265316662643765636435303964303730313364643034313238343266640ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030623263636163363561643066633736343561383137626661626334383761643765343133313165376133313938623337666238343264383463333935623366363764366264383438663130633666303363323930653866376461613864303031613834343164633335326131393136306133313933653638623832656466313961653637363933613961333364346362383765373839613130373037313535313565613737326361613862383661353639623931633534353038333564396333353466306461636563393766653737303931623435623134373639386237663836303134323264636432323631653932386465346461633963343264636261666466393663303732333362613330323730373666333763393639653865643330623662356438663530333462653764393263353936663862653836316535316663633361323432626639643862653965326139653865306631353565626366663233656666613763643537633130353432383131643830373736633935383535323666646230656161333465653139353564353131313933393066653837336534633034646564643239313635383834623938623436333038373838616537666334643461613461386663396263323637346261333231343933623632343435356164343130633164653731626339356431643931666130663230313431386137393565333039656166323937623639396266323763396661323736336364353963656230323165313662383230306331303630663238313766643833636663373637313833343839343631653335393932393162333830643665393339626161346231393233326136613237326464653635316638303436666463333464623237366137373764366662326265633332353562326363323434623461663536366231303566333063363530366464616530656233646564646366393437626362396336306530303039383466336234613863366334656434626639306263313933326237663934646333616536623336303030386562393032303430663962303230333031303030312802320218053a603561383634313561303861306138323566336232656237353031303135353230326533313234336665343161303333333834653738633138633131653565386632303964343933623062326664343565303662333734663262363964663564370ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030613365333762373663366364356636363232643639323434343464313263363737633339356632623539303266336262393862386138623530353561373037373036636130323863643735303630613264383730326432643862303439343762646366653061386331343161613238343462316530366536363139303031326538623633323661623066613331373937336263376362346432393439663231303861613034633462306339316261613537323866356235363232656337356162663537386131663762343165646532613637656264363963313865353831666466396336303230616330646539636132633331663063363436393030333331316662623563653764623439633738376531613764323761613432356565376238346461376536363933396639633830643065383266636535356530326466633862356337383431386132366161343336353036393837313962616663656366306264343930303061646463666134303537303862646265666262313937343964323264616230303765343464343565613233623130366638383334633135326532353036326434636632346666323533353663376562333732393130353339336662343962616239303461303266306630626234313763643931396433353238393031323865366262666634666163396639306465313138613937346632613664643031653033326137396231373866363066613166636262643032623537303466623436323935633135313930383136333733656464363633356338353639373866316239353033663166373362346230626538616261326564316665656164353939353362663832656664653933613334373161626435356364613362613861363733666262333739393734396662303036643030336630653633663636356333343631643261376232396463386232303462613539613635363638613436616532383738663030643166393439306466396532383066656266343331356561303465616135363861336139666434386336326336336236656364613639303230333031303030312803320218063a606434363430333938303337393230373965636364356134343331316361306463323262353065633839356235366535336431326232396637326463366462613363616665326535623831303466626461303338616635623434376430666231320ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393361323135636334613761373232636165396331336162643633366466393963636565633661663964623436623639666135313637313665663530636532343930613938316530396162303139636132636234363831316235623631396431626431643565653666343661343263373737636264656536343261313438346563646635646464333732393634326333386336643433613838353838373434373566353832343434333636346330346466656439623839303435666230383565323563336566636234383431373333656666376335323963313339653639333530633263643739623263386431393637396137313265346538636166643332363735343162383332623365313061303132353564656636396466316539643362386438656166303331316465363764356531326232366464303164626264396433653432643335643964653237313330326530663166363964383763626337616361396538383637653964343238643363616230363636656234393064356662616233306266663366373835643033663230373261343362623962356535343635366135393263623631656166643561356566323834633763616563363666376634373332356363306434633164323766363631643861373438636135303731633036656631333464666639366634303836363838333636643436386132343738303031376530623536616261376661623433623362376330623737393036666165353438326633323831316332393265366231343435346531346238393438303161383661303363633437373934646430643734353237613732653432346564336166613034383939656362396136336632613961653732626537666139383961646630643635613332633835316439383031666334313034386466333335363466633762333137303765633866623830313430666537623761316661313230626131636236363033323463656666623462636332643962623764653063663534633831396632646433626365616465633963323566356531396463396231303230333031303030312806320218093a603365303261363732306334343636353965383633303564353562666565383230623335653635306665636163633535333039373435356532633465303332636339646564313662316262343464336235393262626163623663326266663165360ab70722cc063330383230316132333030643036303932613836343838366637306430313031303130353030303338323031386630303330383230313861303238323031383130303930323539663465336439663066333934323536353438653963373330386231306237333430336363393039346439376164313531623737303631373062393737326365623634643636326563656639303161386437643135643331396135396338623731303731616363643839356237633933363130646336393736663637633465313732396261383337336162376535326133663363386632363534393164646536396436653039393934373065373434353938313133316264393663333665363836353230336662326562643564353065616461666237323633393664656331643931373438393862346539626530346337346433303466656164643963626433323334633362376633333036633939636230633333396663323539363962343164353861326237636663313833326532323664383163313936333939336532323535613038376431363938633033643432313062643634353830363434643039356361373661613137393465646434306331633837623566383261386533396636303365393731313662613034353738653765383033343634393564373835643465663763663737313462396562366635663965306239613934663462373338383436313962393237346434613935656631353735346138396439376566356331613838623664363933653061383065626435333766633963663063613931643163363264393135646537656438313862393532653634633230303239336565386532383461343136613732613365313266633764343233623135386639623439363630636263323436366662656430666564326532346531303266646539343265623463666439346265633436643364393066633038633339666563626130336530636132343634616536363462393739353135626132396531663730326333666537303262653739333739366438656462313761613438633039323930623032343534396630363131663561653233656437653136343432646637643164616432323836633262623039643535323264643365643639386332663032303330313030303128093202180c3a606339373462623938326338313931336237333236643561336639646363343836313261313566376161643032663230376230663130636432303137613666626666353830336537636139626662343730396162323862366230396435623133660ab70722cc063330383230316132333030643036303932613836343838366637306430313031303130353030303338323031386630303330383230313861303238323031383130303962646438653834666164616133353332666334636530316138613137643463336232333266353061393739306532363236383465646334383233653831356131626435623230656365613762663536653239663662623762383331666233626636656663643134373566306238656435666662306231333835623936643136366236323966303339366138666566356630366534626361323565653461313334306565323633613464396262303230643866343732333036663364383836313338646537613031396530353962643061666339303263636261316132313361653264616136306338613031333735356665306134386530333466356234303233613264616465616138386335343836383335336163376137613364663132623266623634313837373465396231346265366561623863633237623838303132616436313632646137346530656562313631333539303566343337333734646162383538366437353061323662626433616332346165643837386334643533653635313037326338373165393464376163633537356339363733383137333461353366656166346437626136626364643234316363363435386336303837643836333032616132353163303466366435366239633332643764393636323437353065643035353738356430373733663433646330393962323863393232383131343865366338316632393766663964313636653030306163303462333132343138363737356663656637356635656261306331303332626631333064663663643761343632313164306466336530353834643932656136373334396438343930353038656234656638386635346338633364343836646538373139663130666139366665623835636337393630373663613738313331386565326439656439303363613133333630343063353961643931613464326636393865393130386165306564623962316362393561643333623139376666623138626431626138623536636265653261616539353835656365323038613165313462343835363436333032303330313030303128083202180b3a603937303834333033333130373866353638326337663332343464383263336233653238316139313837393537386465656163646363326132656265353431616631383831313561643265383338363565356635643234376234613138633165650ab50722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303039303938383635646566326632616233373663376630663733386331643837613237616330316166643030383632306333356362366562666362623063333330303331393361333838633334366433303233313732373031323139336262373666643330303462383634333132633638396566353231336362623930313130313530396465616239346632366137333265363337393239646134633463623332353137653361646262333831316435306163346337376331666365386236353136303632313566333437303766336537323635353435653538633839343630396532383337366264623737373566653330343339653065313539326664636230633365653163333035373733643037326136623839353765616663653161313162653936356564616666333834333336366362366134346563323561383930313036653632343735363766373662353530666461343832626165633633303764363938656338383834316664363666323366323130653437623861396463626136626134653166613731366462333363383065333038313934393664636235653536303966623665376336313533373962646465643432376539323331623932353463326261663934333630386138366436393861653961336338363339646638383764366636623561373133383564323433333864393131613231326266373166316532616363386231383662393665633865363963383662366430353832313737373661303963396336383935336564623539313635373862356132363362326634363965336230633037656164613731613434376565613766386663316262383037343235353536376237663062643165366166623033353837313863393862343239653234623232393835393666633736636636616633393663613934333464373932366563376433376434623932616635366434356665666638313936303935323234613931366331666665366236363765323535666333616338636363656639323064633034346232353030333133326238373830363734326630323033303130303031320218033a603333373339306438666561313434616663313265383132353461323864616336656138323839333833366163303732656666643835653061373734383538306566323830393636343863356137663864626234636538313437363831353133370ab70722cc063330383230316132333030643036303932613836343838366637306430313031303130353030303338323031386630303330383230313861303238323031383130306335376564623966663237366530323362323830323163623164383763646631393636623639386366343865346561616137633639323037376365656538636362323339613463393231353937653865383966376363303564336633313331353738393736633465333134343035643461346530336137323431306335633039636135323761643561383562393938363337653732613332653166626330643535343662323436356539653830366332646435303965623035306162356662323730363366643932383135623164643236383965323131316361656236663534396539346139663030663038323164346361366336613631313766356135333363393236336266303734613330643563626566353064316338633233383762636139373265646564613039383362356430613662353764636230303230303036383238623430653430373662343837306232346261643834303536656535326235663432326538383430303238633235303036333832643865396336363132323566346637366561373265333430363037653966633666336332303433333037366131636138636231356564303361633839363664303530376263646536383165346530323331656539663837643131316537623438616338663934643264383432623532646637336635373363633534313439363437393763363236393638666661653734313866336236313039623561306630396533323233663461346435653335303964643235303133386636626331376266366365636531373539343433306466313830613338653930616466326166666266616430633662386331623837663137386130363164636662666638623932633931363664383734633166663561663466626364626665386539643039393337306464663630626537343736333364333665653465623563643531663665336333333965313531653431626462356135636532633863393761306134336233636434636330383138383463383739663964326633373438343238633835373366313763393066336362643032303330313030303128073202180a3a603734306166366266373339653838336338386633333434633961306638623330316533396463393831633531363365306465326133666634326239396534323665643765353662363766343231383530333834356466363266343963396662300ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393133316161333638663933343532323966393762363235396363636166666561323365303063643565616430326533663639366331653731346565333933396461643836306533386266393561323937346639656234386539333433663861616334303565613935356430353332336531313762336231633934383133613361663432666538303832633364343362616631626434643833363765393364623030616436393665363237613130333661653533346630313165616435653536663337613666666534346236623965303939343031313932616435363061303334366234316138313030393566356632643766643332643665656236353562613735386336623532366331323933383661663731393763376135336165363033643632323833323235343936316631366430656661383037396137363835363138383862653733333439323231373935366262636166616562623631333563356662623234383464356234613566646630333336616330326532366331363532633162643865616633306461653164366433656230306637623466616238643634373866653864393565623931316466393636613064656134653532326462373662383936363537306563633561663039353136343234663061663566386565363665333836643536353037313339393731363961633337353733626635326664303538646539356162326666363865363831313161623233343035656139363462326262383864303263306631636165643731656364643465346534303835393438373666646238353030626335356337626130323036366530356162393864396637653034363664393730326562353765653337323266386663633835613735353035666633323632313730323838623738383732336164623937653464653536323063633930656164313338326663643735373138383966656662313165363737316263336636663366656231396337616335343238373864303361393032373035323663336565643234393465666635346531353363613966363839303230333031303030312801320218043a603765616236393661623935343336363538626331346666366234626534643932356364353162323230646632613164356336656531363061646166323961353165363934646533656531383463653232656164386437646239333231383266330ab70722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303038326465373330363566333466666332393334306435393439643232323062316534333636656435636637633665626436313663663934313661353365613030313766366262313136626664336633646566636331356237613464646630653434643032666536393536383830353365373961373730653230316263663731393333393030333965653866303836643466613734366337653035363931383330316639623565383465333932363238323830383561373962333232626361306235643835666539373232316132366262646532353863363230663064636561303261623165646431366363343961336632616239323838653364643166333764633462366136663731333366663932653534316337316237306432613266363664353537323561623138626638366430303965633364323466356431326530623565363830326431313531333732643462373634656265636234616638326636343934383565633537623561303164633637393538663561303363636161623763626139333534613137333732633133313662613437633935336161663934393031623366386332346536613361666436373538653766336231343363653264643363623037316232613734633932316365653934396134623561366265383739663163373930613662386436336231393264376565323961393439316664643638396139386330613763336436303332306631623461633264363232396466643934653432663361363034386137366265316562393538633861313837336265386433333861656339666335396162376633373632363738393430326331666435393566313930383735373565306265383237666334633061346662336433393361643734613934396363393836626662363463616264646165353339333566366463353630373464623933643737656133623831366264643662653533343439373237323238393835396666333463653531383630616666623632316431303438376463333834336631663836643534303334613633653438613161306430323033303130303031280a3202180d3a606132656363316232616539386264323862633161303864386633373161306434663734356337363864306337373339363235363265333433623235643833343235656565613765663865613134323935333432623865623738643332656333660ab70722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303039383735356134303862353332316532363330353230303064366437643461326333613535346435653133383461396362356562663437346165383832633633623438366264303864313434646466316139346365396137643632353139363330303661666461616334353838343666313736343031393566653235333961363536393330656661383534663231343865363865633161303863316334396432303063336633303435666537313437663036643533346334626432363231303063623164643339373339643736306438316130626432306638336632353564323530376434636362313130366235333631386336613934343039633838376361653236326434636565396338363233323134376365633134303465306335376262613733313731333065653339363433383838616633643539386564643832623863363165363561653831613465316135366263303664333937313433613938643431636138376433656634333365663061656162363830313139316233653338343830393638663636623665383836363261663435613965323132393934663638623238386562393637626562393834373863323433653231333663316131353931663036316635626330346232316666326261343862323966313834333130383838373362646665393966386135326539343038393731383536653830346465613630326133313137383663393835363532393633633361333737303332396234303966373466646663373436623232613566383431383931323037316334636538343663396234623332306665646636653962363465326362653338346639613832623661616164346232303930373433316466316133336636393230376135363536303062653831303730643038333239303039393538353961343439386435623539333135626365626566656538303765623061336139343266316364663333363764643434343466646232393838366566636464306265346162653961313838383033393533383735656461333364623732393839663736336230323033303130303031280b3202180e3a603139366237623132303739376364623361396430303362393833643537646131303331303662313733306531376636376532633762616161646234333738396166313639366461313031316232353362636263383630333333383566303332380ab70722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303061396462376638626161313236383938666162373839313135613362356438393734346631393765323830343161653039386633653838366336393837313732316531316262306164313166336365393132346161393631643661306463383435663439373635633366616231393935383430323637366635363434363262663238316462613535383837383066303365393035373938653138343236396161613630663761313437323333316532666231646561646438373763383463626362363431636139653563386164366534356263313539636230373966636230643434396364636438643932333963316130343765376234343864613063646361323636313061323566323936643936653734363962363736643461343434353136653761353965383532393361383038366638343063303532383534653032613863623230303264616433353832356265346438336235326661393165386337336666303439373436313438383632373837633131313866393234643331636261633162343466656666323264343336623339373965616466396234336134626661373265313562343735356663616232363065303661323739633362623733626337663136613036306434643532326664343930353830333838616135393564383034343733366535323266363432343931356637383033623735383365303935636466373863333235313936393764653831623839666235303035343735336231613137663961616662303634643834633939326639616231316363626338636231303831346463616635323634616134356632316264656661633832636361636161663335386533313337336565316261346537343032666438613730656130633238636135636337346463343235313063393639636432633435396231656333363838613031656133396139393237313063643232393763393861383462363334386135373738303466646332333464336665313930336532633231653137326461323862353961653665346337653865646438623731633439643730323033303130303031280c3202180f3a603538343661353366343437353239666439636462373830346364333136383865643665656265336236336461326635663231316666626337333731393763663366316366626664613631626537643135313066306539323339383131376637340ab70722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303061386365616333363765623166316465356630643965663365616630646639623938343438666532303830383437363536326130363063353163323839373730623463616366653932636236353536393832336539363263326132633966656435336264333663613361313232646531633532356135383266323561346437643632386331613364356264623839333661656365373531306537353534656537303333303235633039326338323865656235373338626530326564393633646138316135393230353633346365393435343537376162383266343066313366316565353565306165373237653233633330323834623166343462393961636534646463356639616337616438386439666132323535393335623234646362613834303036343265313663663235333263306230643638393239303436303837313563343037366634366438346130653066656433366537366363646339363335356537613236313630393435633262353461653236636330306664303832333236333436656565656137646437356639313931316539396462636239396561346163366261303536633333323238643838316438353833316439636338373935393364613137343664643065653935646332623936666539336261666366663263643764393239353864373864663333663230356437313135656439666163346462366634636336306535366135343431646135623562353566613539393939303265393538613662366334346438313064646335363138313234316238376632326630353961363838306538303231373336643031383937646236353434396365383137613233373564303335353163623064653530376336303961306338303330656366346266646562323133633033646161373634613138323162373234333334663731663736386437616563623237373035326137303333373635663037323138303536633738663261383761663138333836643866363161356366636233663262613464643539393135663133643338363334643136393537353730323033303130303031280d320218103a603030306162636435396133306135333838633530306265363832663663613239343034363239356339323735383831633230643334626230643639306564613762333862366262643037613364643166646662366137303434626230396366660ab70722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303061663062393134323537626637613436353563346135306430636164356530613165343538316564363632336630653837333066373936623866323963353831373862636363363933326331666333316633396566343462383264336334336233393837333733373366656362313239353232386130346664353061313466333634366438346665316634363763616562393864343633653239373565393935623864326531653339663362663661646463323561653335643635643032363038653033343535333739363665326162636534396238313462656164336331623735373137346165333063303062306334336539396238303439366237326433633133316631633665346663646130356632383131376566396532386334333033626534643863376530343264353862383363633132313934356132633635653739363263616139313835393338663337353764663763636139356366303262356533313934346133613631396130616333663165333462396230313364346332323463346631653730666439666433363938336566383661646535313833363263633833323263306637623631613961633735666238326537623836643638626330663039396130396131346361633561316438643338663961386137306363333766663563633362626432373432666664313436323535633137316536613137383038333237316463653066646536383165643439326362353962303739366432373031373538333864633539303831303765336136656133663961343036623364313133306363656333623437393165343962626332333136303362343661623264306639336434336265373561623961346437313065613934306532383561376231353362306361376364646565366439646365306164383335306334316439306332313562393538383531356166613061633333363561653037653831663362626233366264626561633462333162636231616134653832353635623937376639646164383564363236656566396161613965663864376533666230323033303130303031280e320218113a603933653238313031303462326231376230303935326235613431303264333365646230343363623136646533616433643364363832363066353562623065353837333765613539343463333338663763386362383863373833336663383630630ab70722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303038633037626533303561643630623930626132646162333962306565373736306531613232663835373532323534306437306230336233663965343837356133613239616230383038386631343466353765623235326534366261353933383564306536643432373031313764613061626331623362383036393463396135303538623836643631646661303665373136373039633838653866656163376333613065316432356663306165626636613866373666636239396638343566653138313436316361623638353862393763336134303237666233373132623134653663303738396465313764343137363435373765353131343137656231363236393265623037616531653733353532333565396262343339303437623663303136313337383265376464366636303464616134363734363631643533393631663436633366616136623765373637363264333733623562353432623739656139363365666266333361633638313938626232623636316366663637363931366566333732616434633236633231366334626334373837633834656333326431383464373763373531383663303963663364396639313433336361393835333131396261623331666136616432366634353365353936643962646563613638613537363962633866656537613533356438306338633666336566623164666232383861623661393739383534623763653833313234656330643130326166663934633362373466396333373839353863323565623933336464353363316538303561313836353464366439313836393930663635373034323966393630663334653862346637666439393732646362666539323430653037346461326433353561356637656639633161663632656635393832613831373435373862396331356334396563353636626461636233306363666365663039636466653730386164343837343234653963316265363533663965653736363065376439343263316566613564613238366531616464616230366139613333663964653934363739356230323033303130303031280f320218123a603934383235313739643163333934303137306233356432363665346366613830643737386335653966356261653764653833666638636334373431663362653336616336336431653761653439373261656466366263316533636632303638390ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030626531376339393634376365633635613434343037623533353835366233633362616566356235346635363561663538623834353662613863376365353335643561633732633631633434633736623363353763386538363438343136333762653130613833636665333963303932343736643064626534643663646364636437323061333062356266656235316130316131386635383263343566366338363939336663663764663138323933356465316438363930363034346463663335313836393335643962643765656137393532333532626562623465663961653066373636316537306134323337616661393839393636383763613438666366633562303064333830376630353462653066613863336266613432353033386265366566323935313634663232663733623765383863393465613962653861613466336132343563383962396431666435313932663761353062393538623265663831303462333666316266386664326366623238633134323138303063316334376534656639386166313530303730636336643639643137653865623932663138613661613161363532363661343935323338643130336638663639356235376563663337333635306130353230303837343537323162656138313536323739363763383037363336356466386334633761376434646438663263333835306331386662613731656236306536653864666264313936653035333766643730623334346563626363353330646663383364613666656466343964353161393034313935303262613964373063643335663163663363303639346532333534663930363466646266353335656232336332376330613433643062373863316638363763363164393836393564386465663762633261313062623636373463323266363661616230613931383133646466323763646238353263353965663739653162396531613037356661366565323761376533373734646266346232363436353432376536643561623931666537663066336137313738346563613138326235303230333031303030312810320218133a603038393039376465663031623037633764393734613537353532353161366161613061666236623332613534353334336432393138653732626164303433323163313131633234643432373538306633626131653236616139643735653632360ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030613561643262373634336130346330353564326638636432353131623135313339666334353537353632313338386534396331313962326633393861636131313066363133393662306338363664653530363335323262623835343032373365313366366439346365316536303433386636616662303061616136343631326637313435653962636538626331613533623934313931336161373663396633613238333366616437636632383563376163326433376639396633633263646234396465346431353165363136373835363466323831663534313432346234316661376335316232613936303232383363376433326565303065623833386461313563333861666339366530363164393763656465323231363566663161613935396631633432373562326430393863343035383661353537396662623363623930303732373034313230613861363661353237306634666366643130383663393233363930613335653766643434356533336163303366313339633638363835353635373063646334616166323231303761366331613434323435366137633663373965653034303930653765356434663636626361363063613166343762366466623534336461633363626631396137373139613866353562366638336234613362386136366436303235366430613436353531666137303234626430353633316238613535383038373732353463326632663236386364633333643264626263666237333365396662653233336262396362353961623331613031343862323365386334323638306666313061663463373961346430383334366662373961393364393632393534386561663162623132343639386661656661346364643732343432633033613034623733333433326637343839303361333235633238336434353661623961653932316165376564333339316535643137383765666463323335343061376238356336393161653837306130376639306231316331336233326365343365616564313562333639363835636534393137376363393835303230333031303030312811320218143a603939666162633461646534653636326336653238323366346139366562323134343034383465356136643064333132623730633036386432326236323936333830376332333361343964626239383361376562623330653737303637373261340ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030386434356332316330633935656636356130323964353263393537666430663835663230313233646130333465363136373164646565353437356630373338326136366336366362346463353035303464646664333735383130383364663864313735373733306564386436663336346466346333366132363531353931393535646132303161323430376661386162396232333133383131323235613064613233306662653338306530393061613536656661346632303265633962343832336636353031643936616336393865626632366161636633656532643166333261373231633934376531303736636633356233373364613164383761333661313532653030653731303131373932323832653832356666313731633538333362383835373062666336646138343439653666393566386231323635616235353531393430333135353364316435373666393363343263306361363061616261633463386464313632643831313466326232313531313538336337323533396665353663343939613932396465336134306130643435633137633538396332643739383863653236656166633932613364333762376561303034326434336530336166613632373162323632353561366363636661653533373138323164383165306230356332353062353966306139303734316130653065383861303965643536633562393738306430393566303930366630623831643531323633393832616165303131333663303732643834346131316436646134623261363163363434653161623137663136666634386565323366656465383435326631653432653264333061303739306332356434323036306531643434613637316132656232336431313466363863373165333366313736646235386136386234333030353462633164323938336132336133326561366666393566613763346438653338306562323936653938623739363865636638343534643831376337333765656135646439323165623836633136633762323933303461346137656362653561336131303230333031303030312812320218153a606537396165396337313933643164326263393433383436346338616135663632323461653835323936366134336239383235383833663766373432633533393562643330393935383761393638363662393233396431656666336165353037610ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030623035616265326162303066646430366339353565383637313062306530366631613932363234613438616431636263386466633666323231323936326230633330666462643238346133376335613337363538623633633336656138313632353631613865346639343663626535373232633032383830316630663238316337306638643838633763303061326632653239663539376237393938363965643833353664663537633437626539393434613261616666363530663962346262613064626335336463383830666462623639656134353139303564323830323230326638653239633034613736643237616632656237633534383438356266336634363934633930633431383130383838383433373932383438383335663738313637303764336538643736663465363766353738306263663038383133633535656336333961396264363234313738663565623134376435303061663335316539656631623165333432343834636132363064623763636261653438366631336366323635623562316162363838303636303038303533623230633364656463653737316339613038613033323061613963653435316562396439383361376234396361613130393666386164633039383331386463333865306537636566306438653564353537613036373536383561316339653235366132626339646261333232623362623331373263663731343037376263333830663861306134333361386266613766626663353966366230393365633862663665393339376330396231386531383034306331623536363836343733376338666137653239373935663361343538386464613763326261623439353636356363346139623833366532656239306336326133666361663539316662356638313830346337363138306536323666613236343461376465333435313164366334363637643938393337653237373333663464316539313338383333353465353466643733353137323165373666376235366333343833333838663461366238376232386165626562303230333031303030312813320218163a603962343038383566313362366163316337353336393262613366313739303061333838333165363934613061663937343934623834333838323039636235656662646339386136646162623265316337313833393166633133356264616163330ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030396463643863306135336539306333353539353734663636323034313137643362353033653530613336643330393766616338343239653663656364333762623534303731383038663265653938323033356638353161306339626532313736333833613232653338633161626131363866333266393035373063623332333363666536323539383736363661663637623531346361656632316662386466366430666364333363663236303662393264646561353533366236303638643836373832653339626435633338343435393931643431396237643165633038353939343132633039343964316332343062333563313464633535323734646261373166666165393336313235613566383139663534313332653234333964346163353539373939366563653835653133646666333336316639313331663536636561633562396635353262343963663666396139616336653564636532646233363934363266393361663830653562353662366538626566613136326130363162346137363839326264633834363437333036633630303835386664643237303332373663326337303434303139386566643766653335343563663261623538306337346366643634343561616637626437663734356363323532656162643236356561626565383632343137313034653639343861353537353666646332323264663061313031353234646531633363303863636630343330313165633766653936346564643834353161313330313437633037333633613335663131666465656638663261326237363137353762343335386666383962373561343864363762646336303930363933653062623836373965636262393366666462336633656439366265633933656634363536653337313661623837636534366361386531323539633866656464653866326631656130663365623263343865393635353164653132333330333435373235663435656436396338353735623531363833616661343732363231383236646232326262326431633466316533363436346139303230333031303030312814320218173a60346630613033333466393737363738313632663830643936376637323139313431333630633062376637663033316233376336396536323137333933336564616434366263626139373636376565373262666435613933346261313532326330",
          ),
      ),
  );

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../channel/MirrorChannel.js").default} MirrorChannel
   * @typedef {import("../Node.js").default} Node
   * @typedef {import("../MirrorNode.js").default} MirrorNode
   * @typedef {import("../address_book/NodeAddressBook.js").default} NodeAddressBook
   */

  /**
   * @template {Channel | MirrorChannel} ChannelT
   * @typedef {import("../ManagedNode.js").default<ChannelT>} ManagedNode
   */

  /**
   * @template {Channel | MirrorChannel} ChannelT
   * @template {ManagedNode<ChannelT>} NetworkNodeT
   * @template {{ toString: () => string }} KeyT
   */
  class ManagedNetwork {
      /**
       * @param {(address: string) => ChannelT} createNetworkChannel
       */
      constructor(createNetworkChannel) {
          /**
           * Map of node account ID (as a string)
           * to the node URL.
           *
           * @internal
           * @type {Map<string, NetworkNodeT[]>}
           */
          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
          this._network = new Map();

          /**
           * List of node account IDs.
           *
           * @protected
           * @type {NetworkNodeT[]}
           */
          this._nodes = [];

          /**
           * List of node account IDs.
           *
           * @protected
           * @type {NetworkNodeT[]}
           */
          this._healthyNodes = [];

          /** @type {(address: string, cert?: string) => ChannelT} */
          this._createNetworkChannel = createNetworkChannel;

          /** @type {LedgerId | null} */
          this._ledgerId = null;

          this._minBackoff = 8000;
          this._maxBackoff = 1000 * 60 * 60;

          /** @type {number} */
          this._maxNodeAttempts = -1;

          this._nodeMinReadmitPeriod = this._minBackoff;
          this._nodeMaxReadmitPeriod = this._maxBackoff;

          this._earliestReadmitTime = Date.now() + this._nodeMinReadmitPeriod;
      }

      /**
       * @deprecated
       * @param {string} networkName
       * @returns {this}
       */
      setNetworkName(networkName) {
          console.warn("Deprecated: Use `setLedgerId` instead");
          return this.setLedgerId(networkName);
      }

      /**
       * @deprecated
       * @returns {string | null}
       */
      get networkName() {
          console.warn("Deprecated: Use `ledgerId` instead");
          return this.ledgerId != null ? this.ledgerId.toString() : null;
      }

      /**
       * @param {string|LedgerId} ledgerId
       * @returns {this}
       */
      setLedgerId(ledgerId) {
          this._ledgerId =
              typeof ledgerId === "string"
                  ? LedgerId.fromString(ledgerId)
                  : ledgerId;
          return this;
      }

      /**
       * @returns {LedgerId | null}
       */
      get ledgerId() {
          return this._ledgerId != null ? this._ledgerId : null;
      }

      /**
       * @abstract
       * @param {[string, KeyT]} entry
       * @returns {NetworkNodeT}
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _createNodeFromNetworkEntry(entry) {
          throw new Error("not implemented");
      }

      /**
       * @abstract
       * @param {Map<string, KeyT>} network
       * @returns {number[]}
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _getNodesToRemove(network) {
          throw new Error("not implemented");
      }

      _removeDeadNodes() {
          if (this._maxNodeAttempts > 0) {
              for (let i = this._nodes.length - 1; i >= 0; i--) {
                  const node = this._nodes[i];

                  if (node._badGrpcStatusCount < this._maxNodeAttempts) {
                      continue;
                  }

                  this._closeNode(i);
              }
          }
      }

      _readmitNodes() {
          const now = Date.now();

          if (this._earliestReadmitTime <= now) {
              let nextEarliestReadmitTime = Number.MAX_SAFE_INTEGER;
              let searchForNextEarliestReadmitTime = true;

              outer: for (let i = 0; i < this._nodes.length; i++) {
                  for (let j = 0; j < this._healthyNodes.length; j++) {
                      if (
                          searchForNextEarliestReadmitTime &&
                          this._nodes[i]._readmitTime > now
                      ) {
                          nextEarliestReadmitTime = Math.min(
                              this._nodes[i]._readmitTime,
                              nextEarliestReadmitTime,
                          );
                      }

                      if (this._nodes[i] == this._healthyNodes[j]) {
                          continue outer;
                      }
                  }

                  searchForNextEarliestReadmitTime = false;

                  if (this._nodes[i]._readmitTime <= now) {
                      this._healthyNodes.push(this._nodes[i]);
                  }
              }

              this._earliestReadmitTime = Math.min(
                  Math.max(nextEarliestReadmitTime, this._nodeMinReadmitPeriod),
                  this._nodeMaxReadmitPeriod,
              );
          }
      }

      /**
       * @param {number} count
       * @returns {NetworkNodeT[]}
       */
      _getNumberOfMostHealthyNodes(count) {
          this._removeDeadNodes();
          this._readmitNodes();

          const nodes = [];
          // Create a shallow for safe iteration
          let healthyNodes = this._healthyNodes.slice();
          count = Math.min(count, healthyNodes.length);

          for (let i = 0; i < count; i++) {
              // Select a random index
              const nodeIndex = Math.floor(Math.random() * healthyNodes.length);
              const selectedNode = healthyNodes[nodeIndex];

              // Check if the node exists
              if (!selectedNode) {
                  break; // Break out of the loop if undefined node is selected
              }

              // Add the selected node in array for execution
              nodes.push(selectedNode);
              // Remove all nodes with the same account id as
              // the selected node account id from the array
              healthyNodes = healthyNodes.filter(
                  // eslint-disable-next-line ie11/no-loop-func
                  (node) => node.getKey() !== selectedNode.getKey(),
              );
          }

          return nodes;
      }

      /**
       * @param {number} i
       */
      _closeNode(i) {
          const node = this._nodes[i];

          node.close();
          this._removeNodeFromNetwork(node);
          this._nodes.splice(i, 1);
      }

      /**
       * @param {NetworkNodeT} node
       */
      _removeNodeFromNetwork(node) {
          const network = /** @type {NetworkNodeT[]} */ (
              this._network.get(node.getKey())
          );

          for (let j = 0; j < network.length; j++) {
              if (network[j] === node) {
                  network.splice(j, 1);
                  break;
              }
          }

          if (network.length === 0) {
              this._network.delete(node.getKey());
          }
      }

      /**
       * @param {Map<string, KeyT>} network
       * @returns {this}
       */
      _setNetwork(network) {
          /** @type {NetworkNodeT[]} */
          const newNodes = [];
          const newNodeKeys = new Set();
          const newNodeAddresses = new Set();

          /** @type {NetworkNodeT[]} */
          const newHealthyNodes = [];

          /** @type {Map<string, NetworkNodeT[]>} */
          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
          const newNetwork = new Map();

          // Remove nodes that are not in the new network
          for (const i of this._getNodesToRemove(network)) {
              this._closeNode(i);
          }

          // Copy all the unclosed nodes
          for (const node of this._nodes) {
              newNodes.push(node);
              newNodeKeys.add(node.getKey());
              newNodeAddresses.add(node.address.toString());
          }

          // Add new nodes
          for (const [key, value] of network) {
              if (
                  newNodeKeys.has(value.toString()) &&
                  newNodeAddresses.has(key)
              ) {
                  continue;
              }
              newNodes.push(this._createNodeFromNetworkEntry([key, value]));
          }

          // Shuffle the nodes so we don't immediately pick the first nodes
          shuffle(newNodes);

          // Copy all the nodes into the healhty nodes list initially
          // and push the nodes into the network; this maintains the
          // shuffled state from `newNodes`
          for (const node of newNodes) {
              if (!node.isHealthy()) {
                  continue;
              }

              newHealthyNodes.push(node);

              const newNetworkNodes = newNetwork.has(node.getKey())
                  ? /** @type {NetworkNodeT[]} */ (newNetwork.get(node.getKey()))
                  : [];
              newNetworkNodes.push(node);
              newNetwork.set(node.getKey(), newNetworkNodes);
          }

          this._nodes = newNodes;
          this._healthyNodes = newHealthyNodes;
          this._network = newNetwork;

          return this;
      }

      /**
       * @returns {number}
       */
      get maxNodeAttempts() {
          return this._maxNodeAttempts;
      }

      /**
       * @param {number} maxNodeAttempts
       * @returns {this}
       */
      setMaxNodeAttempts(maxNodeAttempts) {
          this._maxNodeAttempts = maxNodeAttempts;
          return this;
      }

      /**
       * @returns {number}
       */
      get minBackoff() {
          return this._minBackoff;
      }

      /**
       * @param {number} minBackoff
       * @returns {this}
       */
      setMinBackoff(minBackoff) {
          this._minBackoff = minBackoff;
          for (const node of this._nodes) {
              node.setMinBackoff(minBackoff);
          }
          return this;
      }

      /**
       * @returns {number}
       */
      get maxBackoff() {
          return this._maxBackoff;
      }

      /**
       * @param {number} maxBackoff
       * @returns {this}
       */
      setMaxBackoff(maxBackoff) {
          this._maxBackoff = maxBackoff;
          for (const node of this._nodes) {
              node.setMaxBackoff(maxBackoff);
          }
          return this;
      }

      /**
       * @returns {number}
       */
      get nodeMinReadmitPeriod() {
          return this._nodeMinReadmitPeriod;
      }

      /**
       * @param {number} nodeMinReadmitPeriod
       * @returns {this}
       */
      setNodeMinReadmitPeriod(nodeMinReadmitPeriod) {
          this._nodeMinReadmitPeriod = nodeMinReadmitPeriod;
          this._earliestReadmitTime = Date.now() + this._nodeMinReadmitPeriod;
          return this;
      }

      /**
       * @returns {number}
       */
      get nodeMaxReadmitPeriod() {
          return this._nodeMaxReadmitPeriod;
      }

      /**
       * @param {number} nodeMaxReadmitPeriod
       * @returns {this}
       */
      setNodeMaxReadmitPeriod(nodeMaxReadmitPeriod) {
          this._nodeMaxReadmitPeriod = nodeMaxReadmitPeriod;
          return this;
      }

      /**
       * @param {KeyT=} key
       * @returns {NetworkNodeT}
       */
      getNode(key) {
          this._readmitNodes();
          if (key != null && key != undefined) {
              const lockedNodes = this._network.get(key.toString());
              if (lockedNodes) {
                  const randomNodeAddress = Math.floor(
                      Math.random() * lockedNodes.length,
                  );
                  return /** @type {NetworkNodeT[]} */ (lockedNodes)[
                      randomNodeAddress
                  ];
              } else {
                  const nodes = Array.from(this._network.keys());
                  const randomNodeAccountId =
                      nodes[Math.floor(Math.random() * nodes.length)];

                  const randomNode = this._network.get(randomNodeAccountId);
                  // We get the `randomNodeAccountId` from the network mapping,
                  // so it cannot be `undefined`
                  const randomNodeAddress = Math.floor(
                      // @ts-ignore
                      Math.random() * randomNode.length,
                  );
                  // @ts-ignore
                  return randomNode[randomNodeAddress];
              }
          } else {
              if (this._healthyNodes.length == 0) {
                  throw new Error("failed to find a healthy working node");
              }

              return this._healthyNodes[
                  Math.floor(Math.random() * this._healthyNodes.length)
              ];
          }
      }

      /**
       * @param {NetworkNodeT} node
       */
      increaseBackoff(node) {
          node.increaseBackoff();

          for (let i = 0; i < this._healthyNodes.length; i++) {
              if (this._healthyNodes[i] == node) {
                  this._healthyNodes.splice(i, 1);
              }
          }
      }

      /**
       * @param {NetworkNodeT} node
       */
      decreaseBackoff(node) {
          node.decreaseBackoff();
      }

      close() {
          for (const node of this._nodes) {
              node.close();
          }

          this._network.clear();
          this._nodes = [];
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../address_book/NodeAddressBook.js").default} NodeAddressBook
   */

  /**
   * @augments {ManagedNetwork<Channel, Node, AccountId>}
   */
  class Network extends ManagedNetwork {
      /**
       * @param {(address: string) => Channel} createNetworkChannel
       */
      constructor(createNetworkChannel) {
          super(createNetworkChannel);

          this._maxNodesPerTransaction = -1;

          /** @type {NodeAddressBook | null} */
          this._addressBook = null;

          /** @type {boolean} */
          this._transportSecurity = false;
      }

      /**
       * @param {{[key: string]: (string | AccountId)}} network
       */
      setNetwork(network) {
          this._setNetwork(
              // eslint-disable-next-line ie11/no-collection-args
              new Map(
                  // eslint-disable-next-line ie11/no-collection-args
                  Object.entries(network).map(([key, value]) => {
                      return [
                          key,
                          typeof value === "string"
                              ? AccountId.fromString(value)
                              : value,
                      ];
                  }),
              ),
          );
      }

      /**
       * @param {NodeAddressBook} addressBook
       * @returns {this}
       */
      setNetworkFromAddressBook(addressBook) {
          /** @type {Record<string, AccountId>} */
          const network = {};
          const port = this.isTransportSecurity() ? 50212 : 50211;

          for (const nodeAddress of addressBook.nodeAddresses) {
              for (const endpoint of nodeAddress.addresses) {
                  // TODO: We hard code ports too much, should fix
                  if (endpoint.port === port && nodeAddress.accountId != null) {
                      network[endpoint.toString()] = nodeAddress.accountId;
                  }
              }
          }

          this.setNetwork(network);
          return this;
      }

      /**
       * @returns {{[key: string]: (string | AccountId)}}
       */
      get network() {
          /**
           * @type {{[key: string]: (string | AccountId)}}
           */
          var n = {};

          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          for (const node of this._nodes) {
              n[node.address.toString()] = node.accountId;
          }

          return n;
      }

      /**
       * @param {string} networkName
       * @returns {this}
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      setNetworkName(networkName) {
          super.setLedgerId(networkName);

          switch (networkName) {
              case "mainnet":
                  this._addressBook = MAINNET_ADDRESS_BOOK;
                  break;
              case "testnet":
                  this._addressBook = TESTNET_ADDRESS_BOOK;
                  break;
              case "previewnet":
                  this._addressBook = PREVIEWNET_ADDRESS_BOOK;
                  break;
          }

          if (this._addressBook != null) {
              for (const node of this._nodes) {
                  for (const address of this._addressBook.nodeAddresses) {
                      if (
                          address.accountId != null &&
                          address.accountId.toString() ===
                              node.accountId.toString()
                      ) {
                          node.setNodeAddress(address);
                      }
                  }
              }
          }

          return this;
      }

      /**
       * @returns {string | null}
       */
      get networkName() {
          return this._ledgerId != null ? this._ledgerId.toString() : null;
      }

      /**
       * @abstract
       * @param {[string, (string | AccountId)]} entry
       * @returns {Node}
       */
      _createNodeFromNetworkEntry(entry) {
          const accountId =
              typeof entry[1] === "string"
                  ? AccountId.fromString(entry[1])
                  : entry[1];

          return new Node({
              newNode: {
                  address: entry[0],
                  accountId,
                  channelInitFunction: this._createNetworkChannel,
              },
          }).setMinBackoff(this._minBackoff);
      }

      /**
       * @abstract
       * @param {Map<string, AccountId>} network
       * @returns {number[]}
       */
      _getNodesToRemove(network) {
          const indexes = [];

          for (let i = this._nodes.length - 1; i >= 0; i--) {
              const node = this._nodes[i];
              const accountId = network.get(node.address.toString());

              if (
                  accountId == null ||
                  accountId.toString() !== node.accountId.toString()
              ) {
                  indexes.push(i);
              }
          }

          return indexes;
      }

      /**
       * @abstract
       * @param {[string, (string | AccountId)]} entry
       * @returns {boolean}
       */
      _checkNetworkContainsEntry(entry) {
          for (const node of this._nodes) {
              if (node.address.toString() === entry[0]) {
                  return true;
              }
          }

          return false;
      }

      /**
       * @returns {number}
       */
      get maxNodesPerTransaction() {
          return this._maxNodesPerTransaction;
      }

      /**
       * @param {number} maxNodesPerTransaction
       * @returns {this}
       */
      setMaxNodesPerTransaction(maxNodesPerTransaction) {
          this._maxNodesPerTransaction = maxNodesPerTransaction;
          return this;
      }

      /**
       * @returns {number}
       */
      get maxNodeAttempts() {
          return this._maxNodeAttempts;
      }

      /**
       * @param {number} maxNodeAttempts
       * @returns {this}
       */
      setMaxNodeAttempts(maxNodeAttempts) {
          this._maxNodeAttempts = maxNodeAttempts;
          return this;
      }

      /**
       * @returns {boolean}
       */
      isTransportSecurity() {
          return this._transportSecurity;
      }

      /**
       * @param {boolean} transportSecurity
       * @returns {this}
       */
      setTransportSecurity(transportSecurity) {
          if (this._transportSecurity == transportSecurity) {
              return this;
          }

          this._network.clear();

          for (let i = 0; i < this._nodes.length; i++) {
              let node = this._nodes[i];
              node.close();

              node = /** @type {Node} */ (
                  transportSecurity
                      ? node
                            .toSecure()
                            .setCert(
                                this._ledgerId != null
                                    ? this._ledgerId.toString()
                                    : "",
                            )
                      : node.toInsecure()
              );
              this._nodes[i] = node;

              const nodes =
                  this._network.get(node.getKey()) != null
                      ? /** @type {Node[]} */ (this._network.get(node.getKey()))
                      : [];
              nodes.push(node);
              this._network.set(node.getKey(), nodes);
          }

          // Overwrite healthy node list since new ports might make the node work again
          this._healthyNodes = [...this._nodes];

          this._transportSecurity = transportSecurity;
          return this;
      }

      /**
       * @internal
       * @returns {number}
       */
      getNumberOfNodesForTransaction() {
          if (this._maxNodesPerTransaction > 0) {
              return this._maxNodesPerTransaction;
          }
          // ultimately it does not matter if we round up or down
          // if we round up, we will eventually take one more healthy node for execution
          // and we would hit the 'nodes.length == count' check in _getNumberOfMostHealthyNodes() less often
          return this._nodes.length <= 9
              ? this._nodes.length
              : Math.floor((this._nodes.length + 3 - 1) / 3);
      }

      /**
       * @internal
       * @returns {AccountId[]}
       */
      getNodeAccountIdsForExecute() {
          return this._getNumberOfMostHealthyNodes(
              this.getNumberOfNodesForTransaction(),
          ).map((node) => node.accountId);
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {import("./channel/MirrorChannel.js").default} MirrorChannel
   * @typedef {import("./ManagedNodeAddress.js").default} ManagedNodeAddress
   */

  /**
   * @typedef {object} NewNode
   * @property {string} address
   * @property {(address: string, cert?: string) => MirrorChannel} channelInitFunction
   */

  /**
   * @typedef {object} CloneNode
   * @property {MirrorNode} node
   * @property {ManagedNodeAddress} address
   */

  /**
   * @augments {ManagedNode<MirrorChannel>}
   */
  class MirrorNode extends ManagedNode {
      /**
       * @param {object} props
       * @param {NewNode=} [props.newNode]
       * @param {CloneNode=} [props.cloneNode]
       */
      constructor(props = {}) {
          super(props);
      }

      /**
       * @returns {string}
       */
      getKey() {
          return this._address.toString();
      }

      /**
       * Gets the base URL for this mirror node's REST API.
       *
       * @returns {string} The base URL for the mirror node REST API
       * @throws {Error} When the mirror node has invalid address configuration
       */
      get mirrorRestApiBaseUrl() {
          const host = this.address.address;
          const port = this.address.port;

          if (!host || !port) {
              throw new Error("Mirror node has invalid address configuration");
          }

          // For localhost/127.0.0.1, mirror node gRPC and REST API use different ports
          // gRPC typically uses port 5600, but REST API uses port 5551
          // Note: Contract calls may use port 8545 (handled separately in MirrorNodeContractQuery)
          if (host === "localhost" || host === "127.0.0.1") {
              return `http://${host}:5551/api/v1`;
          }

          const scheme = this._getSchemeFromHostAndPort(host, port);

          return `${scheme}://${host}:${port}/api/v1`;
      }

      /**
       * Determines the appropriate scheme (http/https) based on the host and port.
       *
       * @private
       * @param {string} host - The host address
       * @param {number} port - The port number
       * @returns {string} - The scheme ('http' or 'https')
       */
      _getSchemeFromHostAndPort(host, port) {
          // For localhost and 127.0.0.1, use HTTP scheme
          if (host === "localhost" || host === "127.0.0.1") {
              return "http";
          }

          // Standard HTTP ports
          if (port === 80) {
              return "http";
          }

          // For other ports, assume HTTPS for security
          return "https";
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {import("../channel/MirrorChannel.js").default} MirrorChannel
   */

  /**
   * @augments {ManagedNetwork<MirrorChannel, MirrorNode, string>}
   */
  let MirrorNetwork$1 = class MirrorNetwork extends ManagedNetwork {
      /**
       * @param {(address: string) => MirrorChannel} channelInitFunction
       */
      constructor(channelInitFunction) {
          super(channelInitFunction);
      }

      /**
       * @param {string[]} network
       */
      setNetwork(network) {
          // eslint-disable-next-line ie11/no-collection-args
          this._setNetwork(new Map(network.map((address) => [address, address])));
      }

      /**
       * @returns {string[]}
       */
      get network() {
          /**
           * @type {string[]}
           */
          var n = [];

          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          for (const node of this._nodes) {
              n.push(node.address.toString());
          }

          return n;
      }

      /**
       * @abstract
       * @param {[string, string]} entry
       * @returns {MirrorNode}
       */
      _createNodeFromNetworkEntry(entry) {
          return new MirrorNode({
              newNode: {
                  address: entry[1],
                  channelInitFunction: this._createNetworkChannel,
              },
          }).setMinBackoff(this._minBackoff);
      }

      /**
       * @abstract
       * @param {Map<string, string>} network
       * @returns {number[]}
       */
      _getNodesToRemove(network) {
          const indexes = [];

          const values = Object.values(network);

          for (let i = this._nodes.length - 1; i >= 0; i--) {
              const node = this._nodes[i];

              if (!values.includes(node.address.toString())) {
                  indexes.push(i);
              }
          }

          return indexes;
      }

      /**
       * @returns {MirrorNode}
       */
      getNextMirrorNode() {
          return this._getNumberOfMostHealthyNodes(1)[0];
      }

      /**
       * Gets the base URL for the mirror node REST API.
       *
       * @returns {string} The base URL for the mirror node REST API
       * @throws {Error} When no mirror network is configured or available
       */
      get mirrorRestApiBaseUrl() {
          try {
              const mirrorNode = this.getNextMirrorNode();
              return mirrorNode.mirrorRestApiBaseUrl;
          } catch (error) {
              // Re-throw with a more descriptive error message
              throw new Error(
                  "Client has no mirror network configured or no healthy mirror nodes are available",
              );
          }
      }
  };

  /* NOSONAR */

  /**
   * Default gRPC deadline in milliseconds (10 seconds)
   *
   * Maximum time allowed for a single gRPC request. If exceeded, the node
   * is marked unhealthy and the SDK rotates to the next node.
   */
  const DEFAULT_GRPC_DEADLINE = 10 * 1000;

  /**
   * Default request timeout in milliseconds (2 minutes)
   *
   * Maximum total time for a complete Transaction/Query operation including
   * retries and node rotation. Must be >= grpcDeadline.
   */
  const DEFAULT_REQUEST_TIMEOUT = 2 * 60 * 1000;

  // MAINNET node proxies are the same for both 'WebClient' and 'NativeClient'
  const MAINNET = {
      "node00.swirldslabs.com:443": new AccountId(3),
      "node01-00-grpc.swirlds.com:443": new AccountId(4),
      "node03.swirldslabs.com:443": new AccountId(6),
      "node04.swirldslabs.com:443": new AccountId(7),
      "node05.swirldslabs.com:443": new AccountId(8),
      "node06.swirldslabs.com:443": new AccountId(9),
      "node07.swirldslabs.com:443": new AccountId(10),
      "node09.swirldslabs.com:443": new AccountId(12),
      "node10.swirldslabs.com:443": new AccountId(13),
      "node11.swirldslabs.com:443": new AccountId(14),
      "node12.swirldslabs.com:443": new AccountId(15),
      "node14.swirldslabs.com:443": new AccountId(17),
      "node15.swirldslabs.com:443": new AccountId(18),
      "node16.swirldslabs.com:443": new AccountId(19),
      "node17.swirldslabs.com:443": new AccountId(20),
      "node18.swirldslabs.com:443": new AccountId(21),
      "node19.swirldslabs.com:443": new AccountId(22),
      "node20.swirldslabs.com:443": new AccountId(23),
      "node21.swirldslabs.com:443": new AccountId(24),
      "node22.swirldslabs.com:443": new AccountId(25),
      "node24.swirldslabs.com:443": new AccountId(27),
      "node25.swirldslabs.com:443": new AccountId(28),
      "node26.swirldslabs.com:443": new AccountId(29),
      "node27.swirldslabs.com:443": new AccountId(30),
      "node28.swirldslabs.com:443": new AccountId(31),
      "node29.swirldslabs.com:443": new AccountId(32),
      "node30.swirldslabs.com:443": new AccountId(33),
      "node31.swirldslabs.com:443": new AccountId(34),
      "node32.swirldslabs.com:443": new AccountId(35),
      "node33.swirldslabs.com:443": new AccountId(36),
      "node34.swirldslabs.com:443": new AccountId(37),
  };

  const WEB_TESTNET = {
      "testnet-node00-00-grpc.hedera.com:443": new AccountId(3),
      "testnet-node01-00-grpc.hedera.com:443": new AccountId(4),
      "testnet-node02-00-grpc.hedera.com:443": new AccountId(5),
      "testnet-node03-00-grpc.hedera.com:443": new AccountId(6),
      "testnet-node04-00-grpc.hedera.com:443": new AccountId(7),
      "testnet-node05-00-grpc.hedera.com:443": new AccountId(8),
      "testnet-node06-00-grpc.hedera.com:443": new AccountId(9),
  };

  const WEB_PREVIEWNET = {
      "previewnet-node00-00-grpc.hedera.com:443": new AccountId(3),
      "previewnet-node01-00-grpc.hedera.com:443": new AccountId(4),
      "previewnet-node02-00-grpc.hedera.com:443": new AccountId(5),
      "previewnet-node03-00-grpc.hedera.com:443": new AccountId(6),
      "previewnet-node04-00-grpc.hedera.com:443": new AccountId(7),
      "previewnet-node05-00-grpc.hedera.com:443": new AccountId(8),
      "previewnet-node06-00-grpc.hedera.com:443": new AccountId(9),
  };

  ({
      "testnet-node00-00-grpc.hedera.com:443": new AccountId(3),
  });

  ({
      "previewnet-node00-00-grpc.hedera.com:443": new AccountId(3),
  });

  ({
      "127.0.0.1:50211": new AccountId(3),
  });

  const LocalNodeWebNetwork = {
      "localhost:8080": new AccountId(3),
  };

  /**
   * @type {Record<string, AccountId>}
   */
  const ALL_WEB_NETWORK_NODES = {
      ...MAINNET,
      ...WEB_TESTNET,
      ...WEB_PREVIEWNET,
  };

  const MirrorNetwork = {
      /**
       * @param {string} name
       * @returns {string[]}
       */
      fromName(name) {
          switch (name) {
              case "mainnet":
                  return MirrorNetwork.MAINNET;

              case "testnet":
                  return MirrorNetwork.TESTNET;

              case "previewnet":
                  return MirrorNetwork.PREVIEWNET;

              case "local-node":
                  return MirrorNetwork.LOCAL_NODE;

              default:
                  throw new Error(`unknown network name: ${name}`);
          }
      },

      MAINNET: ["mainnet-public.mirrornode.hedera.com:443"],
      TESTNET: ["testnet.mirrornode.hedera.com:443"],
      PREVIEWNET: ["previewnet.mirrornode.hedera.com:443"],
      LOCAL_NODE: ["127.0.0.1:5600"],
  };

  const WebMirrorNetwork = {
      ...MirrorNetwork,
      LOCAL_NODE: ["127.0.0.1:5551"],
  };

  const WebNetwork = {
      MAINNET: MAINNET,
      TESTNET: WEB_TESTNET,
      PREVIEWNET: WEB_PREVIEWNET,
      LOCAL_NODE: LocalNodeWebNetwork,
  };

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../channel/MirrorChannel.js").default} MirrorChannel
   * @typedef {import("../channel/MirrorChannel.js").MirrorError} MirrorError
   */

  /**
   * @template {Channel} ChannelT
   * @typedef {import("../client/Client.js").default<ChannelT, MirrorChannel>} Client<ChannelT, MirrorChannel>
   */

  /**
   * @typedef {object} EndpointWebResponse
   * @property {string} domain_name
   * @property {string} ip_address_v4
   * @property {number} port
   */

  /**
   * @typedef {object} AddressBookQueryWebResponse
   * @property {Array<{
   *   admin_key: {
   *     key: string,
   *     _type: string,
   *   },
   *   decline_reward: boolean,
   *   grpc_proxy_endpoint: EndpointWebResponse,
   *   file_id: string,
   *   memo: string,
   *   public_key: string,
   *   node_id: number,
   *   node_account_id: string,
   *   node_cert_hash: string,
   *   address: string,
   *   service_endpoints: EndpointWebResponse[],
   *   description: string,
   *   stake: number
   * }>} nodes
   * @property {?{next: ?string}} links - Links object containing pagination information
   */

  /**
   * Default page size limit for optimal pagination performance
   * @constant {number}
   */
  const DEFAULT_PAGE_SIZE = 25;

  /**
   * Web-compatible query to get a list of Hedera network node addresses from a mirror node.
   * Uses fetch API instead of gRPC for web environments.
   *
   * This query can be used to retrieve node addresses either from a specific file ID
   * or from the most recent address book if no file ID is specified. The response
   * contains node metadata including IP addresses and ports for both node and mirror
   * node services.
   * @augments {Query<NodeAddressBook>}
   */
  class AddressBookQueryWeb extends Query {
      /**
       * @param {object} props
       * @param {FileId | string} [props.fileId]
       * @param {number} [props.limit] - Page size limit (defaults to 25 for optimal performance)
       */
      constructor(props = {}) {
          super();

          /**
           * @private
           * @type {?FileId}
           */
          this._fileId = null;
          if (props.fileId != null) {
              this.setFileId(props.fileId);
          }

          /**
           * Page limit for the query
           * @private
           * @type {?number}
           */
          this._limit = null;
          if (props.limit != null) {
              this.setLimit(props.limit);
          }

          /**
           * @private
           * @type {(error: MirrorError | Error | null) => boolean}
           */
          this._retryHandler = (error) => {
              if (error != null) {
                  if (error instanceof Error) {
                      // Retry on all errors which are not `MirrorError` because they're
                      // likely lower level HTTP errors
                      return true;
                  } else {
                      // Retry on `NOT_FOUND`, `RESOURCE_EXHAUSTED`, `UNAVAILABLE`, and conditionally on `INTERNAL`
                      // if the message matches the right regex.
                      switch (error.code) {
                          // INTERNAL
                          // eslint-disable-next-line no-fallthrough
                          case 13:
                              return RST_STREAM.test(error.details.toString());
                          // NOT_FOUND
                          // eslint-disable-next-line no-fallthrough
                          case 5:
                          // RESOURCE_EXHAUSTED
                          // eslint-disable-next-line no-fallthrough
                          case 8:
                          // UNAVAILABLE
                          // eslint-disable-next-line no-fallthrough
                          case 14:
                          case 17:
                              return true;
                          default:
                              return false;
                      }
                  }
              }

              return false;
          };

          /** @type {NodeAddress[]} */
          this._addresses = [];
      }

      /**
       * @returns {?FileId}
       */
      get fileId() {
          return this._fileId;
      }

      /**
       * @param {FileId | string} fileId
       * @returns {AddressBookQueryWeb}
       */
      setFileId(fileId) {
          this._fileId =
              typeof fileId === "string"
                  ? FileId.fromString(fileId)
                  : fileId.clone();

          return this;
      }

      /**
       * Page limit for the query
       * @returns {?number}
       */
      get limit() {
          return this._limit;
      }

      /**
       * Set the page limit for the query
       * @param {number} limit
       * @returns {AddressBookQueryWeb}
       */
      setLimit(limit) {
          this._limit = limit;

          return this;
      }

      /**
       * @param {number} attempts
       * @returns {this}
       */
      setMaxAttempts(attempts) {
          this._maxAttempts = attempts;
          return this;
      }

      /**
       * @param {number} backoff
       * @returns {this}
       */
      setMaxBackoff(backoff) {
          this._maxBackoff = backoff;
          return this;
      }

      /**
       * @param {Client<Channel>} client
       * @param {number=} requestTimeout
       * @returns {Promise<NodeAddressBook>}
       */
      execute(client, requestTimeout) {
          return new Promise((resolve, reject) => {
              void this._makeFetchRequest(
                  client,
                  resolve,
                  reject,
                  requestTimeout,
              );
          });
      }

      /**
       * @private
       * @param {Client<Channel>} client
       * @param {(value: NodeAddressBook) => void} resolve
       * @param {(error: Error) => void} reject
       * @param {number=} requestTimeout
       */
      async _makeFetchRequest(client, resolve, reject, requestTimeout) {
          const { port, address } =
              client._mirrorNetwork.getNextMirrorNode().address;

          let baseUrl = `${
            address.includes("127.0.0.1") || address.includes("localhost")
                ? "http"
                : "https"
        }://${address}`;

          if (port) {
              baseUrl = `${baseUrl}:${port}`;
          }

          // Initialize aggregated results
          this._addresses = [];
          let nextUrl = null;
          let isLastPage = false;

          // Build initial URL
          const initialUrl = new URL(`${baseUrl}/api/v1/network/nodes`);
          if (this._fileId != null) {
              initialUrl.searchParams.append("file.id", this._fileId.toString());
          }

          // Use the specified limit, or default to DEFAULT_PAGE_SIZE for optimal pagination performance
          const effectiveLimit =
              this._limit != null ? this._limit : DEFAULT_PAGE_SIZE;
          initialUrl.searchParams.append("limit", effectiveLimit.toString());

          // Fetch all pages
          while (!isLastPage) {
              const currentUrl = nextUrl ? new URL(nextUrl, baseUrl) : initialUrl;

              for (let attempt = 0; attempt <= this._maxAttempts; attempt++) {
                  try {
                      // eslint-disable-next-line n/no-unsupported-features/node-builtins
                      const response = await fetch(currentUrl.toString(), {
                          method: "GET",
                          headers: {
                              Accept: "application/json",
                          },
                          signal: requestTimeout
                              ? AbortSignal.timeout(requestTimeout)
                              : undefined,
                      });

                      if (!response.ok) {
                          throw new Error(
                              `HTTP error! status: ${response.status}`,
                          );
                      }

                      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                      const data = /** @type {AddressBookQueryWebResponse} */ (
                          await response.json()
                      );

                      const nodes = data.nodes || [];

                      // Aggregate nodes from this page
                      const pageNodes = nodes.map((node) =>
                          NodeAddress.fromJSON({
                              nodeId: node.node_id.toString(),
                              accountId: node.node_account_id,
                              addresses:
                                  this._handleAddressesFromGrpcProxyEndpoint(
                                      node,
                                      client,
                                  ),
                              certHash: node.node_cert_hash,
                              publicKey: node.public_key,
                              description: node.description,
                              stake: node.stake?.toString(),
                          }),
                      );

                      this._addresses.push(...pageNodes);
                      nextUrl = data.links?.next || null;

                      // If no more pages, set flag to exit loop
                      if (!nextUrl) {
                          isLastPage = true;
                      }

                      // Move to next page
                      break;
                  } catch (error) {
                      console.error("Error in _makeFetchRequest:", error);
                      const message =
                          error instanceof Error ? error.message : String(error);

                      // Check if we should retry
                      if (
                          attempt < this._maxAttempts &&
                          !client.isClientShutDown &&
                          this._retryHandler(
                              /** @type {MirrorError | Error | null} */ (error),
                          )
                      ) {
                          const delay = Math.min(
                              250 * 2 ** attempt,
                              this._maxBackoff,
                          );

                          if (this._logger) {
                              this._logger.debug(
                                  `Error getting nodes from mirror for file ${
                                    this._fileId != null
                                        ? this._fileId.toString()
                                        : "UNKNOWN"
                                } during attempt ${
                                    attempt + 1
                                }. Waiting ${delay} ms before next attempt: ${message}`,
                              );
                          }

                          // Wait before next attempt
                          // eslint-disable-next-line ie11/no-loop-func
                          await new Promise((resolve) =>
                              setTimeout(resolve, delay),
                          );
                          continue;
                      }

                      // If we shouldn't retry or have exhausted attempts, reject
                      const maxAttemptsReached = attempt >= this._maxAttempts;
                      const errorMessage = maxAttemptsReached
                          ? `Failed to query address book after ${
                              this._maxAttempts + 1
                          } attempts. Last error: ${message}`
                          : `Failed to query address book: ${message}`;
                      reject(new Error(errorMessage));
                      return;
                  }
              }
          }

          // Return the aggregated results
          const addressBook = new NodeAddressBook({
              nodeAddresses: this._addresses,
          });
          resolve(addressBook);
      }

      /**
       * Handles the grpc_proxy_endpoint fallback logic for a node.
       * @param {AddressBookQueryWebResponse['nodes'][number]} node - The node object from the mirror node response.
       * @param {Client<Channel>} client - The client instance.
       * @returns {Array<{address: string, port: string}>}
       */
      _handleAddressesFromGrpcProxyEndpoint(node, client) {
          const grpcProxyEndpoint = node.grpc_proxy_endpoint;

          if (
              grpcProxyEndpoint &&
              grpcProxyEndpoint.domain_name &&
              grpcProxyEndpoint.port
          ) {
              return [
                  {
                      address: grpcProxyEndpoint.domain_name,
                      port: grpcProxyEndpoint.port.toString(),
                  },
              ];
          }

          let networkConstant;
          const ledgerId = client._network.ledgerId;

          if (ledgerId && ledgerId.isMainnet()) {
              networkConstant = MAINNET;
          } else if (ledgerId && ledgerId.isTestnet()) {
              networkConstant = WEB_TESTNET;
          } else if (ledgerId && ledgerId.isPreviewnet()) {
              networkConstant = WEB_PREVIEWNET;
          } else {
              return [];
          }

          const nodeAccountId = node.node_account_id;

          for (const [address, accountIdObj] of Object.entries(networkConstant)) {
              if (accountIdObj.toString() === nodeAccountId) {
                  const [domain_name, port] = address.split(":");

                  return [
                      {
                          address: domain_name,
                          port,
                      },
                  ];
              }
          }

          return [];
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {import("../channel/Channel.js").default} Channel
   * @typedef {import("../channel/MirrorChannel.js").default} MirrorChannel
   * @typedef {import("../address_book/NodeAddressBook.js").default} NodeAddressBook
   */

  /**
   * @typedef {object} Operator
   * @property {string | PrivateKey} privateKey
   * @property {string | AccountId} accountId
   */

  /**
   * @typedef {object} ClientOperator
   * @property {PublicKey} publicKey
   * @property {AccountId} accountId
   * @property {(message: Uint8Array) => Promise<Uint8Array>} transactionSigner
   */

  /**
   * @typedef {object} ClientConfiguration
   * @property {{[key: string]: (string | AccountId)} | string} [network]
   * @property {string[] | string} [mirrorNetwork]
   * @property {Operator} [operator]
   * @property {boolean} [scheduleNetworkUpdate]
   * @property {number} [shard]
   * @property {number} [realm]
   * @property {number} [grpcDeadline]
   * @property {number} [requestTimeout]
   */

  /**
   * @typedef {"mainnet" | "testnet" | "previewnet"} NetworkName
   */

  /**
   * The `Client` class is the main entry point for interacting with the Hedera Hashgraph network.
   * It provides methods for managing network connections, setting operators, handling transactions
   * and queries, and configuring various client settings.
   *
   * @abstract
   * @template {Channel} ChannelT
   * @template {MirrorChannel} MirrorChannelT
   */
  class Client {
      /**
       * @protected
       * @hideconstructor
       * @param {ClientConfiguration} [props]
       */
      constructor(props) {
          /**
           * List of mirror network URLs.
           *
           * @internal
           * @type {MirrorNetwork}
           */
          this._mirrorNetwork = new MirrorNetwork$1(
              this._createMirrorNetworkChannel(),
          );

          /**
           * Map of node account ID (as a string)
           * to the node URL.
           *
           * @internal
           * @type {Network}
           */
          this._network = new Network(this._createNetworkChannel());

          /**
           * @internal
           * @type {?ClientOperator}
           */
          this._operator = null;

          /**
           * @private
           * @type {?Hbar}
           */
          this._defaultMaxTransactionFee = null;

          /**
           * @private
           * @type {Hbar}
           */
          this._defaultMaxQueryPayment = new Hbar(1);

          if (props != null) {
              if (props.operator != null) {
                  this.setOperator(
                      props.operator.accountId,
                      props.operator.privateKey,
                  );
              }
          }

          /** @type {number | null} */
          this._maxAttempts = null;

          /** @private */
          this._signOnDemand = false;

          /** @private */
          this._autoValidateChecksums = false;

          /** @private */
          this._minBackoff = 250;

          /** @private */
          this._maxBackoff = 8000;

          /** @private */
          this._defaultRegenerateTransactionId = true;

          /** @private */
          this._requestTimeout = DEFAULT_REQUEST_TIMEOUT;

          /** @private */
          this._grpcDeadline = DEFAULT_GRPC_DEADLINE;

          /**
           * @type {boolean}
           */
          this._isUpdatingNetwork = false;

          /** @private */
          this._networkUpdatePeriod = 24 * 60 * 60 * 1000;

          /** @private */
          this._isShutdown = false;

          this._shard = 0;

          this._realm = 0;

          if (props != null && props.scheduleNetworkUpdate !== false) {
              this._scheduleNetworkUpdate();
          }

          if (props != null && props.shard != null) {
              this._shard = props.shard;
          }

          if (props != null && props.realm != null) {
              this._realm = props.realm;
          }

          if (props != null && props.grpcDeadline != null) {
              this.setGrpcDeadline(props.grpcDeadline);
          }

          if (props != null && props.requestTimeout != null) {
              this.setRequestTimeout(props.requestTimeout);
          }

          // Validate that requestTimeout is larger than grpcDeadline after both are set
          if (this._requestTimeout <= this._grpcDeadline) {
              console.warn(
                  `DEPRECATION WARNING: requestTimeout (${this._requestTimeout}ms) should be larger than grpcDeadline (${this._grpcDeadline}ms). ` +
                      `This configuration may cause operations to fail unexpectedly. ` +
                      `This will throw an error in the next major version. Please adjust your timeout values.`,
              );
          }

          /** @internal */
          /** @type {NodeJS.Timeout} */
          this._timer;

          /**
           * Logger
           *
           * @external
           * @type {Logger | null}
           */
          this._logger = null;
      }

      /**
       * @deprecated
       * @param {NetworkName} networkName
       * @returns {this}
       */
      setNetworkName(networkName) {
          // uses custom NetworkName type
          // remove if phasing out set|get NetworkName
          console.warn("Deprecated: Use `setLedgerId` instead");
          return this.setLedgerId(networkName);
      }

      /**
       * @deprecated
       * @returns {string | null}
       */
      get networkName() {
          console.warn("Deprecated: Use `ledgerId` instead");
          return this.ledgerId != null ? this.ledgerId.toString() : null;
      }

      /**
       * @param {string|LedgerId} ledgerId
       * @returns {this}
       */
      setLedgerId(ledgerId) {
          this._network.setLedgerId(
              typeof ledgerId === "string"
                  ? LedgerId.fromString(ledgerId)
                  : ledgerId,
          );

          return this;
      }

      /**
       * @returns {LedgerId | null}
       */
      get ledgerId() {
          return this._network._ledgerId != null ? this._network.ledgerId : null;
      }

      /**
       * @param {{[key: string]: (string | AccountId)} | string} network
       * @returns {void}
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      setNetwork(network) {
          // TODO: This logic _can_ be de-duplicated and likely should
          throw new Error("not implemented");
      }

      /**
       * @param {NodeAddressBook} addressBook
       * @returns {this}
       */
      setNetworkFromAddressBook(addressBook) {
          this._network.setNetworkFromAddressBook(addressBook);
          return this;
      }

      /**
       * @returns {{[key: string]: (string | AccountId)}}
       */
      get network() {
          return this._network.network;
      }

      /**
       * @returns {number}
       */
      get shard() {
          return this._shard;
      }

      /**
       * @returns {number}
       */
      get realm() {
          return this._realm;
      }

      /**
       * @param {string[] | string} mirrorNetwork
       * @returns {void}
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      setMirrorNetwork(mirrorNetwork) {
          throw new Error("not implemented");
      }

      /**
       * @returns {string[]}
       */
      get mirrorNetwork() {
          return this._mirrorNetwork.network;
      }

      /**
       * @returns {string}
       * @throws {Error} When no mirror network is configured or available
       */
      get mirrorRestApiBaseUrl() {
          return this._mirrorNetwork.mirrorRestApiBaseUrl;
      }

      /**
       * @returns {boolean}
       */
      get signOnDemand() {
          return this._signOnDemand;
      }

      /**
       * @param {boolean} signOnDemand
       */
      setSignOnDemand(signOnDemand) {
          this._signOnDemand = signOnDemand;
      }

      /**
       * @returns {boolean}
       */
      isTransportSecurity() {
          return this._network.isTransportSecurity();
      }

      /**
       * @param {boolean} transportSecurity
       * @returns {this}
       */
      setTransportSecurity(transportSecurity) {
          this._network.setTransportSecurity(transportSecurity);
          return this;
      }

      /**
       * Set the account that will, by default, pay for transactions and queries built with this client.
       * NOTE: When using string for private key, the string needs to contain DER headers
       *
       * @param {AccountId | string} accountId
       * @param {PrivateKey | string} privateKey
       * @returns {this}
       */
      setOperator(accountId, privateKey) {
          const key =
              typeof privateKey === "string"
                  ? PrivateKey.fromStringDer(privateKey)
                  : privateKey;

          return this.setOperatorWith(accountId, key.publicKey, (message) =>
              Promise.resolve(key.sign(message)),
          );
      }

      /**
       * @returns {?ClientOperator}
       */
      getOperator() {
          return this._operator;
      }

      /**
       * Sets the account that will, by default, pay for transactions and queries built with
       * this client.
       *
       * @param {AccountId | string} accountId
       * @param {PublicKey | string} publicKey
       * @param {(message: Uint8Array) => Promise<Uint8Array>} transactionSigner
       * @returns {this}
       */
      setOperatorWith(accountId, publicKey, transactionSigner) {
          const accountId_ =
              accountId instanceof AccountId
                  ? accountId
                  : AccountId.fromString(accountId);

          if (this._network._ledgerId != null) {
              accountId_.validateChecksum(this);
          }

          this._operator = {
              transactionSigner,

              accountId: accountId_,

              publicKey:
                  publicKey instanceof PublicKey
                      ? publicKey
                      : PublicKey.fromString(publicKey),
          };

          return this;
      }

      /**
       * @param {boolean} value
       * @returns {this}
       */
      setAutoValidateChecksums(value) {
          this._autoValidateChecksums = value;
          return this;
      }

      /**
       * @returns {boolean}
       */
      isAutoValidateChecksumsEnabled() {
          return this._autoValidateChecksums;
      }

      /**
       * @returns {?AccountId}
       */
      get operatorAccountId() {
          return this._operator != null ? this._operator.accountId : null;
      }

      /**
       * @returns {?PublicKey}
       */
      get operatorPublicKey() {
          return this._operator != null ? this._operator.publicKey : null;
      }

      /**
       * @returns {?Hbar}
       */
      get defaultMaxTransactionFee() {
          return this._defaultMaxTransactionFee;
      }

      /**
       * @deprecated - Use `defaultMaxTransactionFee` instead
       * @returns {?Hbar}
       */
      get maxTransactionFee() {
          return this.defaultMaxTransactionFee;
      }

      /**
       * Set the defaultimum fee to be paid for transactions
       * executed by this client.
       *
       * @param {Hbar} defaultMaxTransactionFee
       * @returns {this}
       */
      setDefaultMaxTransactionFee(defaultMaxTransactionFee) {
          if (defaultMaxTransactionFee.toTinybars().toInt() < 0) {
              throw new Error("defaultMaxTransactionFee must be non-negative");
          }
          this._defaultMaxTransactionFee = defaultMaxTransactionFee;
          return this;
      }

      /**
       * @deprecated - Use `setDefaultMaxTransactionFee()` instead
       * Set the maximum fee to be paid for transactions
       * executed by this client.
       * @param {Hbar} maxTransactionFee
       * @returns {this}
       */
      setMaxTransactionFee(maxTransactionFee) {
          return this.setDefaultMaxTransactionFee(maxTransactionFee);
      }

      /**
       * @returns {boolean}
       */
      get defaultRegenerateTransactionId() {
          return this._defaultRegenerateTransactionId;
      }

      /**
       * Set if a new transaction ID should be generated when a `TRANSACTION_EXPIRED` status
       * is returned.
       *
       * @param {boolean} defaultRegenerateTransactionId
       * @returns {this}
       */
      setDefaultRegenerateTransactionId(defaultRegenerateTransactionId) {
          this._defaultRegenerateTransactionId = defaultRegenerateTransactionId;
          return this;
      }

      /**
       * @returns {Hbar}
       */
      get defaultMaxQueryPayment() {
          return this._defaultMaxQueryPayment;
      }

      /**
       * @deprecated in a favor of defaultMaxQueryPayment
       * @returns {Hbar}
       */
      get maxQueryPayment() {
          return this.defaultMaxQueryPayment;
      }

      /**
       * Set the maximum payment allowable for queries.
       *
       * @param {Hbar} defaultMaxQueryPayment
       * @returns {Client<ChannelT, MirrorChannelT>}
       */
      setDefaultMaxQueryPayment(defaultMaxQueryPayment) {
          const isMaxQueryPaymentNegative =
              convertToNumber(defaultMaxQueryPayment.toTinybars()) < 0;
          if (isMaxQueryPaymentNegative) {
              throw new Error("defaultMaxQueryPayment must be non-negative");
          }
          this._defaultMaxQueryPayment = defaultMaxQueryPayment;
          return this;
      }
      /**
       * @deprecated in a favor of setDefaultMaxQueryPayment()
       * Set the maximum payment allowable for queries.
       * @param {Hbar} maxQueryPayment
       * @returns {Client<ChannelT, MirrorChannelT>}
       */
      setMaxQueryPayment(maxQueryPayment) {
          return this.setDefaultMaxQueryPayment(maxQueryPayment);
      }

      /**
       * @returns {number}
       */
      get maxAttempts() {
          return this._maxAttempts != null ? this._maxAttempts : 10;
      }

      /**
       * @param {number} maxAttempts
       * @returns {this}
       */
      setMaxAttempts(maxAttempts) {
          this._maxAttempts = maxAttempts;
          return this;
      }

      /**
       * @returns {number}
       */
      get maxNodeAttempts() {
          return this._network.maxNodeAttempts;
      }

      /**
       * @param {number} maxNodeAttempts
       * @returns {this}
       */
      setMaxNodeAttempts(maxNodeAttempts) {
          this._network.setMaxNodeAttempts(maxNodeAttempts);
          return this;
      }

      /**
       * @returns {number}
       */
      get nodeWaitTime() {
          return this._network.minBackoff;
      }

      /**
       * @param {number} nodeWaitTime
       * @returns {this}
       */
      setNodeWaitTime(nodeWaitTime) {
          this._network.setMinBackoff(nodeWaitTime);
          return this;
      }

      /**
       * Gets the maximum number of nodes that a transaction or query will attempt to execute against.
       *
       * @returns {number} The current maximum nodes per transaction setting.
       *   Returns -1 if no limit is set (uses network defaults).
       */
      get maxNodesPerTransaction() {
          return this._network.maxNodesPerTransaction;
      }

      /**
       * Sets the maximum number of nodes that a transaction or query will execute against.
       *
       * - **Before freezing**: Limits automatic node selection when no explicit nodes are set
       * - **After freezing**: Trims frozen transactions to the first N nodes while preserving signatures
       * - **Special values**: 0 disables limiting, values > available nodes cause no trimming
       *
       * @param {number} maxNodesPerTransaction - Maximum nodes per transaction. Set to 0 to disable.
       * @returns {this} The client instance for method chaining
       */
      setMaxNodesPerTransaction(maxNodesPerTransaction) {
          this._network.setMaxNodesPerTransaction(maxNodesPerTransaction);
          return this;
      }

      /**
       * @param {?number} minBackoff
       * @returns {this}
       */
      setMinBackoff(minBackoff) {
          if (minBackoff == null) {
              throw new Error("minBackoff cannot be null.");
          }
          if (minBackoff > this._maxBackoff) {
              throw new Error("minBackoff cannot be larger than maxBackoff.");
          }
          this._minBackoff = minBackoff;
          return this;
      }

      /**
       * @returns {number}
       */
      get minBackoff() {
          return this._minBackoff;
      }

      /**
       * @param {?number} maxBackoff
       * @returns {this}
       */
      setMaxBackoff(maxBackoff) {
          if (maxBackoff == null) {
              throw new Error("maxBackoff cannot be null.");
          } else if (maxBackoff < this._minBackoff) {
              throw new Error("maxBackoff cannot be smaller than minBackoff.");
          }
          this._maxBackoff = maxBackoff;
          return this;
      }

      /**
       * @returns {number}
       */
      get maxBackoff() {
          return this._maxBackoff;
      }

      /**
       * @param {number} nodeMinBackoff
       * @returns {this}
       */
      setNodeMinBackoff(nodeMinBackoff) {
          this._network.setMinBackoff(nodeMinBackoff);
          return this;
      }

      /**
       * @returns {number}
       */
      get nodeMinBackoff() {
          return this._network.minBackoff;
      }

      /**
       * @param {number} nodeMaxBackoff
       * @returns {this}
       */
      setNodeMaxBackoff(nodeMaxBackoff) {
          this._network.setMaxBackoff(nodeMaxBackoff);
          return this;
      }

      /**
       * @returns {number}
       */
      get nodeMaxBackoff() {
          return this._network.maxBackoff;
      }

      /**
       * @param {number} nodeMinReadmitPeriod
       * @returns {this}
       */
      setNodeMinReadmitPeriod(nodeMinReadmitPeriod) {
          this._network.setNodeMinReadmitPeriod(nodeMinReadmitPeriod);
          return this;
      }

      /**
       * @returns {number}
       */
      get nodeMinReadmitPeriod() {
          return this._network.nodeMinReadmitPeriod;
      }

      /**
       * @param {number} nodeMaxReadmitPeriod
       * @returns {this}
       */
      setNodeMaxReadmitPeriod(nodeMaxReadmitPeriod) {
          this._network.setNodeMaxReadmitPeriod(nodeMaxReadmitPeriod);
          return this;
      }

      /**
       * @returns {number}
       */
      get nodeMaxReadmitPeriod() {
          return this._network.nodeMaxReadmitPeriod;
      }

      /**
       * Set the total request timeout for complete operations.
       *
       * @param {number} requestTimeout - Maximum time in milliseconds for complete Transaction/Query operations
       * @returns {this}
       */
      setRequestTimeout(requestTimeout) {
          if (requestTimeout <= 0) {
              throw new Error("requestTimeout must be a positive number");
          }
          if (requestTimeout <= this._grpcDeadline) {
              console.warn(
                  `DEPRECATION WARNING: requestTimeout (${requestTimeout}ms) should be larger than grpcDeadline (${this._grpcDeadline}ms). ` +
                      `This configuration may cause operations to fail unexpectedly. ` +
                      `This will throw an error in the next major version. Please adjust your timeout values.`,
              );
          }
          this._requestTimeout = requestTimeout;
          return this;
      }

      /**
       * Get the total request timeout for complete operations.
       *
       * @returns {number} Maximum time in milliseconds for complete Transaction/Query operations
       */
      get requestTimeout() {
          return this._requestTimeout;
      }

      /**
       * Set the global gRPC deadline for all requests.
       *
       * @param {number} grpcDeadline - Maximum time in milliseconds for a single gRPC request
       * @returns {this}
       */
      setGrpcDeadline(grpcDeadline) {
          if (grpcDeadline <= 0) {
              throw new Error("grpcDeadline must be a positive number");
          }
          if (grpcDeadline >= this._requestTimeout) {
              console.warn(
                  `DEPRECATION WARNING: grpcDeadline (${grpcDeadline}ms) should be smaller than requestTimeout (${this._requestTimeout}ms). ` +
                      `This configuration may cause operations to fail unexpectedly. ` +
                      `This will throw an error in the next major version. Please adjust your timeout values.`,
              );
          }
          this._grpcDeadline = grpcDeadline;
          return this;
      }

      /**
       * Get the global gRPC deadline for all requests.
       *
       * @returns {number} Maximum time in milliseconds for a single gRPC request
       */
      get grpcDeadline() {
          return this._grpcDeadline;
      }

      /**
       * @returns {number}
       */
      get networkUpdatePeriod() {
          return this._networkUpdatePeriod;
      }

      /**
       * @param {number} networkUpdatePeriod
       * @returns {this}
       */
      setNetworkUpdatePeriod(networkUpdatePeriod) {
          clearTimeout(this._timer);
          this._networkUpdatePeriod = networkUpdatePeriod;
          this._scheduleNetworkUpdate();
          return this;
      }
      /**
       * Set logger
       *
       * @param {Logger} logger
       * @returns {this}
       */
      setLogger(logger) {
          this._logger = logger;
          return this;
      }

      /**
       * Get logger if set
       *
       * @returns {?Logger}
       */
      get logger() {
          return this._logger;
      }

      /**
       * @param {AccountId | string} accountId
       */
      async ping(accountId) {
          await new AccountBalanceQuery({ accountId })
              .setNodeAccountIds([
                  accountId instanceof AccountId
                      ? accountId
                      : AccountId.fromString(accountId),
              ])
              .execute(this);
      }

      async pingAll() {
          for (const nodeAccountId of Object.values(this._network.network)) {
              await this.ping(nodeAccountId);
          }
      }

      /**
       * Update the network address book.
       * @returns {Promise<this>}
       */
      async updateNetwork() {
          if (this._isUpdatingNetwork) {
              return this;
          }

          this._isUpdatingNetwork = true;

          try {
              const addressBook = await new AddressBookQueryWeb()
                  .setFileId(
                      FileId.getAddressBookFileIdFor(this._shard, this._realm),
                  )
                  .execute(this);
              this.setNetworkFromAddressBook(addressBook);
          } catch (error) {
              if (this._logger) {
                  this._logger.trace(
                      `failed to update client address book: ${
                        /** @type {Error} */ (error).toString()
                    }`,
                  );
              }
          } finally {
              this._isUpdatingNetwork = false;
          }

          return this;
      }

      /**
       * @returns {void}
       */
      close() {
          this._network.close();
          this._mirrorNetwork.close();
          this._isShutdown = true;
          clearTimeout(this._timer);
      }

      /**
       * @abstract
       * @returns {(address: string) => ChannelT}
       */
      _createNetworkChannel() {
          return () => {
              throw new Error("not implemented");
          };
      }

      /**
       * @abstract
       * @returns {(address: string) => MirrorChannelT}
       */
      _createMirrorNetworkChannel() {
          return () => {
              throw new Error("not implemented");
          };
      }

      /**
       * @private
       */
      _scheduleNetworkUpdate() {
          // This is the automatic network update promise that _eventually_ completes
          // eslint-disable-next-line @typescript-eslint/no-floating-promises,@typescript-eslint/no-misused-promises
          this._timer = setTimeout(async () => {
              await this.updateNetwork();

              if (!this._isShutdown) {
                  // Recall this method to continuously update the network
                  // every `networkUpdatePeriod` amount of itme
                  this._scheduleNetworkUpdate();
              }
          }, this._networkUpdatePeriod);
      }

      /**
       * @returns {boolean}
       */
      get isClientShutDown() {
          return this._isShutdown;
      }

      /**
       * Validates that all nodes in a network are in the same shard and realm.
       *
       * @param {{[key: string]: (string | AccountId)}} network
       */
      static _validateNetworkConsistency(network) {
          if (Object.keys(network).length === 0) {
              return;
          }

          const [, nodeAccountId] = Object.entries(network)[0];

          const accountIdStr = nodeAccountId.toString();

          const [firstNodeShard, firstNodeRealm] = accountIdStr
              .split(".")
              .map(Number);

          const isNetworkValid = Object.values(network).every((accountId) => {
              const accountIdStr = accountId.toString();

              const [currentShard, currentRealm] = accountIdStr
                  .split(".")
                  .map(Number);
              return (
                  currentShard === firstNodeShard &&
                  currentRealm === firstNodeRealm
              );
          });

          if (!isNetworkValid) {
              throw new Error(
                  "Network is not valid, all nodes must be in the same shard and realm",
              );
          }
      }

      /**
       * Extracts shard and realm values from a network configuration.
       * Note: This method assumes the network is consistent (all nodes in same shard/realm).
       * Use validateNetworkConsistency() first to ensure this.
       *
       * @param {{[key: string]: (string | AccountId)}} network
       * @returns {{shard: number, realm: number}}
       */
      static _extractShardRealm(network) {
          const entries = Object.entries(network);
          if (entries.length === 0) {
              return { shard: 0, realm: 0 };
          }

          const [, firstNodeAccountId] = entries[0];

          const accountIdStr = firstNodeAccountId.toString();
          const [shard, realm] = accountIdStr.split(".").map(Number);

          return { shard, realm };
      }
  }

  const SDK_NAME = "hiero-sdk-js";
  const SDK_VERSION =
      "2.77.0" ;

  // SPDX-License-Identifier: Apache-2.0


  const { proto } = HieroProto;

  /**
   * @internal
   * @abstract
   */
  class Channel {
      /**
       * @protected
       * @param {number} [grpcDeadline] - The gRPC deadline in milliseconds
       */
      constructor(grpcDeadline = DEFAULT_GRPC_DEADLINE) {
          /**
           * @protected
           * @type {?HieroProto.proto.CryptoService}
           */
          this._crypto = null;

          /**
           * @protected
           * @type {?HieroProto.proto.SmartContractService}
           */
          this._smartContract = null;

          /**
           * @protected
           * @type {?HieroProto.proto.FileService}
           */
          this._file = null;

          /**
           * @protected
           * @type {?HieroProto.proto.ConsensusService}
           */
          this._consensus = null;

          /**
           * @protected
           * @type {?HieroProto.proto.FreezeService}
           */
          this._freeze = null;

          /**
           * @protected
           * @type {?HieroProto.proto.NetworkService}
           */
          this._network = null;

          /**
           * @protected
           * @type {?HieroProto.proto.TokenService}
           */
          this._token = null;

          /**
           * @protected
           * @type {?HieroProto.proto.ScheduleService}
           */
          this._schedule = null;

          /**
           * @protected
           * @type {?HieroProto.proto.UtilService}
           */
          this._util = null;

          /**
           * @protected
           * @type {?HieroProto.proto.AddressBookService}
           */
          this._addressBook = null;

          /**
           * @protected
           * @type {number}
           */
          this._grpcDeadline = grpcDeadline;
      }

      /**
       * Set the gRPC deadline for this channel
       * @param {number} deadline - The deadline in milliseconds, or null to clear
       */
      setGrpcDeadline(deadline) {
          this._grpcDeadline = deadline;
      }

      /**
       * Get the gRPC deadline for this channel
       * @returns {number}
       */
      get grpcDeadline() {
          return this._grpcDeadline;
      }

      /**
       * @abstract
       * @returns {void}
       */
      close() {
          throw new Error("not implemented");
      }

      /**
       * @returns {HieroProto.proto.CryptoService}
       */
      get crypto() {
          if (this._crypto != null) {
              return this._crypto;
          }

          this._crypto = proto.CryptoService.create(
              this._createUnaryClient("CryptoService"),
          );

          return this._crypto;
      }

      /**
       * @returns {HieroProto.proto.SmartContractService}
       */
      get smartContract() {
          if (this._smartContract != null) {
              return this._smartContract;
          }

          this._smartContract = proto.SmartContractService.create(
              this._createUnaryClient("SmartContractService"),
          );

          return this._smartContract;
      }

      /**
       * @returns {HieroProto.proto.FileService}
       */
      get file() {
          if (this._file != null) {
              return this._file;
          }

          this._file = proto.FileService.create(
              this._createUnaryClient("FileService"),
          );

          return this._file;
      }

      /**
       * @returns {HieroProto.proto.ConsensusService}
       */
      get consensus() {
          if (this._consensus != null) {
              return this._consensus;
          }

          this._consensus = proto.ConsensusService.create(
              this._createUnaryClient("ConsensusService"),
          );

          return this._consensus;
      }

      /**
       * @returns {HieroProto.proto.FreezeService}
       */
      get freeze() {
          if (this._freeze != null) {
              return this._freeze;
          }

          this._freeze = proto.FreezeService.create(
              this._createUnaryClient("FreezeService"),
          );

          return this._freeze;
      }

      /**
       * @returns {HieroProto.proto.NetworkService}
       */
      get network() {
          if (this._network != null) {
              return this._network;
          }

          this._network = proto.NetworkService.create(
              this._createUnaryClient("NetworkService"),
          );

          return this._network;
      }

      /**
       * @returns {HieroProto.proto.TokenService}
       */
      get token() {
          if (this._token != null) {
              return this._token;
          }

          this._token = proto.TokenService.create(
              this._createUnaryClient("TokenService"),
          );

          return this._token;
      }

      /**
       * @returns {HieroProto.proto.ScheduleService}
       */
      get schedule() {
          if (this._schedule != null) {
              return this._schedule;
          }

          this._schedule = proto.ScheduleService.create(
              this._createUnaryClient("ScheduleService"),
          );

          return this._schedule;
      }

      /**
       * @returns {HieroProto.proto.UtilService}
       */
      get util() {
          if (this._util != null) {
              return this._util;
          }

          this._util = proto.UtilService.create(
              this._createUnaryClient("UtilService"),
          );

          return this._util;
      }

      /**
       * @returns {HieroProto.proto.AddressBookService}
       */
      get addressBook() {
          if (this._addressBook != null) {
              return this._addressBook;
          }

          this._addressBook = proto.AddressBookService.create(
              this._createUnaryClient("AddressBookService"),
          );

          return this._addressBook;
      }

      /**
       * @abstract
       * @protected
       * @param {string} serviceName
       * @returns {import("protobufjs").RPCImpl}
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _createUnaryClient(serviceName) {
          throw new Error("not implemented");
      }
  }

  // grpc-web+proto is a series of data or trailer frames

  // a frame is identified by a single byte (0 = data or 1 = trailer) followed by 4 bytes for the
  // length of the frame, followed by the frame data

  /**
   * @param {Uint8Array} data
   * @returns {ArrayBuffer}
   */
  function encodeRequest(data) {
      // for our requests, we want to transfer a single data frame

      const frame = new ArrayBuffer(data.byteLength + 5);

      // the frame type (data) is zero and can be left default-initialized

      // the length of the frame data
      new DataView(frame, 1, 4).setUint32(0, data.length);

      // copy in the frame data
      new Uint8Array(frame, 5).set(data);

      return frame;
  }

  /**
   * @param {ArrayBuffer} data
   * @param {number} byteOffset
   * @param {number} byteLength
   * @returns {Uint8Array}
   */
  function decodeUnaryResponse(
      data,
      byteOffset = 0,
      byteLength = data.byteLength,
  ) {
      const dataView = new DataView(data, byteOffset, byteLength);
      let dataOffset = 0;

      /** @type {?Uint8Array} */
      let unaryResponse = null;

      // 0 = successful
      let status = 0;

      while (dataOffset < dataView.byteLength) {
          const frameByte = dataView.getUint8(dataOffset + 0);
          const frameType = frameByte >> 7;
          const frameByteLength = dataView.getUint32(dataOffset + 1);
          const frameOffset = dataOffset + 5; // offset from the start of the dataView
          if (frameOffset + frameByteLength > dataView.byteLength) {
              throw new Error("(BUG) unexpected frame length past the boundary");
          }
          const frameData = new Uint8Array(
              data,
              dataView.byteOffset + frameOffset,
              frameByteLength,
          );

          if (frameType === 0) {
              if (unaryResponse != null) {
                  throw new Error(
                      "(BUG) unexpectedly received more than one data frame",
                  );
              }

              unaryResponse = frameData;
          } else if (frameType === 1) {
              const trailer = decode$1(frameData);
              const [trailerName, trailerValue] = trailer.split(":");

              if (trailerName === "grpc-status") {
                  status = parseInt(trailerValue);
              } else {
                  throw new Error(`(BUG) unhandled trailer, ${trailer}`);
              }
          } else {
              throw new Error(`(BUG) unexpected frame type: ${frameType}`);
          }

          dataOffset += frameByteLength + 5;
      }

      if (status !== 0) {
          throw new Error(`(BUG) unhandled grpc-status: ${status}`);
      }

      if (unaryResponse == null) {
          throw new Error("(BUG) unexpectedly received no response");
      }

      return unaryResponse;
  }

  // SPDX-License-Identifier: Apache-2.0

  class WebChannel extends Channel {
      /**
       * @param {string} address
       * @param {number=} grpcDeadline
       */
      constructor(address, grpcDeadline) {
          super(grpcDeadline);

          /**
           * @type {string}
           * @private
           */
          this._address = address;

          // Set the gRPC deadline using the base class method

          /**
           * Flag indicating if the connection is ready (health check has passed)
           * Set to true after the first successful health check
           *
           * @type {boolean}
           * @private
           */
          this._isReady = false;

          /**
           * Promise that resolves when the health check is complete
           * Used to prevent multiple concurrent health checks
           *
           * @type {Promise<void>|null}
           * @private
           */
          this._healthCheckPromise = null;
      }

      /**
       * Determines whether to use HTTPS based on the address
       * @param {string} address - The address to check
       * @returns {boolean} - True if HTTPS should be used, false for HTTP
       * @private
       */
      _shouldUseHttps(address) {
          return !(
              address.includes("localhost") || address.includes("127.0.0.1")
          );
      }

      /**
       * Builds the full URL with appropriate scheme (http/https)
       * @param {string} address - The base address
       * @returns {string} - The full URL with scheme
       * @private
       */
      _buildUrl(address) {
          // Check if address already contains a scheme
          const hasScheme =
              address.startsWith("http://") || address.startsWith("https://");

          if (hasScheme) {
              // Use the address as-is if it already has a scheme
              return address;
          } else {
              // Only prepend scheme if none exists
              const shouldUseHttps = this._shouldUseHttps(address);
              return shouldUseHttps ? `https://${address}` : `http://${address}`;
          }
      }

      /**
       * Check if the gRPC-Web proxy is reachable and healthy
       * Performs a POST request and verifies the response has gRPC-Web headers,
       * which indicates the proxy is running and processing gRPC requests.
       * Results are cached per address for the entire lifecycle.
       * Uses promise-based synchronization to prevent multiple concurrent health checks.
       *
       * @param {Date} deadline - Deadline for the health check
       * @returns {Promise<void>}
       * @private
       */
      async _waitForReady(deadline) {
          // Check if we've already validated this address
          if (this._isReady) {
              return; // Health check already passed for this address
          }

          // If a health check is already in progress, wait for it to complete
          if (this._healthCheckPromise) {
              return this._healthCheckPromise;
          }

          // Start a new health check and store the promise
          this._healthCheckPromise = this._performHealthCheck(deadline);

          try {
              await this._healthCheckPromise;
          } finally {
              // Clear the promise when done (success or failure)
              this._healthCheckPromise = null;
          }
      }

      /**
       * Performs the actual health check request
       * @param {Date} deadline - Deadline for the health check
       * @returns {Promise<void>}
       * @private
       */
      async _performHealthCheck(deadline) {
          const address = this._buildUrl(this._address);

          // Calculate remaining time until deadline
          const timeoutMs = deadline.getTime() - Date.now();
          if (timeoutMs <= 0) {
              throw new GrpcServiceError(
                  GrpcStatus.Timeout,
                  ALL_WEB_NETWORK_NODES?.[this._address]?.toString(),
              );
          }

          const abortController = new AbortController();
          const timeoutId = setTimeout(() => abortController.abort(), timeoutMs);

          try {
              // Make a POST request to verify the gRPC-Web proxy is running
              // We use a minimal gRPC-Web compatible request
              //eslint-disable-next-line n/no-unsupported-features/node-builtins
              const response = await fetch(address, {
                  method: "POST",
                  headers: {
                      "content-type": "application/grpc-web+proto",
                      "x-user-agent": `${SDK_NAME}/${SDK_VERSION}`,
                      "x-grpc-web": "1",
                  },
                  body: new Uint8Array(0), // Empty body for health check
                  signal: abortController.signal,
              });

              clearTimeout(timeoutId);

              // Check if response is successful (200) or indicates a redirect (3xx)
              // 3xx status codes indicate the resource has moved, which is valid for proxies
              if (
                  response.ok ||
                  (response.status >= 300 && response.status < 400)
              ) {
                  const grpcStatus = response.headers.get("grpc-status");
                  const grpcMessage = response.headers.get("grpc-message");

                  // If gRPC headers exist, the proxy is running and processing requests
                  if (grpcStatus != null || grpcMessage != null) {
                      // Mark this connection as ready
                      this._isReady = true;
                      return; //  Healthy - gRPC-Web proxy is responding
                  }
              }

              // If we get here, either status isn't 200/3xx or no gRPC headers present
              // This means the proxy might not be configured correctly or not running
              throw new GrpcServiceError(
                  GrpcStatus.Unavailable,
                  ALL_WEB_NETWORK_NODES?.[this._address]?.toString(),
              );
          } catch (error) {
              clearTimeout(timeoutId);

              if (error instanceof Error && error.name === "AbortError") {
                  throw new GrpcServiceError(
                      GrpcStatus.Timeout,
                      ALL_WEB_NETWORK_NODES?.[this._address]?.toString(),
                  );
              }

              if (error instanceof GrpcServiceError) {
                  throw error;
              }

              // Network error - server is not reachable
              throw new GrpcServiceError(
                  GrpcStatus.Unavailable,
                  ALL_WEB_NETWORK_NODES?.[this._address]?.toString(),
              );
          }
      }

      /**
       * @override
       * @returns {void}
       */
      close() {
          // do nothing
      }

      /**
       * @override
       * @protected
       * @param {string} serviceName
       * @returns {import("protobufjs").RPCImpl}
       */
      _createUnaryClient(serviceName) {
          // eslint-disable-next-line @typescript-eslint/no-misused-promises
          return async (method, requestData, callback) => {
              // Calculate deadline for connection check
              const deadline = new Date();
              const milliseconds = this._grpcDeadline;

              deadline.setMilliseconds(deadline.getMilliseconds() + milliseconds);

              try {
                  // Wait for connection to be ready (similar to gRPC waitForReady)
                  await this._waitForReady(deadline);

                  // Build the full URL with appropriate scheme
                  const address = this._buildUrl(this._address);
                  // this will be executed in a browser environment so eslint is
                  // disabled for the fetch call
                  //eslint-disable-next-line n/no-unsupported-features/node-builtins
                  const response = await fetch(
                      `${address}/proto.${serviceName}/${method.name}`,
                      {
                          method: "POST",
                          headers: {
                              "content-type": "application/grpc-web+proto",
                              "x-user-agent": `${SDK_NAME}/${SDK_VERSION}`,
                              "x-grpc-web": "1",
                          },
                          body: encodeRequest(requestData),
                      },
                  );

                  if (!response.ok) {
                      const error = new HttpError(
                          HttpStatus._fromValue(response.status),
                      );
                      callback(error, null);
                      return;
                  }

                  // Check headers for gRPC errors
                  const grpcStatus = response.headers.get("grpc-status");
                  const grpcMessage = response.headers.get("grpc-message");

                  if (grpcStatus != null && grpcMessage != null) {
                      const error = new GrpcServiceError(
                          GrpcStatus._fromValue(parseInt(grpcStatus)),
                          ALL_WEB_NETWORK_NODES?.[this._address]?.toString(),
                      );
                      error.message = grpcMessage;
                      callback(error, null);
                      return;
                  }

                  const responseBuffer = await response.arrayBuffer();
                  const unaryResponse = decodeUnaryResponse(responseBuffer);

                  callback(null, unaryResponse);
              } catch (error) {
                  if (error instanceof GrpcServiceError) {
                      callback(error, null);
                      return;
                  }

                  const err = new GrpcServiceError(
                      // retry on grpc web errors
                      GrpcStatus._fromValue(18),
                      ALL_WEB_NETWORK_NODES?.[this._address]?.toString(),
                  );
                  callback(err, null);
              }
          };
      }
  }

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {import("./Client.js").ClientConfiguration} ClientConfiguration
   * @typedef {import("../account/AccountId.js").default} AccountId
   */

  /**
   * Represents a client for interacting with the Hedera network over the web.
   * The `WebClient` class extends the base `Client` class and provides methods
   * for configuring and managing connections to the Hedera network, including
   * setting the network type (mainnet, testnet, previewnet) and handling
   * transactions and queries.
   * @augments {Client<WebChannel, *>}
   */
  class WebClient extends Client {
      /**
       * @param {ClientConfiguration} [props]
       */
      constructor(props) {
          super(props);

          if (props != null) {
              if (typeof props.network === "string") {
                  this._setNetworkFromName(props.network);
              } else if (props.network != null) {
                  Client._validateNetworkConsistency(props.network);

                  const { shard, realm } = Client._extractShardRealm(
                      props.network,
                  );

                  // Shard and realm are inferred from the network, so we need to set them here
                  // to ensure that the client is properly configured.
                  this._shard = shard;
                  this._realm = realm;

                  this.setNetwork(props.network);
              }

              if (typeof props.mirrorNetwork === "string") {
                  switch (props.mirrorNetwork) {
                      case "mainnet":
                          this.setMirrorNetwork(WebMirrorNetwork.MAINNET);
                          break;

                      case "testnet":
                          this.setMirrorNetwork(WebMirrorNetwork.TESTNET);
                          break;

                      case "previewnet":
                          this.setMirrorNetwork(WebMirrorNetwork.PREVIEWNET);
                          break;

                      default:
                          this.setMirrorNetwork([props.mirrorNetwork]);
                          break;
                  }
              } else if (props.mirrorNetwork != null) {
                  this.setMirrorNetwork(props.mirrorNetwork);
              }
          }
      }

      /**
       * @param {string | ClientConfiguration} data
       * @returns {WebClient}
       */
      static fromConfig(data) {
          return new WebClient(
              typeof data === "string"
                  ? /** @type {ClientConfiguration | undefined} */ (
                        JSON.parse(data)
                    )
                  : data,
          );
      }

      /**
       * Construct a client for a specific network.
       *
       * It is the responsibility of the caller to ensure that all nodes in the map are part of the
       * same Hedera network. Failure to do so will result in undefined behavior.
       *
       * The client will load balance all requests to Hedera using a simple round-robin scheme to
       * chose nodes to send transactions to. For one transaction, at most 1/3 of the nodes will be
       * tried.
       *
       * @param {{[key: string]: (string | AccountId)} | string} network
       * @returns {WebClient}
       */
      static forNetwork(network) {
          return new WebClient({ network });
      }

      /**
       * @param {string} network
       * @returns {WebClient}
       */
      static forName(network) {
          return new WebClient({ network });
      }

      /**
       * Construct a Hedera client pre-configured for Mainnet access.
       *
       * @returns {WebClient}
       */
      static forMainnet() {
          return new WebClient({
              network: "mainnet",
          });
      }

      /**
       * Construct a Hedera client pre-configured for Testnet access.
       *
       * @returns {WebClient}
       */
      static forTestnet() {
          return new WebClient({
              network: "testnet",
          });
      }

      /**
       * Construct a Hedera client pre-configured for Previewnet access.
       *
       * @returns {WebClient}
       */
      static forPreviewnet() {
          return new WebClient({
              network: "previewnet",
          });
      }

      /**
       * Construct a Hedera client pre-configured for local-node access.
       *
       * @param {object} [props]
       * @param {boolean} [props.scheduleNetworkUpdate]
       * @returns {WebClient}
       */
      static forLocalNode(props = { scheduleNetworkUpdate: false }) {
          return new WebClient({
              network: "local-node",
              ...props,
          });
      }

      /**
       * Construct a Hedera client pre-configured for Mainnet access with network update.
       *
       * @returns {Promise<WebClient>}
       */
      static async forMainnetAsync() {
          return new WebClient({
              network: "mainnet",
          }).updateNetwork();
      }

      /**
       * Construct a Hedera client pre-configured for Testnet access with network update.
       *
       * @returns {Promise<WebClient>}
       */
      static async forTestnetAsync() {
          return new WebClient({
              network: "testnet",
          }).updateNetwork();
      }

      /**
       * Construct a Hedera client pre-configured for Previewnet access with network update.
       *
       * @returns {Promise<WebClient>}
       */
      static async forPreviewnetAsync() {
          return new WebClient({
              network: "previewnet",
          }).updateNetwork();
      }

      /**
       * Construct a client for a specific network with optional network update.
       * Updates network only if the network is not "local-node".
       *
       * @param {string} network
       * @returns {Promise<WebClient>}
       */
      static async forNameAsync(network) {
          const client = new WebClient({ network });

          if (network !== "local-node") {
              await client.updateNetwork();
          }

          return client;
      }

      /**
       * Construct a client configured to use mirror nodes.
       * This will query the address book to get the network nodes.
       *
       * @param {string[] | string} mirrorNetwork
       * @returns {Promise<WebClient>}
       */
      static async forMirrorNetwork(mirrorNetwork) {
          const client = new WebClient({ mirrorNetwork: mirrorNetwork });

          await client.updateNetwork();

          return client;
      }

      /**
       * @param {{[key: string]: (string | AccountId)} | string} network
       * @returns {void}
       */
      setNetwork(network) {
          if (typeof network === "string") {
              switch (network) {
                  case "previewnet":
                      this._network.setNetwork(WebNetwork.PREVIEWNET);
                      break;
                  case "testnet":
                      this._network.setNetwork(WebNetwork.TESTNET);
                      break;
                  case "mainnet":
                      this._network.setNetwork(WebNetwork.MAINNET);
                      break;
                  case "local-node":
                      this._network.setNetwork(WebNetwork.LOCAL_NODE);
                      break;
              }
          } else {
              // Check for deprecation warnings for network endpoints with schemes
              for (const [key] of Object.entries(network)) {
                  if (key.startsWith("https://") || key.startsWith("http://")) {
                      console.warn(
                          '[Deprecation Notice] Hiero SDK: Network endpoint "' +
                              key +
                              '" includes a URL scheme (e.g. "https://"). ' +
                              "This format was accepted in earlier versions but is now deprecated. " +
                              'Please remove the scheme and use "host:port" instead (e.g. "node00.swirldslabs.com:443"). ' +
                              "Support for scheme-prefixed endpoints will be removed in a future major release.",
                      );
                  }
              }
              this._network.setNetwork(network);
          }
      }

      /**
       * @param {string[] | string} mirrorNetwork
       * @returns {this}
       */
      setMirrorNetwork(mirrorNetwork) {
          if (typeof mirrorNetwork === "string") {
              switch (mirrorNetwork) {
                  case "local-node":
                      this._mirrorNetwork.setNetwork(WebMirrorNetwork.LOCAL_NODE);
                      break;
                  case "previewnet":
                      this._mirrorNetwork.setNetwork(WebMirrorNetwork.PREVIEWNET);
                      break;
                  case "testnet":
                      this._mirrorNetwork.setNetwork(WebMirrorNetwork.TESTNET);
                      break;
                  case "mainnet":
                      this._mirrorNetwork.setNetwork(WebMirrorNetwork.MAINNET);
                      break;
                  default:
                      this._mirrorNetwork.setNetwork([mirrorNetwork]);
              }
          } else {
              this._mirrorNetwork.setNetwork(mirrorNetwork);
          }

          return this;
      }

      /**
       * @private
       * @param {string} name
       * @returns {this}
       */
      _setNetworkFromName(name) {
          switch (name) {
              case "mainnet":
                  this.setNetwork(WebNetwork.MAINNET);
                  this.setMirrorNetwork(WebMirrorNetwork.MAINNET);
                  this.setLedgerId(LedgerId.MAINNET);
                  break;

              case "testnet":
                  this.setNetwork(WebNetwork.TESTNET);
                  this.setMirrorNetwork(WebMirrorNetwork.TESTNET);
                  this.setLedgerId(LedgerId.TESTNET);
                  break;

              case "previewnet":
                  this.setNetwork(WebNetwork.PREVIEWNET);
                  this.setMirrorNetwork(WebMirrorNetwork.PREVIEWNET);
                  this.setLedgerId(LedgerId.PREVIEWNET);
                  break;

              case "local-node":
                  this.setNetwork(WebNetwork.LOCAL_NODE);
                  this.setMirrorNetwork(WebMirrorNetwork.LOCAL_NODE);
                  this.setLedgerId(LedgerId.LOCAL_NODE);
                  break;

              default:
                  throw new Error(
                      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                      `unknown network: ${name}`,
                  );
          }
          return this;
      }

      /**
       * @override
       * @returns {Promise<this>}
       */
      async updateNetwork() {
          if (this._isUpdatingNetwork) {
              return this;
          }

          this._isUpdatingNetwork = true;

          try {
              const addressBook = await new AddressBookQueryWeb()
                  .setFileId(
                      FileId.getAddressBookFileIdFor(this.shard, this.realm),
                  )
                  .execute(this);

              /** @type {Record<string, AccountId>} */
              const network = {};
              for (const nodeAddress of addressBook.nodeAddresses) {
                  for (const endpoint of nodeAddress.addresses) {
                      if (nodeAddress.accountId != null) {
                          network[endpoint.toString()] = nodeAddress.accountId;
                      }
                  }
              }

              this.setNetwork(network);
          } catch (/** @type {unknown} */ error) {
              if (this._logger) {
                  const errorMessage =
                      error instanceof Error ? error.message : String(error);
                  this._logger.trace(
                      `failed to update client address book: ${errorMessage}`,
                  );
              }
          } finally {
              this._isUpdatingNetwork = false;
          }

          return this;
      }

      /**
       * @override
       * @returns {(address: string) => WebChannel}
       */
      _createNetworkChannel() {
          return (address) => new WebChannel(address, this.grpcDeadline);
      }

      /**
       * @override
       * @returns {(address: string) => *}
       */
      _createMirrorNetworkChannel() {
          return () => {
              throw new Error("mirror support is not supported in browsers");
          };
      }
  }

  // SPDX-License-Identifier: Apache-2.0

  /**
   * @typedef {import("./client/Client.js").NetworkName} ClientNetworkName
   * @typedef {import("./Provider.js").Provider} Provider
   * @typedef {import("./Signer.js").Signer} Signer
   * @typedef {import("./account/AccountBalance.js").AccountBalanceJson} AccountBalanceJson
   * @typedef {import("./account/AccountBalance.js").TokenBalanceJson} TokenBalanceJson
   * @typedef {import("./transaction/TransactionResponse.js").TransactionResponseJSON} TransactionResponseJSON
   */

  /**
   * @typedef {object} NetworkNameType
   * @property {ClientNetworkName} Mainnet
   * @property {ClientNetworkName} Testnet
   * @property {ClientNetworkName} Previewnet
   */
  /**
   * @type {NetworkNameType}
   */
  const NetworkName = {
      Mainnet: "mainnet",
      Testnet: "testnet",
      Previewnet: "previewnet",
  };

  // SPDX-License-Identifier: Apache-2.0


  /**
   * @typedef {import("./Provider.js").Provider} Provider
   * @typedef {import("./LedgerId.js").default} LedgerId
   * @typedef {import("./Key.js").default} Key
   * @typedef {import("./transaction/Transaction.js").default} Transaction
   * @typedef {import("./transaction/TransactionId.js").default} TransactionId
   * @typedef {import("./transaction/TransactionResponse.js").default} TransactionResponse
   * @typedef {import("./transaction/TransactionReceipt.js").default} TransactionReceipt
   * @typedef {import("./transaction/TransactionRecord.js").default} TransactionRecord
   * @typedef {import("./account/AccountId.js").default} AccountId
   * @typedef {import("./account/AccountBalance.js").default} AccountBalance
   * @typedef {import("./account/AccountInfo.js").default} AccountInfo
   * @typedef {import("./logger/Logger.js").default} Logger
   */

  /**
   * @template {any} O
   * @typedef {import("./query/Query.js").default<O>} Query<O>
   */

  /**
   * @template RequestT
   * @template ResponseT
   * @template OutputT
   * @typedef {import("./Executable.js").default<RequestT, ResponseT, OutputT>} Executable<RequestT, ResponseT, OutputT>
   */

  /**
   * @implements {Provider}
   */
  class LocalProviderWeb {
      /**
       * @param {object} props
       * @param {Client} [props.client]
       * @param {"mainnet" | "testnet" | "previewnet" | "local-node"} [props.networkName]
       */
      constructor(props = {}) {
          if (props != null && props.client != null) {
              this._client = props.client;
              return;
          }

          this._client = WebClient.forName(props.networkName || "local-node");
      }

      /**
       * @param {Client} client
       * @returns {LocalProviderWeb}
       */
      static fromClient(client) {
          return new LocalProviderWeb({ client });
      }

      /**
       * @returns {LedgerId?}
       */
      getLedgerId() {
          return this._client.ledgerId;
      }

      /**
       * @returns {{[key: string]: (string | AccountId)}}
       */
      getNetwork() {
          return this._client.network;
      }

      /**
       * @returns {string[]}
       */
      getMirrorNetwork() {
          return this._client.mirrorNetwork;
      }

      /**
       * @param {AccountId | string} accountId
       * @returns {Promise<AccountBalance>}
       */
      getAccountBalance(accountId) {
          return new AccountBalanceQuery()
              .setAccountId(accountId)
              .execute(this._client);
      }

      /**
       * @param {AccountId | string} accountId
       * @returns {Promise<AccountInfo>}
       */
      getAccountInfo(accountId) {
          return new AccountInfoQuery()
              .setAccountId(accountId)
              .execute(this._client);
      }

      /**
       * @param {AccountId | string} accountId
       * @returns {Promise<TransactionRecord[]>}
       */
      getAccountRecords(accountId) {
          return new AccountRecordsQuery()
              .setAccountId(accountId)
              .execute(this._client);
      }

      /**
       * @param {TransactionId | string} transactionId
       * @returns {Promise<TransactionReceipt>}
       */
      getTransactionReceipt(transactionId) {
          return new TransactionReceiptQuery()
              .setTransactionId(transactionId)
              .execute(this._client);
      }

      /**
       * @param {Transaction} transaction
       * @returns {Promise<TransactionResponse>}
       */
      async sendTransaction(transaction) {
          return await transaction.execute(this._client);
      }

      /**
       * @template O
       * @param {Query<O>} query
       * @returns {Promise<O>}
       */
      async sendQuery(query) {
          return await query.execute(this._client);
      }

      /**
       * @param {TransactionResponse} response
       * @returns {Promise<TransactionReceipt>}
       */
      async waitForReceipt(response) {
          return await response.getReceipt(this._client);
      }

      /**
       * @template RequestT
       * @template ResponseT
       * @template OutputT
       * @param {Executable<RequestT, ResponseT, OutputT>} request
       * @returns {Promise<OutputT>}
       */
      async call(request) {
          return await request.execute(this._client);
      }

      /**
       * @returns {void}
       */
      close() {
          this._client.close();
      }
  }

  exports.AccountAllowanceAdjustTransaction = AccountAllowanceAdjustTransaction;
  exports.AccountAllowanceApproveTransaction = AccountAllowanceApproveTransaction;
  exports.AccountAllowanceDeleteTransaction = AccountAllowanceDeleteTransaction;
  exports.AccountBalance = AccountBalance;
  exports.AccountBalanceQuery = AccountBalanceQuery;
  exports.AccountCreateTransaction = AccountCreateTransaction;
  exports.AccountDeleteTransaction = AccountDeleteTransaction;
  exports.AccountId = AccountId;
  exports.AccountInfo = AccountInfo;
  exports.AccountInfoFlow = AccountInfoFlow;
  exports.AccountInfoQuery = AccountInfoQuery;
  exports.AccountRecordsQuery = AccountRecordsQuery;
  exports.AccountUpdateTransaction = AccountUpdateTransaction;
  exports.AddressBookQuery = AddressBookQueryWeb;
  exports.AssessedCustomFee = AssessedCustomFee;
  exports.BadKeyError = BadKeyError;
  exports.BadMnemonicError = BadMnemonicError;
  exports.BadMnemonicReason = BadMnemonicReason;
  exports.BatchTransaction = BatchTransaction;
  exports.Cache = CACHE;
  exports.Client = WebClient;
  exports.ContractByteCodeQuery = ContractByteCodeQuery;
  exports.ContractCallQuery = ContractCallQuery;
  exports.ContractCreateFlow = ContractCreateFlow;
  exports.ContractCreateTransaction = ContractCreateTransaction;
  exports.ContractDeleteTransaction = ContractDeleteTransaction;
  exports.ContractExecuteTransaction = ContractExecuteTransaction;
  exports.ContractFunctionParameters = ContractFunctionParameters;
  exports.ContractFunctionResult = ContractFunctionResult;
  exports.ContractFunctionSelector = ContractFunctionSelector;
  exports.ContractId = ContractId;
  exports.ContractInfo = ContractInfo;
  exports.ContractInfoQuery = ContractInfoQuery;
  exports.ContractLogInfo = ContractLogInfo;
  exports.ContractNonceInfo = ContractNonceInfo;
  exports.ContractUpdateTransaction = ContractUpdateTransaction;
  exports.CustomFee = CustomFee;
  exports.CustomFeeLimit = CustomFeeLimit;
  exports.CustomFixedFee = CustomFixedFee;
  exports.CustomFractionalFee = CustomFractionalFee;
  exports.CustomRoyaltyFee = CustomRoyalyFee;
  exports.DelegateContractId = DelegateContractId;
  exports.EntityIdHelper = EntityIdHelper;
  exports.EthereumFlow = EthereumFlow;
  exports.EthereumTransaction = EthereumTransaction;
  exports.EthereumTransactionData = EthereumTransactionData;
  exports.EthereumTransactionDataEip1559 = EthereumTransactionDataEip1559;
  exports.EthereumTransactionDataEip2930 = EthereumTransactionDataEip2930;
  exports.EthereumTransactionDataLegacy = EthereumTransactionDataLegacy;
  exports.EvmAddress = EvmAddress;
  exports.ExchangeRate = ExchangeRate;
  exports.ExchangeRates = ExchangeRates;
  exports.Executable = Executable;
  exports.FeeAssessmentMethod = FeeAssessmentMethod;
  exports.FeeComponents = FeeComponents;
  exports.FeeData = FeeData;
  exports.FeeDataType = FeeDataType;
  exports.FeeSchedule = FeeSchedule;
  exports.FeeSchedules = FeeSchedules;
  exports.FileAppendTransaction = FileAppendTransaction;
  exports.FileContentsQuery = FileContentsQuery;
  exports.FileCreateTransaction = FileCreateTransaction;
  exports.FileDeleteTransaction = FileDeleteTransaction;
  exports.FileId = FileId;
  exports.FileInfo = FileInfo;
  exports.FileInfoQuery = FileInfoQuery;
  exports.FileUpdateTransaction = FileUpdateTransaction;
  exports.FreezeTransaction = FreezeTransaction;
  exports.FreezeType = FreezeType;
  exports.HEDERA_PATH = HEDERA_PATH;
  exports.Hbar = Hbar;
  exports.HbarAllowance = HbarAllowance;
  exports.HbarUnit = HbarUnit;
  exports.Key = Key;
  exports.KeyList = KeyList;
  exports.LedgerId = LedgerId;
  exports.LiveHash = LiveHash;
  exports.LiveHashAddTransaction = LiveHashAddTransaction;
  exports.LiveHashDeleteTransaction = LiveHashDeleteTransaction;
  exports.LiveHashQuery = LiveHashQuery;
  exports.LocalProvider = LocalProviderWeb;
  exports.LogLevel = LogLevel;
  exports.Logger = Logger;
  exports.Long = Long;
  exports.MaxAttemptsOrTimeoutError = MaxAttemptsOrTimeoutError;
  exports.MaxQueryPaymentExceeded = MaxQueryPaymentExceeded;
  exports.MirrorNodeContractCallQuery = MirrorNodeContractCallQuery;
  exports.MirrorNodeContractEstimateQuery = MirrorNodeContractEstimateQuery;
  exports.Mnemonic = Mnemonic;
  exports.NetworkName = NetworkName;
  exports.NetworkVersionInfo = NetworkVersionInfo;
  exports.NetworkVersionInfoQuery = NetworkVersionInfoQuery;
  exports.NftId = NftId;
  exports.NodeAddressBook = NodeAddressBook;
  exports.NodeCreateTransaction = NodeCreateTransaction;
  exports.NodeDeleteTransaction = NodeDeleteTransaction;
  exports.NodeUpdateTransaction = NodeUpdateTransaction;
  exports.PendingAirdropId = PendingAirdropId;
  exports.PrecheckStatusError = PrecheckStatusError;
  exports.PrivateKey = PrivateKey;
  exports.PrngTransaction = PrngTransaction;
  exports.Provider = Provider;
  exports.ProxyStaker = ProxyStaker;
  exports.PublicKey = PublicKey;
  exports.Query = Query;
  exports.ReceiptStatusError = ReceiptStatusError;
  exports.RequestType = RequestType;
  exports.SLIP44_ECDSA_ETH_PATH = SLIP44_ECDSA_ETH_PATH;
  exports.SLIP44_ECDSA_HEDERA_PATH = SLIP44_ECDSA_HEDERA_PATH;
  exports.ScheduleCreateTransaction = ScheduleCreateTransaction;
  exports.ScheduleDeleteTransaction = ScheduleDeleteTransaction;
  exports.ScheduleId = ScheduleId;
  exports.ScheduleInfo = ScheduleInfo;
  exports.ScheduleInfoQuery = ScheduleInfoQuery;
  exports.ScheduleSignTransaction = ScheduleSignTransaction;
  exports.SemanticVersion = SemanticVersion;
  exports.ServiceEndpoint = ServiceEndpoint;
  exports.SignatureMap = SignatureMap$1;
  exports.Signer = Signer;
  exports.SignerSignature = SignerSignature;
  exports.Status = Status;
  exports.StatusError = StatusError;
  exports.SubscriptionHandle = SubscriptionHandle;
  exports.SystemDeleteTransaction = SystemDeleteTransaction;
  exports.SystemUndeleteTransaction = SystemUndeleteTransaction;
  exports.Timestamp = Timestamp;
  exports.TokenAirdropTransaction = TokenAirdropTransaction;
  exports.TokenAllowance = TokenAllowance;
  exports.TokenAssociateTransaction = TokenAssociateTransaction;
  exports.TokenBurnTransaction = TokenBurnTransaction;
  exports.TokenCancelAirdropTransaction = TokenCancelAirdropTransaction;
  exports.TokenClaimAirdropTransaction = TokenClaimAirdropTransaction;
  exports.TokenCreateTransaction = TokenCreateTransaction;
  exports.TokenDeleteTransaction = TokenDeleteTransaction;
  exports.TokenDissociateTransaction = TokenDissociateTransaction;
  exports.TokenFeeScheduleUpdateTransaction = TokenFeeScheduleUpdateTransaction;
  exports.TokenFreezeTransaction = TokenFreezeTransaction;
  exports.TokenGrantKycTransaction = TokenGrantKycTransaction;
  exports.TokenId = TokenId;
  exports.TokenInfo = TokenInfo;
  exports.TokenInfoQuery = TokenInfoQuery;
  exports.TokenKeyValidation = TokenKeyValidation;
  exports.TokenMintTransaction = TokenMintTransaction;
  exports.TokenNftAllowance = TokenNftAllowance;
  exports.TokenNftInfo = TokenNftInfo;
  exports.TokenNftInfoQuery = TokenNftInfoQuery;
  exports.TokenPauseTransaction = TokenPauseTransaction;
  exports.TokenRejectFlow = TokenRejectFlow;
  exports.TokenRejectTransaction = TokenRejectTransaction;
  exports.TokenRevokeKycTransaction = TokenRevokeKycTransaction;
  exports.TokenSupplyType = TokenSupplyType;
  exports.TokenType = TokenType;
  exports.TokenUnfreezeTransaction = TokenUnfreezeTransaction;
  exports.TokenUnpauseTransaction = TokenUnpauseTransaction;
  exports.TokenUpdateNftsTransaction = TokenUpdateNftsTransaction;
  exports.TokenUpdateTransaction = TokenUpdateTransaction;
  exports.TokenWipeTransaction = TokenWipeTransaction;
  exports.TopicCreateTransaction = TopicCreateTransaction;
  exports.TopicDeleteTransaction = TopicDeleteTransaction;
  exports.TopicId = TopicId;
  exports.TopicInfo = TopicInfo;
  exports.TopicInfoQuery = TopicInfoQuery;
  exports.TopicMessage = TopicMessage;
  exports.TopicMessageChunk = TopicMessageChunk;
  exports.TopicMessageQuery = TopicMessageQuery;
  exports.TopicMessageSubmitTransaction = TopicMessageSubmitTransaction;
  exports.TopicUpdateTransaction = TopicUpdateTransaction;
  exports.Transaction = Transaction;
  exports.TransactionFeeSchedule = TransactionFeeSchedule;
  exports.TransactionId = TransactionId;
  exports.TransactionReceipt = TransactionReceipt;
  exports.TransactionReceiptQuery = TransactionReceiptQuery;
  exports.TransactionRecord = TransactionRecord;
  exports.TransactionRecordQuery = TransactionRecordQuery;
  exports.TransactionResponse = TransactionResponse;
  exports.Transfer = Transfer;
  exports.TransferTransaction = TransferTransaction;
  exports.Wallet = Wallet;
  exports.WebClient = WebClient;

}));
